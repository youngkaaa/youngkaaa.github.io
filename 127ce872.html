<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="SurfaceFlinger - DisplayDevice"/>




  <meta name="keywords" content="AndroidFrameworks,SurfaceFlinger,Display," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/127ce872.html"/>


<meta name="description" content="在 SurfaceFlinger 中，存在 mDisplays 的属性，它的类型是一个 std::map，key是 IBinder ，value 是DisplayDevice 。 对于 mDisplays ，以及 DisplayDevice 来说，它在之后的代码中经常出现，因此这里对他做简单的分析，方便后续其他文章的理解。本文暂时不牵扯 HWC 中的逻辑，只看SurfaceFlinger 中的 h">
<meta property="og:type" content="article">
<meta property="og:title" content="SurfaceFlinger - DisplayDevice">
<meta property="og:url" content="https://youngkaaa.github.io/127ce872.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="在 SurfaceFlinger 中，存在 mDisplays 的属性，它的类型是一个 std::map，key是 IBinder ，value 是DisplayDevice 。 对于 mDisplays ，以及 DisplayDevice 来说，它在之后的代码中经常出现，因此这里对他做简单的分析，方便后续其他文章的理解。本文暂时不牵扯 HWC 中的逻辑，只看SurfaceFlinger 中的 h">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-07T11:49:56.000Z">
<meta property="article:modified_time" content="2023-02-24T12:14:30.768Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="SurfaceFlinger">
<meta property="article:tag" content="Display">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> SurfaceFlinger - DisplayDevice - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          SurfaceFlinger - DisplayDevice
        
      </h1>

      <time class="post-time">
          8月 07 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>在 SurfaceFlinger 中，存在 mDisplays 的属性，它的类型是一个 std::map，key是 IBinder ，value 是DisplayDevice 。</p>
<p>对于 mDisplays ，以及 DisplayDevice 来说，它在之后的代码中经常出现，因此这里对他做简单的分析，方便后续其他文章的理解。本文暂时不牵扯 HWC 中的逻辑，只看SurfaceFlinger 中的 hotplug 事件，以及相关的 DisplayDevice 内容。</p>
<h3 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h3><p>在 SurfaceFlinger 的 init 方法中，会创建 HWComposer 实例，并且会往其中注册 HWC2::ComposerCallback 回调监听，而由于 SurfaceFlinger 正好实现了该接口，因此后续在 SurfaceFlinger 中的  onVsyncReceived() 方法和  onHotplugReceived() 方法中会接受到相关回调。</p>
<p>可以翻阅之前的文章复习下 SurfaceFlinger 的初始化：<a href="2fa835ad.html">SurfaceFlinger 初始化</a>。</p>
<p>而这里提到的两个方法中的第一个：onVsyncReceived() ，它是关于 Vsync 信号的，详见：<a href="6caea16d.html"> Vsync - DispSync &amp; DispSyncSource</a>。而本文这里主要介绍第二个方法：onHotplugReceived()。</p>
<h3 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h3><p>在正式开始讲后续内容之前，需要铺垫一些基础的概念知识，以方便后续逻辑的讲解。当然限于篇幅这里只是做简单讲解而已，对于本文后续内容的理解够用就行。</p>
<h4 id="mCurrentState"><a href="#mCurrentState" class="headerlink" title="mCurrentState"></a>mCurrentState</h4><p>在 SurfaceFlinger 中存在这几个相关属性的定义：mCurrentState 、mDrawingState。如果看过其他文章的话，看到这俩命名 mCurrentXXX 和 mDrawingXXX，就对它的作用猜的差不多了。比如在 <a href="https://youngkaaa.github.io/tags/AndroidFrameworks-Surface/">Surface</a> 中存在的双缓冲，以及其他地方。</p>
<p>而此处这俩都是 State 类型的，先看看它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::processDisplayHotplugEventsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 mPendingHotplugEvents 列表中是否有值，有的话才处理，没有则啥都不做</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;event: mPendingHotplugEvents) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将 hotplug 事件通知到 HWComposer 中，最终会返回一个对应的  DisplayIdentificationInfo</span></span><br><span class="line">    <span class="type">const</span> std::optional&lt;DisplayIdentificationInfo&gt; info =</span><br><span class="line">        <span class="built_in">getHwComposer</span>().<span class="built_in">onHotplug</span>(event.hwcDisplayId, event.connection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!info) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时是新插入了一个屏幕，使用屏幕id作为index，其创建一个匿名 Binder 对象，存储到 mPhysicalDisplayTokens 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (event.connection == HWC2::Connection::Connected) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 如果 mPhysicalDisplayTokens 中没有该显示设备的id，那么往里面添加一个BBinder实例保存起来，作为后续的key</span></span><br><span class="line"><span class="comment">       * info-&gt;id 拿到的就是在 HWComposer 中创建的 DisplayId 实例</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!mPhysicalDisplayTokens.<span class="built_in">count</span>(info-&gt;id)) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating display %s&quot;</span>, <span class="built_in">to_string</span>(info-&gt;id).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        mPhysicalDisplayTokens[info-&gt;id] = <span class="keyword">new</span> <span class="built_in">BBinder</span>();</span><br><span class="line"></span><br><span class="line">        DisplayDeviceState state;</span><br><span class="line">        state.displayId = info-&gt;id;</span><br><span class="line">        state.isSecure = <span class="literal">true</span>;</span><br><span class="line">        state.displayName = info-&gt;name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次 connected 的时候，mCurrentState.displays 中是空的，此时将包装成 DisplayDeviceState 保存起来</span></span><br><span class="line"><span class="comment">         * 注意此时是先放入到 mCurrentState.displays 中的，此时 mCurrentState.displays 中有一个 Display 了，而 mDrawingState 里面还没有</span></span><br><span class="line"><span class="comment">         * 这里操作的都是 mCurrentState ，然后在后面的 processDisplayChangesLocked 中会对比 mCurrentState 和 mDrawingState 的差异</span></span><br><span class="line"><span class="comment">         * 从而判断出是新增了 Display 还是 减少了 Display</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 这里只给 DisplayDeviceState 的一些参数赋值了，剩余参数要等待后续赋值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mCurrentState.displays.<span class="built_in">add</span>(mPhysicalDisplayTokens[info-&gt;id], state);</span><br><span class="line">        mInterceptor-&gt;<span class="built_in">saveDisplayCreation</span>(state);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果此时屏幕关闭或者拔出，则移除掉对应的信息</span></span><br><span class="line"></span><br><span class="line">      <span class="type">ssize_t</span> index = mCurrentState.displays.<span class="built_in">indexOfKey</span>(mPhysicalDisplayTokens[info-&gt;id]);</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> DisplayDeviceState &amp;state = mCurrentState.displays.<span class="built_in">valueAt</span>(index);</span><br><span class="line">        mInterceptor-&gt;<span class="built_in">saveDisplayDeletion</span>(state.sequenceId);</span><br><span class="line">        mCurrentState.displays.<span class="built_in">removeItemsAt</span>(index);</span><br><span class="line">      &#125;</span><br><span class="line">      mPhysicalDisplayTokens.<span class="built_in">erase</span>(info-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理屏幕状态发生变化后的处理，因为经过上面的逻辑之后， mCurrentState 和 mDrawingState 中的 display 可能存在差异了，所以此时要处理这些差异</span></span><br><span class="line">    <span class="built_in">processDisplayChangesLocked</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完事之后就清掉它，因为能执行到这里表示它里面的事件都处理完了</span></span><br><span class="line">  mPendingHotplugEvents.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlinger.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">State</span><span class="params">(LayerVector::StateSet set)</span> : stateSet(set), layersSortedByZ(set) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    State &amp;<span class="keyword">operator</span>=(<span class="type">const</span> State &amp;other) &#123;</span><br><span class="line">      layersSortedByZ = other.layersSortedByZ;</span><br><span class="line">      displays = other.displays;</span><br><span class="line">      colorMatrixChanged = other.colorMatrixChanged;</span><br><span class="line">      <span class="keyword">if</span> (colorMatrixChanged) &#123;</span><br><span class="line">        colorMatrix = other.colorMatrix;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 State 的状态，默认是 Invalid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> LayerVector::StateSet stateSet = LayerVector::StateSet::Invalid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 SurfaceFlinger 中的 Layer 集合</span></span><br><span class="line">    LayerVector layersSortedByZ;</span><br><span class="line">    <span class="comment">// 所有显示设备信息，这个一个 map 对象，key 是一个 IBinder，值是 DisplayDeviceState</span></span><br><span class="line">    DefaultKeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他属性值</span></span><br><span class="line">    <span class="type">bool</span> colorMatrixChanged = <span class="literal">true</span>;</span><br><span class="line">    mat4 colorMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 layersSortedByZ 中的 Layer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverseInZOrder</span><span class="params">(<span class="type">const</span> LayerVector::Visitor &amp;visitor)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverseInReverseZOrder</span><span class="params">(<span class="type">const</span> LayerVector::Visitor &amp;visitor)</span> <span class="type">const</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">// LayerVector.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">StateSet</span> &#123;</span><br><span class="line">      Invalid,  <span class="comment">// 已失效的</span></span><br><span class="line">      Current,  <span class="comment">// 当前的</span></span><br><span class="line">      Drawing,  <span class="comment">// 之前绘制的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// DisplayDevice.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DisplayDeviceState</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否是虚拟显示设备</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isVirtual</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !displayId.<span class="built_in">has_value</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int32_t</span> sequenceId = sNextSequenceId++;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 该显示设备的id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  std::optional&lt;DisplayId&gt; displayId;</span><br><span class="line">  sp&lt;IGraphicBufferProducer&gt; surface;</span><br><span class="line">  <span class="type">uint32_t</span> layerStack = DisplayDevice::NO_LAYER_STACK;</span><br><span class="line">  Rect viewport;</span><br><span class="line">  Rect frame;</span><br><span class="line">  <span class="type">uint8_t</span> orientation = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> width = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> height = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 该显示设备的名称，</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  std::string displayName;</span><br><span class="line">  <span class="type">bool</span> isSecure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> std::atomic&lt;<span class="type">int32_t</span>&gt; sNextSequenceId;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实 State 中的  layersSortedByZ 属性，以及它内部定义的两个遍历方法在其他文章中已经用到过了，比如在 <a href="5440e75b.html">SurfaceFlinger INVALIDATE</a> 中，做合成之前的INVALIDATE操作时，会多次遍历 mCurrentState 中的这个  layersSortedByZ 集合。</p>
<p>下面简单介绍下其中的这几个属性：</p>
<p>① stateSet ：表示当前该 State 实例的状态，比如是 Invalid 即不可用状态，也是一开始的初始状态；比如是 Current ，即当前正在操作的状态，实际对应 mCurrentState 属性，类似于 Surface 双缓冲中的 backBuffer ，也就是后缓冲，去进行当前修改操作的；比如是 Drawing ，即当前已经绘制使用生效了的状态，实际对应mDrawingState 属性，表示其内部的属性目前已经生效，在使用中了。类似于 Surface 中的 frontBuffer 。</p>
<p>② layersSortedByZ ：当前 SurfaceFlinger 中所有的 Layer 集合，比如在调用 SurfaceFlinger 的 createLayer 方法创建一个 Layer 时，就可能会将该 Layer 添加到该集合中以供后续使用。</p>
<p>③ displays ：它是一个 DefaultKeyedVector 类型的实例，类似于一个 Map 。key 是 IBinder ，实际是 BBinder 匿名Binder 实例；value 是 DisplayDeviceState 实例， 内部封装了该显示设备的信息，比如宽高，id，name等。</p>
<p>而在 SurfaceFlinger 中定义的 mCurrentState 、mDrawingState 这俩属性都是 State 类型的了，不过他俩对应的 stateSet 不一样，分别是：LayerVector::StateSet::Current 和 LayerVector::StateSet::Drawing ，因此他俩代表的含义用途也不一样，mCurrentState 中存储着最新的修改之后的信息，等到合适的时候，会将其赋值给 mDrawingState ，比如在 <a href="5440e75b.html">SurfaceFlinger INVALIDATE</a> 中，在处理 INVALIDATE 消息时，会执行 handleTransactionLocked() 方法，在该方法最后会执行 commitTransaction() 方法，最后会执行上述的赋值操作。因此把这俩值当做 Surface 的双缓冲来想的话，就更好理解了。</p>
<h4 id="FramebufferSurface"><a href="#FramebufferSurface" class="headerlink" title="FramebufferSurface"></a>FramebufferSurface</h4><p>先看其源码中的定义和其构造方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FramebufferSurface.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FramebufferSurface</span> : <span class="keyword">public</span> ConsumerBase, <span class="keyword">public</span> compositionengine::DisplaySurface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FramebufferSurface</span>(HWComposer&amp; hwc, DisplayId displayId,</span><br><span class="line">                       <span class="type">const</span> sp&lt;IGraphicBufferConsumer&gt;&amp; consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 来自 compositionengine::DisplaySurface 接口中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">beginFrame</span><span class="params">(<span class="type">bool</span> mustRecompose)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">prepareFrame</span><span class="params">(CompositionType compositionType)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">advanceFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onFrameCommitted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FramebufferSurface</span>() &#123; &#125;; <span class="comment">// this class cannot be overloaded</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeBufferLocked</span><span class="params">(<span class="type">int</span> slotIndex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">nextBuffer</span><span class="params">(<span class="type">uint32_t</span>&amp; outSlot, sp&lt;GraphicBuffer&gt;&amp; outBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">            sp&lt;Fence&gt;&amp; outFence, ui::Dataspace&amp; outDataspace)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> DisplayId mDisplayId;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mCurrentBufferSlot;</span><br><span class="line"></span><br><span class="line">    ui::Dataspace mDataSpace;</span><br><span class="line"></span><br><span class="line">    sp&lt;GraphicBuffer&gt; mCurrentBuffer;</span><br><span class="line"></span><br><span class="line">    sp&lt;Fence&gt; mCurrentFence;</span><br><span class="line"></span><br><span class="line">    HWComposer&amp; mHwc;</span><br><span class="line"></span><br><span class="line">    compositionengine::impl::HwcBufferCache mHwcBufferCache;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mHasPendingRelease;</span><br><span class="line">    <span class="type">int</span> mPreviousBufferSlot;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; mPreviousBuffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// FramebufferSurface.cpp</span></span><br><span class="line"></span><br><span class="line">FramebufferSurface::<span class="built_in">FramebufferSurface</span>(HWComposer&amp; hwc, DisplayId displayId,</span><br><span class="line">                                       <span class="type">const</span> sp&lt;IGraphicBufferConsumer&gt;&amp; consumer)</span><br><span class="line">      : <span class="built_in">ConsumerBase</span>(consumer),  </span><br><span class="line">        <span class="built_in">mDisplayId</span>(displayId),</span><br><span class="line">        <span class="built_in">mCurrentBufferSlot</span>(<span class="number">-1</span>),</span><br><span class="line">        <span class="built_in">mCurrentBuffer</span>(),</span><br><span class="line">        <span class="built_in">mCurrentFence</span>(Fence::NO_FENCE),</span><br><span class="line">        <span class="built_in">mHwc</span>(hwc),</span><br><span class="line">        <span class="built_in">mHasPendingRelease</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mPreviousBufferSlot</span>(BufferQueue::INVALID_BUFFER_SLOT),</span><br><span class="line">        <span class="built_in">mPreviousBuffer</span>() &#123;</span><br><span class="line"></span><br><span class="line">    mName = <span class="string">&quot;FramebufferSurface&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mConsumer 来自于父类 ConsumerBase 中，实际对应的就是这里的入参 consumer</span></span><br><span class="line">    mConsumer-&gt;<span class="built_in">setConsumerName</span>(mName);</span><br><span class="line">    mConsumer-&gt;<span class="built_in">setConsumerUsageBits</span>(GRALLOC_USAGE_HW_FB |</span><br><span class="line">                                       GRALLOC_USAGE_HW_RENDER |</span><br><span class="line">                                       GRALLOC_USAGE_HW_COMPOSER);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; activeConfig = mHwc.<span class="built_in">getActiveConfig</span>(displayId);</span><br><span class="line">    mConsumer-&gt;<span class="built_in">setDefaultBufferSize</span>(activeConfig-&gt;<span class="built_in">getWidth</span>(),</span><br><span class="line">            activeConfig-&gt;<span class="built_in">getHeight</span>());</span><br><span class="line">    mConsumer-&gt;<span class="built_in">setMaxAcquiredBufferCount</span>(</span><br><span class="line">            SurfaceFlinger::maxFrameBufferAcquiredBuffers - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 FramebufferSurface 的定义中可以看到，它继承自 ConsumerBase 类，而这个类在之前的 <a href="25fde216.html">Surface学习(二)–Layer简介</a> 中讲过了，可以翻看下提前熟悉下 ConsumerBase 。</p>
<p>这篇文章不是专门讲 FramebufferSurface 的，所以就简单只讲重点。这里我们首先从 FramebufferSurface 的构造方法来看。</p>
<p>它接收三个参数：</p>
<p>① hwc ： 它是 HWComposer 类型的，一般对应的就是 SurfaceFlinger 中创建的那个 HWComposer 实例。详见 <a href="2fa835ad.html">SurfaceFlinger 初始化</a> 中的 SurfaceFlinger 初始化相关分析。</p>
<p>该参数会被存储在 FramebufferSurface.mHwc 属性中。</p>
<p>② displayId ： 它是 DisplayId 类型的实例，表示一个显示设备的唯一标识。</p>
<p>该参数会被存储在 FramebufferSurface.mDisplayId 属性中。</p>
<p>③ consumer ：它是 IGraphicBufferConsumer 接口类型的，实际对应的是一个 BufferQueueConsumer 实例。关于 BufferQueue 相关分析详见：<a href="https://youngkaaa.github.io/tags/BufferQueue/">BufferQueue</a></p>
<p>该参数会被存储在 FramebufferSurface 的父类 ComsumerBase 中的 mConsumer 属性中。</p>
<p>接下来在 FramebufferSurface 构造方法中就可以通过 mConsumer 来设置一些属性参数值了。</p>
<p>关于 FramebufferSurface 中的其他属性，方法，等在本篇文章中后续遇到时在做分析吧。这里只需要多 FramebufferSurface 有个简单认识即可。</p>
<h4 id="NativeWindowSurface"><a href="#NativeWindowSurface" class="headerlink" title="NativeWindowSurface"></a>NativeWindowSurface</h4><p>先看其源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NativeWindowSurface.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NativeWindowSurface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">NativeWindowSurface</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;ANativeWindow&gt; <span class="title">getNativeWindow</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">preallocateBuffers</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeWindowSurface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;surfaceflinger::NativeWindowSurface&gt; <span class="title">createNativeWindowSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;producer)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 临时创建一个 NativeWindowSurface 接口的实现类，并且创建其对象实例返回</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">NativeWindowSurface</span> <span class="keyword">final</span> : <span class="keyword">public</span> surfaceflinger::NativeWindowSurface &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法中使用 producer 来创建一个 Surface 对象实例</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NativeWindowSurface</span><span class="params">(<span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;producer)</span></span></span><br><span class="line"><span class="function">        : mSurface(new Surface(producer, /* controlledByApp */ false)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">NativeWindowSurface</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的其实就是上面创建的 Surface</span></span><br><span class="line">    <span class="function">sp&lt;ANativeWindow&gt; <span class="title">getNativeWindow</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> mSurface; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preallocateBuffers</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; mSurface-&gt;<span class="built_in">allocateBuffers</span>(); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;Surface&gt; mSurface;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建上面的 NativeWindowSurface 类并返回</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;NativeWindowSurface&gt;(producer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>NativeWindowSurface 接口的定义比较简单，主要是定义了 getNativeWindow() 方法，用来提供 ANativeWindow 实例。</p>
<p>而 NativeWindowSurface 接口的实现类呢，是在createNativeWindowSurface() 方法中定义的。</p>
<p>它创建的这个NativeWindowSurface实现类中，定义了构造方法，接收一个  IGraphicBufferProducer 实例，也就是生产消费队列中的生产者，实际是： BufferQueueProducer 实例。内部会使用这个 producer 来创建一个 Surface 实例保存在该实现类中，等待后续使用。</p>
<p>因此说，创建 NativeWindowSurface 实例时，需要一个生产者 Producer 实例，内部会使用它来创建一个  Surface 实例，这样后续就可以使用这个 NativeWindowSurface 实例来操作这个 Surface 了。</p>
<p>关于 Surface 的分析可以看看：<a href="https://youngkaaa.github.io/tags/AndroidFrameworks-Surface/">Surface</a>。</p>
<h4 id="RenderSurface"><a href="#RenderSurface" class="headerlink" title="RenderSurface"></a>RenderSurface</h4><p>先看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderSurface.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RenderSurface</span> : <span class="keyword">public</span> compositionengine::RenderSurface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RenderSurface</span>(<span class="type">const</span> CompositionEngine&amp;, compositionengine::Display&amp;,</span><br><span class="line">                  compositionengine::RenderSurfaceCreationArgs&amp;&amp;);</span><br><span class="line">    ~<span class="built_in">RenderSurface</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> compositionengine::CompositionEngine&amp; mCompositionEngine;</span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> compositionengine::Display&amp; mDisplay;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> sp&lt;ANativeWindow&gt; mNativeWindow;</span><br><span class="line">  </span><br><span class="line">    sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> sp&lt;DisplaySurface&gt; mDisplaySurface;</span><br><span class="line">  </span><br><span class="line">    ui::Size mSize;</span><br><span class="line">  </span><br><span class="line">    <span class="type">bool</span> mProtected&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::<span class="type">uint32_t</span> mPageFlipCount&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RenderSurface.cpp</span></span><br><span class="line"></span><br><span class="line">RenderSurface::<span class="built_in">RenderSurface</span>(<span class="type">const</span> CompositionEngine&amp; compositionEngine, Display&amp; display,</span><br><span class="line">                             RenderSurfaceCreationArgs&amp;&amp; args)</span><br><span class="line">      : <span class="built_in">mCompositionEngine</span>(compositionEngine),</span><br><span class="line">        <span class="built_in">mDisplay</span>(display),</span><br><span class="line">        <span class="comment">// 详见 SF::processDisplayChangesLocked</span></span><br><span class="line">        <span class="built_in">mNativeWindow</span>(args.nativeWindow),</span><br><span class="line">        <span class="comment">// 详见 SF::processDisplayChangesLocked</span></span><br><span class="line">        <span class="built_in">mDisplaySurface</span>(args.displaySurface), </span><br><span class="line">        <span class="comment">// 通过 ANativeWindow_getHeight等方法拿到上面 nativeWindow 中的宽高信息</span></span><br><span class="line">        <span class="built_in">mSize</span>(args.displayWidth, args.displayHeight) &#123;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!mNativeWindow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RenderSurfaceCreationArgs.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RenderSurfaceCreationArgs</span> &#123;</span><br><span class="line">    <span class="comment">// The initial width of the surface</span></span><br><span class="line">    <span class="type">int32_t</span> displayWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The initial height of the surface</span></span><br><span class="line">    <span class="type">int32_t</span> displayHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The ANativeWindow for the buffer queue for this surface</span></span><br><span class="line">    sp&lt;ANativeWindow&gt; nativeWindow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The DisplaySurface for this surface</span></span><br><span class="line">    sp&lt;DisplaySurface&gt; displaySurface;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里先看 RenderSurface 的构造方法，它的构造放方法中需要接收三个参数：</p>
<p>① compositionEngine：它是一个  CompositionEngine 实例，实际对应的是 SurfaceFlinger 中创建的。详见 SurfaceFlinger 的初始化： <a href="2fa835ad.html">SurfaceFlinger 初始化</a> 。</p>
<p>② display ：compositionengine::Display 实例，一般对应的是 DisplayDevice 中的 mCompositionDisplay 属性值。</p>
<p>③ args ：它是一个 RenderSurfaceCreationArgs 类型的实例，他是一个结构体，内部定义了四个属性：nativeWindow、displaySurface、 displayWidth、displayHeight 。其中 nativeWindow 是 ANativeWindow 类型的，实际对应的是一个 Surface 实例；displaySurface 是 DisplaySurface 类型的，实际对应的是 FramebufferSurface 实例，这个 FramebufferSurface 实例看到本文后面就明白哪里来的了；剩下的 displayWidth、displayHeight 是对应的 Surface 中的宽高信息。另外需要补充一下：这个 nativeWindow ，也就是 Surface ，和这个 displaySurface，也就是FramebufferSurface 是一对，他俩分别对应着同一个生产消费队列的生产者和消费者。等本文后面会揭晓原因。</p>
<p>因此到了 RenderSurface 的构造方法中，它会将入参保存到自身的对应属性中去，也就仅仅是保存而已。</p>
<p>这样的话就拿到了 RenderSurface 的实例，后续一般是要调用其  initialize() 方法来进行初始化的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderSurface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderSurface::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ANativeWindow* <span class="type">const</span> window = mNativeWindow.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = <span class="built_in">native_window_api_connect</span>(window, NATIVE_WINDOW_API_EGL);</span><br><span class="line">    <span class="built_in">ALOGE_IF</span>(status != NO_ERROR, <span class="string">&quot;Unable to connect BQ producer: %d&quot;</span>, status);</span><br><span class="line">    status = <span class="built_in">native_window_set_buffers_format</span>(window, HAL_PIXEL_FORMAT_RGBA_8888);</span><br><span class="line">    <span class="built_in">ALOGE_IF</span>(status != NO_ERROR, <span class="string">&quot;Unable to set BQ format to RGBA888: %d&quot;</span>, status);</span><br><span class="line">    status = <span class="built_in">native_window_set_usage</span>(window, GRALLOC_USAGE_HW_RENDER);</span><br><span class="line">    <span class="built_in">ALOGE_IF</span>(status != NO_ERROR, <span class="string">&quot;Unable to set BQ usage bits for GPU rendering: %d&quot;</span>, status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// window.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">native_window_api_connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">struct</span> ANativeWindow* window, <span class="type">int</span> api)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> window-&gt;<span class="built_in">perform</span>(window, NATIVE_WINDOW_API_CONNECT, api);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::perform</span><span class="params">(<span class="type">int</span> operation, va_list args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略其他代码，其实内部就是根据 operation 做的 switch case 操作而已，</span></span><br><span class="line">  <span class="comment">// 因此这里只关心 NATIVE_WINDOW_API_CONNECT</span></span><br><span class="line">  <span class="type">int</span> res = NO_ERROR;</span><br><span class="line">  <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> NATIVE_WINDOW_API_CONNECT:res = <span class="built_in">dispatchConnect</span>(args);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Surface:: <span class="built_in">dispatchConnect</span>(va_list args) &#123;</span><br><span class="line">  <span class="type">int</span> api = <span class="built_in">va_arg</span>(args, <span class="type">int</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">connect</span>(api);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::connect</span><span class="params">(<span class="type">int</span> api)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> sp&lt;IProducerListener&gt; listener = <span class="keyword">new</span> <span class="built_in">DummyProducerListener</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">connect</span>(api, listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::connect</span><span class="params">(<span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt; &amp;listener)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">connect</span>(api, listener, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt; &amp;listener, <span class="type">bool</span> reportBufferRemoval)</span> </span>&#123;</span><br><span class="line">  <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">  IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">  mReportRemovedBuffers = reportBufferRemoval;</span><br><span class="line">  <span class="comment">// 其实就是调用内部生产者对象的 connect 方法来将该生产者连接到队列中去</span></span><br><span class="line">  <span class="type">int</span> err = mGraphicBufferProducer-&gt;<span class="built_in">connect</span>(listener, api, mProducerControlledByApp, &amp;output);</span><br><span class="line">  <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    mDefaultWidth = output.width;</span><br><span class="line">    mDefaultHeight = output.height;</span><br><span class="line">    mNextFrameNumber = output.nextFrameNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ignore transform hint if sticky transform is set or transform to display inverse flag is</span></span><br><span class="line">    <span class="comment">// set. Transform hint should be ignored if the client is expected to always submit buffers</span></span><br><span class="line">    <span class="comment">// in the same orientation.</span></span><br><span class="line">    <span class="keyword">if</span> (mStickyTransform == <span class="number">0</span> &amp;&amp; !<span class="built_in">transformToDisplayInverse</span>()) &#123;</span><br><span class="line">      mTransformHint = output.transformHint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mConsumerRunningBehind = (output.numPendingBuffers &gt;= <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!err &amp;&amp; api == NATIVE_WINDOW_API_CPU) &#123;</span><br><span class="line">    mConnectedToCpu = <span class="literal">true</span>;</span><br><span class="line">    mDirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    mDirtyRegion = Region::INVALID_REGION;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>s在 initialize() 方法中，会尝试使用内部的 Surface 来进行 connect 等操作。比如会先调用 native_window_api_connect() 方法来通知 mNativeWindow ，也就是 Surface 中的生产者实例，去调用其 connect 方法来将该生产者 producer 接入到队列中去，后续就可以使用它来生产数据了。</p>
<h3 id="onHotplugReceived"><a href="#onHotplugReceived" class="headerlink" title="onHotplugReceived"></a>onHotplugReceived</h3><p>onHotplugReceived() 方法是当Android系统有显示设备接入或者退出时回调的。而显示驱动一般是系统通电之后最先运行启动的，因此当在 SurfaceFliger 的 init 方法中往 HWComposer 中注册 HWC2::ComposerCallback 回调之后，立马会接受到 onHotplugReceived() 回调，通知说是当前有显示设备接入了。</p>
<p>下面还是先看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onHotplugReceived</span><span class="params">(<span class="type">int32_t</span> sequenceId, <span class="type">hwc2_display_t</span> hwcDisplayId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       HWC2::Connection connection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先判断 sequenceId 是否正确，不正确则跳过它</span></span><br><span class="line">  <span class="keyword">if</span> (sequenceId != <span class="built_in">getBE</span>().mComposerSequenceId) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ConditionalLock <span class="title">lock</span><span class="params">(mStateLock, std::this_thread::get_id() != mMainThreadId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将 hotPlug 事件存储起来，等待后期消费</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mPendingHotplugEvents.<span class="built_in">emplace_back</span>(HotplugEvent&#123;hwcDisplayId, connection&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这里可能出现两个不同的线程一个是来自hwBinder(实际也是一个Binder驱动，只是专门负责和硬件交流罢了)，</span></span><br><span class="line"><span class="comment">   * 一个可能是来自自己线程。我们这里就默认当做是当前线程即可，执行 processDisplayHotplugEventsLocked</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (std::this_thread::<span class="built_in">get_id</span>() == mMainThreadId) &#123;</span><br><span class="line">    <span class="built_in">processDisplayHotplugEventsLocked</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有显示设备发生变化，修改 mTransactionFlags 的值，下次刷新时会处理它</span></span><br><span class="line">  <span class="built_in">setTransactionFlags</span>(eDisplayTransactionNeeded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HotplugEvent</span> &#123;</span><br><span class="line">    <span class="type">hwc2_display_t</span> hwcDisplayId;</span><br><span class="line">    HWC2::Connection connection = HWC2::Connection::Invalid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里在接受到 Hotplug 事件之后，首先会判断 sequenceId 是否正确。而这个 sequenceId 就是前面给 HWComposer 注册回调时，会传入两个参数中的之一：</p>
<p>①this：也就是 SurfaceFlinger 自身，因为它实现了 HWC2::ComposerCallback 接口</p>
<p>②getBE().mComposerSequenceId：相当于是一个唯一id，用来标识这里注册的callback 回调。为啥需要这个id来区分呢？因为在 SurfaceFlinger 中可能不止一次的调用 getHwComposer().registerCallback() 方法来注册回调，但是每次传入的都是 this ，所以后续在接受到回调时，需要区分是对应的哪个callback回调。因此这里会传入这个参数来区分。</p>
<p>而对于这个 SequenceId ，会在上层将这个回调 callback 和  SequenceId 包装成：ComposerCallbackBridge 实例，那么后续回调过来时，这个 SequenceId 就可以直接用了。</p>
<p>接着往后会将回调中通知过来的 设备ID：hwcDisplayId  以及设备插拔状态 ： connection 一起封装成 HotplugEvent 实例，保存到  SurfaceFlinger 中的 mPendingHotplugEvents 容器中，等待后续处理。</p>
<p>接着会调用  processDisplayHotplugEventsLocked() 来处理 mPendingHotplugEvents 容器中的事件。</p>
<p>最后会通过调用 setTransactionFlags() 方法来修改 SurfaceFlinger 中的 mTransactionFlags 属性的值，等到后续刷新时，会根据这个值来完成不同的刷新操作。详见： <a href="5440e75b.html">SurfaceFlinger INVALIDATE</a> 。</p>
<h4 id="processDisplayHotplugEventsLocked"><a href="#processDisplayHotplugEventsLocked" class="headerlink" title="processDisplayHotplugEventsLocked"></a>processDisplayHotplugEventsLocked</h4><p>可以看出，核心逻辑是交给：processDisplayHotplugEventsLocked() 方法来处理的，因此接着看该方法的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::processDisplayHotplugEventsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 mPendingHotplugEvents 列表中是否有值，有的话才处理，没有则啥都不做</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;event: mPendingHotplugEvents) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将 hotplug 事件通知到 HWComposer 中，最终会返回一个对应的  DisplayIdentificationInfo</span></span><br><span class="line">    <span class="type">const</span> std::optional&lt;DisplayIdentificationInfo&gt; info =</span><br><span class="line">        <span class="built_in">getHwComposer</span>().<span class="built_in">onHotplug</span>(event.hwcDisplayId, event.connection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!info) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时是新插入了一个屏幕，使用屏幕id作为index，其创建一个匿名 Binder 对象，存储到 mPhysicalDisplayTokens 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (event.connection == HWC2::Connection::Connected) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 如果 mPhysicalDisplayTokens 中没有该显示设备的id，那么往里面添加一个BBinder实例保存起来，作为后续的key</span></span><br><span class="line"><span class="comment">       * info-&gt;id 拿到的就是在 HWComposer 中创建的 DisplayId 实例</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!mPhysicalDisplayTokens.<span class="built_in">count</span>(info-&gt;id)) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating display %s&quot;</span>, <span class="built_in">to_string</span>(info-&gt;id).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">        mPhysicalDisplayTokens[info-&gt;id] = <span class="keyword">new</span> <span class="built_in">BBinder</span>();</span><br><span class="line"></span><br><span class="line">        DisplayDeviceState state;</span><br><span class="line">        state.displayId = info-&gt;id;</span><br><span class="line">        state.isSecure = <span class="literal">true</span>;</span><br><span class="line">        state.displayName = info-&gt;name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次 connected 的时候，mCurrentState.displays 中是空的，此时将包装成 DisplayDeviceState 保存起来</span></span><br><span class="line"><span class="comment">         * 注意此时是先放入到 mCurrentState.displays 中的，此时 mCurrentState.displays 中有一个 Display 了，而 mDrawingState 里面还没有</span></span><br><span class="line"><span class="comment">         * 这里操作的都是 mCurrentState ，然后在后面的 processDisplayChangesLocked 中会对比 mCurrentState 和 mDrawingState 的差异</span></span><br><span class="line"><span class="comment">         * 从而判断出是新增了 Display 还是 减少了 Display</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 这里只给 DisplayDeviceState 的一些参数赋值了，剩余参数要等待后续赋值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mCurrentState.displays.<span class="built_in">add</span>(mPhysicalDisplayTokens[info-&gt;id], state);</span><br><span class="line">        mInterceptor-&gt;<span class="built_in">saveDisplayCreation</span>(state);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果此时屏幕关闭或者拔出，则移除掉对应的信息</span></span><br><span class="line"></span><br><span class="line">      <span class="type">ssize_t</span> index = mCurrentState.displays.<span class="built_in">indexOfKey</span>(mPhysicalDisplayTokens[info-&gt;id]);</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> DisplayDeviceState &amp;state = mCurrentState.displays.<span class="built_in">valueAt</span>(index);</span><br><span class="line">        mInterceptor-&gt;<span class="built_in">saveDisplayDeletion</span>(state.sequenceId);</span><br><span class="line">        mCurrentState.displays.<span class="built_in">removeItemsAt</span>(index);</span><br><span class="line">      &#125;</span><br><span class="line">      mPhysicalDisplayTokens.<span class="built_in">erase</span>(info-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理屏幕状态发生变化后的处理，因为经过上面的逻辑之后， mCurrentState 和 mDrawingState 中的 display 可能存在差异了，所以此时要处理这些差异</span></span><br><span class="line">    <span class="built_in">processDisplayChangesLocked</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完事之后就清掉它，因为能执行到这里表示它里面的事件都处理完了</span></span><br><span class="line">  mPendingHotplugEvents.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到当前方法中，首先判断的就是 mPendingHotplugEvents 列表中的事件，遍历挨个处理这些 HotplugEvent 。</p>
<p>拿到对应的要处理的 HotplugEvent 之后，首先调用的就是：HWComposer::onHotplug() 方法，该方法会在上层 HWComposer 中读取设备信息，并且保存起来，最后作为一个 DisplayIdentificationInfo 实例来返回出来，这个 DisplayIdentificationInfo 中会包括该显示设备的 id 和 name ，其中 id 是 DisplayId 类型的，可以将它认为是该显示设备的唯一标识。</p>
<p>如果返回的 info 为空，则表示该设备可能存在问题，这里会跳过它。</p>
<p>接下来就是根据 event.connection 来判断当前设备热插拔事件具体对应的是 ：显示设备接入 还是 显示设备断开。下面分两种情况讨论分析：</p>
<p>① 设备接入。</p>
<p>也就是 HWC2::Connection::Connected 。此时会先判断 mPhysicalDisplayTokens 容器中是否已经存在该显示设备了。 mPhysicalDisplayTokens 属性位于 SurfaceFlinger 类中，它是一个 unordered_map ，key 是 DisplayId 类型的，value 是 IBinder ，其实是 BBinder 匿名Binder 对象，可以跨进程传输。</p>
<p>此时会通过 info.id 来判断  mPhysicalDisplayTokens 中是否已经存在了该显示设备。如果已经存在了那么就不做其他操作，当然这种情况是比较少的；绝大多数情况都是不存在，此时会创建一个 BBinder 实例，然后将该 info.id 和 BBinder 实例作为一对保存到 mPhysicalDisplayTokens 中。</p>
<p>接着会创建一个 DisplayDeviceState 实例，该实例中会将 info.id 和 info.name 保存起来，然后将该 DisplayDeviceState 实例保存到  mCurrentState.displays 中去。注意这里的 mCurrentState.displays 也类似于是一个 Map，此时它的 key 是这里 mPhysicalDisplayTokens中key&#x3D;info.id 的 value 值，也就是刚创建出来的那个 BBinder 实例，value 是刚创建并保存好数据的 DisplayDeviceState 实例。</p>
<blockquote>
<p>因此后续当有了显示设备的 DisplayId 时，就可以先去mPhysicalDisplayTokens 中查找其对应的 BBinder 实例，再使用该 BBinder 实例去 mCurrentState （或者是mDrawingState ）的 displays 中查找对应的显示设备信息 DisplayDeviceState 。</p>
</blockquote>
<p>②设备断开。</p>
<p>断开时就只需要和前面接入时做相反的操作即可，也就是将要移除的显示设备从 mPhysicalDisplayTokens 和 mCurrentState 的 displays 中移除掉。</p>
<p>处理完成之后，mCurrentState.displays 中的数据就会和 mDrawingState.displays 中的数据产生差异，比如当有新设备接入时，此时 mCurrentState.displays 回比 mDrawingState.displays 多一项数据；当有设备断开时自然是要少一项数据的了。那么产生了这种差异之后应该怎么做呢？详见下一个方法：processDisplayChangesLocked()。</p>
<h4 id="processDisplayChangesLocked"><a href="#processDisplayChangesLocked" class="headerlink" title="processDisplayChangesLocked"></a>processDisplayChangesLocked</h4><p>先看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::processDisplayChangesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// cur 此时就是 mCurrentState.displays ，而 draw 就是 mDrawingState.displays 了</span></span><br><span class="line">  <span class="comment">// 下面就是处理这些 displays 差异了</span></span><br><span class="line">  <span class="type">const</span> KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt; &amp;<span class="built_in">curr</span>(mCurrentState.displays);</span><br><span class="line">  <span class="type">const</span> KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt; &amp;<span class="built_in">draw</span>(mDrawingState.displays);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这个 if 内部主要是两个for循环</span></span><br><span class="line"><span class="comment">   * 前提是 curr 和 draw 不是同一个实例时,才会进入if条件体内</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!curr.<span class="built_in">isIdenticalTo</span>(draw)) &#123;</span><br><span class="line">    <span class="comment">// 不是同一个实例时，表示 display 发生变化，此时将 mVisibleRegionsDirty 置为true，后续要进行刷新</span></span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> cc = curr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> dc = draw.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个for循环，遍历 draw 列表，寻找那些删除的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dc;) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">ssize_t</span> j = curr.<span class="built_in">indexOfKey</span>(draw.<span class="built_in">keyAt</span>(i));</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 当前processDisplayChangesLocked()方法每次执行完毕时，draw 就等于 cur，</span></span><br><span class="line"><span class="comment">       * 但此时出现了 draw 中有，而 cur 中没有，那么就表示 cur 中的 display 被移除过，那么此时应该把该 display 给断开</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 该 display 被断开了，那么其之前肯定连接过，那么在 mDisplay 中就会有缓存它，这里拿到它</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(draw.<span class="built_in">keyAt</span>(i))) &#123;</span><br><span class="line">          <span class="comment">// 断开该display</span></span><br><span class="line">          <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">          display-&gt;<span class="built_in">disconnect</span>();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!display-&gt;<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">            <span class="built_in">dispatchDisplayHotplugEvent</span>(displayId-&gt;value, <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断开之后，将其从 mDisplay 中移除掉</span></span><br><span class="line">        mDisplays.<span class="built_in">erase</span>(draw.<span class="built_in">keyAt</span>(i));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同时存在于 draw 和 cur 中，那么检查下是否有 display 内部属性发生了变化</span></span><br><span class="line"><span class="comment">         * 因为数量一样的情况下还有可能其中一个 display 属性变化了呢</span></span><br><span class="line"><span class="comment">         * j 是同一个 display 在 cur 中的索引，而i是正常循环遍历的索引，也就是该display在 draw 中的索引</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">const</span> DisplayDeviceState &amp;<span class="built_in">state</span>(curr[j]);</span><br><span class="line">        <span class="type">const</span> wp&lt;IBinder&gt; &amp;displayToken = curr.<span class="built_in">keyAt</span>(j);</span><br><span class="line">        <span class="type">const</span> sp&lt;IBinder&gt; state_binder = IInterface::<span class="built_in">asBinder</span>(state.surface);</span><br><span class="line">        <span class="type">const</span> sp&lt;IBinder&gt; draw_binder = IInterface::<span class="built_in">asBinder</span>(draw[i].surface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个 display 中的 surface 发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (state_binder != draw_binder) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(displayToken)) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">disconnect</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          mDisplays.<span class="built_in">erase</span>(displayToken);</span><br><span class="line">          mDrawingState.displays.<span class="built_in">removeItemsAt</span>(i);</span><br><span class="line">          dc--;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查这俩 Display 中的其他属性是否发生变化，比如 layerStack ，方向，宽高等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(displayToken)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (state.layerStack != draw[i].layerStack) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setLayerStack</span>(state.layerStack);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ((state.orientation != draw[i].orientation) ||</span><br><span class="line">              (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setProjection</span>(state.orientation, state.viewport, state.frame);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (state.width != draw[i].width || state.height != draw[i].height) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setDisplaySize</span>(state.width, state.height);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个 for 循环，遍历 cur 列表，寻找那些新增的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">      <span class="comment">// 在 cur 里面，没在 draw 里面，也就是说是新增的 Display</span></span><br><span class="line">      <span class="keyword">if</span> (draw.<span class="built_in">indexOfKey</span>(curr.<span class="built_in">keyAt</span>(i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拿到这个新增的 DisplayDevice 的相关信息，</span></span><br><span class="line"><span class="comment">         * 此时：mCurrentState.displays 中的数量一定大于等于 mDisplay 中的，因为当前方法是根据：mCurrentState.display 中的数据来为 mDisplays 中添加 DisplayDevice 的</span></span><br><span class="line"><span class="comment">         * 在没添加完成之前，就是大于它的。添加完成之后是等于。所以有 Display 新增之后，先修改 mCurrentState.display ，然后再根据它来在这里修改 mDisplays</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="type">const</span> DisplayDeviceState &amp;<span class="title">state</span><span class="params">(curr[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        sp&lt;compositionengine::DisplaySurface&gt; dispSurface;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; bqProducer;</span><br><span class="line">        sp&lt;IGraphicBufferConsumer&gt; bqConsumer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 BufferQueue 对象实例</span></span><br><span class="line">        <span class="built_in">getFactory</span>().<span class="built_in">createBufferQueue</span>(&amp;bqProducer, &amp;bqConsumer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        std::optional&lt;DisplayId&gt; displayId;</span><br><span class="line">        <span class="comment">// 是虚拟屏幕时，这里先不考虑</span></span><br><span class="line">        <span class="keyword">if</span> (state.<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (state.surface != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// Allow VR composer to use virtual displays.</span></span><br><span class="line">            <span class="keyword">if</span> (mUseHwcVirtualDisplays || <span class="built_in">getHwComposer</span>().<span class="built_in">isUsingVrComposer</span>()) &#123;</span><br><span class="line">              <span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">              <span class="type">int</span> status = state.surface-&gt;<span class="built_in">query</span>(NATIVE_WINDOW_WIDTH, &amp;width);</span><br><span class="line">              <span class="built_in">ALOGE_IF</span>(status != NO_ERROR, <span class="string">&quot;Unable to query width (%d)&quot;</span>, status);</span><br><span class="line">              <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">              status = state.surface-&gt;<span class="built_in">query</span>(NATIVE_WINDOW_HEIGHT, &amp;height);</span><br><span class="line">              <span class="built_in">ALOGE_IF</span>(status != NO_ERROR, <span class="string">&quot;Unable to query height (%d)&quot;</span>, status);</span><br><span class="line">              <span class="type">int</span> intFormat = <span class="number">0</span>;</span><br><span class="line">              status = state.surface-&gt;<span class="built_in">query</span>(NATIVE_WINDOW_FORMAT, &amp;intFormat);</span><br><span class="line">              <span class="built_in">ALOGE_IF</span>(status != NO_ERROR, <span class="string">&quot;Unable to query format (%d)&quot;</span>, status);</span><br><span class="line">              <span class="keyword">auto</span> format = <span class="built_in">static_cast</span>&lt;ui::PixelFormat&gt;(intFormat);</span><br><span class="line"></span><br><span class="line">              displayId =</span><br><span class="line">                  <span class="built_in">getHwComposer</span>().<span class="built_in">allocateVirtualDisplay</span>(width, height, &amp;format);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sp&lt;VirtualDisplaySurface&gt; vds =</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">VirtualDisplaySurface</span>(<span class="built_in">getHwComposer</span>(), displayId, state.surface,</span><br><span class="line">                                          bqProducer, bqConsumer,</span><br><span class="line">                                          state.displayName);</span><br><span class="line">            dispSurface = vds;</span><br><span class="line">            producer = vds;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非虚拟显示器，也就是手机屏幕作为输出了，state 是该显示设备在前面创建并保存了 id name 的 DisplayDeviceState </span></span><br><span class="line">          displayId = state.displayId;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 创建一个  FramebufferSurface 对象实例 ，内部包装了 HWComposer 、 消费队列的消费者端 IGraphicBufferConsumer</span></span><br><span class="line">          dispSurface = <span class="keyword">new</span> <span class="built_in">FramebufferSurface</span>(<span class="built_in">getHwComposer</span>(), *displayId, bqConsumer);</span><br><span class="line">          producer = bqProducer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 display 对应的 BBinder 和通过 setupNewDisplayDeviceInternal 生产的 DisplayService 设置到 mDisplays 这个 map 缓存中</span></span><br><span class="line">        <span class="type">const</span> wp&lt;IBinder&gt; &amp;displayToken = curr.<span class="built_in">keyAt</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (dispSurface != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          mDisplays.<span class="built_in">emplace</span>(displayToken, <span class="built_in">setupNewDisplayDeviceInternal</span>(displayToken, displayId, state, dispSurface, producer));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果不是虚拟屏幕的话，则调用 EventThread 的 hotplugReceived</span></span><br><span class="line">          <span class="keyword">if</span> (!state.<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!displayId);</span><br><span class="line">            <span class="built_in">dispatchDisplayHotplugEvent</span>(displayId-&gt;value, <span class="literal">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次调用该方法最后，都会给将 mDrawingState.displays 赋值为 mCurrentState.displays</span></span><br><span class="line">  <span class="comment">// 所以说后续在其内部 displays 没有被修改时，再次执行当前方法的话，最上面的 if 条件就会不满足。</span></span><br><span class="line">  mDrawingState.displays = mCurrentState.displays;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进入到该方法中，首先会有两个变量：curr 和 draw 分别指向 mCurrentState.displays 和 mDrawingState.displays 容器，后面遇到这俩属性时，能产生对应关系就行。</p>
<p>接着判断 curr 和 draw 是否是同一个实例，因为在当前 processDisplayChangesLocked() 方法的最后会将 mCurrentState.displays 赋值给 mDrawingState.displays ，这样后续如果这俩内容没有发生变化的情况下调用当前方法就不会生效。</p>
<p>进入到 if 条件体内，逻辑比较简单，就是两个 for 循环，下面将这俩循环分开讲解。</p>
<p>① 第一个 for 循环有两个作用。</p>
<p>&lt;1.1&gt; 用来处理那些刚断开的显示设备，即查找那些在 mDrawingState.displays 中但是不在 mCurrentState.displays 总的显示设备信息。</p>
<p>为什么会出现这种情况呢，因为在前面的 processDisplayHotplugEventsLocked() 方法中存在第②种设备断开的情况，会将 mCurrentState.displays 中的指定元素移除掉，而 mDrawingState.displays 中还保持的是之前的值，所以此时产生了差异。</p>
<p>遇到这种情况，会首先从 SurfaceFlinger 中的 mDisplays 容器中查找到该显示设备之前对应的  DisplayDevice 实例，调用其 disconnect() 方法来通知当前它已断开，最后将其从 mDisplays 中移除掉。为啥只从 mDisplays 中移除，不从mDrawingState.displays 中移除呢？看到后面就知道了。</p>
<p>&lt;1.2&gt; 第二个作用就是检查哪些显示设备中的属性发生了变化。这种情况出现在 mCurrentState.displays 和 mDrawingState.displays 中都存在该显示设备时，都存在还有可能内部属性发生变化了呢?因此这里会检查其属性，比如 宽高，方向等。如果发生了变化的话，那么会将最新的状态，也就是从 mCurrentState.displays 中取出的 DisplayDeviceState 中的最新属性值赋值给 mDisplay 中对应的 DisplayDevice 中去。</p>
<p>因此第一个 for 循环中就执行完毕了，那么还有什么情况没考虑呢？有显示设备新移除的情况呐。</p>
<p>② 第二个 for 循环只有一个作用，那就是处理那些在 mCurrentState.displays 中有，但是在 mDrawingState.displays 中没有的情况，也就是有新的显示设备接入了。</p>
<p>此时会为其创建一个新的 DisplayDevice 实例，保存到 SurfaceFlinger 中的 mDisplays 容器内，接下来的重心就是看看这个 DisplayDevice 实例是怎么创建出来的。</p>
<p>在创建 DisplayDevice 实例之前，首先会通过：BufferQueue::createBufferQueue() 来创建一个生产消费者队列，以及对应的生产者实例和消费者实例。对这个不熟的话，可以去翻看下：<a href="https://youngkaaa.github.io/tags/BufferQueue/">BufferQueue </a> 中的分析。</p>
<p>接着会判断该显示设备是否是虚拟屏幕，这里先不考虑虚拟屏幕的逻辑，后期有机会再看吧。如果是正常屏幕的话，会创建一个 FramebufferSurface 实例，在创建 FramebufferSurface 实例时，会将 SurfaceFlinger 中唯一的 HWComposer 实例；该显示设备的id；以及前面刚创建的消费者实例传入进去。关于 FramebufferSurface 的简单认识，详见本文上面。</p>
<p>接着往后，就会通过 setupNewDisplayDeviceInternal() 方法来为该显示设备创建一个 DisplayDevice 实例然后存入到 mDisplays 中，而此时 key 是上面创建的 BBinder 实例，value 就是新创建的 DisplayDevice 实例。</p>
<blockquote>
<p>因此再次接着上面的结论往后补充：</p>
<p>当有了显示设备的 DisplayId 时，就可以先去mPhysicalDisplayTokens 中查找其对应的 BBinder 实例，再使用该 BBinder 实例去 mCurrentState （或者是mDrawingState ）的 displays 中查找对应的显示设备信息 DisplayDeviceState ；或者说是去 mDisplays 容器中查找对应的  DisplayDevice 实例。</p>
</blockquote>
<h4 id="setupNewDisplayDeviceInternal"><a href="#setupNewDisplayDeviceInternal" class="headerlink" title="setupNewDisplayDeviceInternal"></a>setupNewDisplayDeviceInternal</h4><p>终于到了创建 DisplayDevice 的核心方法了。先看看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::processDisplayChangesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// cur 此时就是 mCurrentState.displays ，而 draw 就是 mDrawingState.displays 了</span></span><br><span class="line">  <span class="comment">// 下面就是处理这些 displays 差异了</span></span><br><span class="line">  <span class="type">const</span> KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt; &amp;<span class="built_in">curr</span>(mCurrentState.displays);</span><br><span class="line">  <span class="type">const</span> KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt; &amp;<span class="built_in">draw</span>(mDrawingState.displays);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这个 if 内部主要是两个for循环</span></span><br><span class="line"><span class="comment">   * 前提是 curr 和 draw 不是同一个实例时,才会进入if条件体内</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!curr.<span class="built_in">isIdenticalTo</span>(draw)) &#123; </span><br><span class="line">    <span class="comment">// 不是同一个实例时，表示 display 发生变化，此时将 mVisibleRegionsDirty 置为true，后续要进行刷新</span></span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> cc = curr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> dc = draw.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个for循环，遍历 draw 列表，寻找那些删除的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dc;) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">ssize_t</span> j = curr.<span class="built_in">indexOfKey</span>(draw.<span class="built_in">keyAt</span>(i));</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 当前processDisplayChangesLocked()方法每次执行完毕时，draw 就等于 cur，</span></span><br><span class="line"><span class="comment">       * 但此时出现了 draw 中有，而 cur 中没有，那么就表示 cur 中的 display 被移除过，那么此时应该把该 display 给断开</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 该 display 被断开了，那么其之前肯定连接过，那么在 mDisplay 中就会有缓存它，这里拿到它</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(draw.<span class="built_in">keyAt</span>(i))) &#123;</span><br><span class="line">          <span class="comment">// 断开该display</span></span><br><span class="line">          <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">          display-&gt;<span class="built_in">disconnect</span>();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!display-&gt;<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">            <span class="built_in">dispatchDisplayHotplugEvent</span>(displayId-&gt;value, <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断开之后，将其从 mDisplay 中移除掉</span></span><br><span class="line">        mDisplays.<span class="built_in">erase</span>(draw.<span class="built_in">keyAt</span>(i));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同时存在于 draw 和 cur 中，那么检查下是否有 display 内部属性发生了变化</span></span><br><span class="line"><span class="comment">         * 因为数量一样的情况下还有可能其中一个 display 属性变化了呢</span></span><br><span class="line"><span class="comment">         * j 是同一个 display 在 cur 中的索引，而i是正常循环遍历的索引，也就是该display在 draw 中的索引</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">const</span> DisplayDeviceState &amp;<span class="built_in">state</span>(curr[j]);</span><br><span class="line">        <span class="type">const</span> wp&lt;IBinder&gt; &amp;displayToken = curr.<span class="built_in">keyAt</span>(j);</span><br><span class="line">        <span class="type">const</span> sp&lt;IBinder&gt; state_binder = IInterface::<span class="built_in">asBinder</span>(state.surface);</span><br><span class="line">        <span class="type">const</span> sp&lt;IBinder&gt; draw_binder = IInterface::<span class="built_in">asBinder</span>(draw[i].surface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个 display 中的 surface 发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (state_binder != draw_binder) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(displayToken)) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">disconnect</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          mDisplays.<span class="built_in">erase</span>(displayToken);</span><br><span class="line">          mDrawingState.displays.<span class="built_in">removeItemsAt</span>(i);</span><br><span class="line">          dc--;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查这俩 Display 中的其他属性是否发生变化，比如 layerStack ，方向，宽高等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(displayToken)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (state.layerStack != draw[i].layerStack) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setLayerStack</span>(state.layerStack);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ((state.orientation != draw[i].orientation) ||</span><br><span class="line">              (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setProjection</span>(state.orientation, state.viewport, state.frame);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (state.width != draw[i].width || state.height != draw[i].height) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setDisplaySize</span>(state.width, state.height);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个 for 循环，遍历 cur 列表，寻找那些新增的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">      <span class="comment">// 在 cur 里面，没在 draw 里面，也就是说是新增的 Display</span></span><br><span class="line">      <span class="keyword">if</span> (draw.<span class="built_in">indexOfKey</span>(curr.<span class="built_in">keyAt</span>(i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拿到这个新增的 DisplayDevice 的相关信息，</span></span><br><span class="line"><span class="comment">         * 此时：mCurrentState.displays 中的数量一定大于等于 mDisplay 中的，因为当前方法是根据：mCurrentState.display 中的数据来为 mDisplays 中添加 DisplayDevice 的</span></span><br><span class="line"><span class="comment">         * 在没添加完成之前，就是大于它的。添加完成之后是等于。所以有 Display 新增之后，先修改 mCurrentState.display ，然后再根据它来在这里修改 mDisplays</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="type">const</span> DisplayDeviceState &amp;<span class="title">state</span><span class="params">(curr[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        sp&lt;compositionengine::DisplaySurface&gt; dispSurface;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; bqProducer;</span><br><span class="line">        sp&lt;IGraphicBufferConsumer&gt; bqConsumer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 BufferQueue 对象实例</span></span><br><span class="line">        <span class="built_in">getFactory</span>().<span class="built_in">createBufferQueue</span>(&amp;bqProducer, &amp;bqConsumer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        std::optional&lt;DisplayId&gt; displayId;</span><br><span class="line">        <span class="comment">// 是虚拟屏幕时，这里先不考虑</span></span><br><span class="line">        <span class="keyword">if</span> (state.<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (state.surface != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// Allow VR composer to use virtual displays.</span></span><br><span class="line">            <span class="keyword">if</span> (mUseHwcVirtualDisplays || <span class="built_in">getHwComposer</span>().<span class="built_in">isUsingVrComposer</span>()) &#123;</span><br><span class="line">              <span class="type">int</span> width = <span class="number">0</span>;</span><br><span class="line">              <span class="type">int</span> status = state.surface-&gt;<span class="built_in">query</span>(NATIVE_WINDOW_WIDTH, &amp;width);</span><br><span class="line">              <span class="built_in">ALOGE_IF</span>(status != NO_ERROR, <span class="string">&quot;Unable to query width (%d)&quot;</span>, status);</span><br><span class="line">              <span class="type">int</span> height = <span class="number">0</span>;</span><br><span class="line">              status = state.surface-&gt;<span class="built_in">query</span>(NATIVE_WINDOW_HEIGHT, &amp;height);</span><br><span class="line">              <span class="built_in">ALOGE_IF</span>(status != NO_ERROR, <span class="string">&quot;Unable to query height (%d)&quot;</span>, status);</span><br><span class="line">              <span class="type">int</span> intFormat = <span class="number">0</span>;</span><br><span class="line">              status = state.surface-&gt;<span class="built_in">query</span>(NATIVE_WINDOW_FORMAT, &amp;intFormat);</span><br><span class="line">              <span class="built_in">ALOGE_IF</span>(status != NO_ERROR, <span class="string">&quot;Unable to query format (%d)&quot;</span>, status);</span><br><span class="line">              <span class="keyword">auto</span> format = <span class="built_in">static_cast</span>&lt;ui::PixelFormat&gt;(intFormat);</span><br><span class="line"></span><br><span class="line">              displayId =</span><br><span class="line">                  <span class="built_in">getHwComposer</span>().<span class="built_in">allocateVirtualDisplay</span>(width, height, &amp;format);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sp&lt;VirtualDisplaySurface&gt; vds =</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">VirtualDisplaySurface</span>(<span class="built_in">getHwComposer</span>(), displayId, state.surface,</span><br><span class="line">                                          bqProducer, bqConsumer,</span><br><span class="line">                                          state.displayName);</span><br><span class="line">            dispSurface = vds;</span><br><span class="line">            producer = vds;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 非虚拟显示器，也就是手机屏幕作为输出了，state 是该显示设备在前面创建并保存了 id name 的 DisplayDeviceState </span></span><br><span class="line">          displayId = state.displayId;</span><br><span class="line">    </span><br><span class="line">          <span class="comment">// 创建一个  FramebufferSurface 对象实例 ，内部包装了 HWComposer 、 消费队列的消费者端 IGraphicBufferConsumer</span></span><br><span class="line">          dispSurface = <span class="keyword">new</span> <span class="built_in">FramebufferSurface</span>(<span class="built_in">getHwComposer</span>(), *displayId, bqConsumer);</span><br><span class="line">          producer = bqProducer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 display 对应的 BBinder 和通过 setupNewDisplayDeviceInternal 生产的 DisplayService 设置到 mDisplays 这个 map 缓存中</span></span><br><span class="line">        <span class="type">const</span> wp&lt;IBinder&gt; &amp;displayToken = curr.<span class="built_in">keyAt</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (dispSurface != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          mDisplays.<span class="built_in">emplace</span>(displayToken, <span class="built_in">setupNewDisplayDeviceInternal</span>(displayToken, displayId, state, dispSurface, producer));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果不是虚拟屏幕的话，则调用 EventThread 的 hotplugReceived</span></span><br><span class="line">          <span class="keyword">if</span> (!state.<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!displayId);</span><br><span class="line">            <span class="built_in">dispatchDisplayHotplugEvent</span>(displayId-&gt;value, <span class="literal">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次调用该方法最后，都会给将 mDrawingState.displays 赋值为 mCurrentState.displays</span></span><br><span class="line">  <span class="comment">// 所以说后续在其内部 displays 没有被修改时，再次执行当前方法的话，最上面的 if 条件就会不满足。</span></span><br><span class="line">  mDrawingState.displays = mCurrentState.displays;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;DisplayDevice&gt; <span class="title">SurfaceFlinger::setupNewDisplayDeviceInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> wp&lt;IBinder&gt; &amp;displayToken, <span class="type">const</span> std::optional&lt;DisplayId&gt; &amp;displayId,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DisplayDeviceState &amp;state, <span class="type">const</span> sp&lt;compositionengine::DisplaySurface&gt; &amp;dispSurface,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;producer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备创建 DisplayDevice 对象了，先构建出 DisplayDeviceCreationArgs 实例，用它来创建 DisplayDevice</span></span><br><span class="line">  <span class="function">DisplayDeviceCreationArgs <span class="title">creationArgs</span><span class="params">(<span class="keyword">this</span>, displayToken, displayId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将相关信息赋值给 DisplayDeviceCreationArgs</span></span><br><span class="line">  creationArgs.sequenceId = state.sequenceId;</span><br><span class="line">  creationArgs.isVirtual = state.<span class="built_in">isVirtual</span>();</span><br><span class="line">  creationArgs.isSecure = state.isSecure;</span><br><span class="line">  <span class="comment">// dispSurface : 外部刚创建的那个 FramebufferSurface 对象实例，内部包装了 HWComposer 、 消费队列的消费者端 IGraphicBufferConsumer</span></span><br><span class="line">  creationArgs.displaySurface = dispSurface;</span><br><span class="line">  creationArgs.hasWideColorGamut = <span class="literal">false</span>;</span><br><span class="line">  creationArgs.supportedPerFrameMetadata = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> isInternalDisplay = displayId &amp;&amp; displayId == <span class="built_in">getInternalDisplayIdLocked</span>();</span><br><span class="line">  <span class="comment">// 该 DisplayDevice 是否是默认的</span></span><br><span class="line">  creationArgs.isPrimary = isInternalDisplay;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (useColorManagement &amp;&amp; displayId) &#123;</span><br><span class="line">    std::vector&lt;ColorMode&gt; modes = <span class="built_in">getHwComposer</span>().<span class="built_in">getColorModes</span>(*displayId);</span><br><span class="line">    <span class="keyword">for</span> (ColorMode colorMode: modes) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isWideColorMode</span>(colorMode)) &#123;</span><br><span class="line">        creationArgs.hasWideColorGamut = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      std::vector&lt;RenderIntent&gt; renderIntents = <span class="built_in">getHwComposer</span>().<span class="built_in">getRenderIntents</span>(*displayId, colorMode);</span><br><span class="line">      creationArgs.hwcColorModes.<span class="built_in">emplace</span>(colorMode, renderIntents);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">getHdrCapabilities</span>(*displayId, &amp;creationArgs.hdrCapabilities);</span><br><span class="line">    creationArgs.supportedPerFrameMetadata = <span class="built_in">getHwComposer</span>().<span class="built_in">getSupportedPerFrameMetadata</span>(*displayId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 内部使用这个 producer 创建一个 NativeWindowSurface 对象实例，而这个实例内部会创建一个 Surface实例来跟这个 producer 绑定起来</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">auto</span> nativeWindowSurface = <span class="built_in">getFactory</span>().<span class="built_in">createNativeWindowSurface</span>(producer);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回的就是上面创建出来的 NativeWindowSurface 对象实例中创建的  Surface 实例</span></span><br><span class="line">  <span class="keyword">auto</span> nativeWindow = nativeWindowSurface-&gt;<span class="built_in">getNativeWindow</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因此 creationArgs.nativeWindow 中存储的是一个 Surface 实例，该Surface实例绑定了这个 producer</span></span><br><span class="line">  creationArgs.nativeWindow = nativeWindow;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state.<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">    nativeWindow-&gt;<span class="built_in">setSwapInterval</span>(nativeWindow.<span class="built_in">get</span>(), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  creationArgs.displayInstallOrientation =</span><br><span class="line">      isInternalDisplay ? primaryDisplayOrientation : DisplayState::eOrientationDefault;</span><br><span class="line"></span><br><span class="line">  creationArgs.initialPowerMode = state.<span class="built_in">isVirtual</span>() ? HWC_POWER_MODE_NORMAL : HWC_POWER_MODE_OFF;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 内部使用入参 DisplayDeviceCreationArgs 来创建一个 DisplayDevice 对象实例返回出来</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  sp&lt;DisplayDevice&gt; display = <span class="built_in">getFactory</span>().<span class="built_in">createDisplayDevice</span>(std::<span class="built_in">move</span>(creationArgs));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maxFrameBufferAcquiredBuffers &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    nativeWindowSurface-&gt;<span class="built_in">preallocateBuffers</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新这个 DisplayDevice 中的一些属性</span></span><br><span class="line">  ColorMode defaultColorMode = ColorMode::NATIVE;</span><br><span class="line">  Dataspace defaultDataSpace = Dataspace::UNKNOWN;</span><br><span class="line">  <span class="keyword">if</span> (display-&gt;<span class="built_in">hasWideColorGamut</span>()) &#123;</span><br><span class="line">    defaultColorMode = ColorMode::SRGB;</span><br><span class="line">    defaultDataSpace = Dataspace::V0_SRGB;</span><br><span class="line">  &#125;</span><br><span class="line">  display-&gt;<span class="built_in">getCompositionDisplay</span>()-&gt;<span class="built_in">setColorMode</span>(defaultColorMode, defaultDataSpace,</span><br><span class="line">                                                 RenderIntent::COLORIMETRIC);</span><br><span class="line">  <span class="keyword">if</span> (!state.<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!displayId);</span><br><span class="line">    display-&gt;<span class="built_in">setActiveConfig</span>(<span class="built_in">getHwComposer</span>().<span class="built_in">getActiveConfigIndex</span>(*displayId));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  display-&gt;<span class="built_in">setLayerStack</span>(state.layerStack);</span><br><span class="line">  display-&gt;<span class="built_in">setProjection</span>(state.orientation, state.viewport, state.frame);</span><br><span class="line">  display-&gt;<span class="built_in">setDisplayName</span>(state.displayName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> display;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlingerFactory.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;surfaceflinger::NativeWindowSurface&gt; <span class="title">createNativeWindowSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;producer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 就只是使用这个 producer 来创建 NativeWindowSurface 实例，内部会自动创建好一个 Surface </span></span><br><span class="line">  <span class="keyword">return</span> surfaceflinger::impl::<span class="built_in">createNativeWindowSurface</span>(producer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;DisplayDevice&gt; <span class="title">createDisplayDevice</span><span class="params">(DisplayDeviceCreationArgs &amp;&amp;creationArgs)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 使用入参来创建一个 DisplayDevice 实例</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">DisplayDevice</span>(std::<span class="built_in">move</span>(creationArgs));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// NativeWindowSurface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;surfaceflinger::NativeWindowSurface&gt; <span class="title">createNativeWindowSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;producer)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 临时创建一个 NativeWindowSurface 接口的实现类，并且创建其对象实例返回</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">NativeWindowSurface</span> <span class="keyword">final</span> : <span class="keyword">public</span> surfaceflinger::NativeWindowSurface &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法中使用 producer 来创建一个 Surface 对象实例</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NativeWindowSurface</span><span class="params">(<span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;producer)</span></span></span><br><span class="line"><span class="function">        : mSurface(new Surface(producer, /* controlledByApp */ false)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">NativeWindowSurface</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的其实就是上面创建的 Surface</span></span><br><span class="line">    <span class="function">sp&lt;ANativeWindow&gt; <span class="title">getNativeWindow</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> mSurface; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preallocateBuffers</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; mSurface-&gt;<span class="built_in">allocateBuffers</span>(); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    sp&lt;Surface&gt; mSurface;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建上面的 NativeWindowSurface 类并返回</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;NativeWindowSurface&gt;(producer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在正式看之前，首先先看看当前该方法的几个入参都代表的是啥吧：</p>
<p>① displayToken ：它是一个 IBinder 实例，实际是一个 BBinder ，在本篇文章提到提到 BBinder ，你应该能想到它是啥了吧，没错，就是你想的那个！！！</p>
<p>② displayId ：它是一个 DisplayId 类型的实例，实际就是当前要创建的显示设备的唯一标识。</p>
<p>③ state ：它是一个 DisplayDeviceState 类型的实例。他就是在前面的 processDisplayHotplugEventsLocked() 方法中为当前新接入的显示设备所创建的 DisplayDeviceState 实例，它被存在 mCurrentState.displays 容器中。</p>
<p>④ dispSurface：就是前面使用 consumer 刚创建好的那个 FramebufferSurface 实例。</p>
<p>⑤ producer：前面刚创建好的生产者实例。这个 producer 和上面创建 FramebufferSurface 实例时的 consumer 是一对，对应着同一个 BufferQueue。这个需要记住，对后面的理解很重要。</p>
<p>接着开始分析当前方法，进入到当前方法中，首先会创建一个 DisplayDeviceCreationArgs 实例，然后开始给这个 DisplayDeviceCreationArgs 中的属性赋值。下面挑其中几个重要的来分析下。</p>
<p>①  creationArgs.flinger：就是当前 SurfaceFlinger 实例，这里赋值是在 DisplayDeviceCreationArgs 构造方法中传入的 this。</p>
<p>② creationArgs.displayToken：就是入参displayToken ，也就是那个 BBinder 实例。这里赋值是在 DisplayDeviceCreationArgs 构造方法中传入的。</p>
<p>③ creationArgs.displayId ：就是入参displayId ，这里赋值是在 DisplayDeviceCreationArgs 构造方法中传入的。</p>
<p>④  creationArgs.displaySurface ：将入参 dispSurface 赋值给它，也就是前面 使用 consumer 刚创建好的那个 FramebufferSurface 实例。</p>
<p>⑤ creationArgs.nativeWindow：使用入参 producer 创建的 NativeWindowSurface 对象实例，然后拿到其中创建的 Surface 实例，而这个 Surface 实例正是使用这个入参 producer 来创建出来的。</p>
<p>因此，这里的 Surface ，和上面的 FramebufferSurface 是有关系的，因为一个是使用了 producer ，另外一个是使用了 consumer ，正好是新创建的同一个生产消费队列的两端：生产者和消费者了。因此在这个 Surface 中生产的东西可以在另外一边FramebufferSurface 中获取消费。</p>
<p>等给这个 DisplayDeviceCreationArgs 实例中的属性赋值完成之后，就可以用它来创建 DisplayDevice 实例了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisplayDevice.cpp</span></span><br><span class="line"></span><br><span class="line">DisplayDevice::<span class="built_in">DisplayDevice</span>(DisplayDeviceCreationArgs &amp;&amp;args)</span><br><span class="line">    : <span class="built_in">mFlinger</span>(args.flinger),           <span class="comment">// SurfaceFlinger 对象实例</span></span><br><span class="line">      <span class="built_in">mDisplayToken</span>(args.displayToken), <span class="comment">// 其在 SurfaceFlinger mDisplays 列表中的key</span></span><br><span class="line">      <span class="built_in">mSequenceId</span>(args.sequenceId),</span><br><span class="line">      <span class="built_in">mDisplayInstallOrientation</span>(args.displayInstallOrientation),</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 拿到 SF 中全局唯一的 CompositionEngine 对象实例</span></span><br><span class="line"><span class="comment">       * 然后调用其 createDisplay 方法来创建一个 Display 对象实例</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      mCompositionDisplay&#123;mFlinger-&gt;<span class="built_in">getCompositionEngine</span>().<span class="built_in">createDisplay</span>(</span><br><span class="line">          compositionengine::DisplayCreationArgs&#123;args.isSecure, args.isVirtual,args.displayId&#125;)&#125;,</span><br><span class="line">      <span class="built_in">mIsVirtual</span>(args.isVirtual),</span><br><span class="line">      <span class="built_in">mOrientation</span>(),</span><br><span class="line">      <span class="built_in">mActiveConfig</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mIsPrimary</span>(args.isPrimary)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 上面已经创建好了 mCompositionDisplay ，也就是  Display 对象实例</span></span><br><span class="line"><span class="comment">   * 此时就开始为这个 Display 中创建 RenderSurface</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 这里传入的 nativeWindow 这些属性，就是在 SF::setupNewDisplayDeviceInternal 中创建的 Surface</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mCompositionDisplay-&gt;<span class="built_in">createRenderSurface</span>(</span><br><span class="line">      compositionengine::RenderSurfaceCreationArgs&#123;<span class="built_in">ANativeWindow_getWidth</span>(</span><br><span class="line">                                                       args.nativeWindow.<span class="built_in">get</span>()),</span><br><span class="line">                                                   <span class="built_in">ANativeWindow_getHeight</span>(</span><br><span class="line">                                                       args.nativeWindow.<span class="built_in">get</span>()),</span><br><span class="line">                                                   args.nativeWindow, args.displaySurface&#125;);</span><br><span class="line"></span><br><span class="line">  mCompositionDisplay-&gt;<span class="built_in">createDisplayColorProfile</span>(</span><br><span class="line">      compositionengine::DisplayColorProfileCreationArgs&#123;args.hasWideColorGamut,</span><br><span class="line">                                                         std::<span class="built_in">move</span>(args.hdrCapabilities),</span><br><span class="line">                                                         args.supportedPerFrameMetadata,</span><br><span class="line">                                                         args.hwcColorModes&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!mCompositionDisplay-&gt;<span class="built_in">isValid</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;Composition Display did not validate!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mCompositionDisplay-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">initialize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setPowerMode</span>(args.initialPowerMode);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setProjection</span>(DisplayState::eOrientationDefault, Rect::INVALID_RECT, Rect::INVALID_RECT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传进来的 args 参数中的属性基本都会挨个赋值到 DisplayDevice 中，这些没啥讲的，额外需要补充的是其内部的 mCompositionDisplay 属性的创建。</p>
<p>mCompositionDisplay 是 DisplayDevice 中的一个属性，类型是 compositionengine::Display 。它的创建是在 DisplayDevice 构造方法中，通过调用：CompositionEngine::createDisplay() 方法来实现的，而这里的 CompositionEngine 实例正是从 SurfaceFlinger 中取出来的，而 SurfaceFlinger 实例是从入参 args.flinger 中拿到的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Output</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> compositionengine::Output &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Output</span>(<span class="type">const</span> CompositionEngine&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> CompositionEngine&amp; mCompositionEngine;</span><br><span class="line"></span><br><span class="line">    std::string mName;</span><br><span class="line"></span><br><span class="line">    OutputCompositionState mState;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;compositionengine::DisplayColorProfile&gt; mDisplayColorProfile;</span><br><span class="line">  </span><br><span class="line">    std::unique_ptr&lt;compositionengine::RenderSurface&gt; mRenderSurface;</span><br><span class="line"></span><br><span class="line">    OutputLayers mOutputLayersOrderedByZ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Display.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> Output &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::optional&lt;DisplayId&gt;&amp; <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isSecure</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isVirtual</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">createDisplayColorProfile</span><span class="params">(DisplayColorProfileCreationArgs&amp;&amp;)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">createRenderSurface</span><span class="params">(RenderSurfaceCreationArgs&amp;&amp;)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ~<span class="built_in">Display</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CompositionEngine.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;compositionengine::Display&gt; <span class="title">CompositionEngine::createDisplay</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        DisplayCreationArgs&amp;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compositionengine::impl::<span class="built_in">createDisplay</span>(*<span class="keyword">this</span>, std::<span class="built_in">move</span>(args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Display.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;compositionengine::Display&gt; <span class="title">createDisplay</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> compositionengine::CompositionEngine&amp; compositionEngine,</span></span></span><br><span class="line"><span class="params"><span class="function">        compositionengine::DisplayCreationArgs&amp;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Display&gt;(compositionEngine, std::<span class="built_in">move</span>(args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Display::<span class="built_in">Display</span>(<span class="type">const</span> CompositionEngine&amp; compositionEngine, DisplayCreationArgs&amp;&amp; args)</span><br><span class="line">      : compositionengine::impl::<span class="built_in">Output</span>(compositionEngine),</span><br><span class="line">        <span class="built_in">mIsVirtual</span>(args.isVirtual),</span><br><span class="line">        <span class="built_in">mId</span>(args.displayId) &#123;</span><br><span class="line">    <span class="built_in">editState</span>().isSecure = args.isSecure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建这个 mCompositionDisplay 逻辑还是比较简单的，就是保存入参值即可。</p>
<p>额外需要注意的是，Display 是继承自 Output 的，所有有些属性在 Display 中找不到的话，可以去 Output 中看。</p>
<p>下面简单看看 Output 中的属性：</p>
<p>①  mCompositionEngine：他对应的是 SurfaceFlinger 中的 CompositionEngine 实例。在 Display 构造方法中会设置进来。</p>
<p>② mState：该 Output 中的状态信息，它是一个  OutputCompositionState 类型的值，在SurfaceFlinger 的刷新合成时会用到，详见： <a href="5440e75b.html">SurfaceFlinger INVALIDATE</a>  、 <a href="7cbfb0e.html">SurfaceFlinger REFRESH1</a>  和  <a href="bf779c6b.html">SurfaceFlinger REFRESH2</a>。</p>
<p>③ mRenderSurface ：它是一个 RenderSurface 类型的实例，实际会将 Surface 和 FramebufferSurface 实例包装起来，详见本文上面关于 RenderSurface 的介绍。</p>
<p>④ mOutputLayersOrderedByZ ：存储着要在当前 Output ，或者说是当前 Display 上显示的 Layer 列表，实际是 OutputLayer 列表。详见： <a href="5440e75b.html">SurfaceFlinger INVALIDATE</a>  、 <a href="7cbfb0e.html">SurfaceFlinger REFRESH1</a>  和  <a href="bf779c6b.html">SurfaceFlinger REFRESH2</a></p>
<p>接着会调用 mCompositionDisplay 的 createRenderSurface() 方法来为其内部的 mRenderSurface 创建一个 RenderSurface 实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Display.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display::createRenderSurface</span><span class="params">(RenderSurfaceCreationArgs&amp;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getCompositionEngine() ： 拿到的就是之前设置进来的 SF 全局唯一的 CompositionEngine</span></span><br><span class="line">    <span class="built_in">setRenderSurface</span>(compositionengine::impl::<span class="built_in">createRenderSurface</span>(<span class="built_in">getCompositionEngine</span>(), *<span class="keyword">this</span>, std::<span class="built_in">move</span>(args)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RenderSurface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;compositionengine::RenderSurface&gt; <span class="title">createRenderSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> compositionengine::CompositionEngine&amp; compositionEngine,</span></span></span><br><span class="line"><span class="params"><span class="function">        compositionengine::Display&amp; display, compositionengine::RenderSurfaceCreationArgs&amp;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;RenderSurface&gt;(compositionEngine, display, std::<span class="built_in">move</span>(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，会使用入参 args 中的属性，以及当前 Display ，也就是上面刚创建出来的 mCompositionDisplay 实例。</p>
<p>到这里我们可以知道，这里创建的  RenderSurface 实例中，会将外部传来的 DisplayDeviceCreationArgs 中的 Surface 和 FramebufferSurface 保存起来，也就是将生产者和消费者封装到了一起。</p>
<p>接着会调用这个 RenderSurface 实例的 initialize() 方法来初始化。</p>
<p>具体的关于 RenderSurface 中的赋值和创建，以及其initialize() 方法逻辑分析，可以翻看本文上面的关于 RenderSurface 的讲解。</p>
<p>到这里的话， DisplayDevice 实例就创建成功了。创建的这个 DisplayDevice 中比较重要的就是它的 mCompositionDisplay 属性，它内部会持有 RenderSurface 实例，这个 RenderSurface 中会包括着外部创建出来的 Surface 和 FramebufferSurface ，而这俩正好是同一个生产消费队列的两端。这句话说了好几次了，因为这个概念是真的很重要。尤其是对于 SurfaceFlinger 合成  <a href="bf779c6b.html">SurfaceFlinger REFRESH2</a>。</p>
<p>接着我们回到 setupNewDisplayDeviceInternal() 方法中来，在创建完这个 DisplayDevice 实例后，后续还会给其内部的一些属性赋值，比如其中的 LayerStack等，当然这些暂时都不是重点，最后该方法返回这个刚创建好的  DisplayDevice 实例。</p>
<p>接着回到 processDisplayChangesLocked() 方法中来，会将 setupNewDisplayDeviceInternal() 方法返回的 DisplayDevice 保存到 SurfaceFlinger 中的 mDisplays 容器中，此时用的key是 displayToken ，对，没错，就是那个 BBinder 实例。</p>
<p>该方法中的循环执行完毕之后，会将 mCurrentState.displays 赋值给 mDrawingState.displays ，这样的话这俩容器自然变成了一致的了。因此前面在遇到多了或者少了显示设备时，不需要修改 mDrawingState.displays ，而是只需要将其同步更新到 mDisplays 中就行了，mDrawingState.displays最终都是直接赋值一步到位，让其和 mCurrentState.displays保持一致。这下应该就会对  mDisplays 和 mCurrentState.displays 、 mDrawingState.displays 的区别了吧。</p>
<p>这样的话，processDisplayHotplugEventsLocked() 和 onHotplugReceived() 方法也就执行完毕了。也就完成了 Hotplug 事件的处理。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/SurfaceFlinger/">SurfaceFlinger</a>
		  
			<a href="/tags/Display/">Display</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/c4a594c7.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">GLES&EGL-总述</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/7b339bd2.html">
        <span class="next-text nav-default">SurfaceFlinger - EventThread</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
