<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="DispSync & DispSyncSource"/>




  <meta name="keywords" content="AndroidFrameworks,SurfaceFlinger," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/6caea16d.html"/>


<meta name="description" content="本文主要介绍 frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Scheduler&#x2F;DispSync.cpp 和  frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Scheduler&#x2F;DispSyncSource.cpp。Disp">
<meta property="og:type" content="article">
<meta property="og:title" content="DispSync &amp; DispSyncSource">
<meta property="og:url" content="https://youngkaaa.github.io/6caea16d.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="本文主要介绍 frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Scheduler&#x2F;DispSync.cpp 和  frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Scheduler&#x2F;DispSyncSource.cpp。Disp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/6caea16d/pic01.png">
<meta property="og:image" content="https://youngkaaa.github.io/6caea16d/pic02.png">
<meta property="og:image" content="https://youngkaaa.github.io/6caea16d/pic03.png">
<meta property="og:image" content="https://youngkaaa.github.io/6caea16d/pic04.png">
<meta property="og:image" content="https://youngkaaa.github.io/6caea16d/pic05.png">
<meta property="og:image" content="https://youngkaaa.github.io/6caea16d/pic06.png">
<meta property="article:published_time" content="2022-08-05T14:04:38.000Z">
<meta property="article:modified_time" content="2022-09-05T13:01:02.343Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="SurfaceFlinger">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/6caea16d/pic01.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> DispSync & DispSyncSource - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          DispSync & DispSyncSource
        
      </h1>

      <time class="post-time">
          8月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>本文主要介绍 <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/Scheduler/DispSync.cpp">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Scheduler&#x2F;DispSync.cpp</a> 和  <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/Scheduler/DispSyncSource.cpp">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Scheduler&#x2F;DispSyncSource.cpp</a>。DispSync类主要用于 SurfaceFlinger 中处理计算 Vsync 信号，内部存在一个 DispSyncThread 线程，它承载了 DispSync 类中的主要逻辑。而 DispSyncSource 则是 EventThread 和 DispSync 的中间桥梁。</p>
<p>首先先贴上 DispSync 的类图：</p>
<p><img src="/6caea16d/pic01.png"></p>
<h4 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DispSync::<span class="built_in">DispSync</span>(<span class="type">const</span> <span class="type">char</span>* name) : <span class="built_in">mName</span>(name), <span class="built_in">mRefreshSkipCount</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// This flag offers the ability to turn on systrace logging from the shell.</span></span><br><span class="line">    <span class="type">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="built_in">property_get</span>(<span class="string">&quot;debug.sf.dispsync_trace_detailed_info&quot;</span>, value, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    mTraceDetailedInfo = <span class="built_in">atoi</span>(value);</span><br><span class="line">    mThread = <span class="keyword">new</span> <span class="built_in">DispSyncThread</span>(name, mTraceDetailedInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其构造方法比较简单，接受一个 name 入参，为：”SchedulerDispSync” ，具体是在 Scheduler 构造方法中调用并传入的，详见：<a href="2fa835ad.html">SurfaceFlinger(一)</a>中创建 Scheduler 处的解释。</p>
<p>而进入该方法内部，最主要的逻辑是为其内部 mThread 属性创建一个  DispSyncThread 实例，并且将入参 name 传入进去。而 DispSyncThread  类的定义和实现都在 DispSync 中，它内部承载了 DispSync 中的主要逻辑。而且从上面类图可以看出，DispSyncThread 继承自 Thread 类，后续可以将其当做 Thread 类来用，它当中的指定方法会运行在其对应的单独线程中。</p>
<h4 id="2、初始化init"><a href="#2、初始化init" class="headerlink" title="2、初始化init"></a>2、初始化init</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::init</span><span class="params">(<span class="type">bool</span> hasSyncFramework, <span class="type">int64_t</span> dispSyncPresentTimeOffset)</span> </span>&#123;</span><br><span class="line">    mIgnorePresentFences = !hasSyncFramework;</span><br><span class="line">    mPresentTimeOffset = dispSyncPresentTimeOffset;</span><br><span class="line">    mThread-&gt;<span class="built_in">run</span>(<span class="string">&quot;DispSync&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set DispSync to SCHED_FIFO to minimize jitter</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sched_setscheduler</span>(mThread-&gt;<span class="built_in">getTid</span>(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for DispSyncThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">beginResync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTraceDetailedInfo &amp;&amp; kEnableZeroPhaseTracer) &#123;</span><br><span class="line">        mZeroPhaseTracer = std::<span class="built_in">make_unique</span>&lt;ZeroPhaseTracer&gt;();</span><br><span class="line">        <span class="built_in">addEventListener</span>(<span class="string">&quot;ZeroPhaseTracer&quot;</span>, <span class="number">0</span>, mZeroPhaseTracer.<span class="built_in">get</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一个重要的方法就是其 init 方法了，这个方法内部完成了 mThread ，也就是上面创建出来的 DispSyncThread  线程的启动。主要是先调用其 run() 方法，然后给其设置优先级。这里设置的优先级会保证 DispSyncThread  线程被操作系统优先唤起，尽量减少了 DispSyncThread 线程的执行误差。</p>
<p>所以说每当执行完 DispSync::init 方法之后，其内部对应的 DispSyncThread 线程就会启动，然后开始执行指定方法，而这个指定方法是什么呢？其实是其：threadLoop() 方法，该方法就可以理解为 Java Thread 中的 run 方法了。而 threadLoop 方法其实是在 DispSyncThread  类内的，因为它继承了 Thread 类，然后自己重写了该方法而已。为了保持思维一贯性，接下来就先看看这方法</p>
<h4 id="3、DispSyncThread-内-threadLoop"><a href="#3、DispSyncThread-内-threadLoop" class="headerlink" title="3、DispSyncThread 内 threadLoop"></a>3、DispSyncThread 内 threadLoop</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">        <span class="type">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mTraceDetailedInfo) &#123;</span><br><span class="line">                <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);</span><br><span class="line">            ++mFrameNumber;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            targetTime = <span class="built_in">computeNextEventTimeLocked</span>(now);</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> isWakeup = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (now &lt; targetTime) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mTraceDetailedInfo) <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;DispSync waiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (targetTime == INT64_MAX) &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting forever&quot;</span>, mName);</span><br><span class="line">                    err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(targetTime));</span><br><span class="line">                    err = mCond.<span class="built_in">waitRelative</span>(mMutex, targetTime - now);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err == TIMED_OUT) &#123;</span><br><span class="line">                    isWakeup = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don&#x27;t correct by more than 1.5 ms</span></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">nsecs_t</span> kMaxWakeupLatency = <span class="built_in">us2ns</span>(<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWakeup) &#123;</span><br><span class="line">                mWakeupLatency = ((mWakeupLatency * <span class="number">63</span>) + (now - targetTime)) / <span class="number">64</span>;</span><br><span class="line">                mWakeupLatency = <span class="built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);</span><br><span class="line">                <span class="keyword">if</span> (mTraceDetailedInfo) &#123;</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            callbackInvocations = <span class="built_in">gatherCallbackInvocationsLocked</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callbackInvocations.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fireCallbackInvocations</span>(callbackInvocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是 DispSyncThread  中的一大核心，下面花较长的篇幅来介绍下。</p>
<blockquote>
<p>由上面分析可以知道，在外部创建完 DispSync 实例，并且调用其 init 方法之后，其内部的 DispSyncThread 线程就会启动，并且开始执行如上的 threadLoop 方法。这是该方法执行的前提。</p>
</blockquote>
<p>可以看到，threadLoop 方法中，其实整体都是被包在一个死循环 while(true) 中的，然后内部先定义 callbackInvocations 变量，用来存储最终 vsync callback 的目标，也就是哪些外部监听者此时应该被回调 vsync 事件。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CallbackInvocation</span> &#123;</span><br><span class="line">  DispSync::Callback *mCallback;</span><br><span class="line">  <span class="type">nsecs_t</span> mEventTime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实就是个结构体，将   <strong>外部注册进来的监听 mCallback</strong> 和  <strong>该 mCallback 本次vsync 发生的时间</strong>    两者封装了起来而已。</p>
<p>然后就将 mFrameNumber 自增1，这个属性没有啥用处。然后判断 mStop 如果被置为true 则终止该死循环，而当调用 DispSyncThread 中的 stop() 方法时它就会被置为true，比如在 DispSync 析构函数中会调用。</p>
<p><strong>3.1：执行第一次线程休眠</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">   err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">   <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">       <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的线程休眠逻辑是当 mPeriod &#x3D;0 时，会开始一直休眠。而mPeriod  对应的就是 vsync 信号的周期，比如屏幕刷新频率为 60Hz 的情况下，vsync信号周期就是 1s&#x2F;60 &#x3D; 16.67ms。而一般情况下，DispSyncThread 一开始被启动之后， mPeriod 肯定是 0 ，因为来自 HWC 上层的vsync 信号还没有送达，所以此时都是在这里阻塞住线程执行，将该线程一直休眠下去，直到后续调用  mCond.signal() 来将其唤醒了。</p>
<p>所以承接上面 DispSync::init 方法来讲，当外部创建了 DispSync 对象并且调用了其 init 方法之后，DispSyncThread 线程开始执行，执行到这里之后就会阻塞线程开始休眠，等待后续唤醒了。</p>
<p>比如：后续外部SurfaceFlinger 在收到来自 HWC 的vsync 信号，然后一层层调用到 DispSyncThread 中的 updateModel  方法中来，然后修改 mPeriod 的值之后，执行：mCond.signal() 来唤醒这里的等待，此时被唤醒之后，会接着往下执行，遇到到continue之后重头开始执行。等再次执行到这里时，就不会被阻塞了。</p>
<p><strong>3.2：根据period、phase的值来计算下一次vsync事件发生的时间</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">targetTime = <span class="built_in">computeNextEventTimeLocked</span>(now);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isWakeup = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (now &lt; targetTime) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mTraceDetailedInfo) <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;DispSync waiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (targetTime == INT64_MAX) &#123;</span><br><span class="line">     <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting forever&quot;</span>, mName);</span><br><span class="line">     err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(targetTime));</span><br><span class="line">     err = mCond.<span class="built_in">waitRelative</span>(mMutex, targetTime - now);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err == TIMED_OUT) &#123;</span><br><span class="line">     isWakeup = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">     <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的核心是 computeNextEventTimeLocked 方法，传入的 now 是上面获取的系统当前时间，但是这个时间不是即时的，因为它在被赋值之后，中间可能会存在线程休眠再唤醒的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeNextEventTimeLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] computeNextEventTimeLocked&quot;</span>, mName);</span><br><span class="line">    <span class="type">nsecs_t</span> nextEventTime = INT64_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], now);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt; nextEventTime) &#123;</span><br><span class="line">            nextEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] nextEventTime = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(nextEventTime));</span><br><span class="line">    <span class="keyword">return</span> nextEventTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 computeNextEventTimeLocked 方法中，会遍历内部的  mEventListeners 列表，然后通过 computeListenerNextEventTimeLocked 方法来计算：对于每个EventListener 来说，所对应的下个vsync信号发生的时刻是什么。而一个 EventListener 对应的是外部一个vsync监听者。</p>
<blockquote>
<p>对于SurfaceFlinger 自身算一个监听者，它通过 sf EventThread 来的注册监听来接收 vsync 信号。而另外还有 app EventThread ，它是每个独立的app所注册过来的，也就是每个独立的app也会受到vsync事件。当然他们能接收到的前提是他们请求过vsync信号，只要请求过vsync信号，那么它就会通过 DispSyncSource 来往 DispSyncThread 中注册一个 EventListener。所以说一个 EventListener 就可以理解为一个外部Vsync监听者。后者使用这两个描述时基本都等价。</p>
</blockquote>
<p>而computeListenerNextEventTimeLocked 返回的值就是：<strong>其入参1 EventListener 相对于入参2 now 这一时刻来说，它的下一次 vsync 应该发生的时间</strong>。所以这里使用其和 nextEventTime 去作比较，nextEventTime 默认是 INT64_MAX 也就是一个最大值，然后经由for循环之后，它保存的就是：computeListenerNextEventTimeLocked  方法返回的<strong>最小值</strong>，代表的意思就是：<strong>对于所有 EventListener 来说，距离下一个vsync时间最近的那个时刻</strong>。</p>
<blockquote>
<p>比如有 2个EventListener，当前时间 now&#x3D;100，由于存在 phase 相位差，每个 EventListener 被回调的时机是不一样的，这里针对这两个 EventListener 分别计算出来的时间是： 116和 120 (这不是时间戳格式，这里只是举例而已)，那么最终 nextEventTime 就是 116 ，也就是距离当前时间最近的那个。</p>
</blockquote>
<p>当然额外注意一点，如果 mEventListeners 为空的话，也就是外部没有请求 Vsync 的，那么这里会返回 INT64_MAX哦。</p>
<p>接下来压力来到了 computeListenerNextEventTimeLocked 方法这边：</p>
<p><strong>3.2.1：computeListenerNextEventTimeLocked()分析</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeListenerNextEventTimeLocked</span><span class="params">(<span class="type">const</span> EventListener&amp; listener, <span class="type">nsecs_t</span> baseTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] [%s] computeListenerNextEventTimeLocked(%&quot;</span> PRId64 <span class="string">&quot;)&quot;</span>, mName, listener.mName,</span><br><span class="line">          <span class="built_in">ns2us</span>(baseTime));</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> lastEventTime = listener.mLastEventTime + mWakeupLatency;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] lastEventTime: %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(lastEventTime));</span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; lastEventTime) &#123;</span><br><span class="line">        baseTime = lastEventTime;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Clamping baseTime to lastEventTime -&gt; %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(baseTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    baseTime -= mReferenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Relative baseTime = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(baseTime));</span><br><span class="line">    <span class="type">nsecs_t</span> phase = mPhase + listener.mPhase;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Phase = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(phase));</span><br><span class="line">    baseTime -= phase;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] baseTime - phase = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(baseTime));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If our previous time is before the reference (because the reference</span></span><br><span class="line">    <span class="comment">// has since been updated), the division by mPeriod will truncate</span></span><br><span class="line">    <span class="comment">// towards zero instead of computing the floor. Since in all cases</span></span><br><span class="line">    <span class="comment">// before the reference we want the next time to be effectively now, we</span></span><br><span class="line">    <span class="comment">// set baseTime to -mPeriod so that numPeriods will be -1.</span></span><br><span class="line">    <span class="comment">// When we add 1 and the phase, we will be at the correct event time for</span></span><br><span class="line">    <span class="comment">// this period.</span></span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Correcting negative baseTime&quot;</span>, mName);</span><br><span class="line">        baseTime = -mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> numPeriods = baseTime / mPeriod;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] numPeriods = %&quot;</span> PRId64, mName, numPeriods);</span><br><span class="line">    <span class="type">nsecs_t</span> t = (numPeriods + <span class="number">1</span>) * mPeriod + phase;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] t = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(t));</span><br><span class="line">    t += mReferenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Absolute t = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(t));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that it&#x27;s been slightly more than half a period since the last</span></span><br><span class="line">    <span class="comment">// event so that we don&#x27;t accidentally fall into double-rate vsyncs</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isCloseToPeriod</span>(t - listener.mLastEventTime)) &#123;</span><br><span class="line">        t += mPeriod;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Modifying t -&gt; %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t -= mWakeupLatency;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Corrected for wakeup latency -&gt; %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先解释一下几个关键变量的含义：</p>
<p><strong>mWakeupLatency ：</strong>它表示的是当前 DispSyncThread 线程在休眠指定时长的情况下，休眠时间结束了，但是由于操作系统调度存在延迟的可能，会导致线程被延迟唤醒。该变量就用来计算存储延迟唤醒的时间差，详见下面第三步。</p>
<p><strong>listener.mLastEventTime：</strong>首先这个 listener 时前面刚说过的 EventListener ，其类结构可以看最上面的类图，其内部就是将外部回调，以及该回调上次被回调时的时间戳mLastCallbackTime、按照周期来算的话它上次应该发生vsync事件的时间mLastEventTime，以及它独有的vsync相位差mPhase。</p>
<blockquote>
<p>1、mLastEventTime具有周期性，周期是 mPeriod，比如16.6ms，</p>
<p>2、mLastCallbackTime是大于mLastEventTime的</p>
<p>3、假设周期是16，那么mLastEventTime 可能就是 0,16,32,48….这些，而mLastCallbackTime可能是 1,18,35,49…等，因为这是线程轮询判断当前时间是否达到mLastEventTime，达到的话则回调出去。也就是每过一会儿判断下【计算出来的vsync事件时】间是否小于系统当前时间now，小于的话，则表示到达了vsync回调的时间了，则开始回调，此时会把 mLastCallbackTime 置为now，把mLastEventTime置为计算出来的那个具有周期性的值。</p>
<p>上面说的【计算出来的vsync事件时间】对应使用的就是 computeListenerNextEventTimeLocked 方法。而上面3说的赋值逻辑，是在下面第三步中会讲到的 gatherCallbackInvocationsLocked() 中。</p>
</blockquote>
<p><strong>mReferenceTime：</strong>相对时间戳，这个时间其实就是 SurfaceFlinger 接收到HWC传递过来的Vsync事件时的时间戳。其调用路径堆栈为：SurfaceFlinger::onVsyncReceived -&gt; Scheduler::addResyncSample -&gt; DispSync::addResyncSample -&gt; DispSyncThread::updateModel 。所以可以粗略的把它理解为是上层硬件产生vsync的时间，它保持着固定的频率，属于硬件上的。但是这里的 DispSyncThread 这些是属于软件环境，它可能会存在误差，比如由于操作系统调度原因等，导致产生了偏差，所以软件的vsync是按照软件自身环境来调节的。但是他们俩具有相同的周期。而这里使用它作为计算基准，因为它是相对于硬件的，时间是稳定的。</p>
<p><strong>mPhase：</strong>可以理解为是偏移量，这个的值只会在 DispSyncThread :: updateModel 方法中被修改。它可以认为是软件环境和硬件环境之间的误差吧。它是软件环境动态计算出来的，根据前面的软件vsync和硬件vsync信号的差量动态算出来的平均值。因为硬件vsync 是具有周期性的，而软件vsync 也是具有周期性的，他俩周期是一样的，但是会有偏移差量。如果用正弦函数来理解的话，mPhase就是相位差，由于周期相同，则sin(ωt+Φ) 中只有Φ不一样。详见：DispSync::updateModelLocked()</p>
<p>**listener.mPhase:**前面讲过，这里的 listener ，其实就是 EventListener ，它代表了一个外部的vsync信号观察者。比如 SurfaceFlinger ，或者是其他的App。假如此时有两个观察者注册了监听：SurfaceFlinger 、APP1。此时这两者同时都请求了vsync 信号，那么当在下一个vsync信号到达之时，DispSyncThread 中会回调这俩观察者。此时先回调哪个呢？我们先分析一下回调之后的场景：</p>
<ol>
<li>回调给SurfaceFlinger ：是为了合成当前所有的Layer，将每个Layer 中绘制的内容合成在一起(通过OpenglES 或者直接送达 HWC)；</li>
<li>回调给 APP1              ：是为了通知它可以进行绘制了，比如通知其 Choreographer 类来进行 ViewRoot traversal 来进行 measure layout draw 等操作，通过canvas 将APP1中的内容绘制到指定地方去(比如 GraphicBuffer 中)。也就是作为生产者Producer。</li>
</ol>
<p>所以针对 SurfaceFlinger 注册的vsync listener 和普通APP的 vsync listener ，是需要错开点时间的。一是为了缓解cpu压力，避免cpu同时处理太多事务。二是先生产（APP1）后消费(SurfaceFlinger 合成)会使得流程更加顺畅。所以针对listener，也会设置不同的偏移量。比如要使得 SurfaceFlinger 比 APP1 延后 1ms 的话，则只需要给SurfaceFlinger注册 listener 的时候，设置额外的偏移phase 即可。详见：DispSync::addEventListener</p>
<p><strong>mPeriod:</strong> 其实这个就是前面讲的vsync周期了。比如是 16.6ms。它一般是通过 SurfaceFlinger::getVsyncPeriod 方法去 HWC 层获取硬件的vsync周期的，它是固定的值。但是在 DispSync 运作过程中，会根据之前经历的 vsync 信号的时间来动态微调它，就跟 mPhase 差不多，详见：DispSync::updateModelLocked()</p>
<p><strong>baseTime</strong>：computeListenerNextEventTimeLocked()方法的入参，表示<strong>基于哪个时刻来计算该 listener 的下一次 vsync 时间的</strong>，翻译过来也就是：基于 baseTime 这个时刻，来计算该 listener 的下一次vsync 时间。而从 computeNextEventTimeLocked 方法调用过来时，传入的 baseTime 是 now。now在上面讲过了，它表示的是系统当前时间，但是却有延迟，因为可能存在线程休眠导致 now 和系统当前时间不同步，即 now &lt;&#x3D; 系统当前时间。下面为了方便好理解，有些图中会直接使用 now 来替换 baseTime，但是实际的 baseTime 并不总是等于 now。因为computeListenerNextEventTimeLocked 方法可能存在两个地方的调用。</p>
<p>接下来开始分析具体逻辑，首先我们可以将  mWakeupLatency 当做 0 来考虑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">nsecs_t</span> lastEventTime = listener.mLastEventTime + mWakeupLatency;</span><br><span class="line"><span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] lastEventTime: %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(lastEventTime));</span><br><span class="line"><span class="keyword">if</span> (baseTime &lt; lastEventTime) &#123;</span><br><span class="line">   baseTime = lastEventTime;</span><br><span class="line">   <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Clamping baseTime to lastEventTime -&gt; %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(baseTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是拿到该 EventListener 的 mLastEventTime，也就是该观察者上次被回调 Vsync 事件的时间。</p>
<p>下面开始分情况讨论：</p>
<p>1、baseTime 小于 lastEventTime</p>
<p><img src="/6caea16d/pic02.png"></p>
<p>这种情况的话，可以理解为纠正 baseTime，使其大于等于listener.mLastEventTime (也就是 event4)  。</p>
<p>解释下上面的图， event0….event4 表示该观察者 listener 上被周期性的回调了多次 vsync ，一个 event 表示一个 vsync 事件，可以看到理想情况下，每个 vsync event 之间的时间间隔都是固定的 mPeriod （比如16.6ms）。该listener上次回调到了 event4 ，此时要获取 event5 所对应的时间戳。但是此时 now 小于了 event4 （也就是小于 listener.mLastEventTime），那么此时将 baseTime 纠正为 listener.mLastEventTime，也就是使用 event4 (该观察者 listener上次发生vsync 事件的时间)来作为基准时间，来计算 event5。</p>
<p>2、baseTime 大于等于 lastEventTime</p>
<p><img src="/6caea16d/pic03.png"></p>
<p>这种情况的话，不做任何操作，now就处于 event4(上次 vsync event) 和 event5(即将要发生的 vsync event) 之间。</p>
<p>接下来贴出来一个该方法的主要框架：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">nsecs_t</span> <span class="title function_">computeListenerNextEventTimeLocked</span><span class="params">(<span class="type">const</span> EventListener&amp; listener, <span class="type">nsecs_t</span> baseTime)</span> &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> lastEventTime = listener.mLastEventTime + mWakeupLatency;</span><br><span class="line">        <span class="keyword">if</span> (baseTime &lt; lastEventTime) &#123;</span><br><span class="line">            baseTime = lastEventTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        baseTime -= mReferenceTime;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略关键代码，单独分析</span></span><br><span class="line">       </span><br><span class="line">        t += mReferenceTime;</span><br><span class="line">  </span><br><span class="line">        t -= mWakeupLatency;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，先在 baseTime  基础上减去了mReferenceTime 。然后在该方法的最后，返回结果 t 之前，又将 mReferenceTime  加了回来，所以说最终返回的 t 也是时间戳， baseTime 减去 mReferenceTime  只是为了计算差值，计算出来： baseTime 和 mReferenceTime 时间戳之间的差值。而 mReferenceTime 的含义，在上面解释过了，它是硬件层面的vsync 时间戳，表示 mReferenceTime 时刻硬件vsync事件发生了，具有固定的周期。而这里的计算的是软件层面的 vsync 时间，由于操作系统调度会存在误差，所以以 mReferenceTime  为基准，计算出当前软件层面的 baseTime (now)时间戳距离硬件真正的vsync mReferenceTime  时间戳之间的差值，从而判断出当前已在软件层面度过了多长时间。</p>
<p>当然这里计算出来的差值可正可负，负数的次数很少，计算出负数其实个人觉得是异常情况了。</p>
<p>所以下面接着分析上面代码框架中省略的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">nsecs_t</span> phase = mPhase + listener.mPhase;</span><br><span class="line">ALOGV(<span class="string">&quot;[%s] Phase = %&quot;</span> PRId64, mName, ns2us(phase));</span><br><span class="line">baseTime -= phase;</span><br><span class="line">ALOGV(<span class="string">&quot;[%s] baseTime - phase = %&quot;</span> PRId64, mName, ns2us(baseTime));</span><br><span class="line"></span><br><span class="line"><span class="comment">// If our previous time is before the reference (because the reference</span></span><br><span class="line"><span class="comment">// has since been updated), the division by mPeriod will truncate</span></span><br><span class="line"><span class="comment">// towards zero instead of computing the floor. Since in all cases</span></span><br><span class="line"><span class="comment">// before the reference we want the next time to be effectively now, we</span></span><br><span class="line"><span class="comment">// set baseTime to -mPeriod so that numPeriods will be -1.</span></span><br><span class="line"><span class="comment">// When we add 1 and the phase, we will be at the correct event time for</span></span><br><span class="line"><span class="comment">// this period.</span></span><br><span class="line"><span class="keyword">if</span> (baseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;[%s] Correcting negative baseTime&quot;</span>, mName);</span><br><span class="line">    baseTime = -mPeriod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">nsecs_t</span> numPeriods = baseTime / mPeriod;</span><br><span class="line">ALOGV(<span class="string">&quot;[%s] numPeriods = %&quot;</span> PRId64, mName, numPeriods);</span><br><span class="line"><span class="type">nsecs_t</span> t = (numPeriods + <span class="number">1</span>) * mPeriod + phase;</span><br><span class="line">t += mReferenceTime;</span><br></pre></td></tr></table></figure>

<p>经过上面的计算之后，此时 baseTime 表示的就是减去 mReferenceTime 之后的时间差值了。此时先计算出 phase 偏移量，其中 mPhase 对于DispSync 中的所有 Listener 都是一样的，差异主要体现在 listener.mPhase ，即不同的listener监听者都可以给自身设置不同的偏移量。比如在 SurfaceFlinger::init 方法执行时，回调用 Scheduler::createConnection 来分别创建 sf 和 app EventThread时，就设置了偏移量。关于 mPhase 以及 listener.mPhase 的解释，在上面有写到。</p>
<p>然后将 baseTime 减去 phase，因为 phase 表示的时间时该 listener 需要延迟回调的时间，所以需要在时间差值 baseTime 上减去它。</p>
<p>然后判断 baseTime 是否小于0，如果是的话则将其修改为 -mPeriod，因为为了保证最终 baseTime &#x2F; mPeriod &#x3D; -1。当然 baseTime小于0也是少数情况，比如外部更新了 mReferenceTime ，这里相当于是异常情况兜底了。</p>
<p>接着就使用 baseTime 除以 mPeriod ，也就是设置 vsync 周期，结果 numPeriods 就是： baseTime(可以想象为当前时间 now )距离硬件 mReferenceTime 过了多少个周期。</p>
<p>然后再将其加一(表示当前的下一个周期)乘以 mPeriod ，表示计算到其下一个event发生的实际。</p>
<p>比如下面两张图中的情况：</p>
<p><img src="/6caea16d/pic04.png"></p>
<p>如上面图所示，计算出来的差值Delta可能比较小,小于mPeriod，此时将其除以 mPeriod 之后计算出来的 numPeriods  &#x3D; 0。然后将其加一乘以 mPeriod ，也就是 (0+1)*mPeriod 计算出当前 baseTime 之后的下一个 event 时间戳，也就是图上的event3。</p>
<p><img src="/6caea16d/pic05.png"></p>
<p>如上面图所示，计算出来的Delta较大，比如CPU繁忙导致软件层面线程唤醒延迟了，导致now较大，计算出来的差值delta包括了好几个周期，那么此时使用 delta除以 mPeriod 得到 numPeriods  &#x3D; 2 ,再去计算 event3 &#x3D; (2+1)*mPeriod 。此时这种情况中间有两次 vsync 事件被跳过了，也就是跳帧。这种情况出现的话，会产生卡顿现象。</p>
<p>当然还要额外加上 phase，因为它是延迟量。最后再在 t 的基础上加上之前减去的 mReferenceTime ，此时 t 就是该 Listener 从 baseTime 开始往后的下一次vsync event 事件戳了。</p>
<p>接着往下就是调用 isCloseToPeriod 方法来判断：<strong>计算出来的下一次vsync event 的时间距离其上一次回调vsync event 的时间差是否太小</strong>，即可能是计算错误之类的，时间差太小的话就将其再加上 mPeriod ，即往后顺延一周期。</p>
<p>所以简单总结下，computeListenerNextEventTimeLocked 方法的主要作用就是：计算对应的 Listener 相对于 baseTime 来说（将其作为起始点往后），下一个 vsync event 发生时的时间戳。比如baseTime传入now时，则可以计算出相对于当前系统时间now，该Listener 的下一次 vsync event 发生时间戳。</p>
<p>所以分析完computeListenerNextEventTimeLocked 方法之后，我们回到3.2的 computeNextEventTimeLocked 方法中。在此时看该方法就比较明了了。遍历所有注册的 Listener ，然后挨个执行 computeListenerNextEventTimeLocked  方法，挨个计算出其相对于当前时间now 的下一个vsync event 时间，然后取最小值保存到 nextEventTime 中返回出去。也就是返回距离回调下一个 Listener 最近的那个时间戳targetTime。</p>
<p><strong>3.3：第二次休眠，休眠到下一次vsync时刻时，收集对应的Listener</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isWakeup = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (now &lt; targetTime) &#123;</span><br><span class="line">   <span class="keyword">if</span> (mTraceDetailedInfo) <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;DispSync waiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (targetTime == INT64_MAX) &#123;</span><br><span class="line">      <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting forever&quot;</span>, mName);</span><br><span class="line">      err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(targetTime));</span><br><span class="line">      err = mCond.<span class="built_in">waitRelative</span>(mMutex, targetTime - now);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (err == TIMED_OUT) &#123;</span><br><span class="line">      isWakeup = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">      <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t correct by more than 1.5 ms</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">nsecs_t</span> kMaxWakeupLatency = <span class="built_in">us2ns</span>(<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isWakeup) &#123;</span><br><span class="line">   mWakeupLatency = ((mWakeupLatency * <span class="number">63</span>) + (now - targetTime)) / <span class="number">64</span>;</span><br><span class="line">   mWakeupLatency = <span class="built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);</span><br><span class="line">   <span class="keyword">if</span> (mTraceDetailedInfo) &#123;</span><br><span class="line">      <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);</span><br><span class="line">      <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">callbackInvocations = <span class="built_in">gatherCallbackInvocationsLocked</span>(now);</span><br></pre></td></tr></table></figure>

<p>如上面分析，targetTime表示的是：距离回调下一个 Listener 最近的那个时间戳 。此时判断now如果小于targetTime 表示还没有到回调下一个Listener 的时候呢，此时需要休眠当前 DispSyncThread 线程，休眠时间为： targetTime - now 。等休眠结束后，也就到了 targetTime 时刻了，此时再去回调对应 Listener。而如果 targetTime &#x3D;&#x3D; INT64_MAX 的话，表示此时没有 Listener ，导致computeNextEventTimeLocked 返回了 INT64_MAX  ，这种情况则一直休眠，直到下次 addEventListener 等方法将其唤醒。</p>
<p>这里的 isWakeup 默认是 false，当休眠正常结束时，表示线程是休眠结束被操作系统调度唤醒的，则将其置为 true。然后再计算唤醒的延迟。此时先更新下 now 为 systemTime(SYSTEM_TIME_MONOTONIC) ，也就是当前被唤醒之后，系统的实时时间。然后使用 now - targetTime 就能算出唤醒延迟了，因为前面设置的休眠时间是休眠到 target 时刻的，但是由于延迟导致被唤醒时的 now 大于 target 了。注意这里是按照比例来计算延迟的，即上次的延迟时间mWakeupLatency占63&#x2F;64，这次的延迟时间占1&#x2F;64。我觉得可能是因为cpu繁忙时间不一样，会波动。这样按比例来算的话，当CPU波动较大时，软件层面的波动会小一些，或者说是稳定些。而等CPU稳定之后，其值也是稳定的。</p>
<p>等休眠结束后，更新了 now 之后，最后一步就是回调对应的 Listener 了。也就是调用 gatherCallbackInvocationsLocked 来收集此时需要回调的Listener。</p>
<p>3.5：gatherCallbackInvocationsLocked</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CallbackInvocation&gt; <span class="title function_">gatherCallbackInvocationsLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> &#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">   <span class="comment">// 当前系统时间减去一个周期长度，就是一个周期前对应的时间戳了</span></span><br><span class="line">   <span class="type">nsecs_t</span> onePeriodAgo = now - mPeriod;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;eventListener: mEventListeners) &#123;</span><br><span class="line">     <span class="comment">// 每个监听者下一次 VSYNC 信号的发生时间可能都不同，因为可能设置了不同的偏移</span></span><br><span class="line">     <span class="comment">// 因此针对每个监听者都要计算下一次VSYNC信号</span></span><br><span class="line">     <span class="type">nsecs_t</span> t = computeListenerNextEventTimeLocked(eventListener, onePeriodAgo);</span><br><span class="line">     <span class="comment">// 如果计算出来该 listener 的下次回调时间 t 小于当前时间 now ，表示到了该回调它的时候了</span></span><br><span class="line">     <span class="keyword">if</span> (t &lt; now) &#123;</span><br><span class="line">       <span class="comment">// 如果这个listener 距离上次回调它过去的时间，小于 mPeriod 的 3/5 ，则表示周期太短了</span></span><br><span class="line">       <span class="comment">// 跳过这次回调，避免由于错误计算之类的原因导致回调上层vsync过快</span></span><br><span class="line">       <span class="keyword">if</span> (isCloseToPeriod(now - eventListener.mLastCallbackTime)) &#123;</span><br><span class="line">         eventListener.mLastEventTime = t;</span><br><span class="line">         ALOGV(<span class="string">&quot;[%s] [%s] Skipping event due to model error&quot;</span>, mName, eventListener.mName);</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       CallbackInvocation ci;</span><br><span class="line">       ci.mCallback = eventListener.mCallback;</span><br><span class="line">       ci.mEventTime = t;</span><br><span class="line">       callbackInvocations.push_back(ci);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 修改该listener 上次发送 event 的时间为计算出来的t，mLastEventTime 是具有周期性的</span></span><br><span class="line">       eventListener.mLastEventTime = t;  </span><br><span class="line">       <span class="comment">// mLastCallbackTime 是 DispSyncThread 回调的时间，大于 mLastEventTime</span></span><br><span class="line">       <span class="comment">// 不大于也走不到这个if 里面来。</span></span><br><span class="line">       eventListener.mLastCallbackTime = now;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> callbackInvocations;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如上，内部还是调用 computeListenerNextEventTimeLocked 方法来计算那些 Listener 到达了该回调的时间，则将其加入到 callbackInvocations 列表中去，注意这里会修改 EventListener 的 mLastEventTime 和 mLastCallbackTime 。从这里也就能看出来这俩的区别了，mLastEventTime 是具有周期性的，而mLastCallbackTime是具体 DispSyncThread 回调的时间，其大于 mLastEventTime。</p>
<p><strong>3.4：将收集到的Listener回调出去</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   fireCallbackInvocations(callbackInvocations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要通过 fireCallbackInvocations 来将前面收集到的 Listener 列表回调出去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fireCallbackInvocations</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CallbackInvocation&gt; &amp;callbacks)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mTraceDetailedInfo) ATRACE_CALL();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; callbacks.size(); i++) &#123;</span><br><span class="line">     callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>而 fireCallbackInvocations 中逻辑也很简单，就是调用到每个 Listener 中的  onDispSyncEvent 方法中去，其实也就是到 DispSyncSource.cpp 中的  onDispSyncEvent 方法内。</p>
<h4 id="4、DispSyncSource-简介"><a href="#4、DispSyncSource-简介" class="headerlink" title="4、DispSyncSource 简介"></a>4、DispSyncSource 简介</h4><p>DispSyncSource 类逻辑较为简单，所以将其放在 DispSync 一起分析。DispSyncSource 可以理解为唯一的 DispSync 和两个 EventThread 之间的桥梁。</p>
<blockquote>
<p>在 SurfaceFlinger 中持有两个 EventThread ，一个是 app ，一个是 sf ，而这两个 EventThread 中又分别持有一个 DispSyncSource 。而在每个 DispSyncSource 内部又都同时持有同一个 DispSync 实例。</p>
<p>使用的时候，如果对应的 EventThread 需要接受 vsync 事件的话，则会调用其内部的 DispSyncSource 的 setVSyncEnabled(true) 方法，则此时DispSyncSource 中就会往其内部的 DispSync 中注册一个 Listener 。等后续Listener回调时，会先回调到 DispSyncSource 中的 onDispSyncEvent ，然后再从这里回调到 EventThread 中的 onVSyncEvent 方法中，此时就将 vsync 事件传递到了 EventThread 消息机制中。</p>
</blockquote>
<p>懒得画了，借用一张网图：</p>
<p><img src="/6caea16d/pic06.png"></p>
<p>这里只分析 DispDyncSource 中的 setVSyncEnabled 方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DispSyncSource::setVSyncEnabled</span><span class="params">(<span class="type">bool</span> enable)</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard <span class="title function_">lock</span><span class="params">(mVsyncMutex)</span>;</span><br><span class="line">  <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">    tracePhaseOffset();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mDispSync : 其实就是 Schedule.cpp # mPrimaryDispSync</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以在 DispSync 中的 mEventListeners 中保存的回调也就是当前 DispSyncSource 自身</span></span><br><span class="line"><span class="comment">     * 而 DispSyncSource 实现了 DispSync.cpp # DispSync::Callback 接口中的 onDispSyncEvent 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">status_t</span> err = mDispSync-&gt;addEventListener(mName, mPhaseOffset, static_cast&lt;DispSync::Callback *&gt;(this),</span><br><span class="line">                                               mLastCallbackTime);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">      ALOGE(<span class="string">&quot;error registering vsync callback: %s (%d)&quot;</span>, strerror(-err), err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 1);</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">status_t</span> err = mDispSync-&gt;removeEventListener(static_cast&lt;DispSync::Callback *&gt;(this), &amp;mLastCallbackTime);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">      ALOGE(<span class="string">&quot;error unregistering vsync callback: %s (%d)&quot;</span>, strerror(-err), err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 0);</span></span><br><span class="line">  &#125;</span><br><span class="line">  mEnabled = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是调用其内部持有的 mDispSync ，也就是 DispSync 实例的 addEventListener 或者 removeEventListener 方法来分别注册或者移除vsync event监听。</p>
<h4 id="5、DispSync-接受来自-HWC-的-vsync-事件"><a href="#5、DispSync-接受来自-HWC-的-vsync-事件" class="headerlink" title="5、DispSync 接受来自 HWC 的 vsync 事件"></a>5、DispSync 接受来自 HWC 的 vsync 事件</h4><p>在 SurfaceFlinger 中往 Display 中注册了监听，可以接收到来自上层硬件设备的 vsync 事件，即在 SurfaceFlinger::onVsyncReceived ，然后一步步传递到 DispSync::addResyncSample 中来，其中会把对应的 vsync 时间戳传递进来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DispSync::addResyncSample</span><span class="params">(<span class="type">nsecs_t</span> timestamp, <span class="type">bool</span> *periodFlushed)</span> &#123;</span><br><span class="line">  Mutex::Autolock <span class="title function_">lock</span><span class="params">(mMutex)</span>;</span><br><span class="line"></span><br><span class="line">  ALOGV(<span class="string">&quot;[%s] addResyncSample(%&quot;</span>PRId64<span class="string">&quot;)&quot;</span>, mName, ns2us(timestamp));</span><br><span class="line"></span><br><span class="line">  *periodFlushed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 计算出当前进来的 vsync采样数据  对应的索引</span></span><br><span class="line"><span class="comment">   * mFirstResyncSample 表示当前 mResyncSamples 数组中第一个的索引</span></span><br><span class="line"><span class="comment">   * mNumResyncSamples 表示当前 mResyncSamples 数组中有多少个可用的采样数，最大不超过 MAX_RESYNC_SAMPLES</span></span><br><span class="line"><span class="comment">   * 外部会一直调用当前 addResyncSample 方法来添加来自硬件的 vsync 信号采样数据，存储在 mResyncSamples 中，</span></span><br><span class="line"><span class="comment">   * 它是一个长度为 MAX_RESYNC_SAMPLES 的数组，通过 mFirstResyncSample 、 mNumResyncSamples 一起来计算当前的索引</span></span><br><span class="line"><span class="comment">   * 当采样数小于 MAX_RESYNC_SAMPLES 时，mNumResyncSamples 每次自增，表示当前存储了多少个采样；</span></span><br><span class="line"><span class="comment">   * 当大于 MAX_RESYNC_SAMPLES 时，时，mNumResyncSamples = MAX_RESYNC_SAMPLES ，mFirstResyncSample 开始循环自增</span></span><br><span class="line"><span class="comment">   * 即  (mFirstResyncSample + 1) % MAX_RESYNC_SAMPLES ，相当于该数组是一个循环数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;</span><br><span class="line">  mResyncSamples[idx] = timestamp;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果是第一次调用的 addResyncSample ，也就是来的第一个vsync 采样数据 ,</span></span><br><span class="line"><span class="comment">   * 此时将内部 mPhase 重置，相当于是从头开始了。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (mNumResyncSamples == <span class="number">0</span>) &#123;</span><br><span class="line">    mPhase = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPendingPeriod &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// mNumResyncSamples &gt; 0, so priorIdx won&#x27;t overflow</span></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这里是先求出前一个 vsync 信号的采样数据时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> priorIdx = (mFirstResyncSample + mNumResyncSamples - <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> lastTimestamp = mResyncSamples[priorIdx];</span><br><span class="line">    <span class="comment">// 这次的时间戳减去上次的，也就是这次vsync距离上次间隔了多长时间,这里单位是ns</span></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> observedVsync = <span class="built_in">std</span>::<span class="built_in">abs</span>(timestamp - lastTimestamp);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时 observedVsync 计算出来的是这次和上次接受到vsync信号的时间差，然后分别减去 mPendingPeriod 和 mIntendedPeriod</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 假如第一次的时候，外部调用 setPeriod() 方法设置进来的值在 mPendingPeriod 中存储，即mPendingPeriod不等于0，而 mIntendedPeriod = 0，所以第一次时这里肯定满足条件。</span></span><br><span class="line"><span class="comment">     * 此时条件体内部将 mIntendedPeriod 赋值为 mPendingPeriod ，mPendingPeriod 置为 0</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 然后等后续的话，如果不再调用 setPeriod() 方法了, mPendingPeriod =0 , mIntendedPeriod 不等于0 这种状态会一直保持</span></span><br><span class="line"><span class="comment">     * 所以后续不会走这个条件体内，而如果再次调用 setPeriod 设置了新的 period ，保存在了 mPendingPeriod 中，此时 mPendingPeriod 就不等于0了，</span></span><br><span class="line"><span class="comment">     * 那么此时 std::abs(observedVsync - mPendingPeriod) 和 std::abs(observedVsync - mIntendedPeriod) 的比较就</span></span><br><span class="line"><span class="comment">     * 是判断实际的 vsync 间隔距离 mPendingPeriod 和 mIntendedPeriod 哪个近，</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果距离新设置的 mPendingPeriod 近的话则使用新设置的 mPendingPeriod ，也就是 setPerid 生效了</span></span><br><span class="line"><span class="comment">     * 如果 setPeriod 新设置的 period 偏离当前的 vsync 间距较远，则可能不生效，也就是 mPeriod 不会使用 mPendingPeriod 的值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 用实际的数字举个例子：假如这里计算出来的两次vsync周期间隔为 observedVsync 是 1000 ，</span></span><br><span class="line"><span class="comment">     * 那么第一次的时候 mPendingPeriod = 900，mIntendedPeriod=0 ，那么此时肯定走到if条件体内，此时在条件体内会</span></span><br><span class="line"><span class="comment">     * 将 mPeriod 和 mIntendedPeriod 都从0赋值为900，mPendingPeriod 赋值成0，然后后续就一直以mPeriod=900来计算，</span></span><br><span class="line"><span class="comment">     * 然后外部又调用 setPeriod() 方法设置新的周期为800，那么此时 mPendingPeriod=800</span></span><br><span class="line"><span class="comment">     * 假设 observedVsync 还是 1000，那么此时1000肯定是距离 mIntendedPeriod 的900 近，而不是 mPendingPeriod 的 800</span></span><br><span class="line"><span class="comment">     * 所以此时不会走到里面去，所以 mPeriod 还是保持 900，也就是新设置的800没有生效</span></span><br><span class="line"><span class="comment">     * 而如果新设置的是950的话，则1000距离950更近，所以会进入if条件体内使用950作为新的 period</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 可以想象为 observedVsync、mPendingPeriod、mIntendedPeriod 为三个同一起点定长的线段，其中看 mPendingPeriod 和 mIntendedPeriod 那个线段长度和 observedVsync 的接近</span></span><br><span class="line"><span class="comment">     * 也就是设置的两个周期哪个与 observedVsync (实际的周期) 接近。</span></span><br><span class="line"><span class="comment">     * mPendingPeriod 保存的是外部调用 setPeriod 方法设置的 period 周期; mIntendedPeriod 是当前正在使用的周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">abs</span>(observedVsync - mPendingPeriod) &lt;= <span class="built_in">std</span>::<span class="built_in">abs</span>(observedVsync - mIntendedPeriod)) &#123;</span><br><span class="line">      <span class="comment">// Either the observed vsync is closer to the pending period, (and</span></span><br><span class="line">      <span class="comment">// thus we detected a period change), or the period change will</span></span><br><span class="line">      <span class="comment">// no-op. In either case, reset the model and flush the pending</span></span><br><span class="line">      <span class="comment">// period.</span></span><br><span class="line">      <span class="comment">// 由于 period 要发生变化了，所以重置清掉mResyncSamples中老的内容</span></span><br><span class="line">      resetLocked();</span><br><span class="line">      <span class="comment">// mPendingPeriod 是 setPeriod 方法设置的</span></span><br><span class="line">      <span class="comment">// 而 mIntendedPeriod 是只有这里if条件体内才会赋值</span></span><br><span class="line">      <span class="comment">// 将上次 setPeriod 设置的 period 也就是 mPendingPeriod 保存到 mIntendedPeriod 和 mPeriod 中</span></span><br><span class="line">      mIntendedPeriod = mPendingPeriod;</span><br><span class="line">      mPeriod = mPendingPeriod;</span><br><span class="line">      <span class="comment">// 然后将 mPendingPeriod 保存起来，等待下次 setPeriod 设置时再更改</span></span><br><span class="line">      mPendingPeriod = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (mTraceDetailedInfo) &#123;</span><br><span class="line">        ATRACE_INT(<span class="string">&quot;DispSync:PendingPeriod&quot;</span>, mPendingPeriod);</span><br><span class="line">        ATRACE_INT(<span class="string">&quot;DispSync:IntendedPeriod&quot;</span>, mIntendedPeriod);</span><br><span class="line">      &#125;</span><br><span class="line">      *periodFlushed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Always update the reference time with the most recent timestamp.</span></span><br><span class="line">  <span class="comment">// 这里只是修改了 DispSync 中的  mReferenceTime 字段，而不是 DispSyncThread 中的</span></span><br><span class="line">  <span class="comment">// 在 DispSyncThread 中也有一个 mReferenceTime 字段</span></span><br><span class="line">  mReferenceTime = timestamp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 开始更新内部 DispSyncThread 中的数据了</span></span><br><span class="line"><span class="comment">   * 这里是先进行第一次更新,下面的 updateModelLocked 方法中可能还会做vsync周期的纠正</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;</span><br><span class="line">    mNumResyncSamples++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mFirstResyncSample = (mFirstResyncSample + <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重点逻辑，内部可能还会再次调用 updateModel 方法来更新</span></span><br><span class="line">  updateModelLocked();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123;</span><br><span class="line">    resetErrorLocked();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mIgnorePresentFences) &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re ignoring the present fences we have no way to know whether</span></span><br><span class="line">    <span class="comment">// or not we&#x27;re synchronized with the HW vsyncs, so we just request</span></span><br><span class="line">    <span class="comment">// that the HW vsync events be turned on.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check against kErrorThreshold / 2 to add some hysteresis before having to</span></span><br><span class="line">  <span class="comment">// resync again</span></span><br><span class="line">  <span class="comment">// 在上面 updateModelLocked 方法中计算出新的 period phase 之后，就会将 mModelUpdated 置为 true</span></span><br><span class="line">  <span class="type">bool</span> modelLocked = mModelUpdated &amp;&amp; mError &lt; (kErrorThreshold / <span class="number">2</span>) &amp;&amp; mPendingPeriod == <span class="number">0</span>;</span><br><span class="line">  ALOGV(<span class="string">&quot;[%s] addResyncSample returning %s&quot;</span>, mName, modelLocked ? <span class="string">&quot;locked&quot;</span> : <span class="string">&quot;unlocked&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (modelLocked) &#123;</span><br><span class="line">    *periodFlushed = <span class="literal">true</span>;</span><br><span class="line">    mThread-&gt;lockModel();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !modelLocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中，如果除去  updateModelLocked() 方法的话，其实逻辑还是很简单的。注意这里的入参  timestamp 是硬件层面的vsync 时间戳。这里会将其存储到 mResyncSamples 数组中去，以供后续使用。这个数组中的存储着来自硬件层面的 vsync 时间戳，软件层面根据这些采样数据来进行软件层面的纠错，使得软件层面产生固定周期的vsync 信号，回调给 Listener。</p>
<p>重点看 updateModelLocked() 方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DispSync::updateModelLocked</span><span class="params">()</span> &#123;</span><br><span class="line">  ALOGV(<span class="string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);</span><br><span class="line">  <span class="comment">// 采样数据数组的样本数超过一定数量之后，才可以使用它来进行软件层面的vsync纠错</span></span><br><span class="line">  <span class="comment">// 这里是大于 5 个样本数时才会使用它</span></span><br><span class="line">  <span class="keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;[%s] Computing...&quot;</span>, mName);</span><br><span class="line">    <span class="type">nsecs_t</span> durationSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">nsecs_t</span> minDuration = INT64_MAX;</span><br><span class="line">    <span class="type">nsecs_t</span> maxDuration = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// We skip the first 2 samples because the first vsync duration on some</span></span><br><span class="line">    <span class="comment">// devices may be much more inaccurate than on other devices, e.g. due</span></span><br><span class="line">    <span class="comment">// to delays in ramping up from a power collapse. By doing so this</span></span><br><span class="line">    <span class="comment">// actually increases the accuracy of the DispSync model even though</span></span><br><span class="line">    <span class="comment">// we&#x27;re effectively relying on fewer sample points.</span></span><br><span class="line">    <span class="type">static</span> constexpr <span class="type">size_t</span></span><br><span class="line">    numSamplesSkipped = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 默认跳过前两个，即从 index= 2 开始往后遍历 mResyncSamples 数组中的时间戳</span></span><br><span class="line">    <span class="comment">// 因为可能一开始前几个都不稳定吧，后面的数据才是稳定的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">      <span class="comment">// 计算当前索引</span></span><br><span class="line">      <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">      <span class="comment">// 计算上一个索引</span></span><br><span class="line">      <span class="type">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">      <span class="comment">// 计算前一个索引和当前索引对应时间戳的间隔，也就是这两个vsync信号中间的间隔</span></span><br><span class="line">      <span class="type">nsecs_t</span> duration = mResyncSamples[idx] - mResyncSamples[prev];</span><br><span class="line">      <span class="comment">// 将这些 vsync 间隔挨个加起来</span></span><br><span class="line">      durationSum += duration;</span><br><span class="line">      <span class="comment">// 并且记录下来其中最大、最小的 vsync 间隔</span></span><br><span class="line">      minDuration = min(minDuration, duration);</span><br><span class="line">      maxDuration = max(maxDuration, duration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exclude the min and max from the average</span></span><br><span class="line">    <span class="comment">// 总的时间间隔中减去最大、最小值</span></span><br><span class="line">    durationSum -= minDuration + maxDuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总时间除以数量，算出平均的间隔。减去 2 是因为剔除了最大值和最小值</span></span><br><span class="line"><span class="comment">     * 根据目前所有的硬件 sync sample 发生的时间，计算出平均的 mPeriod 周期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 为啥要计算出来平均值来作为周期呢？因为硬件发送信号到软件，软件处理完。这需要一个时间周期，直接使用硬件的VSync的周期是不可取，</span></span><br><span class="line"><span class="comment">     * 需要结合当前软件和硬件的运行情况进行动态调整。理想是每一次VSync从硬件到SF，SF从第一次VSync消费到第二次的间隔是一致的，</span></span><br><span class="line"><span class="comment">     * 但是实际上是不太可能，这个间隔和当前的CPU环境相关。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以这里计算出来的是平均的周期值，比如是 16ms，那么真正的vsync信号的时间间隔可能一会儿大于16ms，一会儿小于16ms。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mPeriod = durationSum / (mNumResyncSamples - numSamplesSkipped - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> sampleAvgX = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> sampleAvgY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 360° 是角度，其对应弧度中的 2π</span></span><br><span class="line"><span class="comment">     * 所以这里 2π / mPeriod 就是将 360° mPeriod 等分，比如 mPeriod=16ms,那么scale代表360 / 16，即1ms代表22度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">double</span> scale = <span class="number">2.0</span> * M_PI / <span class="type">double</span>(mPeriod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">      <span class="comment">// 计算出索引</span></span><br><span class="line">      <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 用每个 vsync 的时间戳，减去当前 vsync 发生时的时间戳</span></span><br><span class="line"><span class="comment">       * mResyncSamples[idx] 就是之前接受到 vsync 时的时间戳，然后挨个减去当前的时间戳</span></span><br><span class="line"><span class="comment">       * 那 sample 肯定都是小于等于0的，最后一个sample等于0，其他的都是小于0</span></span><br><span class="line"><span class="comment">       * 这个计算出来的是之前每个vsync 距离当前vsync的时间间隔</span></span><br><span class="line"><span class="comment">       * 比如目前是第6个vsync，mResyncSamples中就有6个值，跳过前两个不合法的，</span></span><br><span class="line"><span class="comment">       * 然后从第三个开始，使用 mResyncSamples[2] - mReferenceTime 计算出第三个vsync信号到第6个vsync之间的时间差</span></span><br><span class="line"><span class="comment">       * 这个时间差delta肯定满足一个: delta=aX+b 的公式，而 x 可以认为是 mPeriod(即经历了a个完整周期mPeriod，然后额外还多了b时间长度)</span></span><br><span class="line"><span class="comment">       * 那么将其对 mPeriod 求余数就可以算出b了，那么这个b就是每次软件每次收到 硬件vsync 之后的偏移量了，可以认为是软件损耗</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">nsecs_t</span> sample = mResyncSamples[idx] - mReferenceTime;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 比如上面sample计算出来的值是 10.5 ms，mPeriod是 2 ms，也就是：2*5+0.5</span></span><br><span class="line"><span class="comment">       * 那么取余之后余数是 0.5 ms，也就是说10.5可以完整度过5（5*2=10） 个 mPeriod 周期，然后剩余一个 0.5 ms偏差。</span></span><br><span class="line"><span class="comment">       * 而 scale 代表的是 360° 被 mPeriod ms 等分了，也就是 1ms 对应多少度</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * 而在正弦函数曲线上，有几个关键的点，比如x=0时，sin(0)=0; x=π/2 时函数达到最大值,即sin(π/2)=1; 同理 sin(π)=0； sin(2π)=0</span></span><br><span class="line"><span class="comment">       * 而这里vsync 事件也是具有周期性的，周期性发生的，周期T= mPeriod,所以可以将其看做正弦函数来考虑</span></span><br><span class="line"><span class="comment">       * 而一个 mPeriod 就是正弦的一个周期，对应x轴上就是一个2π长度，每增加一个 mPeriod ,x 增加一个 2π 。</span></span><br><span class="line"><span class="comment">       * 而由于硬件vsync 是固定的,不会受操作系统cpu等影响,而软件vsync会受其影响,所以相当于有了硬件vsync 正弦函数,此时要求软件vsync 正弦函数</span></span><br><span class="line"><span class="comment">       * 即这俩函数具有相同的周期,但是却有不同的相位差。</span></span><br><span class="line"><span class="comment">       * 而此时hw vsync 相对于 sw vsync 的平均周期 mPeriod 的时间差距是： sample (比如单位是ms)。 那它对应x轴上偏移 samplePhase 是多少(此时单位要转换为弧度了)呢？</span></span><br><span class="line"><span class="comment">       * 由上面知道：一个 mPeriod 就是正弦的一个周期，对应x轴上就是一个2π长度 ，所以 samplePhase =  sample * scale 。</span></span><br><span class="line"><span class="comment">       * 但是由于 sample 是包括了诺干个完整周期的（即上面说的 sample=a*mPeriod+b），所以先 sample % mPeriod 求出周期外剩余的时间差，</span></span><br><span class="line"><span class="comment">       * 然后使用该时间差乘以 scale 就可以算出该时间差对应的弧度制了。</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 为啥要求弧度值呢？因为后面要将其转换为 角度 ，要使用三角函数描述周期性的东西，要使用的就是弧度(角度)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">double</span> samplePhase = <span class="type">double</span>(sample % mPeriod) * scale;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 上面计算出这个 sample 的弧度值，然后分别求该弧度的正弦和余弦，假设是三角形，斜边是单位长度1的话</span></span><br><span class="line"><span class="comment">       * 那么sin 就是这个角的对边长度，cos就是这个角的邻边长度，而对边线段长度和邻边线段长度是线性的，可以求平均值</span></span><br><span class="line"><span class="comment">       * 而弧度或者说是角度不是线性的，三角函数不是线性的，具有周期性，不是线性的话就不能求平均值</span></span><br><span class="line"><span class="comment">       * 所以这里存储计算的是cos 和 sin 边线段长度的总和，然后下面做除法求出线段边长的平均值。</span></span><br><span class="line"><span class="comment">       * 然后在通过计算出来的两个边长的平均值，再使用这俩值通过反正切函数将计算出对应的弧度</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      sampleAvgX += <span class="built_in">cos</span>(samplePhase);</span><br><span class="line">      sampleAvgY += <span class="built_in">sin</span>(samplePhase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如上描述，这里开始计算平均的边长长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sampleAvgX /= <span class="type">double</span>(mNumResyncSamples - numSamplesSkipped);</span><br><span class="line">    sampleAvgY /= <span class="type">double</span>(mNumResyncSamples - numSamplesSkipped);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * scale 是 1ms 对应多少度，而这里 atan2 是反正切，</span></span><br><span class="line"><span class="comment">     * 所以这里先使用 atan2 计算出平均的弧度，然后再计算出该弧度对应的时间差</span></span><br><span class="line"><span class="comment">     * 通过这个比例式：</span></span><br><span class="line"><span class="comment">     * 2π/mPeriod = angle / mPhase</span></span><br><span class="line"><span class="comment">     * 即  scale=angle / mPhase </span></span><br><span class="line"><span class="comment">     * 那么 mPhase =  angle/scale</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mPhase = <span class="type">nsecs_t</span>(<span class="built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">&quot;[%s] mPhase = %&quot;</span></span><br><span class="line">    PRId64, mName, ns2us(mPhase));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPhase &lt; -(mPeriod / <span class="number">2</span>)) &#123;</span><br><span class="line">      mPhase += mPeriod;</span><br><span class="line">      ALOGV(<span class="string">&quot;[%s] Adjusting mPhase -&gt; %&quot;</span></span><br><span class="line">      PRId64, mName, ns2us(mPhase));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Artificially inflate the period if requested.</span></span><br><span class="line">    mPeriod += mPeriod * mRefreshSkipCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将纠正之后的平均周期和偏移量设置进去。然后将 mModelUpdated 置为 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">    mModelUpdated = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中，主要逻辑是通过目前已收集到的vsync采样数据，来计算平均的周期和平均的偏移量。这个偏移量可以理解为软件层面的平均损耗，因为cpu某时可能存在繁忙导致线程唤醒延迟之类的。这些都会导致软件vsync时快时慢，而这里求平均值就是保证软件vsync可以尽可能的稳定。</p>
<p>注意这里牵扯到三角函数，可以类比为 正弦函数，也正是因为vsync具有周期性，所以才可以使用正弦函数来描述它。这里计算的 mPhase 是整个 DispSyncThread 中所有 EventListener 共用的，可以理解为它就是软件层面的平均损耗时间。而 EventListener.mPhase 则是每个观察者单独设置的只针对它自身的偏移量。</p>
<p>在计算出来新的period和phase之后，通过 mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime) 来将其更新传递到 DispSyncThread 中去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">updateModel</span><span class="params">(<span class="type">nsecs_t</span> period, <span class="type">nsecs_t</span> phase, <span class="type">nsecs_t</span> referenceTime)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mTraceDetailedInfo) ATRACE_CALL();</span><br><span class="line">  Mutex::Autolock <span class="title function_">lock</span><span class="params">(mMutex)</span>;</span><br><span class="line"></span><br><span class="line">  mPhase = phase;</span><br><span class="line">  <span class="comment">// 第一次的时候，DispSyncThread 中的 mReferenceTime 等于 0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> referenceTimeChanged = mReferenceTime != referenceTime;</span><br><span class="line">  mReferenceTime = referenceTime;</span><br><span class="line">  <span class="comment">// 如果 period发生了变化的话</span></span><br><span class="line">  <span class="keyword">if</span> (mPeriod != <span class="number">0</span> &amp;&amp; mPeriod != period &amp;&amp; mReferenceTime != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Inflate the reference time to be the most recent predicted</span></span><br><span class="line">    <span class="comment">// vsync before the current time.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算 now 到 mReferenceTime 这段时间内过了多少个周期</span></span><br><span class="line"><span class="comment">     * mReferenceTime 是 addResample 时设置的，也就是接受到硬件 HWC 的时间</span></span><br><span class="line"><span class="comment">     * 而在 addResample 中可能会经过一系列的计算，比如 updateModelLocked 等，会消耗时间</span></span><br><span class="line"><span class="comment">     * 所以这里先计算从在 addResample 接受到 HWC 的时间，一直到balabala计算一堆之后，确定了 period 、 phase 等参数之后，</span></span><br><span class="line"><span class="comment">     * 来调用当前方法来更新 DispSyncThread ，这段时间消耗的时间 baseTime (因为在这段时间内，threadLoop还在照样循环执行呢)</span></span><br><span class="line"><span class="comment">     * 然后将其除以旧的 mPeriod ，也就是在 baseTime 这段时间内，外面 listener 都过去了多少个周期了</span></span><br><span class="line"><span class="comment">     * 然后再重新调整 mReferenceTime 的时间，就是在原来基础上加上  (numOldPeriods) * mPeriod ，也就是把  mReferenceTime 往后挪</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这里是 mPeriod 发生变化时才会执行的，如果没有发生变化，则按照原来的步调正常执行</span></span><br><span class="line"><span class="comment">     * 这里相当于是一个 mReferenceTime 时间的校正。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> baseTime = now - mReferenceTime;</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> numOldPeriods = baseTime / mPeriod;</span><br><span class="line">    mReferenceTime = mReferenceTime + (numOldPeriods) * mPeriod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改 DispSyncThread 对象中的 mPeriod 的值</span></span><br><span class="line">  mPeriod = period;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两次 reference 的时间发生变化了，则更新下所有 listener 中的 lastEventTime</span></span><br><span class="line">  <span class="keyword">if</span> (!mModelLocked &amp;&amp; referenceTimeChanged) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;eventListener: mEventListeners) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * eventListener.mLastEventTime : 在前面解释过了，这是该listener 上次 vsync event 的时间，具有周期性</span></span><br><span class="line"><span class="comment">       * 而这里发现 referenceTime 发生了变化，则使用新的 referenceTime 加上该listener 设置的偏移量，来更新 mLastEventTime 的值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      eventListener.mLastEventTime = mReferenceTime + mPhase + eventListener.mPhase;</span><br><span class="line">      <span class="comment">// If mLastEventTime is after mReferenceTime (can happen when positive phase offsets</span></span><br><span class="line">      <span class="comment">// are used) we treat it as like it happened in previous period.</span></span><br><span class="line">      <span class="comment">// 加上偏移量之后，如果大于 mReferenceTime 则将其 mLastEventTime 往前挪动一个周期认为是上次回调的</span></span><br><span class="line">      <span class="comment">// 如果 mPhase 这些是正的话，则会出现这里的情况，比如  eventListener.mPhase = 1000 us</span></span><br><span class="line">      <span class="comment">// 把所有的 eventListener 的时间修改为 mReferenceTime - mPeriod (phase理解为0 的话)</span></span><br><span class="line">      <span class="comment">// 因为 mReferenceTime 相对时间发生变化了，就将之前所有的listener 时间校正一下，vsync模型也是在不断修改不断修复的过程</span></span><br><span class="line">      <span class="keyword">if</span> (eventListener.mLastEventTime &gt; mReferenceTime) &#123;</span><br><span class="line">        eventListener.mLastEventTime -= mPeriod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 到最后唤醒 mCond 上的等待，即 threadLoop 中的等待</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mCond.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细的注释如上，这里最终是会调用 mCond.signal() 来唤醒 DispSyncThread 中的 threadLoop 方法来接着循环，关于 threadLoop 方法在上面分析过了，它内部可能会由于 mPeriod &#x3D;0  等条件而休眠。</p>
<p>当然同样的唤醒 threadLoop 的还有好几个方法，这里不再展开。</p>
<h4 id="6、小结"><a href="#6、小结" class="headerlink" title="6、小结"></a>6、小结</h4><p>DispSync 是只存在唯一的实例（ Scheduler 类中的 mPrimaryDispSync），它内部主要逻辑借助于 DispSyncThread 来实现 Vsync 事件的处理，以及周期性的分发。外部那些对Vsync事件感兴趣的观察者(监听者)可以借助 DispSyncSource 实例来往 DispSync 中注册监听器，然后等待后续Vsync 事件的回调即可，比如在SurfaceFlinger 中创建的 sf EventTnread 和 app EventThread 。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/SurfaceFlinger/">SurfaceFlinger</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/5e3d97eb.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">EventControlThread</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/3c031a43.html">
        <span class="next-text nav-default">AOSP-BP-File</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2022
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
