<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Kotlin协程 - 协程启动原理"/>




  <meta name="keywords" content="Kotlin Coroutine," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/b72a4fb1.html"/>


<meta name="description" content="在初步了解完协程相关的基础概念之后，就可以开始使用协程了。协程的使用很简单，首先第一步就是要启动协程。 启动协程有很多种方式，比如使用 runBlocking 、 launch 等方式。这里以 launch 为切入点进行分析 launch123456789101112131415161718192021222324252627282930313233343536373839404142434445">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin协程 - 协程启动原理">
<meta property="og:url" content="https://youngkaaa.github.io/b72a4fb1.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="在初步了解完协程相关的基础概念之后，就可以开始使用协程了。协程的使用很简单，首先第一步就是要启动协程。 启动协程有很多种方式，比如使用 runBlocking 、 launch 等方式。这里以 launch 为切入点进行分析 launch123456789101112131415161718192021222324252627282930313233343536373839404142434445">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-05T08:48:56.000Z">
<meta property="article:modified_time" content="2022-11-02T13:04:51.860Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Kotlin Coroutine">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Kotlin协程 - 协程启动原理 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Kotlin协程 - 协程启动原理
        
      </h1>

      <time class="post-time">
          5月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>在初步了解完协程相关的基础概念之后，就可以开始使用协程了。协程的使用很简单，首先第一步就是要启动协程。</p>
<p>启动协程有很多种方式，比如使用 runBlocking 、 launch 等方式。这里以 launch 为切入点进行分析</p>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builders.common.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前是位于 CoroutineScope 域内的，所以默认持有 this 是 CoroutineScope 对象实例</span></span><br><span class="line"><span class="comment">     * 而 newCoroutineContext 的定义是 CoroutineScope.newCoroutineContext</span></span><br><span class="line"><span class="comment">     * 所以在 newCoroutineContext 中可以访问到 CoroutineScope 对象实例中的属性，比如 coroutineContext</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以在 newCoroutineContext() 方法中会将当前 CoroutineScope 实例中的 coroutineContext 和入参 context 做合并</span></span><br><span class="line"><span class="comment">     * 如果存在相同key的话，后者中的value会覆盖前者中对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 start 类型来创建不同的对象实例，一般是 StandaloneCoroutine</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用其 start 方法，其实都是走到了 AbstractCoroutine 中</span></span><br><span class="line"><span class="comment">     * 因为上面的 StandaloneCoroutine 继承自 AbstractCoroutine</span></span><br><span class="line"><span class="comment">     * 而 LazyStandaloneCoroutine 又继承自 StandaloneCoroutine</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CoroutineContext.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">newCoroutineContext</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将这俩 context 合并在一起。可以理解为：coroutineContext + context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> combined = foldCopies(coroutineContext, context, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> debug = <span class="keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="keyword">else</span> combined</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果最终的 context 中没有 Dispatcher ，那么就为其增加一个默认的 Dispatchers.Default</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="literal">null</span>)</span><br><span class="line">        debug + Dispatchers.Default <span class="keyword">else</span> debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 launch 方法是 CoroutineScope 的扩展方法，所以它会在编译之后为launch 方法入参第一位上添加 CoroutineScope 的实例入参。常见的协程域有 GlobalScope ，或者Android中的 viewModelScope 、lifecycleScope或者 MainScope等，当然也可以定义协程域，下面简单看看 GlobalScope 的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CoroutineScope.kt</span><br><span class="line">public object GlobalScope : CoroutineScope &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns [EmptyCoroutineContext].</span><br><span class="line">     */</span><br><span class="line">    override val coroutineContext: CoroutineContext</span><br><span class="line">        get() = EmptyCoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它是一个单例object，并且其内部的coroutineContext是使用的EmptyCoroutineContext ，也就是空的 Context。</p>
<p>接着看 launch 方法，它接收三个参数：</p>
<p>1、context: CoroutineContext</p>
<blockquote>
<p>默认值为：EmptyCoroutineContext。表示为要启动的协程对象所指定的指定上下文，可以不填因为有默认值。如果指定了的话，则最终的上下文是：协程域的context 和 此处指定的context 合并之后的结果。详见 CoroutineScope.newCoroutineContext() 方法</p>
</blockquote>
<p>2、start: CoroutineStart</p>
<blockquote>
<p>默认值为： CoroutineStart.DEFAULT。该协程的启动模式，是枚举值。其中每个启动模式之间的差异和用途详见 CoroutineStart.kt 文件中的注释</p>
</blockquote>
<p>3、block: suspend CoroutineScope.() -&gt; Unit</p>
<blockquote>
<p>协程体lambda，无默认值。前文可知，该lambda语句最终会被编译为指定子类，继承自SuspendLambda并实现Function2接口(原因见前文)。</p>
<p>而与此同此，编译器会为其实现内部的抽象方法，即会将原lambda block中的代码修改并填充到 invokeSuspend() 方法中。</p>
<p>并且由于子类继承自 SuspendLambda ，所以子类也是一层层的继承到 ContinuationImpl 、BaseContinuationImpl 以及 Continuation 的。</p>
</blockquote>
<p>所以在launch 中，首先是将入参 context 和当前协程域内的 coroutineContext 做合并，合并规则是：将两者内部元素全部加在一起，如果存在重复的key，则优先使用入参 context 的。也就是说入参context中的元素会覆盖掉协程域coroutineContext中的。然后根据启动模式不同创建不同的对象实例(启动模式详见CoroutineStart.kt)，(当然一般就是 StandaloneCoroutine，后续也默认认为这里创建的是 StandaloneCoroutine) 。创建时会将 newContext 作为入参传入其中。最后调用 StandaloneCoroutine的 start 方法来启动协程并返回该 StandaloneCoroutine 实例。</p>
<p>在分析 StandaloneCoroutine 构造方法以及其 start 方法之前，先看下对于 入参 block 的补充点：</p>
<p>先举个例子，比如kotlin代码这样写的时候：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch&#123;</span><br><span class="line">        println(<span class="string">&quot;coroutine in&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;coroutine finish&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后会产生两个文件 Demo01Kt.class 和 Demo01Kt$main$1.class ，后者是将block编译产生的中间类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用的是 GlobalScope.launch 方法反编译之后实际是调用某个类中的 launch 方法(是哪个类不重要，实际应该是 Builders.common.kt)，</span></span><br><span class="line"><span class="comment">         * 并且第一个参数传入的是 GlobalScope.INSTANCE 单例对象，因为它是 GlobalScope.launch() 方法，GlobalScope 实例自动作为第一个参数传入</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 接着三个就是 launch 中的参数了：CoroutineContext 和 CoroutineStart没传入使用默认值 null</span></span><br><span class="line"><span class="comment">         * block 传入的是lambda 语句，实际在编译后会为其产生一个中间类 Demo01Kt$main$1 ，所以这里是new出一个 Demo01Kt$main$1 实例并传入</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 后两个参数 3 和 null 这里暂时不清楚是干啥的，先不管。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BuildersKt.launch$default(GlobalScope.INSTANCE, (CoroutineContext) <span class="literal">null</span>, (CoroutineStart) <span class="literal">null</span>, new Demo01Kt$main$<span class="number">1</span>(<span class="literal">null</span>), <span class="number">3</span>, (Object) <span class="literal">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只看这个文件就可以看出来，block 被编译产生了一个中间类:’Demo01Kt$main$1<br>‘，然后 new 出了一个该中间类的实例(构造方法入参是null)传入了 launch。而该中间类继承自 SuspendLambda ，以及一层层继承到 Continuation。</p>
<p>回到 launch 方法，创建了 StandaloneCoroutine 实例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builders.common.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">StandaloneCoroutine</span>(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    active: <span class="built_in">Boolean</span></span><br><span class="line">) : AbstractCoroutine&lt;<span class="built_in">Unit</span>&gt;(parentContext, initParentJob = <span class="literal">true</span>, active = active) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleJobException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        handleCoroutineException(context, exception)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractCoroutine.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCoroutine</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    parentContext: CoroutineContext,</span><br><span class="line">    initParentJob: <span class="built_in">Boolean</span>,</span><br><span class="line">    active: <span class="built_in">Boolean</span></span><br><span class="line">) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Setup parent-child relationship between the parent in the context and the current coroutine.</span></span><br><span class="line"><span class="comment">         * It may cause this coroutine to become _cancelling_ if the parent is already cancelled.</span></span><br><span class="line"><span class="comment">         * It is dangerous to install parent-child relationship here if the coroutine class</span></span><br><span class="line"><span class="comment">         * operates its state from within onCancelled or onCancelling</span></span><br><span class="line"><span class="comment">         * (with exceptions for rx integrations that can&#x27;t have any parent)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 传入的是 parentContext[Job] 也就是从 parentContext 中取出其中的 Job 实例传入进去</span></span><br><span class="line"><span class="comment">         * 也就是把父 Job 传入进去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (initParentJob) initParentJob(parentContext[Job])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of this coroutine that includes this coroutine as a [Job].</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 继承自 Continuation ，所以需要实现其内部的 context</span></span><br><span class="line"><span class="comment">     * 此处的 this 是当做 Job 来处理的，也就是把当前对象当做Job 来加入到 parentContext 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;LeakingThis&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = parentContext + <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of this scope which is the same as the [context] of this coroutine.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当前 AbstractCoroutine 也是一个 CoroutineScope ，也可以把它当做 CoroutineScope 来使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext <span class="keyword">get</span>() = context</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里创建的 StandaloneCoroutine 的主要逻辑是在其父类 AbstractCoroutine 中的。</p>
<blockquote>
<p>AbstractCoroutine 它继承了 JobSupport 类，实现了 Job 、 Continuation 和 CoroutineScope 接口。所以相当于它自身是身兼三职，在合适的时候可以灵活的将其转换为对应的角色来使用。</p>
</blockquote>
<p>这里在创建StandaloneCoroutine实例时，是将 newContext 作为其 parentContext 传入的。此时首先会执行 AbstractCoroutine 的构造方法，也就是 initParentJob ，此时入参是从parentContext中取出key&#x3D;Job的Element，也就是取出父Job传入进去。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JobSupport.kt</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">initParentJob</span><span class="params">(parent: <span class="type">Job</span>?)</span></span> &#123;</span><br><span class="line">    assert &#123; parentHandle == <span class="literal">null</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        parentHandle = NonDisposableHandle</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动一下父Job，确保父Job当前是启动状态</span></span><br><span class="line">    parent.start() <span class="comment">// make sure the parent is started</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;DEPRECATION&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> handle = parent.attachChild(<span class="keyword">this</span>)</span><br><span class="line">    parentHandle = handle</span><br><span class="line">    <span class="comment">// now check our state _after_ registering (see tryFinalizeSimpleState order of actions)</span></span><br><span class="line">    <span class="keyword">if</span> (isCompleted) &#123;</span><br><span class="line">        handle.dispose()</span><br><span class="line">        parentHandle = NonDisposableHandle <span class="comment">// release it just in case, to aid GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachChild</span><span class="params">(child: <span class="type">ChildJob</span>)</span></span>: ChildHandle &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note: This function attaches a special ChildHandleNode node object. This node object</span></span><br><span class="line"><span class="comment">         * is handled in a special way on completion on the coroutine (we wait for all of them) and</span></span><br><span class="line"><span class="comment">         * is handled specially by invokeOnCompletion itself -- it adds this node to the list even</span></span><br><span class="line"><span class="comment">         * if the job is already cancelling. For cancelling state child is attached under state lock.</span></span><br><span class="line"><span class="comment">         * It&#x27;s required to properly wait all children before completion and provide linearizable hierarchy view:</span></span><br><span class="line"><span class="comment">         * If child is attached when the job is already being cancelled, such child will receive immediate notification on</span></span><br><span class="line"><span class="comment">         * cancellation, but parent *will* wait for that child before completion and will handle its exception.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> invokeOnCompletion(onCancelling = <span class="literal">true</span>, handler = ChildHandleNode(child).asHandler) <span class="keyword">as</span> ChildHandle</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用该方法目的是：将当前新创建的协程对象作为子Job绑定给协程域中的父Job，这样等到后期就可以直接调用scope.cancel()实现取消传递了，即通过 parent.attachChild(this) 来将当前 Job 绑定到入参 父Job 中，实际就是通过 invokeOnCompletion 方法给父Job注册一个回调，当父Job被取消时回调通知给子Job，子Job执行其 parentCancelled() 方法来取消自己及其内部的子协程。</p>
<p>可以看下协程域的 cancel方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineScope.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">cancel</span><span class="params">(cause: <span class="type">CancellationException</span>? = <span class="literal">null</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> job = coroutineContext[Job] ?: error(<span class="string">&quot;Scope cannot be cancelled because it does not have a job: <span class="variable">$this</span>&quot;</span>)</span><br><span class="line">    job.cancel(cause)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协程域在取消时，会取出该协程域内部 coroutineContext 中的Job去取消，然后该Job是父Job，其会回调 invokeOnCompletion ，然后之前注册的子Job就会收到回调从而取消自己，这样一层层的传递进去。所以这也就是为什么：</p>
<p>1、调用 GlobalScope.cancel 时会抛出异常：java.lang.IllegalStateException: Scope cannot be cancelled because it does not have a job: kotlinx.coroutines.GlobalScope@4f8e5cde</p>
<blockquote>
<p>因为 GlobalScope 的 coroutineContext 默认为 EmptyCoroutineContext ，其内部没有 Job</p>
</blockquote>
<p>2、调用 viewModelScope 、 lifecycleScope 或者 MainScope 时不会有异常，因为他们在实现时，都使用了 SupervisorJob ，存在Job所以没问题。具体代码就不贴了。</p>
<p>在 AbstractCoroutine 中还有额外的属性需要解释：</p>
<p>1、context: CoroutineContext : 该属性是继承自 Continuation 接口的，它是 parentContext + this ，而这里的 this 是当做 Job 来使用的，也就是把当前 Job 加入到 context 中去，替换掉其中的父Job（如果存在的话），因为同一个Key只能在 context 中存在一份。</p>
<p>2、coroutineContext: CoroutineContext : 该属性是继承自 CoroutineScope 的，作为协程域的上下文来使用的，因为在其内部也可以直接调用 launch 等方法来启动子协程。比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> userId = getUserId()</span><br><span class="line">    <span class="keyword">val</span> userInfo = getUserInfo(userId)</span><br><span class="line">    <span class="comment">// 可以这样起子协程</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(userInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就基本完成了对 StandaloneCoroutine 的创建，接下来是执行其 start 方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractCoroutine.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">start</span><span class="params">(start: <span class="type">CoroutineStart</span>, receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        start(block, receiver, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意这里传过来的参数：</p>
<p>1、start: CoroutineStart</p>
<blockquote>
<p>启动模式，默认是 CoroutineStart.DEFAULT 。详见 CoroutineStart.kt 。后续都假设它是 CoroutineStart.DEFAULT</p>
</blockquote>
<p>2、receiver: R,</p>
<blockquote>
<p>新创建的 StandaloneCoroutine 对象自身</p>
</blockquote>
<p>3、block: suspend R.() -&gt; T</p>
<blockquote>
<p>suspend lambda实例，经编译之后为指定中间类，继承自SuspendLambda。这里是对应的中间类的实例，详见上面分析</p>
</blockquote>
<p>这里直接调用入参 start() ，最终会触发到:kotlin</p>
<p>&#x2F;&#x2F; CoroutineStart.kt</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="title">invoke</span><span class="params">(block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>, receiver: <span class="type">R</span>, completion: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据不同的启动模式来执行不同的方法来启动协程</span></span><br><span class="line"><span class="comment">     * 注意这里是调用的 block.XXX ，也就是 (suspend (R) -&gt; T).XXX</span></span><br><span class="line"><span class="comment">     * 而前面的分析可知：(suspend (R) -&gt; T) 最终编译之后会产生一个中间类(假设是类A)，继承自 SuspendLambda</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        DEFAULT -&gt; block.startCoroutineCancellable(receiver, completion)</span><br><span class="line">        ATOMIC -&gt; block.startCoroutine(receiver, completion)</span><br><span class="line">        UNDISPATCHED -&gt; block.startCoroutineUndispatched(receiver, completion)</span><br><span class="line">        LAZY -&gt; <span class="built_in">Unit</span> <span class="comment">// will start lazily</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>CoroutineStart.DEFAULT 的话执行到startCoroutineCancellable() 方法中去，注意此时的 block 是中间类(假设是类A)的实例哦，继承自SuspendLambda：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cancellable.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(</span><br><span class="line">    receiver: R, completion: Continuation&lt;T&gt;,</span><br><span class="line">    onCancellation: ((cause: Throwable) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">) =</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前方法是带有接受者类型的 (suspend (R) -&gt; T). 而其最终编译之后会为其产生一个中间类(假设是类A)，它继承自 SuspendLambda</span></span><br><span class="line"><span class="comment">     * 当前内部的 this 就是这个类A的一个实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1、 createCoroutineUnintercepted 方法的签名也是带有 (suspend (R) -&gt; T). 的，这里的调用就相当于：</span></span><br><span class="line"><span class="comment">     * -   类A.this.createCoroutineUnintercepted(receiver, completion).XXX</span></span><br><span class="line"><span class="comment">     * -   该方法会再次创建并返回一个 类A 实例，但是不同的是它传入了 receiver, completion</span></span><br><span class="line"><span class="comment">     * -   详见 createCoroutineUnintercepted 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2、 上一步返回了一个重新创建的类A实例，并且其内部的 continuation 属性被赋值为入参 completion (其实是被包装了一层的)</span></span><br><span class="line"><span class="comment">     * -   所以这里调用的方法实际是 Continuation&lt;T&gt;.intercepted()</span></span><br><span class="line"><span class="comment">     * -   执行到 ContinuationImpl 中的 intercepted 方法内，来返回拦截转换之后的 Continuation</span></span><br><span class="line"><span class="comment">     * -   因为在 ContinuationImpl 中有一个 intercept 属性来保存将原来的 continuation 拦截转换之后的 continuation</span></span><br><span class="line"><span class="comment">     * -   比如由上面第一步可以知道，此时类A实例中的 continuation 实际是 StandaloneCoroutine 实例</span></span><br><span class="line"><span class="comment">     * -   然后经过这里的 intercept 方法来将其转换包装为另外一个 DispatchedContinuation</span></span><br><span class="line"><span class="comment">     * -   然后该 DispatchedContinuation 实例会存在在类A 实例中的 intercept 属性中并且通过 intercepted 方法返回出来</span></span><br><span class="line"><span class="comment">     * -   所以这里 intercepted() 执行完毕返回 DispatchedContinuation 实例，内部包装了 StandaloneCoroutine 和 Dispatchers.Default</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3、 此时就是 DispatchedContinuation.resumeCancellableWith 来将其加入到对应队列中处理了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    runSafely(completion) &#123;</span><br><span class="line">        createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellableWith(Result.success(<span class="built_in">Unit</span>), onCancellation)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">runSafely</span><span class="params">(completion: <span class="type">Continuation</span>&lt;*&gt;, block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        dispatcherFailure(completion, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里再次明确下一些参数：</p>
<p>1、receiver ：</p>
<blockquote>
<p>新创建的 StandaloneCoroutine 对象自身</p>
</blockquote>
<p>2、completion ：</p>
<blockquote>
<p>和上面的 receiver 是同一个对象，因为在 AbstractCoroutine 中的 start 方法内，最后一个 completion 参数传入的是 this</p>
</blockquote>
<p>3、this ：</p>
<blockquote>
<p>当前处于 (suspend (R) -&gt; T).startCoroutineCancellable() 方法内，也就是 block 内，所以默认的 this 是 block ，也就是编译器自动生成的类A 的实例内，此时this就是类A实例</p>
</blockquote>
<p>在startCoroutineCancellable()方法内启动协程一共分为如下三步：</p>
<h4 id="createCoroutineUnintercepted"><a href="#createCoroutineUnintercepted" class="headerlink" title="createCoroutineUnintercepted"></a>createCoroutineUnintercepted</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntrinsicsJvm.kt </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutineUnintercepted(</span><br><span class="line">    receiver: R,</span><br><span class="line">    completion: Continuation&lt;T&gt;</span><br><span class="line">): Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前方法是带有接受者类型的 (suspend (R) -&gt; T). 而其最终编译之后，会生成一个类(假设为A)，继承自 SuspendLambda</span></span><br><span class="line"><span class="comment">     * 当前内部的 this 就是生成的这个类A的一个实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * probeCoroutineCreated 方法内部原封不动返回了 completion</span></span><br><span class="line"><span class="comment">     * 但在实际运行时，它内部会产生对应的代码来将 completion 再包装一层</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> probeCompletion = probeCoroutineCreated(completion)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 而 SuspendLambda 的继承关系如下：</span></span><br><span class="line"><span class="comment">     * SuspendLambda -&gt; ContinuationImpl -&gt; BaseContinuationImpl -&gt; Continuation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以动态生成的这个类A实例也是间接继承自 BaseContinuationImpl 的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以这里的 create 方法是执行到自动生成的类 A 中的 create 实现中，返回一个 Continuation&lt;Unit&gt;</span></span><br><span class="line"><span class="comment">     * 其实也就是又返回了一个 类A 的实例。但是此时返回的类A中的 continuation 属性是已经被赋值了的</span></span><br><span class="line"><span class="comment">     * 因为类A 继承自BaseContinuationImpl ，而这里传入进去的第二个参数 probeCompletion 就是其被赋的值</span></span><br><span class="line"><span class="comment">     * 也就是可以理解为 StandaloneCoroutine (其实是被probeCoroutineCreated包装了一层的)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以总结来说，这里返回的是中间生成类A 的一个实例，它继承自 Continuation-&gt; BaseContinuationImpl 等</span></span><br><span class="line"><span class="comment">     * 并且此时这个类A 中的 continuation 属性被赋值为 StandaloneCoroutine(其实是被probeCoroutineCreated包装了一层)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">is</span> BaseContinuationImpl)</span><br><span class="line">        create(receiver, probeCompletion)</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        createCoroutineFromSuspendFunction(probeCompletion) &#123;</span><br><span class="line">            (<span class="keyword">this</span> <span class="keyword">as</span> Function2&lt;R, Continuation&lt;T&gt;, Any?&gt;).invoke(receiver, it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的入参receiver、completion和this同上面。由于此时this 是编译器生成的中间类，继承自Suspend ，也就继承自 BaseContinuationImpl ，所以走第一个执行其 create 方法，其实是 this.create() 方法，将 receiver 和 completion 传入进去。</p>
<p>下面举例看看反编译之后的类，也正好看看这个中间类的真面目：</p>
<p>假设Kotlin代码为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch&#123;</span><br><span class="line">        println(<span class="string">&quot;coroutine in&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;coroutine finish&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译之后共两个class 文件: <code>Demo01Kt.class</code> 和 <code>Demo01Kt$main $1.class</code> :</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01Kt.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用的是 GlobalScope.launch 方法反编译之后实际是调用某个类中的 launch 方法(是哪个类不重要，实际应该是 Builders.common.kt)，</span></span><br><span class="line"><span class="comment">         * 并且第一个参数传入的是 GlobalScope.INSTANCE 单例对象，因为它是 GlobalScope.launch() 方法，GlobalScope 实例自动作为第一个参数传入</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 接着三个就是 launch 中的参数入了：CoroutineContext 和 CoroutineStart没传使用默认值 null</span></span><br><span class="line"><span class="comment">         * block 传入的是lambda 语句，实际在编译后会为其产生一个中间类 Demo01Kt$main$1 ，所以这里是new出一个 Demo01Kt$main$1 实例并传入</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 后两个参数 3 和 null 这里暂时不清楚是干啥的，先不管。</span></span><br><span class="line"><span class="comment">         * 接下来的重心是要看生成的 Demo01Kt$main$1 类是什么样子</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BuildersKt.launch$default(GlobalScope.INSTANCE, (CoroutineContext) <span class="literal">null</span>, (CoroutineStart) <span class="literal">null</span>, new Demo01Kt$main$<span class="number">1</span>(<span class="literal">null</span>), <span class="number">3</span>, (Object) <span class="literal">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01Kt$main$1.class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个中间类 Demo01Kt$main$1 代表的是源代码中 launch 方法体的内容，即花括号的内容</span></span><br><span class="line"><span class="comment"> * 它其实是一个 lambda ，不过位于 launch 最后，所以可以写到方法体外用花括号包起来</span></span><br><span class="line"><span class="comment"> * 其就是一个类型为：suspend CoroutineScope.() -&gt; Unit 的 lambda</span></span><br><span class="line"><span class="comment"> * 因为 suspend 修饰了他，所以继承自 SuspendLambda ，且在方法参数最后一位增加一个 Continuation 参数，</span></span><br><span class="line"><span class="comment"> * 且因为是 CoroutineScope. 的，所以会在参数第一位加一个 CoroutineScope 参数 ，</span></span><br><span class="line"><span class="comment"> * 所以实现了 Function2 ，一共两个参数：CoroutineScope 和 Continuation 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 而由于继承自 SuspendLambda ，所以其内部的 create 、invokeSuspend 方法会被实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01Kt</span>$<span class="title">main</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function2</span>&lt;<span class="type">CoroutineScope, Continuation&lt;? super Unit</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承自 SuspendLambda ，所以这里的 super 是调用 SuspendLambda 的构造方法，</span></span><br><span class="line"><span class="comment">     * 传入第一个参数 arity = 2，这个含义不清楚</span></span><br><span class="line"><span class="comment">     * 传入第二个参数 continuation ，也是 Demo01Kt$main$1 构造方法的入参，可以从前面Demo01Kt.class 中看到，创建 Demo01Kt$main$1 实例时传入的是 null</span></span><br><span class="line"><span class="comment">     * 所以传递到 SuspendLambda 中的 continuation 也是 null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Demo01Kt$main$<span class="number">1</span>(Continuation&lt;? <span class="keyword">super</span> Demo01Kt$main$<span class="number">1</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">2</span>, continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 [createCoroutineUnintercepted] 方法中通过 suspend lambda 语句创建一个 Continuation 实例时会调用到这里</span></span><br><span class="line"><span class="comment">     * 在这里实际会返回 Demo01Kt$main$1 实例，而它是继承自 SuspendLambda ，然后再一层层往上也是实现自 Continuation 的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里传入的第一个参数是：value = StandaloneCoroutine ，</span></span><br><span class="line"><span class="comment">     * 第二个参数也可以理解为是 StandaloneCoroutine</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 然后这里使用第二个入参调用 SuspendLambda 的构造方法，然后将入参 completion  传入，此时会执行生成类的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation&lt;<span class="built_in">Unit</span>&gt; create(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation&lt;?&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">return</span> new Demo01Kt$main$<span class="number">1</span>(continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@NotNull</span> CoroutineScope p1, <span class="meta">@Nullable</span> Continuation&lt;? <span class="keyword">super</span> <span class="built_in">Unit</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">return</span> create(p1, continuation).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resumeWith() 中调用，在 &#123;<span class="doctag">@link</span> BaseContinuationImpl&#125; 中可以知道。</span></span><br><span class="line"><span class="comment">     * 可以先看看上面这个类里面的逻辑，总的来说，调用 Continuation 的 resumeWith 方法之后，最后会执行到这里</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在其&#123;<span class="doctag">@link</span> BaseContinuationImpl#resumeWith(Object)&#125; 方法中，会执行死循环来调用invokeSuspend方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果其返回了 CoroutineSingletons.COROUTINE_SUSPENDED 表示内部挂起了，那么return掉，终止死循环。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1-&gt; 存储 CoroutineSingletons.COROUTINE_SUSPENDED</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object coroutine_suspended = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2-&gt; label默认是0，所以刚开始执行的应该是 case 0</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            case <span class="number">0</span>:</span><br><span class="line">                ResultKt.throwOnFailure($result);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.1 -&gt; 按照协程体内的逻辑，先sout输出 ，并且会更新 label 为 1，下次执行当前方法时，会执行  1 的case</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;coroutine in&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.2 -&gt; 执行到第一个delay 挂起函数，挂起 100ms。注意这里传入的第二个参数 this，作为 Continuation 类型传入的</span></span><br><span class="line"><span class="comment">                 * 因为delay是被suspend修饰的函数，那么编译之后会自动在最后一位增加 Continuation 类型的参数</span></span><br><span class="line"><span class="comment">                 * 如果 delay 内部返回了 CoroutineSingletons.COROUTINE_SUSPENDED 表示挂起了，此时返回CoroutineSingletons.COROUTINE_SUSPENDED出去</span></span><br><span class="line"><span class="comment">                 * 此时在 &#123;<span class="doctag">@link</span> BaseContinuationImpl#resumeWith(Object)&#125; 中会直接return而终止其外部while死循环</span></span><br><span class="line"><span class="comment">                 * 此时该 Continuation 会停止执行，此时 label=1，等待该协程下次被调用 resumeWith 方法</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 而这里 delay，传入 100ms，相当于协程挂起100ms，停止执行当前协程体内代码，线程去执行其他协程逻辑，而在delay方法中，可以理解为 postDelay</span></span><br><span class="line"><span class="comment">                 * 延迟100ms后执行当前 Continuation 的 resumeWith 方法。</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 所以总的来说：这里 return CoroutineSingletons.COROUTINE_SUSPENDED 出去，当前协程体执行终止，外部也终止，协程体逻辑停止执行，等待指</span></span><br><span class="line"><span class="comment">                 * 定时间后，协程体代码再次被执行，此时 label = 1</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (DelayKt.delay(<span class="number">100</span>, (Continuation) <span class="keyword">this</span>) == coroutine_suspended) &#123;</span><br><span class="line">                    <span class="keyword">return</span> coroutine_suspended;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3 -&gt; 从 2.2 处开始等待100ms之后，再次执行 Continuation 的 resumeWith 方法，由于此时 label=1 所以执行到 case 1 这里，</span></span><br><span class="line"><span class="comment">             * 这里判断入参result是否合法，不合法则会抛出异常终止执行，如果合法，则 break 掉当前 switch语句，执行到最下面输出 coroutine finish</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            case <span class="number">1</span>:</span><br><span class="line">                ResultKt.throwOnFailure($result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;coroutine finish&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里说的中间类A 其实就是 <code>Demo01Kt$main$1</code>类。它继承自 SuspendLambda，实现了 Function2 接口（原因前面解释过）。</p>
<p>在这里存在两次 <code>Demo01Kt$main$1</code>类实例的创建：</p>
<p>1、在 Demo01Kt.class 中调用 launch 方法时，会先创建new出来一个 <code>Demo01Kt$main$1</code>类实例，但是此时传入的参数是 null。</p>
<p>2、在createCoroutineUnintercepted()方法内又会调用到<code>Demo01Kt$main$1</code>类实例的 create() 方法来再次创建一个 <code>Demo01Kt$main$1</code>类实例</p>
<p>第一次创建时其内部的 continuation 被设置为 null ，因为当时还没有创建出来 StandaloneCoroutine 那些，相当于缺少这些东西所以只能先传入null，相当于第一次的时候是不完整的对象实例；等到第二次的时候有了 StandaloneCoroutine 等实例，那么此时就可以再次创建，此时就是完整的对象实例了。</p>
<blockquote>
<p>完整不完整主要表现在 <code>Demo01Kt$main$1</code>类中的 context （位于ContinuationImpl） 和 completion (位于 BaseContinuationImpl)是否被赋值。</p>
</blockquote>
<p>第二次创建 <code>Demo01Kt$main$1</code>类实例的时候，调用的是其 create() 方法，传入两个参数：receiver 和 completion。而这俩在上面分析过了，都是新创建的 StandaloneCoroutine 对象实例，这里传入俩是因为他俩有不同的作用，比如第二个 completion 入参就是将 StandaloneCoroutine 当做 Continuation 角色类型来使用的。</p>
<p>而在 <code>Demo01Kt$main$1</code>类的 create 方法内逻辑很简单，就是调用 <code>Demo01Kt$main$1</code>类的构造方法，然后把第二个参数StandaloneCoroutine 作为 Continuation类型传入进去。然后一层层的传递给父类 SuspendLambda -&gt; ContinuationImpl (给其中 context赋值) -&gt; BaseContinuationImpl (给其中的 completion赋值)。这样的话第二次创建出来的<code>Demo01Kt$main$1</code>类实例就可以正常使用了。</p>
<p>也就是说，这里创建的<code>Demo01Kt$main$1</code>类实例中的属性 context &#x3D; StandaloneCoroutine.context ，completion &#x3D; StandaloneCoroutine 。</p>
<h4 id="intercepted"><a href="#intercepted" class="headerlink" title="intercepted"></a>intercepted</h4><p>上一步返回了一个新创建的完整的 <code>Demo01Kt$main$1</code>类实例，也就是kotlin编译器为suspend lambda生成的中间类。然后这里接着调用其 intercepted() 方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntrinsicsJvm.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br></pre></td></tr></table></figure>

<p>这里的 this 就是 <code>Demo01Kt$main$1</code>类，继承自 SuspendLambda ，所以自然是继承自 ContinuationImpl的，所以这里调用 ContinuationImpl.intercepted() 方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContinuationImpl.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContinuationImpl</span>(</span><br><span class="line">    completion: Continuation&lt;Any?&gt;?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _context: CoroutineContext?</span><br><span class="line">) : BaseContinuationImpl(completion) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里的 context 是从 completion 中取的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(completion: Continuation&lt;Any?&gt;?) : <span class="keyword">this</span>(completion, completion?.context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = _context!!</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> intercepted: Continuation&lt;Any?&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 intercepted 不为空则返回 intercepted</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 intercepted 为空，则从 context 中取出内部存储的 ContinuationInterceptor</span></span><br><span class="line"><span class="comment">     * -  然后调用其 interceptContinuation 方法来将当前 BaseContinuationImpl 转换为另外一个 Continuation 返回出来</span></span><br><span class="line"><span class="comment">     * -  并且保存该 Continuation 到 intercepted 中，下次就可以直接返回了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">releaseIntercepted</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> intercepted = intercepted</span><br><span class="line">        <span class="keyword">if</span> (intercepted != <span class="literal">null</span> &amp;&amp; intercepted !== <span class="keyword">this</span>) &#123;</span><br><span class="line">            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.intercepted = CompletedContinuation <span class="comment">// just in case</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面可以知道这里的 context &#x3D; StandaloneCoroutine.context ，从中取出key&#x3D; ContinuationInterceptor 的Element。</p>
<p>而这个context可以是在 launch时可以通过入参context来指定Interceptor，也可以是协程域context指定并被继承下来的，当然如果这俩都没有设置的话在CoroutineScope.newCoroutineContext() 方法中也会给其设置一个兜底的：Dispatchers.Default 。所以这里将其认为是 Dispatchers.Default ，因此这里调用到了</p>
<p>CoroutineDispatcher中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineDispatcher.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        DispatchedContinuation(<span class="keyword">this</span>, continuation)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// DispatcherContinuation.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> dispatcher: CoroutineDispatcher,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;</span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line">   <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Dispatchers这些基本都是继承自 CoroutineDispatcher 的，后面会再讲这个。</p>
<p>所以这里调用的是中间类<code>Demo01Kt$main$1</code>的 intercepted() 方法来将其转换为<code>DispatchedContinuation</code>来返回。并且将上一步创建的中间类 <code>Demo01Kt$main$1</code>实例保存在DispatchedContinuation.continuation 中，将Dispatchers.Default保存在DispatchedContinuation.dispatcher 中；</p>
<h4 id="resumeCancellableWith"><a href="#resumeCancellableWith" class="headerlink" title="resumeCancellableWith"></a>resumeCancellableWith</h4><p>上一步返回的是DispatchedContinuation实例，该实例内部封装了 <code>Demo01Kt$main$1</code>和 Dispatchers.Default 实例。然后接着调用其 resumeCancellableWith 来正式启动它：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatcherContinuation.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Unit</span> = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是 DispatchedContinuation 则单独走 resumeCancellableWith 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意第二个参数其默认值是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">is</span> DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)</span><br><span class="line">    <span class="keyword">else</span> -&gt; resumeWith(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上一步可知这里接下来肯定执行的是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatcherContinuation.kt</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">    <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">        _state = state</span><br><span class="line">        resumeMode = MODE_CANCELLABLE</span><br><span class="line">        dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                resumeUndispatchedWith(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 dispatcher 就是前面保存的 Dispatchers.Default ，先判断该 Dispatcher 是否需要dispatcher分发该context，默认是true。所以会执行其 dispatch 方法来将 DispatchedContinuation 实例作为Runnable 分发给指定的线程准备执行。因为DispatchedContinuation 是继承自 DispatchedTask -&gt; SchedulerTask -&gt; Runnable 的。这个暂时就可以理解为将该 DispatchedContinuation 扔到线程池去中待执行（这种只是为了方便现在理解，但说扔到线程池这个说法不完全准确）。</p>
<p>所以说等到指定线程要执行该Runnable 时，就会执行当前 DispatchedContinuation 对象中的 run 方法。这个run 方法实际是在 DispatchedContinuation 的父类 DispatchedTask中实现了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatchedTask.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;                                                            </span><br><span class="line">    assert &#123; resumeMode != MODE_UNINITIALIZED &#125; <span class="comment">// should have been set before dispatching   </span></span><br><span class="line">    <span class="keyword">val</span> taskContext = <span class="keyword">this</span>.taskContext                                                       </span><br><span class="line">    <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span>                                                    </span><br><span class="line">    <span class="keyword">try</span> &#123;                                                                                    </span><br><span class="line">        <span class="keyword">val</span> delegate = delegate <span class="keyword">as</span> DispatchedContinuation&lt;T&gt;                                 </span><br><span class="line">                                                                                             </span><br><span class="line">        <span class="comment">/**                                                                                  </span></span><br><span class="line"><span class="comment">         * 拿到之前在 intercept 方法中创建 DispatchedContinuation 实例保存的那个  continuation 实例             </span></span><br><span class="line"><span class="comment">         * 可以理解为  StandaloneCoroutine                                                        </span></span><br><span class="line"><span class="comment">         */</span>                                                                                  </span><br><span class="line">        <span class="keyword">val</span> continuation = delegate.continuation                                             </span><br><span class="line">                                                                                             </span><br><span class="line">        withContinuationContext(continuation, delegate.countOrElement) &#123;                     </span><br><span class="line">            <span class="keyword">val</span> context = continuation.context                                               </span><br><span class="line">            <span class="keyword">val</span> state = takeState() <span class="comment">// <span class="doctag">NOTE:</span> Must take state in any case, even if cancelled  </span></span><br><span class="line">            <span class="keyword">val</span> exception = getExceptionalResult(state)                                      </span><br><span class="line">            <span class="comment">/*                                                                               </span></span><br><span class="line"><span class="comment">             * Check whether continuation was originally resumed with an exception.          </span></span><br><span class="line"><span class="comment">             * If so, it dominates cancellation, otherwise the original exception            </span></span><br><span class="line"><span class="comment">             * will be silently lost.                                                        </span></span><br><span class="line"><span class="comment">             */</span>                                                                              </span><br><span class="line">            <span class="keyword">val</span> job = <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span>  </span><br><span class="line">            <span class="comment">/**                                                                              </span></span><br><span class="line"><span class="comment">             * 此时如果该任务已经被取消了                                                                 </span></span><br><span class="line"><span class="comment">             */</span>                                                                              </span><br><span class="line">            <span class="keyword">if</span> (job != <span class="literal">null</span> &amp;&amp; !job.isActive) &#123;                                              </span><br><span class="line">                <span class="keyword">val</span> cause = job.getCancellationException()                                   </span><br><span class="line">                cancelCompletedResult(state, cause)                                          </span><br><span class="line">                continuation.resumeWithStackTrace(cause)                                     </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                                                         </span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;                                                     </span><br><span class="line">                    continuation.resumeWithException(exception)                              </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                                                     </span><br><span class="line">                    <span class="comment">/**                                                                      </span></span><br><span class="line"><span class="comment">                     * 接着执行该 continuation 。这里会执行到 BaseContinuationImpl 中去                    </span></span><br><span class="line"><span class="comment">                     */</span>                                                                      </span><br><span class="line">                    continuation.resume(getSuccessfulResult(state))                          </span><br><span class="line">                &#125;                                                                            </span><br><span class="line">            &#125;                                                                                </span><br><span class="line">        &#125;                                                                                    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;                                                                 </span><br><span class="line">        <span class="comment">// This instead of runCatching to have nicer stacktrace and debug experience         </span></span><br><span class="line">        fatalException = e                                                                   </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;                                                                              </span><br><span class="line">        <span class="keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;                                 </span><br><span class="line">        handleFatalException(fatalException, result.exceptionOrNull())                       </span><br><span class="line">    &#125;                                                                                        </span><br><span class="line">&#125;                                                                                                </span><br></pre></td></tr></table></figure>

<p>这里首先拿到 delegate ，这个是一个抽象属性，在 DispatchedContinuation 中会实现它，返回的是 DispatchedContinuation.this ，也就是 DispatchedContinuation 对象实例。然后通过 delegate.continuation 拿到其保存的 <code>Demo01Kt$main$1</code> 实例（不懂可以翻看前面）。</p>
<p>所以这里的 continuation 变量表示的就是 <code>Demo01Kt$main$1</code>类实例对象。然后再通过 continuation 拿到它的 context，再从中查找到 Job (也就是StandaloneCoroutine)判断其是否已被取消，没有的话则调用 continuation的 resume 方法，也就是其 resumeWith 方法，也就是 invokeSuspend 方法。这样的话 <code>Demo01Kt$main$1</code>类中的 invokeSuspend 方法就会被调用，从而执行其中的代码逻辑，也就是完成剩余逻辑的执行。这样的话launch方法协程体内的逻辑就会被执行，也就是协程开始执行了。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Kotlin-Coroutine/">Kotlin Coroutine</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/e2cf098c.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Kotlin协程 - 协程挂起原理</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/ec1be5bf.html">
        <span class="next-text nav-default">Kotlin协程 - 基础概念介绍</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
