<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="GLES&EGL-GLES-03"/>




  <meta name="keywords" content="AndroidFrameworks,OpenGLES,EGL," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/60dbf32.html"/>


<meta name="description" content="前面  GLES&amp;EGL-GLES-01 、 GLES&amp;EGL-GLES-02  中按顺序讲到了常用的几个 gl 函数，本篇接着前面的分析往后看剩下的最后一个，也是最重要的一个方法。 glDrawTexiOES123456789101112131415161718192021222324252627282930313233343536373839404142434445464748">
<meta property="og:type" content="article">
<meta property="og:title" content="GLES&amp;EGL-GLES-03">
<meta property="og:url" content="https://youngkaaa.github.io/60dbf32.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="前面  GLES&amp;EGL-GLES-01 、 GLES&amp;EGL-GLES-02  中按顺序讲到了常用的几个 gl 函数，本篇接着前面的分析往后看剩下的最后一个，也是最重要的一个方法。 glDrawTexiOES123456789101112131415161718192021222324252627282930313233343536373839404142434445464748">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-20T11:55:57.000Z">
<meta property="article:modified_time" content="2023-03-03T14:01:26.173Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="OpenGLES">
<meta property="article:tag" content="EGL">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> GLES&EGL-GLES-03 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          GLES&EGL-GLES-03
        
      </h1>

      <time class="post-time">
          8月 20 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>前面  <a href="e803de1e.html">GLES&amp;EGL-GLES-01</a> 、 <a href="710a8fa4.html">GLES&amp;EGL-GLES-02</a>  中按顺序讲到了常用的几个 gl 函数，本篇接着前面的分析往后看剩下的最后一个，也是最重要的一个方法。</p>
<h3 id="glDrawTexiOES"><a href="#glDrawTexiOES" class="headerlink" title="glDrawTexiOES"></a>glDrawTexiOES</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/texture.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">glDrawTexiOES</span><span class="params">(GLint x, GLint y, GLint z, GLint w, GLint h)</span> </span>&#123;</span><br><span class="line">    <span class="type">ogles_context_t</span>* c = <span class="type">ogles_context_t</span>::<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">drawTexiOES</span>(x, y, z, w, h, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">drawTexiOES</span><span class="params">(GLint x, GLint y, GLint z, GLint w, GLint h, <span class="type">ogles_context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果之前调用过 glEnable(GL_TEXTURE_2D) 的话，它就会被置为 1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ggl_likely</span>(c-&gt;rasterizer.state.enabled_tmu == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> tmu = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="type">texture_unit_t</span>&amp; <span class="title">u</span><span class="params">(c-&gt;textures.tmu[tmu])</span></span>;</span><br><span class="line">        <span class="comment">// 拿到 c-&gt;textures.tmu[0] 中对应的 EGLTextureObject 实例</span></span><br><span class="line">        EGLTextureObject* textureObject = u.texture;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * crop_rect 存储的是之前  glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop) 时</span></span><br><span class="line"><span class="comment">         * 设置进来的 纹理裁剪区域，是长度为4的数组，内部存储着：左边界，下边界，宽，高。</span></span><br><span class="line"><span class="comment">         * 所以这里取出后两个值 宽和高，也就是当时 glTexParameteriv 设置的纹理裁剪区域的宽高，纹理将在该区域内显示</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">const</span> GLint Wcr = textureObject-&gt;crop_rect[<span class="number">2</span>];</span><br><span class="line">        <span class="type">const</span> GLint Hcr = textureObject-&gt;crop_rect[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前方法入参宽高和之前设置的宽高一致</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((w == Wcr) &amp;&amp; (h == -Hcr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((w|h) &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 表示其中的参数发生过变化，则这里需要重新设置新的属性进去</span></span><br><span class="line"><span class="comment">             * 之前好多个地方都会调用 invalidate_texture() 方法来将对应的 dirty 置为 0xFF</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (u.dirty) &#123;</span><br><span class="line">                <span class="comment">// pixelflinger.cpp#ggl_activeTexture</span></span><br><span class="line">                c-&gt;rasterizer.procs.<span class="built_in">activeTexture</span>(c, tmu);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * pixelflinger.cpp#ggl_bindTexture</span></span><br><span class="line"><span class="comment">                 * 传入的第二个参数是 c-&gt;textures.tmu[0]-&gt;surface</span></span><br><span class="line"><span class="comment">                 * 也就是之前 glTexImage2D 方法时，保存了输入像素源数据的结构体实例</span></span><br><span class="line"><span class="comment">                 * </span></span><br><span class="line"><span class="comment">                 * 这里实现的作用是将 glTexImage2D 保存的像素源数据保存到 c-&gt;activeTMU-&gt;surface 中去</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                c-&gt;rasterizer.procs.<span class="built_in">bindTexture</span>(c, &amp;(u.texture-&gt;surface));</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * min_filter 中保存的是之前通过 glTexParameterx 方法设置的 GL_TEXTURE_MIN_FILTER 值</span></span><br><span class="line"><span class="comment">                 * 这里将其传递到 c-&gt;activeTMU 中的对应字段中去</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                c-&gt;rasterizer.procs.<span class="built_in">texParameteri</span>(c, GGL_TEXTURE_2D,</span><br><span class="line">                        GGL_TEXTURE_MIN_FILTER, u.texture-&gt;min_filter);</span><br><span class="line">                c-&gt;rasterizer.procs.<span class="built_in">texParameteri</span>(c, GGL_TEXTURE_2D,</span><br><span class="line">                        GGL_TEXTURE_MAG_FILTER, u.texture-&gt;mag_filter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            c-&gt;rasterizer.procs.<span class="built_in">texGeni</span>(c, GGL_S, GGL_TEXTURE_GEN_MODE, GGL_ONE_TO_ONE);</span><br><span class="line">            c-&gt;rasterizer.procs.<span class="built_in">texGeni</span>(c, GGL_T, GGL_TEXTURE_GEN_MODE, GGL_ONE_TO_ONE);</span><br><span class="line">        </span><br><span class="line">            u.dirty = <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里开始以 textures.active 为准开始操作，首先就是 activeTexture</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            c-&gt;rasterizer.procs.<span class="built_in">activeTexture</span>(c, c-&gt;textures.active);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * c-&gt;rasterizer.state.buffers.color.s 中保存的是之前 egl makeCurrent </span></span><br><span class="line"><span class="comment">             * 或者 eglSwapBuffer 时，通过 bindDrawSurface 设置进来的 GraphicBuffer 的相关信息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">const</span> GGLSurface&amp; cbSurface = c-&gt;rasterizer.state.buffers.color.s;</span><br><span class="line"></span><br><span class="line">            y = cbSurface.height - (y + h);</span><br><span class="line">            <span class="type">const</span> GLint Ucr = textureObject-&gt;crop_rect[<span class="number">0</span>];</span><br><span class="line">            <span class="type">const</span> GLint Vcr = textureObject-&gt;crop_rect[<span class="number">1</span>];</span><br><span class="line">            <span class="type">const</span> GLint s0  = Ucr - x;</span><br><span class="line">            <span class="type">const</span> GLint t0  = (Vcr + Hcr) - y;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> GLuint tw = textureObject-&gt;surface.width;</span><br><span class="line">            <span class="type">const</span> GLuint th = textureObject-&gt;surface.height;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">uint32_t</span>(s0+x+w) &gt; tw) || (<span class="built_in">uint32_t</span>(t0+y+h) &gt; th)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> slow_case;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ogles_lock_textures</span>(c);</span><br><span class="line"></span><br><span class="line">            c-&gt;rasterizer.procs.<span class="built_in">texCoord2i</span>(c, s0, t0);</span><br><span class="line">            <span class="type">const</span> <span class="type">uint32_t</span> enables = c-&gt;rasterizer.state.enables;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ggl_unlikely</span>(enables &amp; (GGL_ENABLE_DEPTH_TEST|GGL_ENABLE_FOG)))</span><br><span class="line">                <span class="built_in">set_depth_and_fog</span>(c, <span class="built_in">gglIntToFixed</span>(z));</span><br><span class="line"></span><br><span class="line">            c-&gt;rasterizer.procs.<span class="built_in">color4xv</span>(c, c-&gt;currentColorClamped.v);</span><br><span class="line">            c-&gt;rasterizer.procs.<span class="built_in">disable</span>(c, GGL_W_LERP);</span><br><span class="line">            c-&gt;rasterizer.procs.<span class="built_in">disable</span>(c, GGL_AA);</span><br><span class="line">            c-&gt;rasterizer.procs.<span class="built_in">shadeModel</span>(c, GL_FLAT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 实际的逻辑在这里来处理</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            c-&gt;rasterizer.procs.<span class="built_in">recti</span>(c, x, y, x+w, y+h);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ogles_unlock_textures</span>(c);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">slow_case:</span><br><span class="line">    <span class="built_in">drawTexxOESImp</span>(</span><br><span class="line">            <span class="built_in">gglIntToFixed</span>(x), <span class="built_in">gglIntToFixed</span>(y), <span class="built_in">gglIntToFixed</span>(z),</span><br><span class="line">            <span class="built_in">gglIntToFixed</span>(w), <span class="built_in">gglIntToFixed</span>(h),</span><br><span class="line">            c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较复杂，但同样也是最重要的，所以将它放在单独的一篇文章里面来分析。</p>
<p>首先进入到 drawTexiOES() 中第一步就是判断：c-&gt;rasterizer.state.enabled_tmu 的值是否是1，如果之前调用过 glEnable(GL_TEXTURE_2D) 方法的话，那么它就会被置为1，并且它这个条件满足才会执行剩余逻辑，否则该方法啥都不执行。</p>
<p>接着会拿到 c-&gt;textures.tmu 数组中，索引为 0 位置的 EGLTextureObject 实例，接着从该 EGLTextureObject 实例中取出之前设置的 crop 属性值，从而得到当时设置的 裁剪宽高。</p>
<p>注意：之前设置这个 crop 属性值是通过调用 glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop) 方法来实现的。设置的 crop 是一个长度为4的 GLint （也就是int） 数组，其中四个数值分别代表的含义是： 纹理的左边界，下边界，宽，高。其中后两个参数代表的 宽和高可以为负数，这样渲染出来的效果是图片时行了左右颠倒，或者上下颠倒，下面还是使用开机动画来做举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/cmds/bootanimation/BootAnimation.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BootAnimation::initTexture</span><span class="params">(Texture* texture, AssetManager&amp; assets,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取出文件资源</span></span><br><span class="line">    Asset* asset = assets.<span class="built_in">open</span>(name, Asset::ACCESS_BUFFER);</span><br><span class="line">    <span class="keyword">if</span> (asset == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    sk_sp&lt;SkData&gt; data = SkData::<span class="built_in">MakeWithoutCopy</span>(asset-&gt;<span class="built_in">getBuffer</span>(<span class="literal">false</span>), asset-&gt;<span class="built_in">getLength</span>());</span><br><span class="line">    sk_sp&lt;SkImage&gt; image = SkImage::<span class="built_in">MakeFromEncoded</span>(data);</span><br><span class="line">    image-&gt;<span class="built_in">asLegacyBitmap</span>(&amp;bitmap, SkImage::kRO_LegacyBitmapMode);</span><br><span class="line">    asset-&gt;<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">delete</span> asset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载成bitmap之后，获取该bitmap图的宽高</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> w = bitmap.<span class="built_in">width</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> h = bitmap.<span class="built_in">height</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* p = bitmap.<span class="built_in">getPixels</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 crop 数组，注意最后一位高度传入的是 负的高度值</span></span><br><span class="line">    GLint crop[<span class="number">4</span>] = &#123; <span class="number">0</span>, h, w, -h &#125;;</span><br><span class="line">    texture-&gt;w = w;</span><br><span class="line">    texture-&gt;h = h;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture-&gt;name);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将像素数据设置进去</span></span><br><span class="line">    <span class="keyword">switch</span> (bitmap.<span class="built_in">colorType</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> kAlpha_8_SkColorType:</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_ALPHA, w, h, <span class="number">0</span>, GL_ALPHA,</span><br><span class="line">                    GL_UNSIGNED_BYTE, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kARGB_4444_SkColorType:</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, w, h, <span class="number">0</span>, GL_RGBA,</span><br><span class="line">                    GL_UNSIGNED_SHORT_4_4_4_4, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kN32_SkColorType:</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, w, h, <span class="number">0</span>, GL_RGBA,</span><br><span class="line">                    GL_UNSIGNED_BYTE, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kRGB_565_SkColorType:</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, w, h, <span class="number">0</span>, GL_RGB,</span><br><span class="line">                    GL_UNSIGNED_SHORT_5_6_5, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// GL_TEXTURE_CROP_RECT_OES：设置纹理的裁剪区域</span></span><br><span class="line">    <span class="built_in">glTexParameteriv</span>(GL_TEXTURE_2D, GL_TEXTURE_CROP_RECT_OES, crop);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glTexParameterx</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">    <span class="built_in">glTexParameterx</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">    <span class="built_in">glTexParameterx</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    <span class="built_in">glTexParameterx</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>z这里传入的 crop 最后一个就是负的高度值，所以内部这里判断时，使用的是：h &#x3D;&#x3D; -Hcr ，其实就是判断当前方法传入的高度值和之前设置的crop中的高度值是否相等。</p>
<p>接着往下，会接着操作这个 c-&gt;textures.tmu 数组中索引为 0 位置的texture_unit_t 实例，判断它的 dirty 值是否非 0，而它在前面好多地方都会通过调用 invalidate_texture() 方法来将对应的 dirty 置为 0xFF ，表示其内部的属性发生了变化。所以这里暂且把它认为是 0xFF，也就是非0 ，符合这里的条件。</p>
<p>满足 dirty 非0的条件之后，条件体内会执行三步：</p>
<p>① 执行 c-&gt;rasterizer.procs.activeTexture() 方法来将 tmu &#x3D; 0 传入进去，最终调用到 pixelflinger.cpp#ggl_activeTexture() 方法中，内部会修改 c-&gt;activeTMUIndex 和 c-&gt;activeTMU ，这个方法在前面的 <a href="710a8fa4.html">glActiveTexture() </a> 中讲过了。</p>
<p>② 调用 c-&gt;rasterizer.procs.bindTexture() 方法，传入的第二个参数是 u.texture-&gt;surface ，它对应的就是之前通过调用 <a href="710a8fa4.html">glTexImage2D()</a> 方法传入进来的图像信息，宽高格式和像素信息了，也就是待处理绘制的像素信息。而这里的 u 是c-&gt;textures.tmu 数组中索引为 0 位置的texture_unit_t 实例，所以这里拿到的像素数据就是之前保存在 0 位置的待处理的数据。</p>
<p>明确完这个入参的含义之后，接着看 c-&gt;rasterizer.procs.bindTexture() 方法的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_bindTexture</span><span class="params">(<span class="type">void</span>* con, <span class="type">const</span> GGLSurface* surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">    <span class="comment">// 如果新输入的像素数据信息的格式和之前activeTMU位置保存的格式不一致，则</span></span><br><span class="line">    <span class="keyword">if</span> (surface-&gt;format != c-&gt;activeTMU-&gt;surface.format)</span><br><span class="line">        <span class="built_in">ggl_state_changed</span>(c, GGL_TMU_STATE);  </span><br><span class="line">    <span class="comment">// 将入参 surface 中的数据赋值到 c-&gt;activeTMU-&gt;surface 中去</span></span><br><span class="line">    <span class="built_in">ggl_set_surface</span>(c, &amp;(c-&gt;activeTMU-&gt;surface), surface);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里呢，就是将 u.texture-&gt;surface 数据转存到 c-&gt;activeTMU-&gt;surface 中去，并且如果发现前后格式变化了，还会调用 ggl_state_changed(c, GGL_TMU_STATE) 方法来刷新下，这个方法后面会用到的。</p>
<p>正如前面 <a href="710a8fa4.html">glActiveTexture() </a> 方法中所说的：c-&gt;state.texture 数组和c-&gt;textures.tmu 数组是有关系的，并且当时列举出了其对应数组中实例 texture_t 和 EGLTextureObject 这两个类型的定义及其内部属性的对比，当时他俩还没有联系，而到这里就能看到一点点联系了，这里会将 EGLTextureObject.surface 中的数据复制给 texture_t.surface 。</p>
<p>③ 调用 c-&gt;rasterizer.procs.texParameteri() 方法来将 u.texture 中的 min_filter 和 mag_filter 属性设置给 c-&gt;activeTMU 中的 min_filter 和 mag_filter。</p>
<p>也就是将 EGLTextureObject 中的 min_filter 和 mag_filter 属性和 texture_t 中的 min_filter 和 mag_filter 关联在了一起，源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_texParameteri</span><span class="params">(<span class="type">void</span>* con,</span></span></span><br><span class="line"><span class="params"><span class="function">        GGLenum target,</span></span></span><br><span class="line"><span class="params"><span class="function">        GGLenum pname,</span></span></span><br><span class="line"><span class="params"><span class="function">        GGLint param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">    <span class="keyword">if</span> (target != GGL_TEXTURE_2D) &#123;</span><br><span class="line">        <span class="built_in">ggl_error</span>(c, GGL_INVALID_ENUM);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (param == GGL_CLAMP_TO_EDGE)</span><br><span class="line">        param = GGL_CLAMP;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span>* what = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 跟  texture.cpp#glTexParameterx  中的逻辑差不多，就是根据 pname 来分别处理 param</span></span><br><span class="line">    <span class="keyword">switch</span> (pname) &#123;</span><br><span class="line">    <span class="keyword">case</span> GGL_TEXTURE_WRAP_S:</span><br><span class="line">        <span class="keyword">if</span> ((param == GGL_CLAMP) ||</span><br><span class="line">            (param == GGL_REPEAT)) &#123;</span><br><span class="line">            what = &amp;c-&gt;activeTMU-&gt;s_wrap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_TEXTURE_WRAP_T:</span><br><span class="line">        <span class="keyword">if</span> ((param == GGL_CLAMP) ||</span><br><span class="line">            (param == GGL_REPEAT)) &#123;</span><br><span class="line">            what = &amp;c-&gt;activeTMU-&gt;t_wrap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_TEXTURE_MIN_FILTER:</span><br><span class="line">        <span class="keyword">if</span> ((param == GGL_NEAREST) ||</span><br><span class="line">            (param == GGL_NEAREST_MIPMAP_NEAREST) ||</span><br><span class="line">            (param == GGL_NEAREST_MIPMAP_LINEAR)) &#123;</span><br><span class="line">            what = &amp;c-&gt;activeTMU-&gt;min_filter;</span><br><span class="line">            param = GGL_NEAREST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((param == GGL_LINEAR) ||</span><br><span class="line">            (param == GGL_LINEAR_MIPMAP_NEAREST) ||</span><br><span class="line">            (param == GGL_LINEAR_MIPMAP_LINEAR)) &#123;</span><br><span class="line">            what = &amp;c-&gt;activeTMU-&gt;min_filter;</span><br><span class="line">            param = GGL_LINEAR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_TEXTURE_MAG_FILTER:</span><br><span class="line">        <span class="keyword">if</span> ((param == GGL_NEAREST) ||</span><br><span class="line">            (param == GGL_LINEAR)) &#123;</span><br><span class="line">            what = &amp;c-&gt;activeTMU-&gt;mag_filter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!what) &#123;</span><br><span class="line">        <span class="built_in">ggl_error</span>(c, GGL_INVALID_ENUM);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// what 指向不同的值地址，比如c-&gt;activeTMU-&gt;min_filter、mag_filter 等</span></span><br><span class="line">    <span class="comment">// 这里就会将其给修改掉</span></span><br><span class="line">    <span class="keyword">if</span> (*what != param) &#123;</span><br><span class="line">        *what = param;</span><br><span class="line">        <span class="built_in">ggl_state_changed</span>(c, GGL_TMU_STATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此， dirty 非0的条件体内的逻辑就执行完毕了。</p>
<p>接着往下，跳过不重要的部分，接下来就开始处理真正的逻辑了，也就是 c-&gt;textures.active 索引位置的数据了。</p>
<p>其实按照我的理解，就应该处理 c-&gt;textures.active 索引位置对应的数据，而不是前面执行的一系列的 索引为 0 的逻辑。而为啥要先按照上面分析的逻辑，默认先处理 0 位置的数据呢？</p>
<p>我的理解如下：</p>
<blockquote>
<p>我们从头开始理一下讲过的这些方法。在 glBindTexture() 方法中会把入参 纹理id及其对应的纹理对象实例 EGLTextureObject 保存到 c-&gt;textures.tmu[c-&gt;textures.active] 中；接着往后的 glTexParameteri() 设置参数时也是 操作的 c-&gt;textures.tmu[c-&gt;textures.active] 中的 EGLTextureObject，包括后续的 glTexImage2D() 方法中传入进来的图片宽高格式像素信息等也是存入到 c-&gt;textures.tmu[c-&gt;textures.active]的 EGLTextureObject中的。</p>
<p>而这个 c-&gt;textures.active 的值一开始是默认的0，所以一开始执行上述操作，都是修改的 c-&gt;textures.tmu[ 0 ] 中的数据，直到后面调用：glActiveTexture() 方法并且传入 不是 GL_TEXTURE0 参数时，这个  c-&gt;textures.active 才会被修改为非0的值，而绝大多数都是使用的  GL_TEXTURE0 ，所以绝大多数情况下 c-&gt;textures.active 的值就是 0。</p>
</blockquote>
<p>下面的逻辑中，还是分为一步步来介绍：</p>
<p>① 调用 c-&gt;rasterizer.procs.activeTexture() 方法来激活 c-&gt;textures.active 索引位置的数据。而这个 activeTexture() 方法前面分析过了，唯一不同的是这里传入的参数是c-&gt;textures.active ,当然它绝大多数情况下是 0。</p>
<p>关于 c-&gt;rasterizer.procs.activeTexture() 方法的实现分析，上面刚讲过了，这里跳过。</p>
<p>② 接下来拿到 c-&gt;rasterizer.state.buffers.color.s 中存储的 GGLSurface 实例。而这个实例中存储的是啥呢？？</p>
<p>来让我们复习下之前 EGL 中的逻辑，可以先看看这里关于 EGL 中  <a href="4446cd65.html">eglMakeCurrent() 方法</a>的分析，当时会调用到egl_window_surface_v2_t::bindDrawSurface() 方法中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/egl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_window_surface_v2_t::bindDrawSurface</span><span class="params">(<span class="type">ogles_context_t</span>* gl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 GGLSurface ，然后将 egl_window_surface_v2_t 中的数据和 GGLSurface 中关联起来</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 前面 makeCurrent 中会先调用其 connect 方法，在该方法中会出队一个 GraphicBuffer 并使用 buffer 指向它</span></span><br><span class="line"><span class="comment">     * 接着会调用 lock() 方法来将该 buffer 内存空间锁住，并使用 bits 指向该内存地址，所以这里会把 bits 赋值给 buffer.data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    GGLSurface buffer;</span><br><span class="line">    buffer.version = <span class="built_in">sizeof</span>(GGLSurface);</span><br><span class="line">    buffer.width   = <span class="keyword">this</span>-&gt;buffer-&gt;width;</span><br><span class="line">    buffer.height  = <span class="keyword">this</span>-&gt;buffer-&gt;height;</span><br><span class="line">    buffer.stride  = <span class="keyword">this</span>-&gt;buffer-&gt;stride;</span><br><span class="line">    buffer.data    = (GGLubyte*)bits;</span><br><span class="line">    buffer.format  = <span class="keyword">this</span>-&gt;buffer-&gt;format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * procs 是 GGLContext ,其 colorBuffer 方法对应的是 ggl_colorBuffer</span></span><br><span class="line"><span class="comment">     * 上面封装的 GGLSurface 其实就是为了这里传入进去。方便里面使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    gl-&gt;rasterizer.procs.<span class="built_in">colorBuffer</span>(gl, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (depth.data != gl-&gt;rasterizer.state.buffers.depth.data)</span><br><span class="line">        gl-&gt;rasterizer.procs.<span class="built_in">depthBuffer</span>(gl, &amp;depth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_colorBuffer</span><span class="params">(<span class="type">void</span>* con, <span class="type">const</span> GGLSurface* surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// GGL_CONTEXT 方法,拿到 con 中的 rasterizer  context_t ，然后让 c 指向它</span></span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">    <span class="comment">// 格式发生变化了</span></span><br><span class="line">    <span class="keyword">if</span> (surface-&gt;format != c-&gt;state.buffers.color.format)</span><br><span class="line">        <span class="built_in">ggl_state_changed</span>(c, GGL_CB_STATE);</span><br><span class="line">    <span class="comment">// 重新为coverage 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (surface-&gt;width &gt; c-&gt;state.buffers.coverageBufferSize) &#123;</span><br><span class="line">        <span class="comment">// allocate the coverage factor buffer</span></span><br><span class="line">        <span class="built_in">free</span>(c-&gt;state.buffers.coverage);</span><br><span class="line">        c-&gt;state.buffers.coverage = (<span class="type">int16_t</span>*)<span class="built_in">malloc</span>(surface-&gt;width * <span class="number">2</span>);</span><br><span class="line">        c-&gt;state.buffers.coverageBufferSize =</span><br><span class="line">                c-&gt;state.buffers.coverage ? surface-&gt;width : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将传进来的 GGLSurface 中的属性设置给 context_t 的 buffers.color</span></span><br><span class="line">    <span class="comment">// 后续 gl 操作 buffers.color 时，就相当于操作了 GraphicBuffer 了，可以往里面写入渲染数据</span></span><br><span class="line">    <span class="built_in">ggl_set_surface</span>(c, &amp;(c-&gt;state.buffers.color), surface);</span><br><span class="line">    <span class="comment">// 第一次时，顺带同时设置给 context_t 的 buffers.read</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;state.buffers.read.format == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ggl_set_surface</span>(c, &amp;(c-&gt;state.buffers.read), surface);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ggl_set_scissor</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/buffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_set_surface</span><span class="params">(<span class="type">context_t</span>* c, <span class="type">surface_t</span>* dst, <span class="type">const</span> GGLSurface* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dst-&gt;width = src-&gt;width;</span><br><span class="line">    dst-&gt;height = src-&gt;height;</span><br><span class="line">    dst-&gt;stride = src-&gt;stride;</span><br><span class="line">    dst-&gt;data = src-&gt;data;</span><br><span class="line">    dst-&gt;format = src-&gt;format;</span><br><span class="line">    dst-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(dst-&gt;stride &lt; <span class="number">0</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> GGLFormat&amp; <span class="title">pixelFormat</span><span class="params">(c-&gt;formats[dst-&gt;format])</span></span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> bpr = -dst-&gt;stride * pixelFormat.size;</span><br><span class="line">        dst-&gt;data += bpr * (dst-&gt;height<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说这里的 c-&gt;rasterizer.state.buffers.color.s 中的数据，其实就是当初 EGL 操作时设置进来的。这点需要记住，至少在本篇文章中需要一直记住，后面还会再遇到的。</p>
<p>拿到当时设置进来的这个 GGLSurface 实例，接下来就可以使用其宽高和当前 textureObject-&gt;surface 中的宽高和 crop裁剪区域 等信息来计算对应属性了。</p>
<p>③ 调用 ogles_lock_textures(c) 方法来锁住 c-&gt;textures.tmu 数组中的 buffer 。而这个buffer 的赋值我没看到过，所以暂且将其认为是空的，所以该 ogles_lock_textures(c) 方法可以忽略。</p>
<p>④ 上面第②步中会计算出来一些值，这里将这些计算出来的值设置进去。也就是通过调用几个方法来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;rasterizer.procs.<span class="built_in">texCoord2i</span>(c, s0, t0);</span><br><span class="line">c-&gt;rasterizer.procs.<span class="built_in">color4xv</span>(c, c-&gt;currentColorClamped.v);</span><br><span class="line">c-&gt;rasterizer.procs.<span class="built_in">disable</span>(c, GGL_W_LERP);</span><br><span class="line">c-&gt;rasterizer.procs.<span class="built_in">disable</span>(c, GGL_AA);</span><br><span class="line">c-&gt;rasterizer.procs.<span class="built_in">shadeModel</span>(c, GL_FLAT);</span><br></pre></td></tr></table></figure>

<p>这些方法的实现就都是修改值，比如 texCoord2i() ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_texCoord2i</span><span class="params">(<span class="type">void</span>* con, GGLint s, GGLint t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ggl_texCoord2x</span>(con, s&lt;&lt;<span class="number">16</span>, t&lt;&lt;<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_texCoord2x</span><span class="params">(<span class="type">void</span>* con, GGLfixed s, GGLfixed t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 其实就是修改到 c-&gt;activeTMU 中去</span></span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">	c-&gt;activeTMU-&gt;shade.is0 = s;</span><br><span class="line">	c-&gt;activeTMU-&gt;shade.it0 = t;</span><br><span class="line">    c-&gt;activeTMU-&gt;shade.sscale= <span class="number">0</span>;</span><br><span class="line">    c-&gt;activeTMU-&gt;shade.tscale= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实也就是修改 c-&gt;activeTMU 中的属性。剩下几个就不一一看了。</p>
<p>⑤ 调用 c-&gt;rasterizer.procs.recti() 方法来处理剩余的逻辑。而对于这个 recti() 方法来说，是在一开始初始化时会赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/state.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ogles_context_t</span> *<span class="title">ogles_init</span><span class="params">(<span class="type">size_t</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> base = <span class="built_in">malloc</span>(extra + <span class="built_in">sizeof</span>(<span class="type">ogles_context_t</span>) + <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> (!base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ogles_context_t</span> *c =</span><br><span class="line">            (<span class="type">ogles_context_t</span> *)((<span class="built_in">ptrdiff_t</span>(base) + extra + <span class="number">31</span>) &amp; ~<span class="number">0x1F</span>L);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">ogles_context_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 context_t c-&gt;rasterizer</span></span><br><span class="line">    <span class="built_in">ggl_init_context</span>(&amp;(c-&gt;rasterizer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_init_context</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">context_t</span>));</span><br><span class="line">    <span class="built_in">ggl_init_procs</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 trap</span></span><br><span class="line">    <span class="built_in">ggl_init_trap</span>(c);</span><br><span class="line">    <span class="comment">// 初始化 scanline</span></span><br><span class="line">    <span class="built_in">ggl_init_scanline</span>(c);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其他的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/trap.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_init_trap</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ggl_state_changed</span>(c, GGL_PIXEL_PIPELINE_STATE|GGL_TMU_STATE|GGL_CB_STATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_state_changed</span><span class="params">(<span class="type">context_t</span>* c, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化内部函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ggl_likely</span>(!c-&gt;dirty)) &#123;</span><br><span class="line">        c-&gt;procs.pointx     = pointx_validate;</span><br><span class="line">        c-&gt;procs.linex      = linex_validate;</span><br><span class="line">        c-&gt;procs.recti      = recti_validate;</span><br><span class="line">        c-&gt;procs.trianglex  = trianglex_validate;</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;dirty |= <span class="built_in">uint32_t</span>(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/scanline.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_init_scanline</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 scanline 相关函数</span></span><br><span class="line">    c-&gt;init_y = init_y;</span><br><span class="line">    c-&gt;step_y = step_y__generic;</span><br><span class="line">    c-&gt;scanline = scanline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>z这里可以看到：c-&gt;procs.recti ，以及 c-&gt;scanline 等函数在一开始就会被初始化为对应的函数实现。接下来我们看看这个 recti 函数的具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/trap.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recti_validate</span><span class="params">(<span class="type">void</span> *con, GGLint l, GGLint t, GGLint r, GGLint b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">    <span class="comment">// 内部会给 init_y、 step_y、scanline、span 等函数赋值</span></span><br><span class="line">    <span class="built_in">ggl_pick</span>(c);</span><br><span class="line">    <span class="comment">// 重新修改 recti 方法的实现，转到 recti 中去执行</span></span><br><span class="line">    c-&gt;procs.recti = recti;</span><br><span class="line">    <span class="comment">// 转到这个新的 recti 实现中去执行</span></span><br><span class="line">    c-&gt;procs.<span class="built_in">recti</span>(con, l, t, r, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gai该方法中，主要分为两步：</p>
<p>① 调用 ggl_pick() 方法来处理 c-&gt;dirty 中的值。</p>
<p>② 将 c-&gt;procs.recti 方法重新赋值为 recti()，并且调用它，进而可以转到新的函数实现中执行。</p>
<p>下面依次介绍这俩方法：</p>
<h4 id="ggl-pick"><a href="#ggl-pick" class="headerlink" title="ggl_pick()"></a>ggl_pick()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/picker.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_pick</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在该方法调用之前，一般都调用过多次的 trap.cpp#ggl_state_changed() 方法的，</span></span><br><span class="line"><span class="comment">     * 该方法内部会给 dirty 附上对应不同的标志位，表示触发 ggl_state_changed()  刷新的原因</span></span><br><span class="line"><span class="comment">     * 而接下来呢就是处理 dirty 中的不同位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ggl_likely</span>(!c-&gt;dirty))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> enables = c-&gt;state.enables;</span><br><span class="line">    <span class="function"><span class="type">needs_t</span> <span class="title">new_needs</span><span class="params">(c-&gt;state.needs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断之前给 dirty 它上面附加的标志位，常见的是 GGL_TMU_STATE</span></span><br><span class="line"><span class="comment">     * 每种标志位表示有那些特性发生变化，则挨个处理对应的变化，并将其处理存储在 c-&gt;state.needs 中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 处理 GGL_CB_STATE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;dirty &amp; GGL_CB_STATE) &#123;</span><br><span class="line">        new_needs.n &amp;= ~GGL_NEEDS_CB_FORMAT_MASK;</span><br><span class="line">        new_needs.n |= <span class="built_in">GGL_BUILD_NEEDS</span>(c-&gt;state.buffers.color.format, CB_FORMAT);</span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_BLENDING)</span><br><span class="line">            c-&gt;dirty |= GGL_PIXEL_PIPELINE_STATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 GGL_PIXEL_PIPELINE_STATE</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;dirty &amp; GGL_PIXEL_PIPELINE_STATE) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> n = <span class="built_in">GGL_BUILD_NEEDS</span>(c-&gt;state.buffers.color.format, CB_FORMAT);</span><br><span class="line">        <span class="type">uint32_t</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_BLENDING) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> src = c-&gt;state.blend.src;</span><br><span class="line">            <span class="type">uint32_t</span> dst = c-&gt;state.blend.dst;</span><br><span class="line">            <span class="type">uint32_t</span> src_alpha = c-&gt;state.blend.src_alpha;</span><br><span class="line">            <span class="type">uint32_t</span> dst_alpha = c-&gt;state.blend.dst_alpha;</span><br><span class="line">            <span class="type">const</span> GGLFormat&amp; cbf = c-&gt;formats[ c-&gt;state.buffers.color.format ];</span><br><span class="line">            <span class="keyword">if</span> (!cbf.c[GGLFormat::ALPHA].h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((src == GGL_ONE_MINUS_DST_ALPHA) ||</span><br><span class="line">                    (src == GGL_DST_ALPHA)) &#123;</span><br><span class="line">                    src = GGL_ONE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((src_alpha == GGL_ONE_MINUS_DST_ALPHA) ||</span><br><span class="line">                    (src_alpha == GGL_DST_ALPHA)) &#123;</span><br><span class="line">                    src_alpha = GGL_ONE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((dst == GGL_ONE_MINUS_DST_ALPHA) ||</span><br><span class="line">                    (dst == GGL_DST_ALPHA)) &#123;</span><br><span class="line">                    dst = GGL_ONE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((dst_alpha == GGL_ONE_MINUS_DST_ALPHA) ||</span><br><span class="line">                    (dst_alpha == GGL_DST_ALPHA)) &#123;</span><br><span class="line">                    dst_alpha = GGL_ONE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            src       = <span class="built_in">ggl_blendfactor_to_needs</span>(src);</span><br><span class="line">            dst       = <span class="built_in">ggl_blendfactor_to_needs</span>(dst);</span><br><span class="line">            src_alpha = <span class="built_in">ggl_blendfactor_to_needs</span>(src_alpha);</span><br><span class="line">            dst_alpha = <span class="built_in">ggl_blendfactor_to_needs</span>(dst_alpha);</span><br><span class="line">                </span><br><span class="line">            n |= <span class="built_in">GGL_BUILD_NEEDS</span>( src, BLEND_SRC );</span><br><span class="line">            n |= <span class="built_in">GGL_BUILD_NEEDS</span>( dst, BLEND_DST );</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;state.blend.alpha_separate) &#123;</span><br><span class="line">                n |= <span class="built_in">GGL_BUILD_NEEDS</span>( src_alpha, BLEND_SRCA );</span><br><span class="line">                n |= <span class="built_in">GGL_BUILD_NEEDS</span>( dst_alpha, BLEND_DSTA );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n |= <span class="built_in">GGL_BUILD_NEEDS</span>( src, BLEND_SRCA );</span><br><span class="line">                n |= <span class="built_in">GGL_BUILD_NEEDS</span>( dst, BLEND_DSTA );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n |= <span class="built_in">GGL_BUILD_NEEDS</span>( GGL_ONE,  BLEND_SRC );</span><br><span class="line">            n |= <span class="built_in">GGL_BUILD_NEEDS</span>( GGL_ZERO, BLEND_DST );</span><br><span class="line">            n |= <span class="built_in">GGL_BUILD_NEEDS</span>( GGL_ONE,  BLEND_SRCA );</span><br><span class="line">            n |= <span class="built_in">GGL_BUILD_NEEDS</span>( GGL_ZERO, BLEND_DSTA );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        n |= <span class="built_in">GGL_BUILD_NEEDS</span>(c-&gt;state.mask.color^<span class="number">0xF</span>,               MASK_ARGB);</span><br><span class="line">        n |= <span class="built_in">GGL_BUILD_NEEDS</span>((enables &amp; GGL_ENABLE_SMOOTH)  ?<span class="number">1</span>:<span class="number">0</span>,   SHADE);</span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_TMUS) &#123;</span><br><span class="line">            n |= <span class="built_in">GGL_BUILD_NEEDS</span>((enables &amp; GGL_ENABLE_W)       ?<span class="number">1</span>:<span class="number">0</span>,   W);</span><br><span class="line">        &#125;</span><br><span class="line">        p |= <span class="built_in">GGL_BUILD_NEEDS</span>((enables &amp; GGL_ENABLE_DITHER)  ?<span class="number">1</span>:<span class="number">0</span>,   P_DITHER);</span><br><span class="line">        p |= <span class="built_in">GGL_BUILD_NEEDS</span>((enables &amp; GGL_ENABLE_AA)      ?<span class="number">1</span>:<span class="number">0</span>,   P_AA);</span><br><span class="line">        p |= <span class="built_in">GGL_BUILD_NEEDS</span>((enables &amp; GGL_ENABLE_FOG)     ?<span class="number">1</span>:<span class="number">0</span>,   P_FOG);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_LOGIC_OP) &#123;</span><br><span class="line">            n |= <span class="built_in">GGL_BUILD_NEEDS</span>(c-&gt;state.logic_op.opcode, LOGIC_OP);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n |= <span class="built_in">GGL_BUILD_NEEDS</span>(GGL_COPY, LOGIC_OP);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_ALPHA_TEST) &#123;</span><br><span class="line">            p |= <span class="built_in">GGL_BUILD_NEEDS</span>(c-&gt;state.alpha_test.func, P_ALPHA_TEST);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p |= <span class="built_in">GGL_BUILD_NEEDS</span>(GGL_ALWAYS, P_ALPHA_TEST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_DEPTH_TEST) &#123;</span><br><span class="line">            p |= <span class="built_in">GGL_BUILD_NEEDS</span>(c-&gt;state.depth_test.func, P_DEPTH_TEST);</span><br><span class="line">            p |= <span class="built_in">GGL_BUILD_NEEDS</span>(c-&gt;state.mask.depth&amp;<span class="number">1</span>, P_MASK_Z);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p |= <span class="built_in">GGL_BUILD_NEEDS</span>(GGL_ALWAYS, P_DEPTH_TEST);</span><br><span class="line">            <span class="comment">// writing to the z-buffer is always disabled if depth-test</span></span><br><span class="line">            <span class="comment">// is disabled.</span></span><br><span class="line">        &#125;</span><br><span class="line">        new_needs.n = n;</span><br><span class="line">        new_needs.p = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 GGL_TMU_STATE</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;dirty &amp; GGL_TMU_STATE) &#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;GGL_TEXTURE_UNIT_COUNT ; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">texture_t</span>&amp; tx = c-&gt;state.texture[i];</span><br><span class="line">            <span class="keyword">if</span> (tx.enable) &#123;</span><br><span class="line">                <span class="type">uint32_t</span> t = <span class="number">0</span>;</span><br><span class="line">                t |= <span class="built_in">GGL_BUILD_NEEDS</span>(tx.surface.format, T_FORMAT);</span><br><span class="line">                t |= <span class="built_in">GGL_BUILD_NEEDS</span>(<span class="built_in">ggl_env_to_needs</span>(tx.env), T_ENV);</span><br><span class="line">                t |= <span class="built_in">GGL_BUILD_NEEDS</span>(<span class="number">0</span>, T_POT);       <span class="comment">// <span class="doctag">XXX:</span> not used yet</span></span><br><span class="line">                <span class="keyword">if</span> (tx.s_coord==GGL_ONE_TO_ONE &amp;&amp; tx.t_coord==GGL_ONE_TO_ONE) &#123;</span><br><span class="line">                    <span class="comment">// we encode 1-to-1 into the wrap mode</span></span><br><span class="line">                    t |= <span class="built_in">GGL_BUILD_NEEDS</span>(GGL_NEEDS_WRAP_11, T_S_WRAP);</span><br><span class="line">                    t |= <span class="built_in">GGL_BUILD_NEEDS</span>(GGL_NEEDS_WRAP_11, T_T_WRAP);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t |= <span class="built_in">GGL_BUILD_NEEDS</span>(<span class="built_in">ggl_wrap_to_needs</span>(tx.s_wrap), T_S_WRAP);</span><br><span class="line">                    t |= <span class="built_in">GGL_BUILD_NEEDS</span>(<span class="built_in">ggl_wrap_to_needs</span>(tx.t_wrap), T_T_WRAP);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tx.mag_filter == GGL_LINEAR) &#123;</span><br><span class="line">                    t |= <span class="built_in">GGL_BUILD_NEEDS</span>(<span class="number">1</span>, T_LINEAR);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tx.min_filter == GGL_LINEAR) &#123;</span><br><span class="line">                    t |= <span class="built_in">GGL_BUILD_NEEDS</span>(<span class="number">1</span>, T_LINEAR);</span><br><span class="line">                &#125;</span><br><span class="line">                new_needs.t[idx++] = t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                new_needs.t[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新计算出来的 needs 和之前上一次保存的 needs 不一样，则表示发生了变化，即需要重新处理</span></span><br><span class="line">    <span class="keyword">if</span> (new_needs != c-&gt;state.needs) &#123;</span><br><span class="line">        <span class="comment">// 保存下来，供下次使用</span></span><br><span class="line">        c-&gt;state.needs = new_needs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 给每个 c-&gt;state.texture[i].surface 中的 read write 函数都赋值</span></span><br><span class="line"><span class="comment">         * c-&gt;state.texture[i].surface 中存储的是像素源数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">ggl_pick_texture</span>(c);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 给 c-&gt;state.buffers.color 中的 read write 函数都赋值</span></span><br><span class="line"><span class="comment">         * c-&gt;state.buffers.color 中存储的是从 EGL 中 makeCurrent 或者 swapBuffers 是传过来的用来存储处理完数据的 GraphicBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">ggl_pick_cb</span>(c);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 给 init_y 、 step_y、scanline 、span 等函数赋值</span></span><br><span class="line">        <span class="built_in">ggl_pick_scanline</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dirty处理完毕，则将其置为 0</span></span><br><span class="line">    c-&gt;dirty = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前面在分析时，多次遇到了 trap.cpp#ggl_state_changed() 方法 ，该方法中会修改 context_t-&gt;dirty 的值，会为其增加不同的位标识，表示不同的刷新原因。而这里呢，就是处理这些位新信息。</p>
<p>将处理完之后的数据会存储在 new_needs 中，使用它和之前的 c-&gt;state.needs 作比较，就能知道是否发生了变化。</p>
<p>如果发生了变化，则会依次执行 ggl_pick_texture()、ggl_pick_cb() 和 ggl_pick_scanline() 方法。下面挨个来分析。</p>
<h5 id="ggl-pick-texture"><a href="#ggl-pick-texture" class="headerlink" title="ggl_pick_texture"></a>ggl_pick_texture</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/buffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_pick_texture</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历 c-&gt;state.texture 数组，将其内部的 surface 中的属性挨个转存给 c-&gt;generated_vars.texture 数组中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;GGL_TEXTURE_UNIT_COUNT ; ++i) &#123;</span><br><span class="line">        <span class="comment">// c-&gt;state.texture[i].surface 中存储着之前 drawTexiOES 时传入进来的像素源数据</span></span><br><span class="line">        <span class="type">surface_t</span>&amp; s = c-&gt;state.texture[i].surface;</span><br><span class="line">        <span class="keyword">if</span> ((!c-&gt;state.texture[i].enable) || (!s.dirty))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        s.dirty = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 给该 surface 中的 write 函数赋值</span></span><br><span class="line">        <span class="built_in">pick_read_write</span>(&amp;s);</span><br><span class="line">        <span class="type">generated_tex_vars_t</span>&amp; gen = c-&gt;generated_vars.texture[i];</span><br><span class="line">        gen.width   = s.width;</span><br><span class="line">        gen.height  = s.height;</span><br><span class="line">        gen.stride  = s.stride;</span><br><span class="line">        gen.data    = <span class="built_in">uintptr_t</span>(s.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pick_read_write</span><span class="params">(<span class="type">surface_t</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分别给 read write 来赋值合适的函数指针</span></span><br><span class="line">    <span class="keyword">switch</span> (s-&gt;format) &#123;</span><br><span class="line">        <span class="keyword">case</span> GGL_PIXEL_FORMAT_RGBA_8888:    s-&gt;read = readABGR8888;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GGL_PIXEL_FORMAT_RGB_565:      s-&gt;read = readRGB565;    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:                            s-&gt;read = read_pixel;    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;write = write_pixel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 c-&gt;state.texture 数组中的数据赋值到 c-&gt;generated_vars.texture 数组中去。而在前面 drawTexiOES() 方法中，会调用 c-&gt;rasterizer.procs.bindTexture() 方法来将 u.texture-&gt;surface 中的数据，也就是通过 glTexImage2D 方法保存进来的图像宽高格式像素信息转存到 c-&gt;activeTMU-&gt;surface 中，也就是会转存到 c-&gt;state.texture 数组中，并且转存完成会将其 dirty 置为 1，所以这里处理的就是它，将它又转存到 c-&gt;generated_vars.texture 中去。</p>
<p>所以说，一开始通过 glTexImage2D 方法保存进来的图像宽高格式像素信息会从 c-&gt;textures.tmu[ ]-&gt;surface 中先转存到 c-&gt;state.texture[ ]-&gt;surface 中，最后转存到 c-&gt;generated_vars.texture[ ] 中。</p>
<p>同时会调用 pick_read_write() 方法来给该 c-&gt;state.texture[ ]-&gt;surface 中的 write() 函数赋值，赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;buffer.cpp文件中的 write_pixel() 方法。这个需要记住，后续会用到的。</p>
<h5 id="ggl-pick-cb"><a href="#ggl-pick-cb" class="headerlink" title="ggl_pick_cb"></a>ggl_pick_cb</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/buffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_pick_cb</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 存储着从 EGL 传过来的用来存储处理完数据的 GraphicBuffer</span></span><br><span class="line">    <span class="type">surface_t</span>&amp; s = c-&gt;state.buffers.color;</span><br><span class="line">    <span class="keyword">if</span> (s.dirty) &#123;</span><br><span class="line">        s.dirty = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 为其 write 方法赋值</span></span><br><span class="line">        <span class="built_in">pick_read_write</span>(&amp;s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先拿到 c-&gt;state.buffers.color 属性，然后给其 write() 函数赋值。同样是赋值为 赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;buffer.cpp文件中的 write_pixel() 方法。</p>
<p>注意这里的 c-&gt;state.buffers.color 就是之前 EGL 中出队，并且设置过来的那个 GraphicBuffer ，这点在本文上面刚讲过了，这里再提一次，后面还会再遇到的。</p>
<h5 id="ggl-pick-scanline"><a href="#ggl-pick-scanline" class="headerlink" title="ggl_pick_scanline"></a>ggl_pick_scanline</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/scanline.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_pick_scanline</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 内部给 c-&gt;scanline 和 c-&gt;init_y 函数指针赋值</span></span><br><span class="line">    <span class="built_in">pick_scanline</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后再检查下，看对其函数赋值是否还要在修改</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;state.enables &amp; GGL_ENABLE_W) &amp;&amp;</span><br><span class="line">        (c-&gt;state.enables &amp; GGL_ENABLE_TMUS))</span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;span = c-&gt;scanline;</span><br><span class="line">        c-&gt;scanline = scanline_perspective;</span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;state.enabled_tmu &amp; (c-&gt;state.enabled_tmu - <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">// only one TMU enabled</span></span><br><span class="line">            c-&gt;scanline = scanline_perspective_single;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">pick_scanline</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (!defined(DEBUG__CODEGEN_ONLY) || (DEBUG__CODEGEN_ONLY == 0))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ANDROID_CODEGEN == ANDROID_CODEGEN_GENERIC</span></span><br><span class="line">    c-&gt;init_y = init_y;</span><br><span class="line">    c-&gt;step_y = step_y__generic;</span><br><span class="line">    c-&gt;scanline = scanline;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;*** needs [%08lx:%08lx:%08lx:%08lx]\n&quot;,</span></span><br><span class="line">    <span class="comment">//    c-&gt;state.needs.n, c-&gt;state.needs.p,</span></span><br><span class="line">    <span class="comment">//    c-&gt;state.needs.t[0], c-&gt;state.needs.t[1]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// first handle the special case that we cannot test with a filter</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> cb_format = <span class="built_in">GGL_READ_NEEDS</span>(CB_FORMAT, c-&gt;state.needs.n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GGL_READ_NEEDS</span>(T_FORMAT, c-&gt;state.needs.t[<span class="number">0</span>]) == cb_format) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;state.needs.<span class="built_in">match</span>(noblend1to1)) &#123;</span><br><span class="line">            <span class="comment">// this will match regardless of dithering state, since both</span></span><br><span class="line">            <span class="comment">// src and dest have the same format anyway, there is no dithering</span></span><br><span class="line">            <span class="comment">// to be done.</span></span><br><span class="line">            <span class="type">const</span> GGLFormat* f =</span><br><span class="line">                &amp;(c-&gt;formats[<span class="built_in">GGL_READ_NEEDS</span>(T_FORMAT, c-&gt;state.needs.t[<span class="number">0</span>])]);</span><br><span class="line">            <span class="keyword">if</span> ((f-&gt;components == GGL_RGB) ||</span><br><span class="line">                (f-&gt;components == GGL_RGBA) ||</span><br><span class="line">                (f-&gt;components == GGL_LUMINANCE) ||</span><br><span class="line">                (f-&gt;components == GGL_LUMINANCE_ALPHA))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// format must have all of RGB components</span></span><br><span class="line">                <span class="comment">// (so the current color doesn&#x27;t show through)</span></span><br><span class="line">                c-&gt;scanline = scanline_memcpy;</span><br><span class="line">                c-&gt;init_y = init_y_noop;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;state.needs.<span class="built_in">match</span>(fill16noblend)) &#123;</span><br><span class="line">        c-&gt;init_y = init_y_packed;</span><br><span class="line">        <span class="keyword">switch</span> (c-&gt;formats[cb_format].size) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: c-&gt;scanline = scanline_memset8;  <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: c-&gt;scanline = scanline_memset16; <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: c-&gt;scanline = scanline_memset32; <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numFilters = <span class="built_in">sizeof</span>(shortcuts)/<span class="built_in">sizeof</span>(<span class="type">shortcut_t</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;numFilters ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;state.needs.<span class="built_in">match</span>(shortcuts[i].filter)) &#123;</span><br><span class="line">            c-&gt;scanline = shortcuts[i].scanline;</span><br><span class="line">            c-&gt;init_y = shortcuts[i].init_y;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_NEEDS</span></span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;Needs: n=0x%08x p=0x%08x t0=0x%08x t1=0x%08x&quot;</span>,</span><br><span class="line">         c-&gt;state.needs.n, c-&gt;state.needs.p,</span><br><span class="line">         c-&gt;state.needs.t[<span class="number">0</span>], c-&gt;state.needs.t[<span class="number">1</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG__CODEGEN_ONLY</span></span></span><br><span class="line"></span><br><span class="line">    c-&gt;init_y = init_y;</span><br><span class="line">    c-&gt;step_y = step_y__generic;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ANDROID_ARM_CODEGEN</span></span><br><span class="line">    <span class="comment">// we&#x27;re going to have to generate some code...</span></span><br><span class="line">    <span class="comment">// here, generate code for our pixel pipeline</span></span><br><span class="line">    <span class="function"><span class="type">const</span> AssemblyKey&lt;<span class="type">needs_t</span>&gt; <span class="title">key</span><span class="params">(c-&gt;state.needs)</span></span>;</span><br><span class="line">    sp&lt;Assembly&gt; assembly = gCodeCache.<span class="built_in">lookup</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (assembly == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// create a new assembly region</span></span><br><span class="line">        sp&lt;ScanlineAssembly&gt; a = <span class="keyword">new</span> <span class="built_in">ScanlineAssembly</span>(c-&gt;state.needs, </span><br><span class="line">                ASSEMBLY_SCRATCH_SIZE);</span><br><span class="line">        <span class="comment">// initialize our assembler</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__arm__)</span></span><br><span class="line">        <span class="function">GGLAssembler <span class="title">assembler</span><span class="params">( <span class="keyword">new</span> ARMAssembler(a) )</span></span>;</span><br><span class="line">        <span class="comment">//GGLAssembler assembler(</span></span><br><span class="line">        <span class="comment">//        new ARMAssemblerOptimizer(new ARMAssembler(a)) );</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__mips__) &amp;&amp; !defined(__LP64__) &amp;&amp; __mips_isa_rev &lt; 6</span></span><br><span class="line">        <span class="function">GGLAssembler <span class="title">assembler</span><span class="params">( <span class="keyword">new</span> ArmToMipsAssembler(a) )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__mips__) &amp;&amp; defined(__LP64__)</span></span><br><span class="line">        <span class="function">GGLAssembler <span class="title">assembler</span><span class="params">( <span class="keyword">new</span> ArmToMips64Assembler(a) )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__aarch64__)</span></span><br><span class="line">        <span class="function">GGLAssembler <span class="title">assembler</span><span class="params">( <span class="keyword">new</span> ArmToArm64Assembler(a) )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// generate the scanline code for the given needs</span></span><br><span class="line">        <span class="type">bool</span> err = assembler.<span class="built_in">scanline</span>(c-&gt;state.needs, c) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ggl_likely</span>(!err)) &#123;</span><br><span class="line">            <span class="comment">// finally, cache this assembly</span></span><br><span class="line">            err = gCodeCache.<span class="built_in">cache</span>(a-&gt;<span class="built_in">key</span>(), a) &lt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ggl_unlikely</span>(err)) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;error generating or caching assembly. Reverting to NOP.&quot;</span>);</span><br><span class="line">            c-&gt;scanline = scanline_noop;</span><br><span class="line">            c-&gt;init_y = init_y_noop;</span><br><span class="line">            c-&gt;step_y = step_y__nop;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assembly = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the previous assembly</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;scanline_as) &#123;</span><br><span class="line">        c-&gt;scanline_as-&gt;<span class="built_in">decStrong</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;scanline_as = assembly.<span class="built_in">get</span>();</span><br><span class="line">    c-&gt;scanline_as-&gt;<span class="built_in">incStrong</span>(c); <span class="comment">//  hold on to assembly</span></span><br><span class="line">    c-&gt;scanline = (<span class="built_in">void</span>(*)(<span class="type">context_t</span>* c))assembly-&gt;<span class="built_in">base</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//    ALOGW(&quot;using generic (slow) pixel-pipeline&quot;);</span></span><br><span class="line">    c-&gt;scanline = scanline;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会先调用 pick_scanline() 方法，这个方法内部逻辑比较复杂，但是完成的任务是固定的，主要是：给 c-&gt;init_y 、c-&gt;step_y 以及 c-&gt;scanline 函数来赋值。内部会判断当前系统，以及内部一些常量等来给他们三个赋不用的函数实现，这里我们只看其中一种情况，所以假设这三个最终被赋值为：</p>
<p>① c-&gt;init_y  被赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的  init_y() 。</p>
<p>② c-&gt;step_y 被赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的  step_y__generic() 。</p>
<p>③ c-&gt;scanline 被赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的 scanline() 。</p>
<p>好了，至此 ggl_pick() 方法执行完毕了，此时内部对应的一些函数定义已经被赋值了。接下来回到 recti_validate() 方法中接着往下执行新的  recti() 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/trap.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recti</span><span class="params">(<span class="type">void</span>* con, GGLint l, GGLint t, GGLint r, GGLint b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数纠正</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; <span class="built_in">GGLint</span>(c-&gt;state.scissor.left))</span><br><span class="line">        l = <span class="built_in">GGLint</span>(c-&gt;state.scissor.left);</span><br><span class="line">    <span class="keyword">if</span> (t &lt; <span class="built_in">GGLint</span>(c-&gt;state.scissor.top))</span><br><span class="line">        t = <span class="built_in">GGLint</span>(c-&gt;state.scissor.top);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="built_in">GGLint</span>(c-&gt;state.scissor.right))</span><br><span class="line">        r = <span class="built_in">GGLint</span>(c-&gt;state.scissor.right);</span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="built_in">GGLint</span>(c-&gt;state.scissor.bottom))</span><br><span class="line">        b = <span class="built_in">GGLint</span>(c-&gt;state.scissor.bottom);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> xc = r - l;</span><br><span class="line">    <span class="type">int</span> yc = b - t;</span><br><span class="line">    <span class="comment">// 宽高都大于0 才接着完成后续操作</span></span><br><span class="line">    <span class="keyword">if</span> (xc&gt;<span class="number">0</span> &amp;&amp; yc&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;iterators.xl = l;</span><br><span class="line">        c-&gt;iterators.xr = r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行之前保存的 init_y 函数，比如 scanline.cpp#init_y 函数</span></span><br><span class="line"><span class="comment">         * 在该函数内部，会给 c-&gt;rect 函数赋值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c-&gt;<span class="built_in">init_y</span>(c, t);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行 c-&gt;rect() 函数的实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c-&gt;<span class="built_in">rect</span>(c, yc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到该方法中，首先会执行 c-&gt;init_y() 方法，而前面已经给它赋值过了，所以这里以当时赋值的其中一种情况来分析，也就是：platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的  init_y() 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/scanline.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_y</span><span class="params">(<span class="type">context_t</span>* c, <span class="type">int32_t</span> ys)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> enables = c-&gt;state.enables;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute iterators...</span></span><br><span class="line">    <span class="type">iterators_t</span>&amp; ci = c-&gt;iterators;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// sample in the center</span></span><br><span class="line">    ci.y = ys;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enables &amp; (GGL_ENABLE_DEPTH_TEST|GGL_ENABLE_W|GGL_ENABLE_FOG)) &#123;</span><br><span class="line">        ci.ydzdy = <span class="built_in">interpolate</span>(ys, c-&gt;shade.z0, c-&gt;shade.dzdx, c-&gt;shade.dzdy);</span><br><span class="line">        ci.ydwdy = <span class="built_in">interpolate</span>(ys, c-&gt;shade.w0, c-&gt;shade.dwdx, c-&gt;shade.dwdy);</span><br><span class="line">        ci.ydfdy = <span class="built_in">interpolate</span>(ys, c-&gt;shade.f0, c-&gt;shade.dfdx, c-&gt;shade.dfdy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ggl_unlikely</span>(enables &amp; GGL_ENABLE_SMOOTH)) &#123;</span><br><span class="line">        ci.ydrdy = <span class="built_in">interpolate</span>(ys, c-&gt;shade.r0, c-&gt;shade.drdx, c-&gt;shade.drdy);</span><br><span class="line">        ci.ydgdy = <span class="built_in">interpolate</span>(ys, c-&gt;shade.g0, c-&gt;shade.dgdx, c-&gt;shade.dgdy);</span><br><span class="line">        ci.ydbdy = <span class="built_in">interpolate</span>(ys, c-&gt;shade.b0, c-&gt;shade.dbdx, c-&gt;shade.dbdy);</span><br><span class="line">        ci.ydady = <span class="built_in">interpolate</span>(ys, c-&gt;shade.a0, c-&gt;shade.dadx, c-&gt;shade.dady);</span><br><span class="line">        c-&gt;step_y = step_y__smooth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ci.ydrdy = c-&gt;shade.r0;</span><br><span class="line">        ci.ydgdy = c-&gt;shade.g0;</span><br><span class="line">        ci.ydbdy = c-&gt;shade.b0;</span><br><span class="line">        ci.ydady = c-&gt;shade.a0;</span><br><span class="line">        <span class="comment">// <span class="doctag">XXX:</span> do only if needed, or make sure this is fast</span></span><br><span class="line">        c-&gt;packed = <span class="built_in">ggl_pack_color</span>(c, c-&gt;state.buffers.color.format,</span><br><span class="line">                ci.ydrdy, ci.ydgdy, ci.ydbdy, ci.ydady);</span><br><span class="line">        c-&gt;packed8888 = <span class="built_in">ggl_pack_color</span>(c, GGL_PIXEL_FORMAT_RGBA_8888, </span><br><span class="line">                ci.ydrdy, ci.ydgdy, ci.ydbdy, ci.ydady);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">generated_vars_t</span>&amp; gen = c-&gt;generated_vars;</span><br><span class="line">    gen.argb[GGLFormat::ALPHA].c  = ci.ydady;</span><br><span class="line">    gen.argb[GGLFormat::ALPHA].dx = c-&gt;shade.dadx;</span><br><span class="line">    gen.argb[GGLFormat::RED  ].c  = ci.ydrdy;</span><br><span class="line">    gen.argb[GGLFormat::RED  ].dx = c-&gt;shade.drdx;</span><br><span class="line">    gen.argb[GGLFormat::GREEN].c  = ci.ydgdy;</span><br><span class="line">    gen.argb[GGLFormat::GREEN].dx = c-&gt;shade.dgdx;</span><br><span class="line">    gen.argb[GGLFormat::BLUE ].c  = ci.ydbdy;</span><br><span class="line">    gen.argb[GGLFormat::BLUE ].dx = c-&gt;shade.dbdx;</span><br><span class="line">    gen.dzdx = c-&gt;shade.dzdx;</span><br><span class="line">    gen.f    = ci.ydfdy;</span><br><span class="line">    gen.dfdx = c-&gt;shade.dfdx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enables &amp; GGL_ENABLE_TMUS) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;GGL_TEXTURE_UNIT_COUNT ; ++i) &#123;</span><br><span class="line">            <span class="type">texture_t</span>&amp; t = c-&gt;state.texture[i];</span><br><span class="line">            <span class="keyword">if</span> (!t.enable) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">texture_iterators_t</span>&amp; ti = t.iterators;</span><br><span class="line">            <span class="comment">// texture.cpp#glDrawTexivOES -&gt; pixelflinger.cpp#ggl_texGeni 会设置进来为 GGL_ONE_TO_ONE</span></span><br><span class="line">            <span class="comment">// 所以 暂时只考虑 if</span></span><br><span class="line">            <span class="keyword">if</span> (t.s_coord == GGL_ONE_TO_ONE &amp;&amp; t.t_coord == GGL_ONE_TO_ONE) &#123;</span><br><span class="line">                ti.dsdx = ti.dsdy = ti.dtdx = ti.dtdy = <span class="number">0</span>;</span><br><span class="line">                ti.ydsdy = t.shade.is0;</span><br><span class="line">                ti.ydtdy = t.shade.it0;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> adjustSWrap = ((t.s_wrap==GGL_CLAMP)?<span class="number">0</span>:<span class="number">16</span>);</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> adjustTWrap = ((t.t_wrap==GGL_CLAMP)?<span class="number">0</span>:<span class="number">16</span>);</span><br><span class="line">                ti.sscale = t.shade.sscale + adjustSWrap;</span><br><span class="line">                ti.tscale = t.shade.tscale + adjustTWrap;</span><br><span class="line">                <span class="keyword">if</span> (!(enables &amp; GGL_ENABLE_W)) &#123;</span><br><span class="line">                    <span class="comment">// S coordinate</span></span><br><span class="line">                    <span class="type">const</span> <span class="type">int32_t</span> sscale = ti.sscale;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int32_t</span> sy = <span class="built_in">interpolate</span>(ys,</span><br><span class="line">                            t.shade.is0, t.shade.idsdx, t.shade.idsdy);</span><br><span class="line">                    <span class="keyword">if</span> (sscale&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                        ti.ydsdy= sy            &lt;&lt; sscale;</span><br><span class="line">                        ti.dsdx = t.shade.idsdx &lt;&lt; sscale; </span><br><span class="line">                        ti.dsdy = t.shade.idsdy &lt;&lt; sscale;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ti.ydsdy= sy            &gt;&gt; -sscale;</span><br><span class="line">                        ti.dsdx = t.shade.idsdx &gt;&gt; -sscale; </span><br><span class="line">                        ti.dsdy = t.shade.idsdy &gt;&gt; -sscale;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// T coordinate</span></span><br><span class="line">                    <span class="type">const</span> <span class="type">int32_t</span> tscale = ti.tscale;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int32_t</span> ty = <span class="built_in">interpolate</span>(ys,</span><br><span class="line">                            t.shade.it0, t.shade.idtdx, t.shade.idtdy);</span><br><span class="line">                    <span class="keyword">if</span> (tscale&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                        ti.ydtdy= ty            &lt;&lt; tscale;</span><br><span class="line">                        ti.dtdx = t.shade.idtdx &lt;&lt; tscale; </span><br><span class="line">                        ti.dtdy = t.shade.idtdy &lt;&lt; tscale;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ti.ydtdy= ty            &gt;&gt; -tscale;</span><br><span class="line">                        ti.dtdx = t.shade.idtdx &gt;&gt; -tscale; </span><br><span class="line">                        ti.dtdy = t.shade.idtdy &gt;&gt; -tscale;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mirror for generated code...</span></span><br><span class="line">            <span class="type">generated_tex_vars_t</span>&amp; gen = c-&gt;generated_vars.texture[i];</span><br><span class="line">            gen.width   = t.surface.width;</span><br><span class="line">            gen.height  = t.surface.height;</span><br><span class="line">            gen.stride  = t.surface.stride;</span><br><span class="line">            gen.data    = <span class="built_in">uintptr_t</span>(t.surface.data);</span><br><span class="line">            gen.dsdx = ti.dsdx;</span><br><span class="line">            gen.dtdx = ti.dtdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 c-&gt;step_y 赋值对应的函数实现</span></span><br><span class="line">    c-&gt;step_y = step_y__nop;</span><br><span class="line">    <span class="keyword">if</span> (enables &amp; GGL_ENABLE_FOG) &#123;</span><br><span class="line">        c-&gt;step_y = step_y__generic;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enables &amp; GGL_ENABLE_TMUS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_SMOOTH) &#123;</span><br><span class="line">            c-&gt;step_y = step_y__generic;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enables &amp; GGL_ENABLE_W) &#123;</span><br><span class="line">            c-&gt;step_y = step_y__w;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c-&gt;step_y = step_y__tmu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_SMOOTH) &#123;</span><br><span class="line">            c-&gt;step_y = step_y__smooth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 给 c-&gt;rect 赋值对应的函数实现</span></span><br><span class="line">    c-&gt;rect = rect_generic;</span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;step_y == step_y__nop) &amp;&amp;</span><br><span class="line">        (c-&gt;scanline == scanline_memcpy))</span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;rect = rect_memcpy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，会完成对 c-&gt;step_y 和 c-&gt;rect 函数的赋值，其中有好几种实现，这里我们只看其中一种，所以假设这两个最终被赋值为：</p>
<p>① c-&gt;step_y  被赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的  step_y__generic() 。</p>
<p>② c-&gt;rect 被赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的  rect_generic() 。</p>
<p>好了接着回到 recti() 方法中接着往下去执行 c-&gt;rect() 方法，正如我们在上面 init_y() 方法中讲到的：c-&gt;rect 会被赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的  rect_generic() ，所以我们接着看这个方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/scanline.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rect_generic</span><span class="params">(<span class="type">context_t</span>* c, <span class="type">size_t</span> yc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到 c-&gt;scanline() 方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c-&gt;<span class="built_in">scanline</span>(c);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到 c-&gt;step_y() 方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c-&gt;<span class="built_in">step_y</span>(c);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--yc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，会循环执行 c-&gt;scanline() 和 c-&gt;step_y() 方法，而通过前面的分析可知，这俩函数的实现分别是：</p>
<p>① c-&gt;scanline 被赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的 scanline() 。</p>
<p>② c-&gt;step_y  被赋值为 platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的  step_y__generic() 。</p>
<p>所以接下来先看platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;scanline.cpp 文件中的 scanline() ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/scanline.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scanline</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> enables = c-&gt;state.enables;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> xs = c-&gt;iterators.xl;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x1 = c-&gt;iterators.xr;</span><br><span class="line">	<span class="type">int</span> xc = x1 - xs;</span><br><span class="line">    <span class="type">const</span> <span class="type">int16_t</span>* covPtr = c-&gt;state.buffers.coverage + xs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际操作之前先重置之前的</span></span><br><span class="line">    GGLcolor r, g, b, a;</span><br><span class="line">    <span class="type">iterators_t</span>&amp; ci = c-&gt;iterators;</span><br><span class="line">    <span class="keyword">if</span> (enables &amp; GGL_ENABLE_SMOOTH) &#123;</span><br><span class="line">        r = (xs * c-&gt;shade.drdx) + ci.ydrdy;</span><br><span class="line">        g = (xs * c-&gt;shade.dgdx) + ci.ydgdy;</span><br><span class="line">        b = (xs * c-&gt;shade.dbdx) + ci.ydbdy;</span><br><span class="line">        a = (xs * c-&gt;shade.dadx) + ci.ydady;</span><br><span class="line">        r = <span class="built_in">ADJUST_COLOR_ITERATOR</span>(r, c-&gt;shade.drdx, xc);</span><br><span class="line">        g = <span class="built_in">ADJUST_COLOR_ITERATOR</span>(g, c-&gt;shade.dgdx, xc);</span><br><span class="line">        b = <span class="built_in">ADJUST_COLOR_ITERATOR</span>(b, c-&gt;shade.dbdx, xc);</span><br><span class="line">        a = <span class="built_in">ADJUST_COLOR_ITERATOR</span>(a, c-&gt;shade.dadx, xc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = ci.ydrdy;</span><br><span class="line">        g = ci.ydgdy;</span><br><span class="line">        b = ci.ydbdy;</span><br><span class="line">        a = ci.ydady;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// z iterators are 1.31</span></span><br><span class="line">    GGLfixed z = (xs * c-&gt;shade.dzdx) + ci.ydzdy;</span><br><span class="line">    GGLfixed f = (xs * c-&gt;shade.dfdx) + ci.ydfdy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        GGLfixed s, t;</span><br><span class="line">    &#125; tc[GGL_TEXTURE_UNIT_COUNT];</span><br><span class="line">    <span class="keyword">if</span> (enables &amp; GGL_ENABLE_TMUS) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;GGL_TEXTURE_UNIT_COUNT ; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;state.texture[i].enable) &#123;</span><br><span class="line">                <span class="type">texture_iterators_t</span>&amp; ti = c-&gt;state.texture[i].iterators;</span><br><span class="line">                <span class="keyword">if</span> (enables &amp; GGL_ENABLE_W) &#123;</span><br><span class="line">                    tc[i].s = ti.ydsdy;</span><br><span class="line">                    tc[i].t = ti.ydtdy;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tc[i].s = (xs * ti.dsdx) + ti.ydsdy;</span><br><span class="line">                    tc[i].t = (xs * ti.dtdx) + ti.ydtdy;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pixel_t</span> fragment;</span><br><span class="line">    <span class="type">pixel_t</span> texel;</span><br><span class="line">    <span class="type">pixel_t</span> fb;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> x = xs;</span><br><span class="line">	<span class="type">uint32_t</span> y = c-&gt;iterators.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环处理图像中的像素</span></span><br><span class="line">	<span class="keyword">while</span> (xc--) &#123;</span><br><span class="line">  </span><br><span class="line">        &#123; <span class="comment">// just a scope</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// read color (convert to 8 bits by keeping only the integer part)</span></span><br><span class="line">        fragment.s[<span class="number">1</span>] = fragment.s[<span class="number">2</span>] =</span><br><span class="line">        fragment.s[<span class="number">3</span>] = fragment.s[<span class="number">0</span>] = <span class="number">8</span>;</span><br><span class="line">        fragment.c[<span class="number">1</span>] = r &gt;&gt; (GGL_COLOR_BITS<span class="number">-8</span>);</span><br><span class="line">        fragment.c[<span class="number">2</span>] = g &gt;&gt; (GGL_COLOR_BITS<span class="number">-8</span>);</span><br><span class="line">        fragment.c[<span class="number">3</span>] = b &gt;&gt; (GGL_COLOR_BITS<span class="number">-8</span>);</span><br><span class="line">        fragment.c[<span class="number">0</span>] = a &gt;&gt; (GGL_COLOR_BITS<span class="number">-8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开始纹理渲染，处理之前设置的 属性</span></span><br><span class="line"><span class="comment">         * 第一步：处理纹理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_TMUS) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;GGL_TEXTURE_UNIT_COUNT ; ++i) &#123;</span><br><span class="line">                <span class="type">texture_t</span>&amp; tx = c-&gt;state.texture[i];</span><br><span class="line">                <span class="keyword">if</span> (!tx.enable)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">texture_iterators_t</span>&amp; ti = tx.iterators;</span><br><span class="line">                <span class="type">int32_t</span> u, v;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// s-coordinate</span></span><br><span class="line">                <span class="keyword">if</span> (tx.s_coord != GGL_ONE_TO_ONE) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> w = tx.surface.width;</span><br><span class="line">                    u = <span class="built_in">wrapping</span>(tc[i].s, w, tx.s_wrap);</span><br><span class="line">                    tc[i].s += ti.dsdx;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    u = (((tx.shade.is0&gt;&gt;<span class="number">16</span>) + x)&lt;&lt;<span class="number">16</span>) + FIXED_HALF;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// t-coordinate</span></span><br><span class="line">                <span class="keyword">if</span> (tx.t_coord != GGL_ONE_TO_ONE) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> h = tx.surface.height;</span><br><span class="line">                    v = <span class="built_in">wrapping</span>(tc[i].t, h, tx.t_wrap);</span><br><span class="line">                    tc[i].t += ti.dtdx;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v = (((tx.shade.it0&gt;&gt;<span class="number">16</span>) + y)&lt;&lt;<span class="number">16</span>) + FIXED_HALF;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// read texture</span></span><br><span class="line">                <span class="keyword">if</span> (tx.mag_filter == GGL_NEAREST &amp;&amp;</span><br><span class="line">                    tx.min_filter == GGL_NEAREST)</span><br><span class="line">                &#123;</span><br><span class="line">                    u &gt;&gt;= <span class="number">16</span>;</span><br><span class="line">                    v &gt;&gt;= <span class="number">16</span>;</span><br><span class="line">                    tx.surface.<span class="built_in">read</span>(&amp;tx.surface, c, u, v, &amp;texel);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> w = tx.surface.width;</span><br><span class="line">                    <span class="type">const</span> <span class="type">int</span> h = tx.surface.height;</span><br><span class="line">                    u -= FIXED_HALF;</span><br><span class="line">                    v -= FIXED_HALF;</span><br><span class="line">                    <span class="type">int</span> u0 = u &gt;&gt; <span class="number">16</span>;</span><br><span class="line">                    <span class="type">int</span> v0 = v &gt;&gt; <span class="number">16</span>;</span><br><span class="line">                    <span class="type">int</span> u1 = u0 + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> v1 = v0 + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (tx.s_wrap == GGL_REPEAT) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (u0&lt;<span class="number">0</span>)  u0 += w;</span><br><span class="line">                        <span class="keyword">if</span> (u1&lt;<span class="number">0</span>)  u1 += w;</span><br><span class="line">                        <span class="keyword">if</span> (u0&gt;=w) u0 -= w;</span><br><span class="line">                        <span class="keyword">if</span> (u1&gt;=w) u1 -= w;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (u0&lt;<span class="number">0</span>)  u0 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (u1&lt;<span class="number">0</span>)  u1 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (u0&gt;=w) u0 = w<span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (u1&gt;=w) u1 = w<span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (tx.t_wrap == GGL_REPEAT) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v0&lt;<span class="number">0</span>)  v0 += h;</span><br><span class="line">                        <span class="keyword">if</span> (v1&lt;<span class="number">0</span>)  v1 += h;</span><br><span class="line">                        <span class="keyword">if</span> (v0&gt;=h) v0 -= h;</span><br><span class="line">                        <span class="keyword">if</span> (v1&gt;=h) v1 -= h;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v0&lt;<span class="number">0</span>)  v0 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (v1&lt;<span class="number">0</span>)  v1 = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (v0&gt;=h) v0 = h<span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (v1&gt;=h) v1 = h<span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">pixel_t</span> texels[<span class="number">4</span>];</span><br><span class="line">                    <span class="type">uint32_t</span> mm[<span class="number">4</span>];</span><br><span class="line">                    tx.surface.<span class="built_in">read</span>(&amp;tx.surface, c, u0, v0, &amp;texels[<span class="number">0</span>]);</span><br><span class="line">                    tx.surface.<span class="built_in">read</span>(&amp;tx.surface, c, u0, v1, &amp;texels[<span class="number">1</span>]);</span><br><span class="line">                    tx.surface.<span class="built_in">read</span>(&amp;tx.surface, c, u1, v0, &amp;texels[<span class="number">2</span>]);</span><br><span class="line">                    tx.surface.<span class="built_in">read</span>(&amp;tx.surface, c, u1, v1, &amp;texels[<span class="number">3</span>]);</span><br><span class="line">                    u = (u &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xF</span>; </span><br><span class="line">                    v = (v &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">                    u += u&gt;&gt;<span class="number">3</span>;</span><br><span class="line">                    v += v&gt;&gt;<span class="number">3</span>;</span><br><span class="line">                    mm[<span class="number">0</span>] = (<span class="number">0x10</span> - u) * (<span class="number">0x10</span> - v);</span><br><span class="line">                    mm[<span class="number">1</span>] = (<span class="number">0x10</span> - u) * v;</span><br><span class="line">                    mm[<span class="number">2</span>] = u * (<span class="number">0x10</span> - v);</span><br><span class="line">                    mm[<span class="number">3</span>] = <span class="number">0x100</span> - (mm[<span class="number">0</span>] + mm[<span class="number">1</span>] + mm[<span class="number">2</span>]);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span> ; j&lt;<span class="number">4</span> ; j++) &#123;</span><br><span class="line">                        texel.s[j] = texels[<span class="number">0</span>].s[j];</span><br><span class="line">                        <span class="keyword">if</span> (!texel.s[j]) <span class="keyword">continue</span>;</span><br><span class="line">                        texel.s[j] += <span class="number">8</span>;</span><br><span class="line">                        texel.c[j] =    texels[<span class="number">0</span>].c[j]*mm[<span class="number">0</span>] +</span><br><span class="line">                                        texels[<span class="number">1</span>].c[j]*mm[<span class="number">1</span>] +</span><br><span class="line">                                        texels[<span class="number">2</span>].c[j]*mm[<span class="number">2</span>] +</span><br><span class="line">                                        texels[<span class="number">3</span>].c[j]*mm[<span class="number">3</span>] ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Texture environnement...</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span> ; j&lt;<span class="number">4</span> ; j++) &#123;</span><br><span class="line">                    <span class="type">uint32_t</span>&amp; Cf = fragment.c[j];</span><br><span class="line">                    <span class="type">uint32_t</span>&amp; Ct = texel.c[j];</span><br><span class="line">                    <span class="type">uint8_t</span>&amp; sf  = fragment.s[j];</span><br><span class="line">                    <span class="type">uint8_t</span>&amp; st  = texel.s[j];</span><br><span class="line">                    <span class="type">uint32_t</span> At = texel.c[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">uint8_t</span> sat = texel.s[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">switch</span> (tx.env) &#123;</span><br><span class="line">                    <span class="keyword">case</span> GGL_REPLACE:</span><br><span class="line">                        <span class="keyword">if</span> (st) &#123;</span><br><span class="line">                            Cf = Ct;</span><br><span class="line">                            sf = st;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> GGL_MODULATE:</span><br><span class="line">                        <span class="keyword">if</span> (st) &#123;</span><br><span class="line">                            <span class="type">uint32_t</span> factor = Ct + (Ct&gt;&gt;(st<span class="number">-1</span>));</span><br><span class="line">                            Cf = (Cf * factor) &gt;&gt; st;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> GGL_DECAL:</span><br><span class="line">                        <span class="keyword">if</span> (sat) &#123;</span><br><span class="line">                            <span class="built_in">rescale</span>(Cf, sf, Ct, st);</span><br><span class="line">                            Cf += ((Ct - Cf) * (At + (At&gt;&gt;(sat<span class="number">-1</span>)))) &gt;&gt; sat;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> GGL_BLEND:</span><br><span class="line">                        <span class="keyword">if</span> (st) &#123;</span><br><span class="line">                            <span class="type">uint32_t</span> Cc = tx.env_color[i];</span><br><span class="line">                            <span class="keyword">if</span> (sf&gt;<span class="number">8</span>)       Cc = (Cc * ((<span class="number">1</span>&lt;&lt;sf)<span class="number">-1</span>))&gt;&gt;<span class="number">8</span>;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (sf&lt;<span class="number">8</span>)  Cc = (Cc - (Cc&gt;&gt;(<span class="number">8</span>-sf)))&gt;&gt;(<span class="number">8</span>-sf);</span><br><span class="line">                            <span class="type">uint32_t</span> factor = Ct + (Ct&gt;&gt;(st<span class="number">-1</span>));</span><br><span class="line">                            Cf = ((((<span class="number">1</span>&lt;&lt;st) - factor) * Cf) + Ct*Cc)&gt;&gt;st;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> GGL_ADD:</span><br><span class="line">                        <span class="keyword">if</span> (st) &#123;</span><br><span class="line">                            <span class="built_in">rescale</span>(Cf, sf, Ct, st);</span><br><span class="line">                            Cf += Ct;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二步：处理片元覆盖</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_AA) &#123;</span><br><span class="line">            <span class="type">int16_t</span> cf = *covPtr++;</span><br><span class="line">            fragment.c[<span class="number">0</span>] = (<span class="built_in">int64_t</span>(fragment.c[<span class="number">0</span>]) * cf) &gt;&gt; <span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第三步：透明测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_ALPHA_TEST) &#123;</span><br><span class="line">            GGLcolor ref = c-&gt;state.alpha_test.ref;</span><br><span class="line">            GGLcolor alpha = (<span class="built_in">uint64_t</span>(fragment.c[<span class="number">0</span>]) *</span><br><span class="line">                    ((<span class="number">1</span>&lt;&lt;GGL_COLOR_BITS)<span class="number">-1</span>)) / ((<span class="number">1</span>&lt;&lt;fragment.s[<span class="number">0</span>])<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">switch</span> (c-&gt;state.alpha_test.func) &#123;</span><br><span class="line">            <span class="keyword">case</span> GGL_NEVER:     <span class="keyword">goto</span> discard;</span><br><span class="line">            <span class="keyword">case</span> GGL_LESS:      <span class="keyword">if</span> (alpha&lt;ref)  <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">            <span class="keyword">case</span> GGL_EQUAL:     <span class="keyword">if</span> (alpha==ref) <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">            <span class="keyword">case</span> GGL_LEQUAL:    <span class="keyword">if</span> (alpha&lt;=ref) <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">            <span class="keyword">case</span> GGL_GREATER:   <span class="keyword">if</span> (alpha&gt;ref)  <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">            <span class="keyword">case</span> GGL_NOTEQUAL:  <span class="keyword">if</span> (alpha!=ref) <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">            <span class="keyword">case</span> GGL_GEQUAL:    <span class="keyword">if</span> (alpha&gt;=ref) <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第四步：深度测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;state.buffers.depth.format) &#123;</span><br><span class="line">            <span class="keyword">if</span> (enables &amp; GGL_ENABLE_DEPTH_TEST) &#123;</span><br><span class="line">                <span class="type">surface_t</span>* cb = &amp;(c-&gt;state.buffers.depth);</span><br><span class="line">                <span class="type">uint16_t</span>* p = (<span class="type">uint16_t</span>*)(cb-&gt;data)+(x+(cb-&gt;stride*y));</span><br><span class="line">                <span class="type">uint16_t</span> zz = <span class="built_in">uint32_t</span>(z)&gt;&gt;(<span class="number">16</span>);</span><br><span class="line">                <span class="type">uint16_t</span> depth = *p;</span><br><span class="line">                <span class="keyword">switch</span> (c-&gt;state.depth_test.func) &#123;</span><br><span class="line">                <span class="keyword">case</span> GGL_NEVER:     <span class="keyword">goto</span> discard;</span><br><span class="line">                <span class="keyword">case</span> GGL_LESS:      <span class="keyword">if</span> (zz&lt;depth)    <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">                <span class="keyword">case</span> GGL_EQUAL:     <span class="keyword">if</span> (zz==depth)   <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">                <span class="keyword">case</span> GGL_LEQUAL:    <span class="keyword">if</span> (zz&lt;=depth)   <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">                <span class="keyword">case</span> GGL_GREATER:   <span class="keyword">if</span> (zz&gt;depth)    <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">                <span class="keyword">case</span> GGL_NOTEQUAL:  <span class="keyword">if</span> (zz!=depth)   <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">                <span class="keyword">case</span> GGL_GEQUAL:    <span class="keyword">if</span> (zz&gt;=depth)   <span class="keyword">break</span>; <span class="keyword">goto</span> discard;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// depth buffer is not enabled, if depth-test is not enabled</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        fragment.s[1] = fragment.s[2] =</span></span><br><span class="line"><span class="comment">        fragment.s[3] = fragment.s[0] = 8;</span></span><br><span class="line"><span class="comment">        fragment.c[1] = </span></span><br><span class="line"><span class="comment">        fragment.c[2] = </span></span><br><span class="line"><span class="comment">        fragment.c[3] = </span></span><br><span class="line"><span class="comment">        fragment.c[0] = 255 - (zz&gt;&gt;8);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                <span class="keyword">if</span> (c-&gt;state.mask.depth) &#123;</span><br><span class="line">                    *p = zz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第五步：雾化效果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_FOG) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=<span class="number">3</span> ; i++) &#123;</span><br><span class="line">                GGLfixed fc = (c-&gt;state.fog.color[i] * <span class="number">0x10000</span>) / <span class="number">0xFF</span>;</span><br><span class="line">                <span class="type">uint32_t</span>&amp; c = fragment.c[i];</span><br><span class="line">                <span class="type">uint8_t</span>&amp; s  = fragment.s[i];</span><br><span class="line">                c = (c * <span class="number">0x10000</span>) / ((<span class="number">1</span>&lt;&lt;s)<span class="number">-1</span>);</span><br><span class="line">                c = <span class="built_in">gglMulAddx</span>(c, f, <span class="built_in">gglMulx</span>(fc, <span class="number">0x10000</span> - f));</span><br><span class="line">                s = <span class="number">16</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第六步：混合纹理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_BLENDING) &#123;</span><br><span class="line">            fb.c[<span class="number">1</span>] = fb.c[<span class="number">2</span>] = fb.c[<span class="number">3</span>] = fb.c[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// placate valgrind</span></span><br><span class="line">            fb.s[<span class="number">1</span>] = fb.s[<span class="number">2</span>] = fb.s[<span class="number">3</span>] = fb.s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            c-&gt;state.buffers.color.<span class="built_in">read</span>(</span><br><span class="line">                    &amp;(c-&gt;state.buffers.color), c, x, y, &amp;fb);</span><br><span class="line">            <span class="built_in">blending</span>( c, &amp;fragment, &amp;fb );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最后一步：将本次处理好的片段写入到 c-&gt;state.buffers.color 中</span></span><br><span class="line"><span class="comment">         * 而这个 c-&gt;state.buffers.color 对应的就是之前 EGL 那边设置的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c-&gt;state.buffers.color.<span class="built_in">write</span>(</span><br><span class="line">                &amp;(c-&gt;state.buffers.color), c, x, y, &amp;fragment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">discard:</span><br><span class="line">		<span class="comment">// iterate...</span></span><br><span class="line">        x += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (enables &amp; GGL_ENABLE_SMOOTH) &#123;</span><br><span class="line">            r += c-&gt;shade.drdx;</span><br><span class="line">            g += c-&gt;shade.dgdx;</span><br><span class="line">            b += c-&gt;shade.dbdx;</span><br><span class="line">            a += c-&gt;shade.dadx;</span><br><span class="line">        &#125;</span><br><span class="line">        z += c-&gt;shade.dzdx;</span><br><span class="line">        f += c-&gt;shade.dfdx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 scanline() 方法中完成了真正的图像处理操作，实际操作过程分为如下六步：</p>
<p>① 处理纹理</p>
<p>② 处理片元覆盖</p>
<p>③ 透明测试</p>
<p>④ 深度测试</p>
<p>⑤ 雾化效果</p>
<p>⑥ 混合纹理</p>
<p>执行完这六步之后就拿到了处理之后的数据了，此时会调用  c-&gt;state.buffers.color.write() 方法来将处理好的数据保存起来。我们先看看这个 write() 方法对应的实现，而它正好在前面的 pick_read_write() 方法中赋值过，实际赋值的是：platform&#x2F;system&#x2F;core&#x2F;libpixelflinger&#x2F;buffer.cpp 文件中的 write_pixel() 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/buffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_pixel</span><span class="params">(<span class="type">const</span> <span class="type">surface_t</span>* s, <span class="type">context_t</span>* c,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y, <span class="type">const</span> <span class="type">pixel_t</span>* pixel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>((x &lt; s-&gt;width) &amp;&amp; (y &lt; s-&gt;height));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dither = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;state.enables &amp; GGL_ENABLE_DITHER) &#123;</span><br><span class="line">        dither = c-&gt;ditherMatrix[ (x &amp; GGL_DITHER_MASK) +</span><br><span class="line">                ((y &amp; GGL_DITHER_MASK)&lt;&lt;GGL_DITHER_ORDER_SHIFT) ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> GGLFormat* f = &amp;(c-&gt;formats[s-&gt;format]);</span><br><span class="line">    <span class="type">int32_t</span> index = x + (s-&gt;stride * y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里获取了入参 surface_t 中的  data 属性，后续往 data 对应的地址 中写入数据就行了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint8_t</span>* <span class="type">const</span> data = s-&gt;data + index * f-&gt;size;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">4</span> ; i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> component_mask = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;components&gt;=GGL_LUMINANCE &amp;&amp;</span><br><span class="line">                (i==GGLFormat::GREEN || i==GGLFormat::BLUE)) &#123;</span><br><span class="line">            <span class="comment">// destinations L formats don&#x27;t have G or B</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> l = f-&gt;c[i].l;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> h = f-&gt;c[i].h;</span><br><span class="line">        <span class="keyword">if</span> (h &amp;&amp; (c-&gt;state.mask.color &amp; component_mask)) &#123;</span><br><span class="line">            mask |= (((<span class="number">1</span>&lt;&lt;(h-l))<span class="number">-1</span>)&lt;&lt;l);</span><br><span class="line">            <span class="type">uint32_t</span> u = pixel-&gt;c[i];</span><br><span class="line">            <span class="type">int32_t</span> pixelSize = pixel-&gt;s[i];</span><br><span class="line">            <span class="keyword">if</span> (pixelSize &lt; (h-l)) &#123;</span><br><span class="line">                u = <span class="built_in">expand</span>(u, pixelSize, h-l);</span><br><span class="line">                pixelSize = h-l;</span><br><span class="line">            &#125;</span><br><span class="line">            v = <span class="built_in">downshift_component</span>(v, u, pixelSize, <span class="number">0</span>, h, l, <span class="number">0</span>, <span class="number">0</span>, dither);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;state.mask.color != <span class="number">0xF</span>) || </span><br><span class="line">        (c-&gt;state.enables &amp; GGL_ENABLE_LOGIC_OP)) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (f-&gt;size) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:	d = *data;									<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:	d = *(<span class="type">uint16_t</span>*)data;						<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:	d = (data[<span class="number">2</span>]&lt;&lt;<span class="number">16</span>)|(data[<span class="number">1</span>]&lt;&lt;<span class="number">8</span>)|data[<span class="number">0</span>];     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:	d = <span class="built_in">GGL_RGBA_TO_HOST</span>(*(<span class="type">uint32_t</span>*)data);		<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;state.enables &amp; GGL_ENABLE_LOGIC_OP) &#123;</span><br><span class="line">            v = <span class="built_in">logic_op</span>(c-&gt;state.logic_op.opcode, v, d);        </span><br><span class="line">            v &amp;= mask;</span><br><span class="line">        &#125;</span><br><span class="line">        v |= (d &amp; ~mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (f-&gt;size) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:		*data = v;									<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:		*(<span class="type">uint16_t</span>*)data = v;						<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            data[<span class="number">0</span>] = v;</span><br><span class="line">            data[<span class="number">1</span>] = v&gt;&gt;<span class="number">8</span>;</span><br><span class="line">            data[<span class="number">2</span>] = v&gt;&gt;<span class="number">16</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:		*(<span class="type">uint32_t</span>*)data = <span class="built_in">GGL_HOST_TO_RGBA</span>(v);     <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中逻辑比较复杂，我没看懂，但是里面有对第一个入参 surface_t 中 data 属性的保存和访问，而第一个参数是 c-&gt;state.buffers.color , 而它正好就是之前在 EGL 那边通过 egl_window_surface_v2_t::bindDrawSurface() 方法保存过来的，它内部的 data 属性实际对应的是 egl_window_surface_v2_t 中的 bits ，它是和该 egl_window_surface_v2_t 实例中 buffer 一起 lock() 的，和 buffer 同时指向同一块儿已锁定的内存地址。所以这里将处理之后的图形数据保存到该 egl_window_surface_v2_t 实例中 buffer 对应的那块儿内存中。至此，就完成了 EGL 和 OpenGL ES的打通。</p>
<p>接着来看 step_y__generic() 方法中的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/scanline.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">step_y__generic</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> enables = c-&gt;state.enables;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate...</span></span><br><span class="line">    <span class="type">iterators_t</span>&amp; ci = c-&gt;iterators;</span><br><span class="line">    ci.y += <span class="number">1</span>;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">if</span> (enables &amp; GGL_ENABLE_SMOOTH) &#123;</span><br><span class="line">        ci.ydrdy += c-&gt;shade.drdy;</span><br><span class="line">        ci.ydgdy += c-&gt;shade.dgdy;</span><br><span class="line">        ci.ydbdy += c-&gt;shade.dbdy;</span><br><span class="line">        ci.ydady += c-&gt;shade.dady;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> mask =</span><br><span class="line">            GGL_ENABLE_DEPTH_TEST |</span><br><span class="line">            GGL_ENABLE_W |</span><br><span class="line">            GGL_ENABLE_FOG;</span><br><span class="line">    <span class="keyword">if</span> (enables &amp; mask) &#123;</span><br><span class="line">        ci.ydzdy += c-&gt;shade.dzdy;</span><br><span class="line">        ci.ydwdy += c-&gt;shade.dwdy;</span><br><span class="line">        ci.ydfdy += c-&gt;shade.dfdy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((enables &amp; GGL_ENABLE_TMUS) &amp;&amp; (!(enables &amp; GGL_ENABLE_W))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;GGL_TEXTURE_UNIT_COUNT ; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;state.texture[i].enable) &#123;</span><br><span class="line">                <span class="type">texture_iterators_t</span>&amp; ti = c-&gt;state.texture[i].iterators;</span><br><span class="line">                ti.ydsdy += ti.dsdy;</span><br><span class="line">                ti.ydtdy += ti.dtdy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是将 c-&gt;iterators 中的 y 值自增1，这样的话，等到下次循环时就可以在 scanline() 中处理下一批数据了。</p>
<p>⑥ 最后回到 drawTexiOES() 方法中接着执行 ogles_unlock_textures() 方法，该方法中没啥要讲的，和前面 ③ 中 ogles_lock_textures(c) 方法类似。</p>
<p>至此完成了 glDrawTexiOES() 方法的分析，也就完成了 gl 绘制操作，绘制之后的结果就会存储在 EGL 之前准备的 GraphicBuffer 中，接下来就可以调用 EGL 中的 eglSwapBuffers() 方法来提交这次绘制的内容到生产消费队列中去，等待消费者侧去消费使用，比如显示器那边拿到内容去显示出来，然后同时 eglSwapBuffers() 方还会再出队一个 GraphicBuffer 给OpenGL ES 来用，它再用 gl 操作去绘制下一帧内容，显示器中的图像内容就“活了”起来。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/OpenGLES/">OpenGLES</a>
		  
			<a href="/tags/EGL/">EGL</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/3c88db7.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">GLES&EGL-Loader-驱动加载</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/710a8fa4.html">
        <span class="next-text nav-default">GLES&EGL-GLES-02</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
