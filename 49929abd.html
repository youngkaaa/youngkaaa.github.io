<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Android Service 启动流程全解析"/>








  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/49929abd.html"/>


<meta name="description" content="作为 Android 四大组件之一的 Service ，平时在应用开发时，经常会用到它，但是也仅限于使用而已，对于其内部的原理，代码流程是怎么处理的并不清楚。所以为了加深对 Service 的理解，我们来分析下 Service 的启动流程。 注意，本文主要侧重于 Service 的启动流程，以及其内部的一些生命周期方法的调用分析，并不牵扯其中的 IBinder 进程间通讯逻辑，这些逻辑属于 Bin">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Service 启动流程全解析">
<meta property="og:url" content="https://youngkaaa.github.io/49929abd.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="作为 Android 四大组件之一的 Service ，平时在应用开发时，经常会用到它，但是也仅限于使用而已，对于其内部的原理，代码流程是怎么处理的并不清楚。所以为了加深对 Service 的理解，我们来分析下 Service 的启动流程。 注意，本文主要侧重于 Service 的启动流程，以及其内部的一些生命周期方法的调用分析，并不牵扯其中的 IBinder 进程间通讯逻辑，这些逻辑属于 Bin">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-13T13:49:58.000Z">
<meta property="article:modified_time" content="2023-03-12T13:03:54.398Z">
<meta property="article:author" content="咔咔咔">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Android Service 启动流程全解析 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Android Service 启动流程全解析
        
      </h1>

      <time class="post-time">
          1月 13 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>作为 Android 四大组件之一的 Service ，平时在应用开发时，经常会用到它，但是也仅限于使用而已，对于其内部的原理，代码流程是怎么处理的并不清楚。所以为了加深对 Service 的理解，我们来分析下 Service 的启动流程。</p>
<p>注意，本文主要侧重于 Service 的启动流程，以及其内部的一些生命周期方法的调用分析，并不牵扯其中的 IBinder 进程间通讯逻辑，这些逻辑属于 Binder 的内容，可以详见：<a href="4ee2033c.html">这篇文章中的 Binder系列文章</a> 中的分析。</p>
<h2 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h2><p>对于 Service 的启动有两种方式：startService 和 bindService 。这两个方法的定义都是在  Context 中的，因此我们通常可以在 Activity 中调用这俩方法来完成服务的启动。</p>
<p>这两个方法有啥区别呢？</p>
<p>① startService  方法会导致 Service 的 onCreate() 和 onStartCommand() 方法被调用，此时 Service 进入运行状态，如果后续又调用该方法来启动该 Service ，则不会再回调 onCreate() 方法，而是只调用 onStartCommand() 方法。再调用  stopService() 方法时，会执行其 onDestroy() 方法。如果调用者后续没有再调用 stopService() 方法的话，则该 Service 会一直在后台运行，除非APP进程被系统kill掉，此时会将该Service一起kill掉。</p>
<p>② bindService 方法会导致 Service 的 onCreate() 和 onBind() 方法被调用，此时Service进入运行状态，如果后续又调用该方法的话，则不会再回调  onCreate() 和 onBind() 方法，在不使用时可以调用 unbindService() 来解除绑定，此时Service 会调用 onUnbind() 和 onDestroy() 方法。</p>
<p>注意 bindService 会使得对应的调用者的 context 和该 Service 绑定起来，当该 context 后续被销毁，比如 Activity 调用 finish() 被 onDestroy 掉时该 Service 会自动被调用 unbindService() 方法来解除绑定。startService  方法并没有这个特性，它只有后续主动调用 stopService() 才行。</p>
<p>接下来就分别从这俩方法作为切入点开始分析</p>
<h2 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h2><p>平常遇到的 Context  的实现类有好多，比如 ContextImpl ，ContextWrapper 等，以及这俩的子类 Activivty 等，但是最终的实现基本都是 ContextImpl ，所以我们从 ContextImpl 中看起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ComponentName <span class="title function_">startService</span><span class="params">(Intent service)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, <span class="literal">false</span>, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ComponentName <span class="title function_">startServiceCommon</span><span class="params">(Intent service, <span class="type">boolean</span> requireForeground,</span></span><br><span class="line"><span class="params">            UserHandle user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查启动 Service 时的 Intent 是否合法</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取到 ActivityManagerService 服务在当前进程中的 BpBinder 代理</span></span><br><span class="line"><span class="comment">         * 然后调用其 startService() 方法，也就是调用 system_server 进程中的 ActivityManagerService 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ComponentName</span> <span class="variable">cn</span> <span class="operator">=</span> ActivityManager.getService().startService(</span><br><span class="line">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), requireForeground,</span><br><span class="line">                        getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="comment">// ActivityManagerService 那边执行完毕，此时通过返回值来判断其是否启动成功了          </span></span><br><span class="line">        <span class="keyword">if</span> (cn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">&quot;!&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(</span><br><span class="line">                        <span class="string">&quot;Not allowed to start service &quot;</span> + service</span><br><span class="line">                        + <span class="string">&quot; without permission &quot;</span> + cn.getClassName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">&quot;!!&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(</span><br><span class="line">                        <span class="string">&quot;Unable to start service &quot;</span> + service</span><br><span class="line">                        + <span class="string">&quot;: &quot;</span> + cn.getClassName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">&quot;?&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;Not allowed to start service &quot;</span> + service + <span class="string">&quot;: &quot;</span> + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateServiceIntent</span><span class="params">(Intent service)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (service.getComponent() == <span class="literal">null</span> &amp;&amp; service.getPackage() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Android 5.0 开始禁止使用隐式方式启动 Service</span></span><br><span class="line">        <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            <span class="type">IllegalArgumentException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Service Intent must be explicit: &quot;</span> + service);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Implicit intents with startService are not safe: &quot;</span> + service</span><br><span class="line">                    + <span class="string">&quot; &quot;</span> + Debug.getCallers(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ContextImpl 中 startService() 时，会先调用 validateServiceIntent() 方法来检查入参 Intent 是否合法，比如对于5.0开始不允许隐式启动Service了，否则会抛出异常。</p>
<p>接着会通过 ActivityManager.getService() 方法来拿到 system_server 进程中运行的 ActivityManagerService 实例在当前进程中的 Binder 代理对象实例，使用这个 Binder 代理对象实例后期就可以调用到 system_server 进程中的 ActivityManagerService 实例中去完成真正的逻辑。</p>
<p>下面来看看 ActivityManager.getService() 方法中时怎么处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityManager.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 去拿到 IActivityManagerSingleton 单例中的对象实例</span></span><br><span class="line">    <span class="comment">// 第一次的话会去执行 IActivityManagerSingleton 中的 create() 方法来创建对象实例</span></span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Singleton</span>&lt;IActivityManager&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> IActivityManager <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 通过 ServiceManager 来查找 Context.ACTIVITY_SERVICE 服务在当前进程对应的代理对象实例</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">b</span> <span class="operator">=</span> ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">            <span class="comment">// 将其包装为 IActivityManager</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">am</span> <span class="operator">=</span> IActivityManager.Stub.asInterface(b);</span><br><span class="line">            <span class="keyword">return</span> am;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>这里是 通过 ServiceManager.getService() 方法去获取服务名为Context.ACTIVITY_SERVICE 的 ActivityManagerService  服务实例在当前进程中的代理对象实例，最后再将其转换包装成 IActivityManager 接口实例返回给外部去使用。</p>
<p>如果你不明白为什么 Context.ACTIVITY_SERVICE  对应的是 ActivityManagerService 服务实例，那么建议你去看看：<a href="d663666b.html">Android 系统服务加载启动</a> 。</p>
<p>如果你不明白 ServiceManager.getService() 的工作原理，那么建议你去看看 <a href="2af50710.html">Binder - Java Framework</a> 中的分析，当然还是建议你最好去看完 Binder 的全系列文章。</p>
<p>接着就调用到了 system_server 进程中的 ActivityManagerService 实例中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ActiveServices mServices;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ComponentName <span class="title function_">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span><br><span class="line"><span class="params">        String resolvedType, <span class="type">boolean</span> requireForeground, String callingPackage, <span class="type">int</span> userId)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;startService&quot;</span>);</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;File descriptors passed in Intent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;callingPackage cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">            <span class="string">&quot;*** startService: &quot;</span> + service + <span class="string">&quot; type=&quot;</span> + resolvedType + <span class="string">&quot; fg=&quot;</span> + requireForeground);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 拿到调用方进程的信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">callingPid</span> <span class="operator">=</span> Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">callingUid</span> <span class="operator">=</span> Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * mServices 在 ActivityManagerService 的构造方法中被初始化</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                    resolvedType, callingPid, callingUid,</span><br><span class="line">                    requireForeground, callingPackage, userId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次提醒下，现在是从刚才的发起方进程调用到了 system_server 进程中来执行了。而发起方对应的进程，我们后续会将其叫做 应用进程，或者叫做 发起方进程。你需要对这俩进程需要做好区分。</p>
<p>这里会将逻辑交给 ActivityManagerService 内部的 mServices 来处理，而 mServices 的初始化是在 ActivityManagerService 的构造方法中完成的，接着往下看：</p>
<h3 id="startServiceLocked"><a href="#startServiceLocked" class="headerlink" title="startServiceLocked"></a>startServiceLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line">ComponentName <span class="title function_">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> callingPid, <span class="type">int</span> callingUid, <span class="type">boolean</span> fgRequired, String callingPackage, <span class="keyword">final</span> <span class="type">int</span> userId)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">return</span> startServiceLocked(caller, service, resolvedType, callingPid, callingUid, fgRequired,</span><br><span class="line">            callingPackage, userId, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ComponentName <span class="title function_">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> callingPid, <span class="type">int</span> callingUid, <span class="type">boolean</span> fgRequired, String callingPackage,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">int</span> userId, <span class="type">boolean</span> allowBackgroundActivityStarts)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">&quot;startService: &quot;</span> + service</span><br><span class="line">            + <span class="string">&quot; type=&quot;</span> + resolvedType + <span class="string">&quot; args=&quot;</span> + service.getExtras());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> callerFg;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">callerApp</span> <span class="operator">=</span> mAm.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(</span><br><span class="line">                    <span class="string">&quot;Unable to find app for caller &quot;</span> + caller</span><br><span class="line">                    + <span class="string">&quot; (pid=&quot;</span> + callingPid</span><br><span class="line">                    + <span class="string">&quot;) when starting service &quot;</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callerFg = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取即将要启动的 Service 信息</span></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">        retrieveServiceLocked(service, <span class="literal">null</span>, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="literal">true</span>, callerFg, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;!&quot;</span>, res.permission != <span class="literal">null</span></span><br><span class="line">                ? res.permission : <span class="string">&quot;private to package&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">r</span> <span class="operator">=</span> res.record;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码，这部分主要是做合法性检查</span></span><br><span class="line">    <span class="comment">// 比如检查当前启动的前后台状态、权限等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 res.record 中的属性</span></span><br><span class="line">    r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    r.startRequested = <span class="literal">true</span>;</span><br><span class="line">    r.delayedStop = <span class="literal">false</span>;</span><br><span class="line">    r.fgRequired = fgRequired;</span><br><span class="line">    r.pendingStarts.add(<span class="keyword">new</span> <span class="title class_">ServiceRecord</span>.StartItem(r, <span class="literal">false</span>, r.makeNextStartId(),</span><br><span class="line">            service, neededGrants, callingUid));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ServiceMap</span> <span class="variable">smap</span> <span class="operator">=</span> getServiceMapLocked(r.userId);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">addToStarting</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 addToStarting 值的计算流程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用到 startServiceInnerLocked 方法中去</span></span><br><span class="line">    <span class="type">ComponentName</span> <span class="variable">cmp</span> <span class="operator">=</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 startServiceLocked 方法中，会对传进来的要启动的服务进行一些前置性检查，比如检查当前调用的前后台状态，权限检查等，最后会调用到 startServiceInnerLocked() 方法中去完成剩余逻辑：</p>
<h3 id="startServiceInnerLocked"><a href="#startServiceInnerLocked" class="headerlink" title="startServiceInnerLocked"></a>startServiceInnerLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line">ComponentName <span class="title function_">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> callerFg, <span class="type">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 日志统计</span></span><br><span class="line">    <span class="type">ServiceState</span> <span class="variable">stracker</span> <span class="operator">=</span> r.getTracker();</span><br><span class="line">    <span class="keyword">if</span> (stracker != <span class="literal">null</span>) &#123;</span><br><span class="line">        stracker.setStarted(<span class="literal">true</span>, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    r.callStart = <span class="literal">false</span>;</span><br><span class="line">    StatsLog.write(StatsLog.SERVICE_STATE_CHANGED, r.appInfo.uid, r.name.getPackageName(),</span><br><span class="line">            r.name.getClassName(), StatsLog.SERVICE_STATE_CHANGED__STATE__START);</span><br><span class="line">    <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">        r.stats.startRunningLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用到 bringUpServiceLocked() 方法中去完成剩余逻辑</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="literal">false</span>, <span class="literal">false</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动失败，则往返回值中 ComponentName 中指定 packageName 为 &quot;!!&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComponentName</span>(<span class="string">&quot;!!&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动成功之后的收尾工作</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; addToStarting) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> smap.mStartingBackground.size() == <span class="number">0</span>;</span><br><span class="line">        smap.mStartingBackground.add(r);</span><br><span class="line">        r.startingBgTimeout = SystemClock.uptimeMillis() + mAm.mConstants.BG_START_TIMEOUT;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) &#123;</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">here</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;here&quot;</span>);</span><br><span class="line">            here.fillInStackTrace();</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">&quot;Starting background (first=&quot;</span> + first + <span class="string">&quot;): &quot;</span> + r, here);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">&quot;Starting background (first=&quot;</span> + first + <span class="string">&quot;): &quot;</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            smap.rescheduleDelayedStartsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callerFg || r.fgRequired) &#123;</span><br><span class="line">        smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 startServiceInnerLocked() 方法中，会先去调用 bringUpServiceLocked() 方法来完成真正的启动逻辑，在该方法执行完毕之后，会拿到最终启动的返回值，如果不为 null，则表示 startServiceInnerLocked() 方法中启动失败了，此时返回一个 ComponentName 实例，同时给该 ComponentName 实例的内部 mPackage 属性赋值为 “!!” ，这样的话后续外部拿到返回值，判断其 packageName 就能知道是因为什么失败了，比如你可以翻看前面的 ContextImpl 中的 startServiceCommon() 方法中最后是怎么判断最终启动结果的。</p>
<p>我们接下来看看 bringUpServiceLocked() 方法中做了什么逻辑：</p>
<h3 id="bringUpServiceLocked"><a href="#bringUpServiceLocked" class="headerlink" title="bringUpServiceLocked"></a>bringUpServiceLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="type">int</span> intentFlags, <span class="type">boolean</span> execInFg,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> whileRestarting, <span class="type">boolean</span> permissionsReviewRequired)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 Service 正在运行 ，那么直接调用 onStartCommand 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span> &amp;&amp; r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该服务正在重启，等待吧...</span></span><br><span class="line">    <span class="keyword">if</span> (!whileRestarting &amp;&amp; mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) &#123;</span><br><span class="line">        Slog.v(TAG_SERVICE, <span class="string">&quot;Bringing up &quot;</span> + r + <span class="string">&quot; &quot;</span> + r.intent + <span class="string">&quot; fg=&quot;</span> + r.fgRequired);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">&quot;REM FR DELAY LIST (bring up): &quot;</span> + r);</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to launch app &quot;</span></span><br><span class="line">                + r.appInfo.packageName + <span class="string">&quot;/&quot;</span></span><br><span class="line">                + r.appInfo.uid + <span class="string">&quot; for service &quot;</span></span><br><span class="line">                + r.intent.getIntent() + <span class="string">&quot;: user &quot;</span> + r.userId + <span class="string">&quot; is stopped&quot;</span>;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                r.packageName, <span class="literal">false</span>, r.userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Failed trying to unstop package &quot;</span></span><br><span class="line">                + r.packageName + <span class="string">&quot;: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前要启动的 Service 是否设置了 android:isolatedProcess 属性</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isolated</span> <span class="operator">=</span> (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">procName</span> <span class="operator">=</span> r.processName;</span><br><span class="line">    <span class="type">HostingRecord</span> <span class="variable">hostingRecord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostingRecord</span>(<span class="string">&quot;service&quot;</span>, r.instanceName);</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有设置 android:isolatedProcess 属性</span></span><br><span class="line">    <span class="comment">// 也就是大多数的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        <span class="comment">// 获取该服务的进程对应的 ProcessRecord</span></span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">&quot;bringUpServiceLocked: appInfo.uid=&quot;</span> + r.appInfo.uid</span><br><span class="line">                    + <span class="string">&quot; app=&quot;</span> + app);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果该 Service 对应的进程已经存在了，此时调用 realStartServiceLocked() 方法去直接启动 Service 就行了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="literal">null</span> &amp;&amp; app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);</span><br><span class="line">                <span class="comment">// 真正的去启动 Service 的地方</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                <span class="comment">// 返回 null 表示启动成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Exception when starting service &quot;</span> + r.shortInstanceName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 忽略这种情况吧</span></span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">        <span class="keyword">if</span> (WebViewZygote.isMultiprocessEnabled()</span><br><span class="line">                &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123;</span><br><span class="line">            hostingRecord = HostingRecord.byWebviewZygote(r.instanceName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r.serviceInfo.flags &amp; ServiceInfo.FLAG_USE_APP_ZYGOTE) != <span class="number">0</span>) &#123;</span><br><span class="line">            hostingRecord = HostingRecord.byAppZygote(r.instanceName, r.definingPackageName,</span><br><span class="line">                    r.definingUid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果该服务对应的进程不存在，那么启动一个新的进程，确保后续服务的启动正常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="literal">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里为该 Service 创建并启动新的进程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="literal">true</span>, intentFlags,</span><br><span class="line">                hostingRecord, <span class="literal">false</span>, isolated, <span class="literal">false</span>)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建新进程失败了</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to launch app &quot;</span></span><br><span class="line">                    + r.appInfo.packageName + <span class="string">&quot;/&quot;</span></span><br><span class="line">                    + r.appInfo.uid + <span class="string">&quot; for service &quot;</span></span><br><span class="line">                    + r.intent.getIntent() + <span class="string">&quot;: process is bad&quot;</span>;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            <span class="comment">// 创建进程失败，那么也就是启动服务失败，返回非空的字符串</span></span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.fgRequired) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_FOREGROUND_SERVICE) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">&quot;Whitelisting &quot;</span> + UserHandle.formatUid(r.appInfo.uid)</span><br><span class="line">                    + <span class="string">&quot; for fg-service launch&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.tempWhitelistUidLocked(r.appInfo.uid,</span><br><span class="line">                SERVICE_START_FOREGROUND_TIMEOUT, <span class="string">&quot;fg-service-launch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里表示上面是新建进程成功了，此时将要启动的 Service 暂存起来</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we&#x27;ve already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">&quot;Applying delayed stop (in bring up): &quot;</span> + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中的逻辑较长，我们分步来讲解：</p>
<p>① 判断当前 Service 是否已经是处于启动状态的，如果的话，则会调用 sendServiceArgsLocked() 方法来通知它去执行自己的 onStartCommand() 方法。这个分为两种情况：</p>
<ol>
<li><p>一种是该 Service  是运行在单独的进程中，比如是A进程。该进程和你发起方进程不是同一个。这种是之前第一次启动它时，你为该 Service 指定了  android:process 属性。</p>
</li>
<li><p>另外一种情况是该 Service 没有指定 android:process 属性，那么该 Service 最终被启动后是在你调用 startService() 方法的那个进程中运行的。</p>
</li>
</ol>
<p>② 判断该 Service 是否设置了 android:isolatedProcess 属性，当然一般都是不设置该属性的，所以我们这里默认最终的 isolated 值为 false ；</p>
<p>③ 判断该 Service 对应的进程是否已被创建了。如果其进程已被创建则会去调用 realStartServiceLocked() 方法来完成该 Service 的真正启动逻辑。</p>
<p>想象一下：该 Service 此时还没启动呢，他对应的进程就已经存在了，那是不是就对应着没有指定 android:process 属性的情况呢，即创建出来的 Service 是和发起方进程在同一个进程中运行的。</p>
<p>④ 如果该 Service 对应的进程是单独指定的，此时该进程还没有被创建呢，所以会先去调用 ActivityManagerService 的 startProcessLocked() 方法去创建并启动该进程。如果创建并启动该进程失败了则会返回非空的错误信息，此时外部就知道当前方法执行失败了，而如果进程创建并启动成功了，此时会接着往后执行，将当前要启动的 Service 信息暂存到 mPendingServices 列表中，等待后续新创建的进程启动之后再处理。</p>
<p>所以说，下面共有三个分支要分析，我们一个个来。</p>
<h3 id="sendServiceArgsLocked"><a href="#sendServiceArgsLocked" class="headerlink" title="sendServiceArgsLocked"></a>sendServiceArgsLocked</h3><p>该方法是当 Service 已经启动了，然后外部又调用 startService() 的情况，此时内部会去再次调用该 Service 的 onStartCommand() 方法 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sendServiceArgsLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> execInFg,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> oomAdjusted)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> r.pendingStarts.size();</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ServiceStartArgs&gt; args = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (r.pendingStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord.<span class="type">StartItem</span> <span class="variable">si</span> <span class="operator">=</span> r.pendingStarts.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">&quot;Sending arguments to: &quot;</span></span><br><span class="line">                    + r + <span class="string">&quot; &quot;</span> + r.intent + <span class="string">&quot; args=&quot;</span> + si.intent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si.intent == <span class="literal">null</span> &amp;&amp; N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">        r.deliveredStarts.add(si);</span><br><span class="line">        si.deliveryCount++;</span><br><span class="line">        <span class="keyword">if</span> (si.neededGrants != <span class="literal">null</span>) &#123;</span><br><span class="line">            mAm.mUgmInternal.grantUriPermissionUncheckedFromIntent(si.neededGrants,</span><br><span class="line">                    si.getUriPermissionsLocked());</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.grantEphemeralAccessLocked(r.userId, si.intent, UserHandle.getAppId(r.appInfo.uid),</span><br><span class="line">                UserHandle.getAppId(si.callingId));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在通知应用进程侧去执行其 onStartCommend() 方法之前，调用当前方法来检查 ANR</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oomAdjusted) &#123;</span><br><span class="line">            oomAdjusted = <span class="literal">true</span>;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="literal">true</span>, OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.fgRequired &amp;&amp; !r.fgWaiting) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!r.isForeground) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">&quot;Launched service must call startForeground() within timeout: &quot;</span> + r);</span><br><span class="line">                &#125;</span><br><span class="line">                scheduleServiceForegroundTransitionTimeoutLocked(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BACKGROUND_CHECK) &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">&quot;Service already foreground; no new timeout: &quot;</span> + r);</span><br><span class="line">                &#125;</span><br><span class="line">                r.fgRequired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (si.deliveryCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_RETRY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si.doneExecutingCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将启动该 Service 时传入的参数保存起来，比如 Intent</span></span><br><span class="line">        args.add(<span class="keyword">new</span> <span class="title class_">ServiceStartArgs</span>(si.taskRemoved, si.id, flags, si.intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ParceledListSlice&lt;ServiceStartArgs&gt; slice = <span class="keyword">new</span> <span class="title class_">ParceledListSlice</span>&lt;&gt;(args);</span><br><span class="line">    slice.setInlineCountLimit(<span class="number">4</span>);</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">caughtException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过 Binder 调用到应用进程那边去执行那边对应 Service 的 onStartCommend() 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        r.app.thread.scheduleServiceArgs(r, slice);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;Transaction too large for &quot;</span> + args.size()</span><br><span class="line">                + <span class="string">&quot; args, first: &quot;</span> + args.get(<span class="number">0</span>).args);</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Failed delivering service starts&quot;</span>, e);</span><br><span class="line">        caughtException = e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;Crashed while sending args: &quot;</span> + r);</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Failed delivering service starts&quot;</span>, e);</span><br><span class="line">        caughtException = e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">        caughtException = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (caughtException != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Keep nesting count correct</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inDestroying</span> <span class="operator">=</span> mDestroyingServices.contains(r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.size(); i++) &#123;</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (caughtException <span class="keyword">instanceof</span> TransactionTooLargeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (TransactionTooLargeException)caughtException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前 sendServiceArgsLocked() 方法中，主要完成了两步操作：</p>
<p>① 将外部启动 Service 时传入的参数保存起来，为后续调用 onStartCommend() 方法做好准备。</p>
<p>② 调用入参 ServiceRecord 中的 app 中的 thread 的 scheduleServiceArgs() 方法来通知到发起方进程去，</p>
<p>ServiceRecord 中的 app 是 ProcessRecord 类型的，它在 system_server 进程中表示的是其他进程的信息，比如应用进程。同时在 ActivityManagerService 实例中存在一个  mProcessList 实例，该实例内部就存储着那些已经启动过的应用程序的进程信息，当然这样说也不太准确，因为一个应用程序可能存在多个进程，比如其内部有些 Service 是单独的进程，而这里 mProcessList  中也会存储这些 Service 对应的进程信息。</p>
<p>或者你可以这样理解理解：只要是通过 ActivityManagerService  进行的操作，在操作进行时如果需要创建进程，那么这些创建的进程信息都会被存在 mProcessList 中。而说的这些操作包括 Activity的启动，Service的启动等。</p>
<p>ProcessRecord 中存在一个 thread 属性，它是 IApplicationThread 接口类型的，实际它是一个  AIDL 文件包括的接口，它的 Stub 实现方，或者说它对应的 Server 端是非system_server 进程，它的 Client 端是 system_server 进程中的 ProcessRecord.thread  实例，使用这个 thread 就可以发起对 另外一个进程 那边的方法调用。而对于现在启动 Service 来说的话，使用这里的 thread 就可以对 <strong>Service 运行的那个进程</strong> 那边的方法完成调用，这里说的  <strong>Service 运行的那个进程</strong>  不一定是发起调用 startService() 的那个进程。举个例子：</p>
<p>假如你的应用程序 (假设进程是 app )中定义了一个Service，并且通过 android:process 为该 Service 指定进程为 A ，那么第一次启动该Service 时就会创建进程 A 并启动该 Service，使其运行在 A进程中。那么后续你再次在进程app 中调用 startService() 方法执行到这里的 sendServiceArgsLocked() 方法中来，此时拿到的 r.app.thread 操作的就是 A 进程，也就是 Service 运行的那个进程，而不是 app 进程，也就是你从 app 调用到了 system_server 进程，然后它又调用到了 A 进程中去执行 Service 的  onStartCommend() 方法 。</p>
<p>当然了，如果你没指定 android:process ，那么这里 r.app.thread  操作的就是 app进程，因为一开始Service就运行在 app进程中。</p>
<p>关于这些你暂时只需要理解到这里，至于为什么，你可以去看看：<a href="8f14e4f4.html">Android Activity 启动流程全解析</a></p>
<p>所以说这里的  r.app.thread.scheduleServiceArgs() 方法就是调用到 Service目前正在运行的 进程中去，具体是：ActivityThread 中的  ApplicationThread 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程 Looper 绑定的 Handler</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略内部常量定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SERVICE_ARGS:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">&quot;serviceStart: &quot;</span> + String.valueOf(msg.obj)));</span><br><span class="line">                <span class="comment">// 实际执行到 handleServiceArgs 方法中</span></span><br><span class="line">                handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 省略其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> msg.obj;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> SomeArgs) &#123;</span><br><span class="line">            ((SomeArgs) obj).recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&lt;&lt;&lt; done: &quot;</span> + codeToString(msg.what));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ApplicationThread</span> <span class="keyword">extends</span> <span class="title class_">IApplicationThread</span>.Stub &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">scheduleServiceArgs</span><span class="params">(IBinder token, ParceledListSlice args)</span> &#123;</span><br><span class="line">        List&lt;ServiceStartArgs&gt; list = args.getList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历传过来的参数列表，然后挨个去处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="type">ServiceStartArgs</span> <span class="variable">ssa</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            <span class="type">ServiceArgsData</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceArgsData</span>();</span><br><span class="line">            s.token = token;</span><br><span class="line">            s.taskRemoved = ssa.taskRemoved;</span><br><span class="line">            s.startId = ssa.startId;</span><br><span class="line">            s.flags = ssa.flags;</span><br><span class="line">            s.args = ssa.args;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 发送一条 SERVICE_ARGS消息，切换到主线程去操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            sendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用方进程内的 ActivityThread 中的  ApplicationThread 内，会有 scheduleServiceArgs() 方法实现，在该方法中会处理传过来的参数，然后挨个调用 sendMessage() 方法来往 ActivityThread 中的 mH 中发送一条：H.SERVICE_ARGS 消息，接着会执行到 H 类中，它继承自 Handler ，所以也就切换到了主线程去执行，在 H 中实际执行的是：handleServiceArgs() 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service 在第一次被启动成功之后，会将其存储在 mServices 中，所以此时取出当前对应的 Service 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.args != <span class="literal">null</span>) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> res;</span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 调用 Service 的 onStartCommand 方法来将参数intent传递进去</span></span><br><span class="line"><span class="comment">                 * 这里也就执行到了你要启动的那个 Service 中去了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 拿到 ActivityManagerService 的 Binder 代理对象实例</span></span><br><span class="line"><span class="comment">                 * 调用其 serviceDoneExecuting() 方法来通知那边我们当前进程中 onStartCommand 方法执行完毕了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                        <span class="string">&quot;Unable to start service &quot;</span> + s</span><br><span class="line">                        + <span class="string">&quot; with &quot;</span> + data.args + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 handleServiceArgs() 方法中共两个逻辑：</p>
<p>① 找到对应的 Service 实例，然后调用其 onStartCommand() 方法来将参数传入进去。</p>
<p>② 调用 ActivityManager.getService() 方法拿到 ActivityManagerService 在当前进程的 Binder 代理对象实例，然后调用其 serviceDoneExecuting() 来通知它，我们这边  onStartCommand() 方法执行完毕了。</p>
<p>接着我们来看看 system_server 进程中的 ActivityManagerService  中的  serviceDoneExecuting()  方法是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> inDestroying,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> finishing)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;&lt;&lt;&lt; DONE EXECUTING &quot;</span> + r</span><br><span class="line">            + <span class="string">&quot;: nesting=&quot;</span> + r.executeNesting</span><br><span class="line">            + <span class="string">&quot;, inDestroying=&quot;</span> + inDestroying + <span class="string">&quot;, app=&quot;</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">            <span class="string">&quot;&lt;&lt;&lt; DONE EXECUTING &quot;</span> + r.shortInstanceName);</span><br><span class="line">    r.executeNesting--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">&quot;Nesting at 0 of &quot;</span> + r.shortInstanceName);</span><br><span class="line">            r.app.execServicesFg = <span class="literal">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                        <span class="string">&quot;No more executingServices of &quot;</span> + r.shortInstanceName);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 在这里会移除掉 SERVICE_TIMEOUT_MSG ANR 的消息，也就是本次没有 anr 发生</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=r.app.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                        r.app.execServicesFg = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inDestroying) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">&quot;doneExecuting remove destroying &quot;</span> + r);</span><br><span class="line">                mDestroyingServices.remove(r);</span><br><span class="line">                r.bindings.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="literal">true</span>, OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        r.executeFg = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.tracker != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">memFactor</span> <span class="operator">=</span> mAm.mProcessStats.getMemFactorLocked();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            r.tracker.setExecuting(<span class="literal">false</span>, memFactor, now);</span><br><span class="line">            r.tracker.setForeground(<span class="literal">false</span>, memFactor, now);</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                r.tracker.clearCurrentOwner(r, <span class="literal">false</span>);</span><br><span class="line">                r.tracker = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="literal">null</span> &amp;&amp; !r.app.isPersistent()) &#123;</span><br><span class="line">                r.app.services.remove(r);</span><br><span class="line">                r.app.updateBoundClientUids();</span><br><span class="line">                <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.setProcess(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里刚从 Service 运行的进程执行切换到了 system_server 进程中来处理了</p>
<p>这里面主要做一些收尾工作，其中有个 ActivityManagerService.SERVICE_TIMEOUT_MSG 消息的移除，这是和 ANR 监测相关的，还记得你在前面的 sendServiceArgsLocked() 方法中调用的 bumpServiceExecutingLocked() 方法吗？在从 system_server 切换到 Service 运行的进程中时，先调用  bumpServiceExecutingLocked() 来发送一个固定时长的延迟消息，然后等在 Service 运行的进程 那边运行完成通知过来到 system_server 时再移除掉它，当然如果在这个 固定时长 结束之前没有移除它，就会发生 ANR。关于 ANR 这里不再细讲，后续可能出 ANR 的文章来专门做分析把。</p>
<p>好了，至此就完成 sendServiceArgsLocked() 方法的执行，这种情况是要启动的 Service 已经启动过了，此时会去调用其   onStartCommand() 方法。</p>
<p>回顾下整个流程：在应用程序(假设其进程是app)中调用 startService() 方法来启动一个已经启动过的 Service ( 假设它此时运行在进程A中) ，其实会先从 app 进程执行到 system_server 进程中，然后在 system_server 中balabala一阵判断操作，然后调用到  A 进程中去执行该 Service 的 onStartCommand() 方法，等其执行完毕又从 A进程调用到 system_server 进程来完成收尾工作。当然如果该 Service 没有指定 android:process 属性的话，则 app &#x3D;  A 。</p>
<h3 id="realStartServiceLocked"><a href="#realStartServiceLocked" class="headerlink" title="realStartServiceLocked"></a>realStartServiceLocked</h3><p>当前方法时发现要启动的 Service 没有启动过，并且其对应的进程已经被创建了，此时会调用当前方法来完成该 Service 的真正创建和启动逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span><br><span class="line"><span class="params">        ProcessRecord app, <span class="type">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 走到该方法中，表示该服务对应的进程肯定已被创建过了，所以此时 app.thread 不可能是 null</span></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MU)</span><br><span class="line">        Slog.v(TAG_MU, <span class="string">&quot;realStartServiceLocked, ServiceRecord.uid = &quot;</span> + r.appInfo.uid</span><br><span class="line">                + <span class="string">&quot;, ProcessRecord.uid = &quot;</span> + app.uid);</span><br><span class="line">    r.setProcess(app);</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">newService</span> <span class="operator">=</span> app.services.add(r);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 还是先调用它来完成 anr 监控</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;create&quot;</span>);</span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    updateServiceForegroundLocked(r.app, <span class="comment">/* oomAdj= */</span> <span class="literal">false</span>);</span><br><span class="line">    mAm.updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                                PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同样的道理，还是调用到当前 service 对应的进程去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.getReportedProcState());</span><br><span class="line">        r.postNotification();</span><br><span class="line">        <span class="comment">// 调用到这里表示创建成功了</span></span><br><span class="line">        created = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Application dead when creating service &quot;</span> + r);</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果创建失败了</span></span><br><span class="line">        <span class="keyword">if</span> (!created) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inDestroying</span> <span class="operator">=</span> mDestroyingServices.contains(r);</span><br><span class="line">            <span class="comment">// 如果创建失败了则移除 anr 消息，不用监控了</span></span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.setProcess(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 service 的绑定操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newService &amp;&amp; created) &#123;</span><br><span class="line">        app.addBoundClientUidsOfNewService(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the service is in the started state, and there are no</span></span><br><span class="line">    <span class="comment">// pending arguments, then fake up one so its onStartCommand() will</span></span><br><span class="line">    <span class="comment">// be called.</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        r.pendingStarts.add(<span class="keyword">new</span> <span class="title class_">ServiceRecord</span>.StartItem(r, <span class="literal">false</span>, r.makeNextStartId(),</span><br><span class="line">                <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前面创建好 Service实例并且调用 onCreate 之后，到这里就开始要执行 onStartCommand 了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">&quot;REM FR DELAY LIST (new proc): &quot;</span> + r);</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we&#x27;ve already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">&quot;Applying delayed stop (from start): &quot;</span> + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中主要执行三部分的逻辑：</p>
<p>① 调用 app.thread.scheduleCreateService() 方法去执行 Service 的创建工作。</p>
<p>② 调用 equestServiceBindingsLocked() 方法来处理该 Service 的绑定 onBind() 逻辑，这里不用考虑</p>
<p>③ 调用 sendServiceArgsLocked() 方法来处理该 Service 的 onStartCommand() 方法逻辑，上面刚讲过了。</p>
<p>所以我们主要看第①个 ： app.thread.scheduleCreateService() 中是怎么处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程 Looper 绑定的 Handler</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略内部常量定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">&quot;serviceCreate: &quot;</span> + String.valueOf(msg.obj)));</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 执行到这里去完成创建工作</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 省略其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> msg.obj;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> SomeArgs) &#123;</span><br><span class="line">            ((SomeArgs) obj).recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&lt;&lt;&lt; done: &quot;</span> + codeToString(msg.what));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ApplicationThread</span> <span class="keyword">extends</span> <span class="title class_">IApplicationThread</span>.Stub &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 Service 过程中，AMS端完成校验后会调用回来到这里</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">scheduleCreateService</span><span class="params">(IBinder token,</span></span><br><span class="line"><span class="params">            ServiceInfo info, CompatibilityInfo compatInfo, <span class="type">int</span> processState)</span> &#123;</span><br><span class="line">        updateProcessState(processState, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">CreateServiceData</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateServiceData</span>();</span><br><span class="line">        s.token = token;</span><br><span class="line">        s.info = info;</span><br><span class="line">        s.compatInfo = compatInfo;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 切换到主线程去执行 CREATE_SERVICE 消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最终调用到 handleCreateService() 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCreateService</span><span class="params">(CreateServiceData data)</span> &#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    <span class="type">LoadedApk</span> <span class="variable">packageInfo</span> <span class="operator">=</span> getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> packageInfo.getClassLoader();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过反射获取 Service 实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        service = packageInfo.getAppFactory()</span><br><span class="line">                .instantiateService(cl, data.info.name, data.intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Unable to instantiate service &quot;</span> + data.info.name</span><br><span class="line">                + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Creating service &quot;</span> + data.info.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为其创建一个 ContextImpl 实例</span></span><br><span class="line">        <span class="type">ContextImpl</span> <span class="variable">context</span> <span class="operator">=</span> ContextImpl.createAppContext(<span class="built_in">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果没有 Application 的话还会创建 Application</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将当前 Application、contexy 等信息和 Service 绑定起来</span></span><br><span class="line"><span class="comment">         * Activity create 的时候也会调用 Activity.attach方法，有点类似</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        service.attach(context, <span class="built_in">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManager.getService());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 Service 的 onCreate 方法，该方法只有在 Service 创建时才会调用，只会调用一次</span></span><br><span class="line"><span class="comment">         * 然后把 Service 放置在 mServices 中缓存起来，后面就可以直接用了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 通知 AMS 那边我们创建完毕了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Unable to create service &quot;</span> + data.info.name</span><br><span class="line">                + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，首先会通过反射来创建 Service 实例，然后再调用其 attach() 方法来将对应的信息保存起来，接着就可以调用其 onCreate() 方法了，最后会将其放置到 ActivityThread 中的 mServices 列表中的，供后续使用。比如上面分析调用 onStartCommand() 时就用到了。</p>
<p>最后还是调用  ActivityManager.getService().serviceDoneExecuting() 方法来通知  ActivityManagerService 那边来完成收尾工作，比如 ANR 消息的移除等。</p>
<p>接着回到 realStartServiceLocked() 那边接着往下执行后面的 第②步，第③步进而完成该 Service 的 onStartCommand()方法的调用。至此就完成了 realStartServiceLocked() 方法的分析。</p>
<p>这里就不总结它的调用路径和，和前面  sendServiceArgsLocked() 方法中类似，只不过这里是两次，一次为执行 onCreate ，一次为调用  onStartCommand() 。</p>
<h3 id="startProcessLocked"><a href="#startProcessLocked" class="headerlink" title="startProcessLocked"></a>startProcessLocked</h3><p>这种情况是当要启动的 Service 对应的进程此时还没创建呢，那么此时会调用当前方法去完成进程创建工作，并且会将当前要启动的 Service 信息暂存到 mPendingServices 列表中，等待后续新创建的进程启动之后再处理。</p>
<p>下面简单看看创建进程的代码流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ProcessRecord <span class="title function_">startProcessLocked</span><span class="params">(String processName,</span></span><br><span class="line"><span class="params">        ApplicationInfo info, <span class="type">boolean</span> knownToBeDead, <span class="type">int</span> intentFlags,</span></span><br><span class="line"><span class="params">        HostingRecord hostingRecord, <span class="type">boolean</span> allowWhileBooting,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isolated, <span class="type">boolean</span> keepIfLarge)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用到其内部的 mProcessList 实例中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,</span><br><span class="line">            hostingRecord, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>, keepIfLarge,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* ABI override */</span>, <span class="literal">null</span> <span class="comment">/* entryPoint */</span>, <span class="literal">null</span> <span class="comment">/* entryPointArgs */</span>,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// com.android.server.am.ProcessList.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ProcessRecord <span class="title function_">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> knownToBeDead, <span class="type">int</span> intentFlags, HostingRecord hostingRecord,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> allowWhileBooting, <span class="type">boolean</span> isolated, <span class="type">int</span> isolatedUid, <span class="type">boolean</span> keepIfLarge,</span></span><br><span class="line"><span class="params">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> SystemClock.elapsedRealtime();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="comment">// 是否设置过 android:isolatedProcess ，默认当做没设置吧，也就是 isolated = false</span></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">        checkSlow(startTime, <span class="string">&quot;startProcess: after getProcessRecord&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">&quot;Bad process: &quot;</span> + info.uid</span><br><span class="line">                        + <span class="string">&quot;/&quot;</span> + info.processName);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">&quot;Clearing bad process: &quot;</span> + info.uid</span><br><span class="line">                    + <span class="string">&quot;/&quot;</span> + info.processName);</span><br><span class="line">            mService.mAppErrors.resetProcessCrashTimeLocked(info);</span><br><span class="line">            <span class="keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,</span><br><span class="line">                        UserHandle.getUserId(info.uid), info.uid,</span><br><span class="line">                        info.processName);</span><br><span class="line">                mService.mAppErrors.clearBadProcessLocked(info);</span><br><span class="line">                <span class="keyword">if</span> (app != <span class="literal">null</span>) &#123;</span><br><span class="line">                    app.bad = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式创建进程之前，还会再检查下当前状态，这里省略掉这些代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正的去创建启动进程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> startProcessLocked(app, hostingRecord, abiOverride);</span><br><span class="line">    checkSlow(startTime, <span class="string">&quot;startProcess: done starting proc!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> success ? app : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mService&quot;)</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span><br><span class="line"><span class="params">        String abiOverride)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(app, hostingRecord,</span><br><span class="line">            <span class="literal">false</span> <span class="comment">/* disableHiddenApiChecks */</span>, <span class="literal">false</span> <span class="comment">/* mountExtStorageFull */</span>, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> disableHiddenApiChecks, <span class="type">boolean</span> mountExtStorageFull,</span></span><br><span class="line"><span class="params">            String abiOverride)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (app.pendingStart) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">seInfo</span> <span class="operator">=</span> app.info.seInfo</span><br><span class="line">                + (TextUtils.isEmpty(app.info.seInfoUser) ? <span class="string">&quot;&quot;</span> : app.info.seInfoUser);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意这里 entryPoint = &quot;android.app.ActivityThread&quot;,他就是最终进程创建出来后去加载执行的类</span></span><br><span class="line"><span class="comment">         * 到时候会在新进程中的线程中，执行其 main 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">entryPoint</span> <span class="operator">=</span> <span class="string">&quot;android.app.ActivityThread&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids,</span><br><span class="line">                runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                startTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        Slog.e(ActivityManagerService.TAG, <span class="string">&quot;Failure starting process &quot;</span> + app.processName, e);</span><br><span class="line">        mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, app.userId, <span class="string">&quot;start failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startProcessLocked</span><span class="params">(HostingRecord hostingRecord,</span></span><br><span class="line"><span class="params">            String entryPoint,</span></span><br><span class="line"><span class="params">            ProcessRecord app, <span class="type">int</span> uid, <span class="type">int</span>[] gids, <span class="type">int</span> runtimeFlags, <span class="type">int</span> mountExternal,</span></span><br><span class="line"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> startTime)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mService.mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里的 entryPoint = &quot;android.app.ActivityThread&quot; </span></span><br><span class="line"><span class="comment">             * 调用 startProcess() 会 fork 出一个新的进程，然后反射创建出 &quot;android.app.ActivityThread&quot; 对象实例，执行其 main 方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> Process.<span class="type">ProcessStartResult</span> <span class="variable">startResult</span> <span class="operator">=</span> startProcess(hostingRecord,</span><br><span class="line">                    entryPoint, app,</span><br><span class="line">                    uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    invokeWith, startTime);</span><br><span class="line">            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                    startSeq, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            Slog.e(ActivityManagerService.TAG, <span class="string">&quot;Failure starting process &quot;</span></span><br><span class="line">                    + app.processName, e);</span><br><span class="line">            app.pendingStart = <span class="literal">false</span>;</span><br><span class="line">            mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                    <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, app.userId, <span class="string">&quot;start failure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app.pid &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么创建进程并不是我们这这篇文章的重心，所以我们只需要直接最终创建出来的进程在一启动，也就是其内部的第一个线程启动后，会执行 ActivityThread 的 main() 方法。接下来，我们去看 ActivityThread 的 main() 方法中做了哪些事情吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    CloseGuard.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">configDir</span> <span class="operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化主线程 Looper 对象实例</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">startSeq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="literal">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建出 ActivityThread 实例，此时它内部的 mH 、mAppThread 等成员属性就会被初始化赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    <span class="comment">// 调用其 attach() 方法</span></span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始 Looper 循环，即主线程的消息循环，开始处理消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其 main() 方法中，主要是创建出 ActivityThread 实例，然后调用其 attach() 方法来进行初始化绑定工作，最后执行主线程的 Looper 循环。</p>
<p>注意当前是该进程中第一个线程中执行的逻辑，这个线程也就会被当做是主线程。但其实在进程中，并不分主线程，子线程之说，只有我们在 Android 中经常会讲，我们一般讲的主线程就是该进程中的第一个线程。</p>
<p>另外这里调用 attach() 方法时传入的第一个参数是 false ，而在 SystemServer 中初始化系统服务时，也会创建一个 ActivityThread 实例，那个时候调用 attach() 方法来绑定时传入的第一个参数就是 true ，详见：<a href="d663666b.html">Android 系统服务加载启动。</a></p>
<p>接下来来看这个 attach() 方法中做了什么操作吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(<span class="type">boolean</span> system, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">    sCurrentActivityThread = <span class="built_in">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时入参 system = false </span></span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        <span class="comment">// 拿到 ActivityManagerService 在当前进程中的 Binder 代理对象实例</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 调用到 ActivityManagerService 中的 attachApplication 方法内</span></span><br><span class="line"><span class="comment">             * 传入的第一个参数 mAppThread 的类型是 ApplicationThread ，它继承自 IApplicationThread.Stub</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册回调监听</span></span><br><span class="line">        BinderInternal.addGcWatcher(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                <span class="type">long</span> <span class="variable">dalvikMax</span> <span class="operator">=</span> runtime.maxMemory();</span><br><span class="line">                <span class="type">long</span> <span class="variable">dalvikUsed</span> <span class="operator">=</span> runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">&quot;Dalvik max=&quot;</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">&quot; total=&quot;</span> + (runtime.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">&quot; used=&quot;</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                    mSomeActivitiesChanged = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ActivityTaskManager.getService().releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;system_process&quot;</span>,</span><br><span class="line">                UserHandle.myUserId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation = <span class="keyword">new</span> <span class="title class_">Instrumentation</span>();</span><br><span class="line">            mInstrumentation.basicInit(<span class="built_in">this</span>);</span><br><span class="line">            <span class="type">ContextImpl</span> <span class="variable">context</span> <span class="operator">=</span> ContextImpl.createAppContext(</span><br><span class="line">                    <span class="built_in">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">            mInitialApplication = context.mPackageInfo.makeApplication(<span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">            mInitialApplication.onCreate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Unable to instantiate Application():&quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ViewRootImpl.<span class="type">ConfigChangedCallback</span> <span class="variable">configChangedCallback</span></span><br><span class="line">            <span class="operator">=</span> (Configuration globalConfig) -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">            <span class="comment">// We need to apply this change to the resources immediately, because upon returning</span></span><br><span class="line">            <span class="comment">// the view hierarchy will be informed about it.</span></span><br><span class="line">            <span class="keyword">if</span> (mResourcesManager.applyConfigurationToResourcesLocked(globalConfig,</span><br><span class="line">                    <span class="literal">null</span> <span class="comment">/* compat */</span>)) &#123;</span><br><span class="line">                updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(),</span><br><span class="line">                        mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This actually changed the resources! Tell everyone about it.</span></span><br><span class="line">                <span class="keyword">if</span> (mPendingConfiguration == <span class="literal">null</span></span><br><span class="line">                        || mPendingConfiguration.isOtherSeqNewer(globalConfig)) &#123;</span><br><span class="line">                    mPendingConfiguration = globalConfig;</span><br><span class="line">                    sendMessage(H.CONFIGURATION_CHANGED, globalConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册监听</span></span><br><span class="line">    ViewRootImpl.addConfigCallback(configChangedCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 attach() 方法中其实最主要的逻辑就一个：调用 ActivityManagerService 中的 attachApplication() 方法，注意这里传入的第一个参数：mAppThread 。它是 ActivityThread  中的成员变量，类型是 ApplicationThread ，它在前面 ActivityThread   实例创建时就已经被初始化了。而 ApplicationThread 是啥呢？你不觉得它很熟悉吗？前面在讲 system_server 中来调用 Service 所在进程去执行其 onStartCommand() 方法时，也是走到了 Service 所在进程的 ActivityThread 中的 ApplicationThread 中的对应方法内的。</p>
<p>其实 ApplicationThread  是继承自 IApplicationThread.Stub 的，也就是作为  IApplicationThread 的服务端实现，而其对应的实例就是 ActivityThread 中的 mAppThread 。</p>
<p>因此，我们可以知道这里调用 调用 ActivityManagerService 中的 attachApplication() 方法的目的是应该是通知 system_server 进程那边的 ActivityManagerService 实例，告诉他： 哥们，你刚不是创建了我么？我现在创建好了，并且已经启动啦，此时我执行了 ActivityThread 中的 attach() 方法中了，我把我的联系方式 mAppThread  通过 Binder 发送给你，你那边存一下，后面有事要找我的话，就通过 mAppThread 联系我就行。</p>
<p>注意，接下来就从当前新创建的进程中切换到了 system_server 进程中去执行了。</p>
<p>接下来我们看看 ActivityManagerService  中是怎么处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attachApplication</span><span class="params">(IApplicationThread thread, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">callingPid</span> <span class="operator">=</span> Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">callingUid</span> <span class="operator">=</span> Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> pid, <span class="type">int</span> callingUid, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="type">long</span> bindApplicationTimeMillis;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">processName</span> <span class="operator">=</span> app.processName;</span><br><span class="line">    <span class="comment">// 注册 Binder 死亡监听</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">AppDeathRecipient</span> <span class="variable">adr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppDeathRecipient</span>(</span><br><span class="line">                app, pid, thread);</span><br><span class="line">        thread.asBinder().linkToDeath(adr, <span class="number">0</span>);</span><br><span class="line">        app.deathRecipient = adr;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        mProcessList.startProcessLocked(app,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HostingRecord</span>(<span class="string">&quot;link fail&quot;</span>, processName));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);</span><br><span class="line"></span><br><span class="line">    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;</span><br><span class="line">    app.setCurrentSchedulingGroup(app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT);</span><br><span class="line">    app.forcingToImportant = <span class="literal">null</span>;</span><br><span class="line">    updateProcessForegroundLocked(app, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    app.hasShownUi = <span class="literal">false</span>;</span><br><span class="line">    app.setDebugging(<span class="literal">false</span>);</span><br><span class="line">    app.cached = <span class="literal">false</span>;</span><br><span class="line">    app.killedByAm = <span class="literal">false</span>;</span><br><span class="line">    app.killed = <span class="literal">false</span>;</span><br><span class="line">    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);</span><br><span class="line"></span><br><span class="line">    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BackupRecord</span> <span class="variable">backupTarget</span> <span class="operator">=</span> mBackupTargets.get(app.userId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.isolatedEntryPoint != <span class="literal">null</span>) &#123;</span><br><span class="line">            thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                    instr2.mClass,</span><br><span class="line">                    profilerInfo, instr2.mArguments,</span><br><span class="line">                    instr2.mWatcher,</span><br><span class="line">                    instr2.mUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, autofillOptions, contentCaptureOptions);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里的 thread ，就是刚从那个新创建进程中传过来的，在当前 system_server 进程中的binder代理对象实例</span></span><br><span class="line"><span class="comment">             * 调用它对应的方法就可以执行到那个新创建进程中去</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 这边是调用过去通知它可以创建那边的 Application 了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, <span class="literal">null</span>, profilerInfo,</span><br><span class="line">                    <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, autofillOptions, contentCaptureOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (profilerInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            profilerInfo.closeFd();</span><br><span class="line">            profilerInfo = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ProcessRecord # makeActive</span></span><br><span class="line"><span class="comment">         * 这样的话后续就可以获取该 IApplicationThread 了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        app.makeActive(thread, mProcessStats);</span><br><span class="line">        checkTime(startTime, <span class="string">&quot;attachApplicationLocked: immediately after bindApplication&quot;</span>);</span><br><span class="line">        <span class="comment">// 将该 ProcessRecord ，也就是该 IApplicationThread 保存到 mProcessList 中</span></span><br><span class="line">        mProcessList.updateLruProcessLocked(app, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        checkTime(startTime, <span class="string">&quot;attachApplicationLocked: after updateLruProcessLocked&quot;</span>);</span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// todo: Yikes!  What should we do?  For now we will try to</span></span><br><span class="line">        <span class="comment">// start another process, but that could easily get us in</span></span><br><span class="line">        <span class="comment">// an infinite loop of restarting processes...</span></span><br><span class="line">        Slog.wtf(TAG, <span class="string">&quot;Exception thrown during bind of &quot;</span> + app, e);</span><br><span class="line"></span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line">        mProcessList.startProcessLocked(app, <span class="keyword">new</span> <span class="title class_">HostingRecord</span>(<span class="string">&quot;bind-fail&quot;</span>, processName));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this record from the list of starting applications.</span></span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_PROCESSES &amp;&amp; mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES,</span><br><span class="line">            <span class="string">&quot;Attach application locked removing on hold: &quot;</span> + app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * badApp 默认是false，如果接下来的 startActivity、startService 。。。。 </span></span><br><span class="line"><span class="comment">     * 等逻辑操作时有一个遇到异常，那么就会置为true，那么就不会尝试后面的其他逻辑了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">badApp</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">didSomething</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面绑定完成 Application 后，表示新创建的进程ok啦，现在接着执行创建进程之前需要做的事儿，</span></span><br><span class="line"><span class="comment">     * 比如是因为 startActivity 而创建的进程，还是 startService 而创建的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1、完成之前的 Activity 启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 接着去尝试完成之前要启动的那个 Activity</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Exception thrown launching activities in &quot;</span> + app, e);</span><br><span class="line">            badApp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、完成之前的 Service 启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行 startService 剩余的逻辑</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">            checkTime(startTime, <span class="string">&quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Exception thrown starting services in &quot;</span> + app, e);</span><br><span class="line">            badApp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、完成之前的 广播发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">            checkTime(startTime, <span class="string">&quot;attachApplicationLocked: after sendPendingBroadcastsLocked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If the app died trying to launch the receiver we declare it &#x27;bad&#x27;</span></span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Exception thrown dispatching broadcasts in &quot;</span> + app, e);</span><br><span class="line">            badApp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; backupTarget != <span class="literal">null</span> &amp;&amp; backupTarget.app == app) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BACKUP) Slog.v(TAG_BACKUP,</span><br><span class="line">                <span class="string">&quot;New app is backup target, launching agent for &quot;</span> + app);</span><br><span class="line">        notifyPackageUse(backupTarget.appInfo.packageName,</span><br><span class="line">                            PackageManager.NOTIFY_PACKAGE_USE_BACKUP);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.scheduleCreateBackupAgent(backupTarget.appInfo,</span><br><span class="line">                    compatibilityInfoForPackage(backupTarget.appInfo),</span><br><span class="line">                    backupTarget.backupMode, backupTarget.userId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Exception thrown creating backup agent in &quot;</span> + app, e);</span><br><span class="line">            badApp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badApp) &#123;</span><br><span class="line">        app.kill(<span class="string">&quot;error during init&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_PROCESS_BEGIN);</span><br><span class="line">        checkTime(startTime, <span class="string">&quot;attachApplicationLocked: after updateOomAdjLocked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StatsLog.write(</span><br><span class="line">            StatsLog.PROCESS_START_TIME,</span><br><span class="line">            app.info.uid,</span><br><span class="line">            app.pid,</span><br><span class="line">            app.info.packageName,</span><br><span class="line">            StatsLog.PROCESS_START_TIME__TYPE__COLD,</span><br><span class="line">            app.startTime,</span><br><span class="line">            (<span class="type">int</span>) (bindApplicationTimeMillis - app.startTime),</span><br><span class="line">            (<span class="type">int</span>) (SystemClock.elapsedRealtime() - app.startTime),</span><br><span class="line">            app.hostingRecord.getType(),</span><br><span class="line">            (app.hostingRecord.getName() != <span class="literal">null</span> ? app.hostingRecord.getName() : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 attachApplication() 方法中主要完成两部分逻辑：</p>
<p>① 调用 thread.bindApplication() 方法来通知刚才新创建好的那个进程，可以去完成其内部的 Application 等实例的创建了，并且还会将传入的“联系方式” thread 保存到 mProcessList 中去，这样的话后续就可以从 mProcessList 中查找到这个新创建的进程的“联系方式” 来通知它一些事情了。</p>
<p>② 完成之前在 system_server 中没完成的事儿，比如之前启动 Activity 遇到了需要新创建进程的情况，或者之前启动 Service 遇到了需要新创建进程的情况等。此时去接着完成 Activity 、Service 的创建工作。而对于本文来说，就是去完成剩余没执行完的 Service 创建工作。</p>
<p>实际是执行了 mServices.attachApplicationLocked() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">didSomething</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断之前是否还有没启动的 Service </span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">ServiceRecord</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历这些没启动的 Service</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr = mPendingServices.get(i);</span><br><span class="line">                <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理一个删一个</span></span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.longVersionCode,</span><br><span class="line">                        mAm.mProcessStats);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 然后挨个去调用 realStartServiceLocked 方法来完成启动</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                realStartServiceLocked(sr, proc, sr.createdFromFg);</span><br><span class="line">                didSomething = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!isServiceNeededLocked(sr, <span class="literal">false</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    bringDownServiceLocked(sr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Exception in new application when starting service &quot;</span></span><br><span class="line">                    + sr.shortInstanceName, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;mRestartingServices.size(); i++) &#123;</span><br><span class="line">            sr = mRestartingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                    || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.mHandler.removeCallbacks(sr.restarter);</span><br><span class="line">            mAm.mHandler.post(sr.restarter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会去遍历 mPendingServices 列表中之前存储的，待创建的 Service 信息。然后挨个去调用 realStartServiceLocked() 方法来完成创建工作。</p>
<p>而 mPendingServices  列表在前面的 bringUpServiceLocked() 方法中讲过了，其内部在创建进程成功后，会将待创建的 Service 信息保存到 mPendingServices 列表中，等待这里去消费掉。</p>
<p>而另外的 realStartServiceLocked()  方法也在前面讲过了，至此我们就完成了  startService() 方法的源码分析。</p>
<h2 id="stopService"><a href="#stopService" class="headerlink" title="stopService"></a>stopService</h2><p>前面使用 startService() 方法启动了 Service ，等后续需要停止掉它时，就可以使用当前 stopService() 方法来停止掉它了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">stopService</span><span class="params">(Intent service)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> stopServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">stopServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 还是去校验输入的 Intent 的合法性</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 调用到 ActivityManagerService 中的 stopService 方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> ActivityManager.getService().stopService(</span><br><span class="line">            mMainThread.getApplicationThread(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 处理启动的返回值</span></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(</span><br><span class="line">                    <span class="string">&quot;Not allowed to stop service &quot;</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是先去调用 validateServiceIntent() 方法来校验入参 Intent 的合法性，然后调用到 ActivityManagerService 中的 stopService() 内去执行剩余逻辑。注意这里传入的第一个参数是 mMainThread.getApplicationThread() ，也就是前面讲到的  ActivityThread 中的 ApplicationThread 实例 mAppThread，也就是将当前调用方进程的 “联系方式”发送给 ActivityManagerService 了 。</p>
<p>注意此时是从发起方进程转到了 system_server 进程中去执行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">stopService</span><span class="params">(IApplicationThread caller, Intent service,</span></span><br><span class="line"><span class="params">        String resolvedType, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;stopService&quot;</span>);</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;File descriptors passed in Intent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.stopServiceLocked(caller, service, resolvedType, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stopServiceLocked</span><span class="params">(IApplicationThread caller, Intent service,</span></span><br><span class="line"><span class="params">        String resolvedType, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;stopService: &quot;</span> + service</span><br><span class="line">            + <span class="string">&quot; type=&quot;</span> + resolvedType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到该 IApplicationThread 对应的之前保存的 ProcessRecord</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">callerApp</span> <span class="operator">=</span> mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="literal">null</span> &amp;&amp; callerApp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(</span><br><span class="line">                <span class="string">&quot;Unable to find app for caller &quot;</span> + caller</span><br><span class="line">                + <span class="string">&quot; (pid=&quot;</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">&quot;) when stopping service &quot;</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到该 Service 相关的信息</span></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">r</span> <span class="operator">=</span> retrieveServiceLocked(service, <span class="literal">null</span>, resolvedType, <span class="literal">null</span>,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.record != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用到 stopServiceLocked() 方法中去</span></span><br><span class="line">                stopServiceLocked(r.record);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成功则返回 1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到 ActivityManagerService  中之后，还是老套路，直接调用到 ActiveServices 中，在 stopServiceLocked() 方法中，首先会通过传入的 IApplicationThread 实例，也就是调用方的信息，去查找它对应的 ProcessRecord 实例，这里能查到是因为之前启动时，将其信息保存过，前面也讲过了。</p>
<p>接着就是调用 stopServiceLocked() 方法去完成剩余的逻辑了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopServiceLocked</span><span class="params">(ServiceRecord service)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (service.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) </span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">&quot;Delaying stop of pending: &quot;</span> + service);</span><br><span class="line">        service.delayedStop = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StatsLog.write(StatsLog.SERVICE_STATE_CHANGED, service.appInfo.uid,</span><br><span class="line">            service.name.getPackageName(), service.name.getClassName(),</span><br><span class="line">            StatsLog.SERVICE_STATE_CHANGED__STATE__STOP);</span><br><span class="line">    <span class="keyword">synchronized</span> (service.stats.getBatteryStats()) &#123;</span><br><span class="line">        service.stats.stopRunningLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    service.startRequested = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (service.tracker != <span class="literal">null</span>) &#123;</span><br><span class="line">        service.tracker.setStarted(<span class="literal">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    service.callStart = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到这里去 bringDownServiceIfNeededLocked</span></span><br><span class="line">    bringDownServiceIfNeededLocked(service, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bringDownServiceIfNeededLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> knowConn,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hasConn)</span> &#123;</span><br><span class="line">    <span class="comment">//Slog.i(TAG, &quot;Bring down service:&quot;);</span></span><br><span class="line">    <span class="comment">//r.dump(&quot;  &quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该 Service 是否还需要存活着，不能被停止，那么直接返回吧</span></span><br><span class="line">    <span class="keyword">if</span> (isServiceNeededLocked(r, knowConn, hasConn)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该 Service 是否刚被启动，目前正处于等待其进程创建成功的过程中</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成剩余逻辑</span></span><br><span class="line">    bringDownServiceLocked(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isServiceNeededLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> knowConn,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hasConn)</span> &#123;</span><br><span class="line">    <span class="comment">// 已经被要求去停止了，则不需要再次处理</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!knowConn) &#123;</span><br><span class="line">        hasConn = r.hasAutoCreateConnections();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该 Service 之前被绑定过了，则判断它现在是否还有unbind的连接</span></span><br><span class="line">    <span class="keyword">if</span> (hasConn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是完成真正停止工作之前的一些检查工作，比如检查该 Serivce 是否还被绑定着，当前 Service 是否在 mPendingServices 列表中，即它刚被启动正在等待它对应的进程创建成功中，此时忽略掉 stopService() 操作。检查完这些没问题之后再去执行剩余的工作：bringDownServiceLocked()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bringDownServiceLocked</span><span class="params">(ServiceRecord r)</span> &#123;</span><br><span class="line">    <span class="comment">//Slog.i(TAG, &quot;Bring down service:&quot;);</span></span><br><span class="line">    <span class="comment">//r.dump(&quot;  &quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 能走到这里表示确实该停止当前 Service 了，断开其 ConnectionRecord 中的连接</span></span><br><span class="line">    ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">conni</span> <span class="operator">=</span> connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; c = connections.valueAt(conni);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;c.size(); i++) &#123;</span><br><span class="line">            <span class="type">ConnectionRecord</span> <span class="variable">cr</span> <span class="operator">=</span> c.get(i);</span><br><span class="line">            cr.serviceDead = <span class="literal">true</span>;</span><br><span class="line">            cr.stopAssociation();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cr.conn.connected(r.name, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Failure disconnecting service &quot;</span> + r.shortInstanceName</span><br><span class="line">                      + <span class="string">&quot; to connection &quot;</span> + c.get(i).conn.asBinder()</span><br><span class="line">                      + <span class="string">&quot; (in &quot;</span> + c.get(i).binding.client.processName + <span class="string">&quot;)&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 能走到这里表示确实该停止当前 Service 了，通知到 Service 进程</span></span><br><span class="line">    <span class="comment">// 因此通知该 Service 对应的 ServiceConnection 中的 onServiceDisconnected 方法</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span> &amp;&amp; r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needOomAdj</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r.bindings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">IntentBindRecord</span> <span class="variable">ibr</span> <span class="operator">=</span> r.bindings.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;Bringing down binding &quot;</span> + ibr</span><br><span class="line">                    + <span class="string">&quot;: hasBound=&quot;</span> + ibr.hasBound);</span><br><span class="line">            <span class="keyword">if</span> (ibr.hasBound) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bumpServiceExecutingLocked(r, <span class="literal">false</span>, <span class="string">&quot;bring down unbind&quot;</span>);</span><br><span class="line">                    needOomAdj = <span class="literal">true</span>;</span><br><span class="line">                    ibr.hasBound = <span class="literal">false</span>;</span><br><span class="line">                    ibr.requested = <span class="literal">false</span>;</span><br><span class="line">                    r.app.thread.scheduleUnbindService(r,</span><br><span class="line">                            ibr.intent.getIntent());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Exception when unbinding service &quot;</span></span><br><span class="line">                            + r.shortInstanceName, e);</span><br><span class="line">                    serviceProcessGoneLocked(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needOomAdj) &#123;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="literal">true</span>,</span><br><span class="line">                    OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消掉该服务的重启任务</span></span><br><span class="line">    unscheduleServiceRestartLocked(r, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 mPendingServices 中移除掉，当然这里只是兜底操作，一般 mPendingServices 中不会有这个服务的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPendingServices.get(i) == r) &#123;</span><br><span class="line">            mPendingServices.remove(i);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;Removed pending: &quot;</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.stopLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        r.app.services.remove(r);</span><br><span class="line">        r.app.updateBoundClientUids();</span><br><span class="line">        <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">            updateWhitelistManagerLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            updateServiceForegroundLocked(r.app, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 准备开始检测 ANR</span></span><br><span class="line">                bumpServiceExecutingLocked(r, <span class="literal">false</span>, <span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">                mDestroyingServices.add(r);</span><br><span class="line">                r.destroying = <span class="literal">true</span>;</span><br><span class="line">                mAm.updateOomAdjLocked(r.app, <span class="literal">true</span>,</span><br><span class="line">                        OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">                <span class="comment">// 执行到 service 进程中去执行其 onDestroy 方法</span></span><br><span class="line">                r.app.thread.scheduleStopService(r);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Exception when destroying service &quot;</span></span><br><span class="line">                        + r.shortInstanceName, e);</span><br><span class="line">                serviceProcessGoneLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                TAG_SERVICE, <span class="string">&quot;Removed service that has no process: &quot;</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">            TAG_SERVICE, <span class="string">&quot;Removed service that is not running: &quot;</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收尾工作</span></span><br><span class="line">    <span class="keyword">if</span> (r.bindings.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r.bindings.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.restarter <span class="keyword">instanceof</span> ServiceRestarter) &#123;</span><br><span class="line">       ((ServiceRestarter)r.restarter).setService(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">memFactor</span> <span class="operator">=</span> mAm.mProcessStats.getMemFactorLocked();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (r.tracker != <span class="literal">null</span>) &#123;</span><br><span class="line">        r.tracker.setStarted(<span class="literal">false</span>, memFactor, now);</span><br><span class="line">        r.tracker.setBound(<span class="literal">false</span>, memFactor, now);</span><br><span class="line">        <span class="keyword">if</span> (r.executeNesting == <span class="number">0</span>) &#123;</span><br><span class="line">            r.tracker.clearCurrentOwner(r, <span class="literal">false</span>);</span><br><span class="line">            r.tracker = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前 bringDownServiceLocked() 方法中代码很长，但主要完成的是三件事儿：</p>
<p>① 如果该 Service 之前被绑定过，那么在它被真正停止之前通过调用  r.app.thread.scheduleUnbindService()  方法来通知 Service 进程那边去执行该服务之前绑定时对应的 ServiceConnection 中的 onServiceDisconnected() 方法。</p>
<p>该方法的逻辑这里先跳过，等后面分析 bindService() 服务绑定情况时再分析。</p>
<p>② 调用 unscheduleServiceRestartLocked() 方法来取消掉该服务可能存在的重启任务，因为服务在启动时可以指定它的重启策略。</p>
<p>③ 调用 r.app.thread.scheduleStopService() 方法来调用到 Service 进程中，执行它的 onDestroy() 方法。</p>
<blockquote>
<p>注意，上面第①步第③步中，都会调用到 Service 进程中去，但在调用过去之前，都会调用 bumpServiceExecutingLocked() 方法来进行  ANR 监测的，他不是本文的重点，所以我这里仅仅提一下就行。</p>
</blockquote>
<p>而我们接下来的重心就是第③步的分析，scheduleStopService() 方法最终会调用到 Service 进程中的 ActivityThread 中的 ApplicationThread 中的 scheduleStopService() 方法内，然后会往 ActivityThread 中的 mH 中发送一条 H.STOP_SERVICE 消息，进而执行到 handleStopService() 方法内，这段代码我就不贴了，我们直接看最终的  handleStopService() 方法就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleStopService</span><span class="params">(IBinder token)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到之前保存的该 Service  实例</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.remove(token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Destroying service &quot;</span> + s);</span><br><span class="line">            <span class="comment">// 调用该 Service  的 onDestroy() 方法</span></span><br><span class="line">            s.onDestroy();</span><br><span class="line">            s.detachAndCleanUp();</span><br><span class="line">            <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> s.getBaseContext();</span><br><span class="line">            <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">who</span> <span class="operator">=</span> s.getClassName();</span><br><span class="line">                ((ContextImpl) context).scheduleFinalCleanup(who, <span class="string">&quot;Service&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通知到 ActivityManagerService 那边，告诉他我执行完毕啦</span></span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        token, SERVICE_DONE_EXECUTING_STOP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                        <span class="string">&quot;Unable to stop service &quot;</span> + s</span><br><span class="line">                        + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;handleStopService: exception for &quot;</span> + token, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;handleStopService: token=&quot;</span> + token + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Slog.i(TAG, &quot;Running services: &quot; + mServices);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑很简单吧？那我问你这里为啥这里能从 mServices 中查找到对应的 Service 实例呢？</p>
<p>这个方法就不解释了，和之前的套路一样的。</p>
<h2 id="bindService"><a href="#bindService" class="headerlink" title="bindService"></a>bindService</h2><p>这种方式是将当前 Context 和该服务绑定起来，一般用于两者之间要进行通讯的情况。</p>
<p>接下来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, <span class="literal">null</span>, mMainThread.getHandler(), <span class="literal">null</span>,</span><br><span class="line">            getUser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        String instanceName, Handler handler, Executor executor, UserHandle user)</span> &#123;</span><br><span class="line">    <span class="comment">// Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;connection is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="literal">null</span> &amp;&amp; executor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Handler and Executor both supplied&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建或者拿到该 context 对应的 ServiceDispatcher 中的 IServiceConnection 实例</span></span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Not supported in system context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验入参 Intent</span></span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">token</span> <span class="operator">=</span> getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 还是调用到 ActivityManagerService 中去</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> ActivityManager.getService().bindIsolatedService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, instanceName, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(</span><br><span class="line">                    <span class="string">&quot;Not allowed to bind to service &quot;</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 bindService() 中，主要就是两步：</p>
<p>① 拿到该入参 ServiceConnection conn 实例对应的 IServiceConnection 实例 ，具体是通过 mPackageInfo.getServiceDispatcher() 方法先创建或者获取 conn  对应的  ServiceDispatcher 实例，再获取其 IServiceConnection 实例。</p>
<p>② 调用到 ActivityManagerService 中去，额外会将拿到的 IServiceConnection  实例发送过去。</p>
<p>接下来我们先看  mPackageInfo.getServiceDispatcher() 方法中的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// android.app.LoadedApk.java</span><br><span class="line"></span><br><span class="line">private final ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices = new ArrayMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">private IServiceConnection getServiceDispatcherCommon(ServiceConnection c,</span><br><span class="line">        Context context, Handler handler, Executor executor, int flags) &#123;</span><br><span class="line">    synchronized (mServices) &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = null;</span><br><span class="line">        // 拿到该 context 对应的 ArrayMap 实例，拿到这个 map 就可以再通过 ServiceConnection 去查找对应的 ServiceDispatcher 了</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        if (map != null) &#123;</span><br><span class="line">            if (DEBUG) Slog.d(TAG, &quot;Returning existing dispatcher &quot; + sd + &quot; for conn &quot; + c);</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果该 ServiceConnection 之前没有创建过 ServiceDispatcher，那么这里给他创建一个新的  ServiceDispatcher 实例</span><br><span class="line">        if (sd == null) &#123;</span><br><span class="line">            if (executor != null) &#123;</span><br><span class="line">                sd = new ServiceDispatcher(c, context, executor, flags);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /**</span><br><span class="line">                 * 其实就是把入参 connection 、 handler等封装在一起</span><br><span class="line">                 */</span><br><span class="line">                sd = new ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG) Slog.d(TAG, &quot;Creating new dispatcher &quot; + sd + &quot; for conn &quot; + c);</span><br><span class="line">            if (map == null) &#123;</span><br><span class="line">                map = new ArrayMap&lt;&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            // 最后将其保存起来，后续就可以再拿出来使用了</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sd.validate(context, handler, executor);</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回这个 ServiceDispatcher 中的 mIServiceConnection 实例</span><br><span class="line">        return sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑比较简单，在 LoadedApk 实例中存在一个 mServices 成员属性，该属性中使用了两层缓存，第一层key是 context ，value 是 Map ； 二级缓存key是 ServiceConnection ，value 是 ServiceDispatcher 实例。所以一般是通过 context 来先获取 Map ，在使用 ServiceConnection  实例来获取其最终对应的  ServiceDispatcher 实例，也就是说一个 context 中可以 bindService() 多个 Service ，设置多个 ServiceConnection ，这也符合我们的认知。</p>
<p>而如果该 ServiceConnection   没查找到 ServiceDispatcher  实例的话，则会为其创建一个保存起来。最后返回的时 ServiceDispatcher 实例中的 mIServiceConnection 属性实例。</p>
<h3 id="ServiceDispatcher"><a href="#ServiceDispatcher" class="headerlink" title="ServiceDispatcher"></a>ServiceDispatcher</h3><p>接下来看看这个 ServiceDispatcher  是何方神圣：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.LoadedApk.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceDispatcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDispatcher.InnerConnection mIServiceConnection;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceConnection mConnection;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mActivityThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor mActivityExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceConnectionLeaked mLocation;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RuntimeException mUnbindLocation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mForgotten;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConnectionInfo</span> &#123;</span><br><span class="line">        IBinder binder;</span><br><span class="line">        IBinder.DeathRecipient deathMonitor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承自 IServiceConnection.Stub ，也就是说它是 IServiceConnection 的 Server 端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerConnection</span> <span class="keyword">extends</span> <span class="title class_">IServiceConnection</span>.Stub &#123;</span><br><span class="line">        <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">        <span class="keyword">final</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">        InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">            mDispatcher = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span></span><br><span class="line">                <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">            LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> mDispatcher.get();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 调用到 ServiceDispatcher 实例中的 connected() 方法中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (sd != <span class="literal">null</span>) &#123;</span><br><span class="line">                sd.connected(name, service, dead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    ServiceDispatcher(ServiceConnection conn,</span><br><span class="line">            Context context, Handler activityThread, <span class="type">int</span> flags) &#123;</span><br><span class="line">        mIServiceConnection = <span class="keyword">new</span> <span class="title class_">InnerConnection</span>(<span class="built_in">this</span>);</span><br><span class="line">        mConnection = conn;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mActivityThread = activityThread;</span><br><span class="line">        mActivityExecutor = <span class="literal">null</span>;</span><br><span class="line">        mLocation = <span class="keyword">new</span> <span class="title class_">ServiceConnectionLeaked</span>(<span class="literal">null</span>);</span><br><span class="line">        mLocation.fillInStackTrace();</span><br><span class="line">        mFlags = flags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ServiceDispatcher 的构造方法中，会将入参保存起来，同时还会为其内部的 mIServiceConnection 属性创建实例，也就是 InnerConnection 实例。</p>
<p>而 InnerConnection 它是继承自 IServiceConnection.Stub 的，如果你熟悉 Binder 的话，就可能知道它其实就是 IServiceConnection 的 Server 端实现，后续可以将该 InnerConnection 实例通过 Binder 传输，也就是作为 匿名Binder 来使用，在另外一端可以拿到该  IServiceConnection.Stub 的代理对象，那么它作为 IServiceConnection 的 Client 端后续就可以调用通知到这里了。如果你不熟悉 Binder的话，建议你去看看：<a href="4ee2033c.html">这篇文章中的 Binder系列文章</a> 中的分析。</p>
<p>而在 IServiceConnection 接口中，或者说是在 IServiceConnection.aidl 中，只定义了一个 connected() 方法，因此Binder Client 端就可以调用其Binder代理对象实例的 connected() 方法来通知这边Service的连接状态变化了。而在这边 Server 端的实现中，会调用到 ServiceDispatcher 中的 connected() 方法内来处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.LoadedApk.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    <span class="comment">// 有指定线程处理器的话，则交给他们去处理</span></span><br><span class="line">    <span class="keyword">if</span> (mActivityExecutor != <span class="literal">null</span>) &#123;</span><br><span class="line">        mActivityExecutor.execute(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mActivityThread != <span class="literal">null</span>) &#123;</span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当然我们默认只看这里，其实都一样</span></span><br><span class="line">        doConnected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前已解除绑定</span></span><br><span class="line">        <span class="keyword">if</span> (mForgotten) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿到当前 name 对应的 ConnectionInfo ，如果是第一次的话则 old =null</span></span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 service 不为空表示当前是连接成功的通知</span></span><br><span class="line">        <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建一个 ConnectionInfo 实例来保存本次连接的信息</span></span><br><span class="line">            info = <span class="keyword">new</span> <span class="title class_">ConnectionInfo</span>();</span><br><span class="line">            info.binder = service;</span><br><span class="line">            info.deathMonitor = <span class="keyword">new</span> <span class="title class_">DeathMonitor</span>(name, service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 为该服务注册死亡监听</span></span><br><span class="line">                service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 将其保存起来，后续就能查到了</span></span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">// 该服务已死亡，因为 linkToDeath 失败了</span></span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// service 为空，表示当前是连接断开的通知</span></span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// old 不等于 null 表示该服务换了一个 ServiceConnection 来绑定了，所以先将旧的回调断开</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 服务死亡，比如调用了 stopSevice 导致服务终止掉了</span></span><br><span class="line">    <span class="keyword">if</span> (dead) &#123;</span><br><span class="line">        mConnection.onBindingDied(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前是服务连接上的通知，则回调 onServiceConnected</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出在  ServiceDispatcher 中的 connected() 方法内会处理本次 connected() 消息，然后根据参数来执行其内部的 ServiceConnection 的不同方法，比如服务连接成功了，则调用 onServiceConnected() 方法来将Client进程发送来的匿名Binder 对象实例传递进去，这个 匿名Binder 对象实例 就是你在 Service 的 onBind() 方法中返回的Binder实体。外部拿到之后，就可以调用对应的asInterface()方法来将其包装为对应的接口类使用了。</p>
<p>注意你从  onServiceConnected() 方法中拿到的 IBinder 实例去使用时，对于这个  IBinder 接口来说，你是Binder Client 端，而其对应的 Binder Server端就是你的 Service，需要区分好，不要迷糊。</p>
<p>好了接下来回到 bindServiceCommon() 方法中接着看第②步：调用到 ActivityManagerService 中的 bindIsolatedService() 方法内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bindIsolatedService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span><br><span class="line"><span class="params">        String resolvedType, IServiceConnection connection, <span class="type">int</span> flags, String instanceName,</span></span><br><span class="line"><span class="params">        String callingPackage, <span class="type">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;bindService&quot;</span>);</span><br><span class="line">    <span class="comment">// 还是做合法性校验</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;File descriptors passed in Intent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;callingPackage cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instanceName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; instanceName.length(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> instanceName.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!((c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                        || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) || c == <span class="string">&#x27;_&#x27;</span> || c == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal instanceName&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 跟startService一样，将真正的启动请求转发到 ActiveServices 中去执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, instanceName, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里并没有做太多工作，主要还是转交到了 ActiveServices 中。另外需要注意两点：</p>
<p>① 目前是从 调用方 进程中切换到了 system_server 进程中来处理了</p>
<p>② 入参 connection 就是上面分析的 ServiceDispatcher 实例中的 mIServiceConnection ，也就是 IServiceConnection 在当前进程的代理对象实例。</p>
<p>接着往后看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span><br><span class="line"><span class="params">        String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        String instanceName, String callingPackage, <span class="keyword">final</span> <span class="type">int</span> userId)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;bindService: &quot;</span> + service</span><br><span class="line">            + <span class="string">&quot; type=&quot;</span> + resolvedType + <span class="string">&quot; conn=&quot;</span> + connection.asBinder()</span><br><span class="line">            + <span class="string">&quot; flags=0x&quot;</span> + Integer.toHexString(flags));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是通过 IApplicationThread 去查找调用方的进程信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">callerApp</span> <span class="operator">=</span> mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="keyword">if</span> (callerApp == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(</span><br><span class="line">                <span class="string">&quot;Unable to find app for caller &quot;</span> + caller</span><br><span class="line">                + <span class="string">&quot; (pid=&quot;</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">&quot;) when binding service &quot;</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityServiceConnectionsHolder&lt;ConnectionRecord&gt; activity = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token 不为 null，代表发起方具有 activity 类型的上下文对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">        activity = mAm.mAtmInternal.getServiceConnectionsHolder(token);</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="literal">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Binding with unknown activity: &quot;</span> + token);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">clientLabel</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">PendingIntent</span> <span class="variable">clientIntent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isCallerSystem</span> <span class="operator">=</span> callerApp.info.uid == Process.SYSTEM_UID;</span><br><span class="line">    <span class="comment">// 省略一些权限检查工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据发起方传递过来的intent构建 ServiceRecord 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">        retrieveServiceLocked(service, instanceName, resolvedType, callingPackage,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="literal">true</span>,</span><br><span class="line">                callerFg, isBindExternal, allowInstant);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">s</span> <span class="operator">=</span> res.record;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">permissionsReviewRequired</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有权限要求，则会去请求权限成功后再去执行其内部的 RemoteCallback 中的 onResult 中的方法</span></span><br><span class="line">    <span class="keyword">if</span> (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">            s.packageName, s.userId)) &#123;</span><br><span class="line"></span><br><span class="line">        permissionsReviewRequired = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show a permission review UI only for binding from a foreground app</span></span><br><span class="line">        <span class="keyword">if</span> (!callerFg) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;u&quot;</span> + s.userId + <span class="string">&quot; Binding to a service in package&quot;</span></span><br><span class="line">                    + s.packageName + <span class="string">&quot; requires a permissions review&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServiceRecord</span> <span class="variable">serviceRecord</span> <span class="operator">=</span> s;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">serviceIntent</span> <span class="operator">=</span> service;</span><br><span class="line"></span><br><span class="line">        <span class="type">RemoteCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteCallback</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RemoteCallback</span>.OnResultListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResult</span><span class="params">(Bundle result)</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">identity</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mPendingServices.contains(serviceRecord)) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!mAm.getPackageManagerInternalLocked()</span><br><span class="line">                                .isPermissionsReviewRequired(</span><br><span class="line">                                        serviceRecord.packageName,</span><br><span class="line">                                        serviceRecord.userId)) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                              	<span class="comment">// 权限结束之后会去尝试启动 service，</span></span><br><span class="line">                                bringUpServiceLocked(serviceRecord,</span><br><span class="line">                                        serviceIntent.getFlags(),</span><br><span class="line">                                        callerFg, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                                <span class="comment">/* ignore - local call */</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            unbindServiceLocked(connection);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        Binder.restoreCallingIdentity(identity);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求权限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK</span><br><span class="line">                | Intent.FLAG_ACTIVITY_MULTIPLE_TASK</span><br><span class="line">                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PERMISSIONS_REVIEW) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;u&quot;</span> + s.userId + <span class="string">&quot; Launching permission review for package &quot;</span></span><br><span class="line">                    + s.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAm.mHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                mAm.mContext.startActivityAsUser(intent, <span class="keyword">new</span> <span class="title class_">UserHandle</span>(userId));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AppBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        <span class="type">ConnectionRecord</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionRecord</span>(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent,</span><br><span class="line">                callerApp.uid, callerApp.processName, callingPackage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为本地绑定创建一个 ConnectionRecord ，存入到 ServiceRecord 中</span></span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> connection.asBinder();</span><br><span class="line">        s.addConnection(binder, c);</span><br><span class="line">        b.connections.add(c);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">            activity.addConnection(c);</span><br><span class="line">        &#125;</span><br><span class="line">        b.client.connections.add(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 省略其他代码</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">                <span class="comment">// 执行到这里去完成后续真正的绑定逻辑</span></span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;</span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里主要就是一些初始化工作，比如为本次绑定创建一些属性保存起来，供后续 unbind 时使用。最后还是会调用到 requestServiceBindingLocked() 方法去完成最终的绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/ com.android.server.am.ActiveServices.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> execInFg, <span class="type">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="comment">// service 进程没了，没法绑定</span></span><br><span class="line">    <span class="keyword">if</span> (r.app == <span class="literal">null</span> || r.app.thread == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.d(TAG_SERVICE, <span class="string">&quot;requestBind &quot;</span> + i + <span class="string">&quot;: requested=&quot;</span> + i.requested</span><br><span class="line">            + <span class="string">&quot; rebind=&quot;</span> + rebind);</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 监测 onBind() 方法的 ANR</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行到 Service 当前正在运行的进程中去</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.getReportedProcState());</span><br><span class="line">            <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                i.requested = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = <span class="literal">true</span>;</span><br><span class="line">            i.doRebind = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;Crashed while binding &quot;</span> + r, e);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inDestroying</span> <span class="operator">=</span> mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;Crashed while binding &quot;</span> + r);</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inDestroying</span> <span class="operator">=</span> mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是会调用到 Service 进程中的 ActivityThread 中的 ApplicationThread 中的 scheduleBindService() 方法内，然后会往 ActivityThread 中的 mH 中发送一条 H.BIND_SERVICE 消息，进而执行到 handleBindService() 方法内，这段代码我就不贴了，我们直接看最终的  handleBindService() 方法就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到之前保存的 service 实例</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, <span class="string">&quot;handleBindService s=&quot;</span> + s + <span class="string">&quot; rebind=&quot;</span> + data.rebind);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 该 Service 是第一次被绑定</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 先回调 onBind() 方法，拿到 Service 端返回的 IBinder 对象实例</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> s.onBind(data.intent);</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 然后将拿到的 IBinder 实例传递到 ActivityManagerService 中 publishService 方法中</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 回调 onRebind</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    <span class="comment">// 通知 ActivityManagerService 我们执行成功了</span></span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                        <span class="string">&quot;Unable to bind to service &quot;</span> + s</span><br><span class="line">                        + <span class="string">&quot; with &quot;</span> + data.intent + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 system_server 进程执行到了 service 运行的进程中来，此时会根据该 Service 是否是第一次被绑定来执行不同的逻辑：</p>
<p>① 第一次被绑定，则需要调用其 onBind() 方法拿到其返回的 IBinder 实例， 这个 IBinder 实例最终是要返回给 bindService() 调用方的。</p>
<p>此时是通过调用 ActivityManagerService 的 publishService() 方法来通知到 ActivityManagerService 的。</p>
<p>② 不是第一次绑定，且上次 unbind 时其内部的 onUnbind() 方法返回了 true， 则需要调用其 onRebind() 方法，最后再调用 ActivityManagerService 的 serviceDoneExecuting() 方法来通知 ActivityManagerService 我这边完事儿了。</p>
<p>而 serviceDoneExecuting() 方法前面都讲过了，因此我们接下来主要看 publishService() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> &#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="literal">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;File descriptors passed in Intent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid service token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将逻辑执行转移到 ActiveServices 中去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;PUBLISHING &quot;</span> + r</span><br><span class="line">                + <span class="string">&quot; &quot;</span> + intent + <span class="string">&quot;: &quot;</span> + service);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">            Intent.<span class="type">FilterComparison</span> <span class="variable">filter</span></span><br><span class="line">                    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>.FilterComparison(intent);</span><br><span class="line">            <span class="type">IntentBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = <span class="literal">true</span>;</span><br><span class="line">                b.received = <span class="literal">true</span>;</span><br><span class="line">                ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">conni</span> <span class="operator">=</span> connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        <span class="type">ConnectionRecord</span> <span class="variable">c</span> <span class="operator">=</span> clist.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                    TAG_SERVICE, <span class="string">&quot;Not publishing to: &quot;</span> + c);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                    TAG_SERVICE, <span class="string">&quot;Bound intent: &quot;</span> + c.binding.intent.intent);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                    TAG_SERVICE, <span class="string">&quot;Published intent: &quot;</span> + intent);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;Publishing to: &quot;</span> + c);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//  通知到 bindService 发起方进程中去</span></span><br><span class="line">                            c.conn.connected(r.name, service, <span class="literal">false</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            Slog.w(TAG, <span class="string">&quot;Failure sending service &quot;</span> + r.shortInstanceName</span><br><span class="line">                                  + <span class="string">&quot; to connection &quot;</span> + c.conn.asBinder()</span><br><span class="line">                                  + <span class="string">&quot; (in &quot;</span> + c.binding.client.processName + <span class="string">&quot;)&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还是执行到 serviceDoneExecutingLocked</span></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终逻辑就两步：</p>
<p>① 调用 c.conn.connected() 方法来通知到刚才调用 bindService() 范发给的发起方进程中的 ServiceDispatcher 实例中的  InnerConnection 。然后它那边进程中就会回调 onServiceConnected() 方法，来讲刚拿到的这个 Binder 对象实例了。</p>
<p>② 调用 serviceDoneExecutingLocked() 方法完成后续逻辑。该方法前面讲过了。</p>
<p>至此就完成了 bindService() 的逻辑分析。</p>
<h2 id="unbindService"><a href="#unbindService" class="headerlink" title="unbindService"></a>unbindService</h2><p>该方法与上面的 bindService() 方法相对应，用来解除服务绑定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unbindService</span><span class="params">(ServiceConnection conn)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;connection is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 拿到该 ServiceConnection 之前 bindService 时创建的 IServiceConnection 实例</span></span><br><span class="line">        <span class="type">IServiceConnection</span> <span class="variable">sd</span> <span class="operator">=</span> mPackageInfo.forgetServiceDispatcher(</span><br><span class="line">                getOuterContext(), conn);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用到 ActivityManagerService 中去</span></span><br><span class="line">            ActivityManager.getService().unbindService(sd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Not supported in system context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面就做了两步：</p>
<p>① 拿到之前 bindService() 时，为 ServiceConnection 创建的那个 ServiceDispatcher 实例中的 IServiceConnection 实例。</p>
<p>② 调用到 ActivityManagerService 中去执行剩余逻辑。</p>
<p>注意接下来的逻辑就会从 调用方进程 切换到 system_server 进程中去执行了 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">unbindService</span><span class="params">(IServiceConnection connection)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.unbindServiceLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">unbindServiceLocked</span><span class="params">(IServiceConnection connection)</span> &#123;</span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> connection.asBinder();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;unbindService: conn=&quot;</span> + binder);</span><br><span class="line">    <span class="comment">// 拿到该 IServiceConnection 之前绑定时创建的 ConnectionRecord 列表</span></span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist == <span class="literal">null</span>) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Unbind failed: could not find connection for &quot;</span></span><br><span class="line">              + connection.asBinder());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (clist.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ConnectionRecord</span> <span class="variable">r</span> <span class="operator">=</span> clist.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行移除逻辑，内部会触发 unbind 逻辑</span></span><br><span class="line">            removeConnectionLocked(r, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除成功之后，执行收尾工作</span></span><br><span class="line">            <span class="keyword">if</span> (clist.size() &gt; <span class="number">0</span> &amp;&amp; clist.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line">                <span class="comment">// In case it didn&#x27;t get removed above, do it now.</span></span><br><span class="line">                Slog.wtf(TAG, <span class="string">&quot;Connection &quot;</span> + r + <span class="string">&quot; not removed for binder &quot;</span> + binder);</span><br><span class="line">                clist.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.binding.service.app != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.binding.service.app.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.binding.service.app);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// This could have made the service less important.</span></span><br><span class="line">                <span class="keyword">if</span> ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                    r.binding.service.app.treatLikeActivity = <span class="literal">true</span>;</span><br><span class="line">                    mAm.updateLruProcessLocked(r.binding.service.app,</span><br><span class="line">                            r.binding.service.app.hasClientActivities()</span><br><span class="line">                            || r.binding.service.app.treatLikeActivity, <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAm.updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 unbindServiceLocked () 方法中，首先会通过入参 IServiceConnection 找到之前 绑定时创建保存的 ConnectionRecord 列表，然后调用 removeConnectionLocked() 方法来完成真正的删除逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeConnectionLocked</span><span class="params">(ConnectionRecord c, ProcessRecord skipApp,</span></span><br><span class="line"><span class="params">        ActivityServiceConnectionsHolder skipAct)</span> &#123;</span><br><span class="line">    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> c.conn.asBinder();</span><br><span class="line">    <span class="type">AppBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> c.binding;</span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">s</span> <span class="operator">=</span> b.service;</span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = s.getConnections().get(binder);</span><br><span class="line">    <span class="comment">// 合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="literal">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            s.removeConnection(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始移除之前创建的实力</span></span><br><span class="line">    b.connections.remove(c);</span><br><span class="line">    c.stopAssociation();</span><br><span class="line">    <span class="keyword">if</span> (c.activity != <span class="literal">null</span> &amp;&amp; c.activity != skipAct) &#123;</span><br><span class="line">        c.activity.removeConnection(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c.serviceDead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;Disconnecting binding &quot;</span> + b.intent</span><br><span class="line">                + <span class="string">&quot;: shouldUnbind=&quot;</span> + b.intent.hasBound);</span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span> &amp;&amp; s.app.thread != <span class="literal">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">                &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(s, <span class="literal">false</span>, <span class="string">&quot;unbind&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span></span><br><span class="line">                        &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123;</span><br><span class="line">                    mAm.updateLruProcessLocked(s.app, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mAm.updateOomAdjLocked(s.app, <span class="literal">true</span>,</span><br><span class="line">                        OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">                b.intent.hasBound = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// Assume the client doesn&#x27;t want to know about a rebind;</span></span><br><span class="line">                <span class="comment">// we will deal with that later if it asks for one.</span></span><br><span class="line">                b.intent.doRebind = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 调用到 Service 运行的进程中去</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Exception when unbinding service &quot;</span> + s.shortInstanceName, e);</span><br><span class="line">                serviceProcessGoneLocked(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除之前保存的待处理的service ，当然一般它现在里面没有该 service</span></span><br><span class="line">        mPendingServices.remove(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasAutoCreate</span> <span class="operator">=</span> s.hasAutoCreateConnections();</span><br><span class="line">            <span class="keyword">if</span> (!hasAutoCreate) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.tracker != <span class="literal">null</span>) &#123;</span><br><span class="line">                    s.tracker.setBound(<span class="literal">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                            SystemClock.uptimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bringDownServiceIfNeededLocked(s, <span class="literal">true</span>, hasAutoCreate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前方法中，清理掉一些属性之后，会通过 s.app.thread.scheduleUnbindService() 方法来通知 Service 。具体是调用到 Service 进程中的 ActivityThread 中的 ApplicationThread 中的 scheduleUnbindService() 方法内，然后会往 ActivityThread 中的 mH 中发送一条 H.UNBIND_SERVICE 消息，进而执行到 handleUnbindService() 方法内，这段代码我就不贴了，我们直接看最终的  handleUnbindService() 方法就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleUnbindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="comment">// 还是先拿到之前保存的 Service 实例</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用该 Service 实例的 onUnbind 方法</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">doRebind</span> <span class="operator">=</span> s.onUnbind(data.intent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通知到 ActivityManagerService 中去</span></span><br><span class="line">                <span class="keyword">if</span> (doRebind) &#123;</span><br><span class="line">                    ActivityManager.getService().unbindFinished(</span><br><span class="line">                            data.token, data.intent, doRebind);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                        <span class="string">&quot;Unable to unbind to service &quot;</span> + s</span><br><span class="line">                        + <span class="string">&quot; with &quot;</span> + data.intent + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意现在从 system_Server 进程执行到了 Service 运行中的进程了。</p>
<p>这里还是先拿到之前启动 Service 时保存的 Service 实例，然后调用其 onUnbind() 方法，拿到返回值：</p>
<p>① 返回值是true 时，表示后续在绑定该 Service 时需要去调用其 onRebind() 方法。这里会调用 ActivityManagerService 中的 unbindFinished() 方法；</p>
<p>② 返回值是false时，表示后续在绑定该 Service 时不需要去调用其 onRebind() 方法。这里会调用 ActivityManagerService 中的 serviceDoneExecuting() 方法；</p>
<p>由于 serviceDoneExecuting() 方法我们在前面讲过了，所以这里我们只看第一种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unbindFinished</span><span class="params">(IBinder token, Intent intent, <span class="type">boolean</span> doRebind)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="literal">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;File descriptors passed in Intent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        mServices.unbindFinishedLocked((ServiceRecord)token, intent, doRebind);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// com.android.server.am.ActiveServices.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unbindFinishedLocked</span><span class="params">(ServiceRecord r, Intent intent, <span class="type">boolean</span> doRebind)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">            Intent.<span class="type">FilterComparison</span> <span class="variable">filter</span></span><br><span class="line">                    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>.FilterComparison(intent);</span><br><span class="line">            <span class="type">IntentBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">&quot;unbindFinished in &quot;</span> + r</span><br><span class="line">                    + <span class="string">&quot; at &quot;</span> + b + <span class="string">&quot;: apps=&quot;</span></span><br><span class="line">                    + (b != <span class="literal">null</span> ? b.apps.size() : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">inDestroying</span> <span class="operator">=</span> mDestroyingServices.contains(r);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b.apps.size() &gt; <span class="number">0</span> &amp;&amp; !inDestroying) &#123;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">inFg</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=b.apps.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="type">ProcessRecord</span> <span class="variable">client</span> <span class="operator">=</span> b.apps.valueAt(i).client;</span><br><span class="line">                        <span class="keyword">if</span> (client != <span class="literal">null</span> &amp;&amp; client.setSchedGroup</span><br><span class="line">                                != ProcessList.SCHED_GROUP_BACKGROUND) &#123;</span><br><span class="line">                            inFg = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这种情况会再去尝试绑定该 service</span></span><br><span class="line">                        requestServiceBindingLocked(r, b, inFg, <span class="literal">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                        <span class="comment">// Don&#x27;t pass this back to ActivityThread, it&#x27;s unrelated.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将 doRebind 置为 true ，下次 bind 时就会在 Service 运行进程中执行 onRebind</span></span><br><span class="line">                    b.doRebind = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 又是执行这个方法</span></span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里，会将 doRebind 置为 true ，那么下次该 Service 被绑定时，会在其最终的 ActivityThread 中的 handleBindService() 方法内去执行该 Service 的 onRebind() 方法，详见上面 bindService() 中的分析。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我们在平时Activity中使用 bindService() 时，经常会忘了 unbindService() ，细心的话你可以发现在页面退出时，会自动解除这些绑定过的 Service，这是怎么实现的呢？</p>
<p>我们来看看 ActivityThread 中的 handleDestroyActivity() 方法中的逻辑，它是在对应的  Activity 要被 finish 退出时调用的，详见：<a href="8f14e4f4.html">Android Activity 启动流程全解析</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDestroyActivity</span><span class="params">(IBinder token, <span class="type">boolean</span> finishing, <span class="type">int</span> configChanges,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> getNonConfigInstance, String reason)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 Activity 的 onDestroy()</span></span><br><span class="line">    <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> performDestroyActivity(token, finishing,</span><br><span class="line">            configChanges, getNonConfigInstance, reason);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Context</span> <span class="variable">c</span> <span class="operator">=</span> r.activity.getBaseContext();</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">          	<span class="comment">// 尝试去清理和该 ContextImpl 有关的对象</span></span><br><span class="line">            ((ContextImpl) c).scheduleFinalCleanup(</span><br><span class="line">                    r.activity.getClass().getName(), <span class="string">&quot;Activity&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">scheduleContextCleanup</span><span class="params">(ContextImpl context, String who,</span></span><br><span class="line"><span class="params">        String what)</span> &#123;</span><br><span class="line">    <span class="type">ContextCleanupInfo</span> <span class="variable">cci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContextCleanupInfo</span>();</span><br><span class="line">    cci.context = context;</span><br><span class="line">    cci.who = who;</span><br><span class="line">    cci.what = what;</span><br><span class="line">    <span class="comment">// 发送一条 CLEAN_UP_CONTEXT 消息到 H 中去</span></span><br><span class="line">    sendMessage(H.CLEAN_UP_CONTEXT, cci);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// android.app.ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">scheduleFinalCleanup</span><span class="params">(String who, String what)</span> &#123;</span><br><span class="line">    mMainThread.scheduleContextCleanup(<span class="built_in">this</span>, who, what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终又执行到了 ActivityThread 中的 scheduleContextCleanup() 方法中，然后往 ActivityThread  中的 mH 中发送一条 H.CLEAN_UP_CONTEXT 消息，最后会切换到主线程中，执行到  cci.context.performFinalCleanup()  方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">performFinalCleanup</span><span class="params">(String who, String what)</span> &#123;</span><br><span class="line">    <span class="comment">//Log.i(TAG, &quot;Cleanup up context: &quot; + this);</span></span><br><span class="line">    mPackageInfo.removeContextRegistrations(getOuterContext(), who, what);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// android.app.LoadedApk.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeContextRegistrations</span><span class="params">(Context context,</span></span><br><span class="line"><span class="params">        String who, String what)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">reportRegistrationLeaks</span> <span class="operator">=</span> StrictMode.vmRegistrationLeaksEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理那些注册的广播，即解除掉这个动态注册的广播监听</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; rmap =</span><br><span class="line">                mReceivers.remove(context);</span><br><span class="line">        <span class="keyword">if</span> (rmap != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rmap.size(); i++) &#123;</span><br><span class="line">                LoadedApk.<span class="type">ReceiverDispatcher</span> <span class="variable">rd</span> <span class="operator">=</span> rmap.valueAt(i);</span><br><span class="line">                <span class="type">IntentReceiverLeaked</span> <span class="variable">leak</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentReceiverLeaked</span>(</span><br><span class="line">                        what + <span class="string">&quot; &quot;</span> + who + <span class="string">&quot; has leaked IntentReceiver &quot;</span></span><br><span class="line">                        + rd.getIntentReceiver() + <span class="string">&quot; that was &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;originally registered here. Are you missing a &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;call to unregisterReceiver()?&quot;</span>);</span><br><span class="line">                leak.setStackTrace(rd.getLocation().getStackTrace());</span><br><span class="line">                <span class="comment">// 输出日志提醒你</span></span><br><span class="line">                Slog.e(ActivityThread.TAG, leak.getMessage(), leak);</span><br><span class="line">                <span class="keyword">if</span> (reportRegistrationLeaks) &#123;</span><br><span class="line">                    StrictMode.onIntentReceiverLeaked(leak);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ActivityManager.getService().unregisterReceiver(</span><br><span class="line">                            rd.getIIntentReceiver());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mUnregisteredReceivers.remove(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理那些绑定的Service，即解除绑定掉他们</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; smap =</span><br><span class="line">                mServices.remove(context);</span><br><span class="line">        <span class="keyword">if</span> (smap != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; smap.size(); i++) &#123;</span><br><span class="line">                LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> smap.valueAt(i);</span><br><span class="line">                <span class="type">ServiceConnectionLeaked</span> <span class="variable">leak</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnectionLeaked</span>(</span><br><span class="line">                        what + <span class="string">&quot; &quot;</span> + who + <span class="string">&quot; has leaked ServiceConnection &quot;</span></span><br><span class="line">                        + sd.getServiceConnection() + <span class="string">&quot; that was originally bound here&quot;</span>);</span><br><span class="line">                leak.setStackTrace(sd.getLocation().getStackTrace());</span><br><span class="line">                <span class="comment">// 输出日志提醒你</span></span><br><span class="line">                Slog.e(ActivityThread.TAG, leak.getMessage(), leak);</span><br><span class="line">                <span class="keyword">if</span> (reportRegistrationLeaks) &#123;</span><br><span class="line">                    StrictMode.onServiceConnectionLeaked(leak);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用 unbindService 方法来挨个解除绑定</span></span><br><span class="line">                    ActivityManager.getService().unbindService(</span><br><span class="line">                            sd.getIServiceConnection());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">                sd.doForget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mUnboundServices.remove(context);</span><br><span class="line">        <span class="comment">//Slog.i(TAG, &quot;Service registrations: &quot; + mServices);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终会分别处理当前 ContextImpl 中之前 动态注册的广播和绑定的服务。而对于那些服务来说，就是挨个调用其 unbind 方法就行了。</p>
<p>而且这里会输出日志来提醒你，比如：“Activity XXXX  has leaked ServiceConnection XXXXX that was originally bound here” ，是不是经常在控制台中看到这个消息呀？那你还不快去加上对应的解除绑定的代码去？😂</p>

            </div>
          

    
      <footer class="post-footer">
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/8f14e4f4.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Android Activity 启动流程全解析</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/d663666b.html">
        <span class="next-text nav-default">Android 系统服务加载启动</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
