<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="ARouter 原理分析"/>




  <meta name="keywords" content="Android," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/d414997b.html"/>


<meta name="description" content="简介ARouter 的话其实是用来模块间通讯的。我们知道在模块化开发中，我们一般会把项目根据业务分为不同的模块，也叫module，然后提供一个主工程来依赖这些模块，最后打包的时候把这些模块会统一都打到apk中。 本文后续不会着重去讲 ARouter 库怎么使用，而是侧重于分析该库的原理内容。默认已经使用过该库了，如果不熟悉使用的话，可以先去翻看官方文档：ARouter 思路在模块化中，由于分了模块">
<meta property="og:type" content="article">
<meta property="og:title" content="ARouter 原理分析">
<meta property="og:url" content="https://youngkaaa.github.io/d414997b.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="简介ARouter 的话其实是用来模块间通讯的。我们知道在模块化开发中，我们一般会把项目根据业务分为不同的模块，也叫module，然后提供一个主工程来依赖这些模块，最后打包的时候把这些模块会统一都打到apk中。 本文后续不会着重去讲 ARouter 库怎么使用，而是侧重于分析该库的原理内容。默认已经使用过该库了，如果不熟悉使用的话，可以先去翻看官方文档：ARouter 思路在模块化中，由于分了模块">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-20T13:48:56.000Z">
<meta property="article:modified_time" content="2023-03-06T12:05:48.468Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> ARouter 原理分析 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          ARouter 原理分析
        
      </h1>

      <time class="post-time">
          1月 20 2022
      </time>
    </header>



    
            <div class="post-content">
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ARouter 的话其实是用来模块间通讯的。我们知道在模块化开发中，我们一般会把项目根据业务分为不同的模块，也叫module，然后提供一个主工程来依赖这些模块，最后打包的时候把这些模块会统一都打到apk中。</p>
<p>本文后续不会着重去讲 ARouter 库怎么使用，而是侧重于分析该库的原理内容。默认已经使用过该库了，如果不熟悉使用的话，可以先去翻看官方文档：<a target="_blank" rel="noopener" href="https://github.com/alibaba/ARouter">ARouter</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在模块化中，由于分了模块，那么 模块A 要访问 模块B 的类怎么办呢？一个简单的办法就是，让 模块A 依赖 模块B ，也就是在gradle文件中加一句 implatementation project 模块B，然后重新同步下项目就可以了，此时相当于就是把模块B当做一个SDK来使用，这样确实是解决了模块间互相访问的问题，但是这样就会产生循环依赖，比如模块A和模块B要互相访问呢？这种方式不对。</p>
<p>但是仔细想，这些不同的模块在开发时无法使用，主要原因是无法引用到。比如你在开发时想使用一个类com.A，你写一个类总得需要导包吧，或者全路径去写，</p>
<p>而我们目的是为了访问另外一个模块，所以有另外一种方式就是：我们可以将那个要访问的，位于另外一个模块的类的全路径保存下来，后续要访问它的时候，就通过反射来访问该类的全路径，通过反射拿到其实例不就可以操作了？别忘了，虽然他俩是不同的模块，但是最终打完包运行时，他们都是会被打进去的，而不管你在开发期间分了多少个模块，最终都是在一个apk内下。所以到时候反射肯定能拿到这个类。</p>
<p>下面举个例子：比如我们目前在模块A中要访问模块B 中的 类B，他的类路径是：com.test.moduleb.data.B，那么我们假设可以使用 key &#x3D; “moduleb_data_B” 来作为key，value 则保存该类的全路径名 &#x3D; “cn.test.moduleb.data.B” 。然后将这对key-value值保存到一个模块A 中的一个Map内，接着后续在模块A中要使用这个类B时，就去访问固定的key&#x3D;“moduleb_data_B”来拿到其对应的类全路径名，然后用反射来构造该类的对象实例，再接着去使用就行了。你也可以把这个 Map 放到所有模块都能访问的地方，这样的话其他的模块C，模块D……都可以访问模块B中的这个类B 了。</p>
<p>但是这样的话，维护麻烦，并且性能太差。比如模块B中的类B被重构挪包了，改名了之类的操作，都会导致之前Map中保存的类路径失效，并且还使用了反射，会导致性能下降。</p>
<p>但是转念一想，导致上面方案不可行的最终根源是：①类变化导致路径变化，最终导致维护麻烦 ？还是 ②反射导致性能下降？我觉得是前者产生的问题更严重些，因为它可能会产生运行问题，一个你开发时认为一定存在的类在实际运行时找不着了，这问题可就大了。所以说，得着重解决掉前者这个问题。解决它，我们可以通过一些自动化的东西，比如注解处理器，当项目每次被编译时，注解处理器都会被执行，因此这是个很好的时机，可以用来处理每个模块中的类。不管你在项目模块中改了啥，改了包，改了类名，删除了类等操作，在之后的项目运行时，都会先走编译，将这些变更的类重新编译，所以说不管模块中发生了挪动包还是改名等重构，都会在重新运行项目时被注解处理器重新处理，重新拿到新的类全路径信息。这里忘了说一个前提，就是得使用注解。</p>
<p>所以可以总结一下思路：</p>
<p>① 我们可以引入自定义的注解，并且实现对应的注解处理器来处理这些自定义的注解。首先这个自定义注解得有一个key的参数要指定，这个key可以用来拿到对应类的全路径名。</p>
<p>② 接着使用这个自定义的注解来修饰要被其他模块访问的类，因为毕竟不是模块中所有的类都需要被别的模块去访问。这样的话在后续该模块被编译时，其对应的注解处理器就可以拿到被该自定义的注解修饰的类的信息，包括注解中指定的key，和被修饰类的Class信息，当然也就能拿到这些类的全路径名了。</p>
<p>③接着我们可以把拿到的key和value（也就是拿到的全路径名）存到一个指定的Map中。</p>
<p>因此，我们可以将该Map定义在一个固定类中，这个固定类可以被其他模块访问到。后续在注解处理器中通过反射去访问这个固定路径，再拿到其中提前定义定义好的Map属性，接着将key-value存入进去。但是对于 ARouter 来说，它使用了另外一种方式：</p>
<p>在编译时，通过注解处理器来生成一系列，存放在指定包下的中间类，这些类内部会定义一个方法loadInto (Map)，该方法接受一个入参Map。同时会在该方法的实现中，将读取到的 key-value 值存入到该方法的入参Map中。那么后续可以通过其他方式(反射，或者修改字节码注入等)找到这些中间类，通过反射实例化它们并调用其loadInto(Map) 方法传入一个Map，那么该 loadInto() 方法执行完毕之后这个入参Map中就存储好了 key-value值，后续就可以访问该Map就能拿到对应的类路径了。</p>
<p>并且在ARouter 中实现时对方案进行了细化，比如分了模块、分了注解等。另外Map中存储的value不再是全路径名，而是对应的 Class 对象实例。</p>
<p>所以说 Arouter 这个库，他的原理简单来说就是 <strong>运用了注解&amp;注解处理器APT</strong> 或者 <strong>Gradle Transform，辅助生成、修改了一些类，来保存这些跨模块使用的类及其路径那些。</strong></p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>在正式介绍之前，首先先讲一些基础概念，这些概念这里只是简单概括，并不专门分析他们的原理，也或者后续有时间了会分析原理。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>在 ARouter 中用到了挺多的注解。注解是从JAVA1.5开始引入的，与之前的类，接口，枚举都是属于同一层次的概念。简单来表述就是：它可以用来描述包、类、字段、方法的 ，也叫他是元数据。在 Java 中自带了一些注解，比如@Override、@Deprecated等，这些主要是给编译器来看的，额外的我们还可以自己创建注解，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> A &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以创建一个自定义的注解了。注意上面的 @Target 和 @Retention，他们也是注解，是用来修饰注解的注解，也叫做：元注解。而像这样的元注解共四个：</p>
<p>① @Target ： 指定被修饰的注解的作用范围。</p>
<blockquote>
<p>它的取值有很多，这里只举几个常用的：1) CONSTRUCTOR ，表示该注解是用在构造方法上的； 2）FIELD，表示该注解是用在属性上的； 3）METHOD，表示该注解是用在方法上；4）TYPE，表示该注解是用在 类、接口或者 enum 上的。</p>
</blockquote>
<p>② @Retention：指定了被修饰的注解的生命周期。</p>
<p>它的取值只有三个：1）RetentionPolicy.SOURCE，表示该注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视，对于这种注解，会由源码编译成 class 文件时被丢弃，这种注解的处理可以使用注解处理器来处理。 2）RetentionPolicy.CLASS，表示该注解会被保留到编译进行时的class文件，但 JVM 加载class文件时候被遗弃，也就是在这个阶段不会读取到该class文件；3）RetentionPolicy.RUNTIME，注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。所以这种一般是运行时通过反射来处理的。</p>
<p>③ @Documented ：指定了被修饰的注解是可以Javadoc等工具文档化</p>
<p>④ @Inherited ：指定了被修饰的注解修饰程序元素的时候是可以被子类继承的</p>
<h3 id="注解处理器分析"><a href="#注解处理器分析" class="headerlink" title="注解处理器分析"></a>注解处理器分析</h3><p>注解处理器也叫 APT，全称 Annotation Processing Tool，它是 javac 的一个工具，它可以被用来在编译时扫描和处理注解。通过 APT 可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，从而省去了手动编写。</p>
<p>而前面讲到了ARouter中的方案思路，接下来先看看它的注解处理器是怎么实现的，ARouter中注解处理器相关类都是放在单独的：arouter-compiler 中的，而它相对应的注解是放在：arouter-annotation 中，这样的话，在其他项目中使用ARouter时，可以减少引入代码量，减少方法数，因为arouter-compiler是没必要打到包里的，它只需要在编译时生效就行，运行时有他没他一个样。</p>
<blockquote>
<p>注意，在本文后续的源码分析中，着重于分析该库的实现思路，而不会在不重要的具体代码逻辑上赘述以拉长篇幅，当然在有些重要的细节点上会仔细分析的。</p>
</blockquote>
<p>而在 arouter-compiler  中的注解处理器实现有好几个，这里我们先看RouteProcessor 它的父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line">    Filer mFiler;</span><br><span class="line">    Logger logger;</span><br><span class="line">    Types types;</span><br><span class="line">    Elements elementUtils;</span><br><span class="line">    TypeUtils typeUtils;</span><br><span class="line">    <span class="comment">// Module name, maybe its &#x27;app&#x27; or others</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">moduleName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// If need generate router doc</span></span><br><span class="line">    <span class="type">boolean</span> generateDoc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.init(processingEnv);</span><br><span class="line"></span><br><span class="line">        mFiler = processingEnv.getFiler();</span><br><span class="line">        types = processingEnv.getTypeUtils();</span><br><span class="line">        elementUtils = processingEnv.getElementUtils();</span><br><span class="line">        typeUtils = <span class="keyword">new</span> <span class="title class_">TypeUtils</span>(types, elementUtils);</span><br><span class="line">        logger = <span class="keyword">new</span> <span class="title class_">Logger</span>(processingEnv.getMessager());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attempt to get user configuration [moduleName]</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 读取在 gradle 文件中配置的 KEY_MODULE_NAME 和 KEY_GENERATE_DOC_NAME 配置</span></span><br><span class="line"><span class="comment">         * KEY_MODULE_NAME 拿到的就是当前 module 的名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; options = processingEnv.getOptions();</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isNotEmpty(options)) &#123;</span><br><span class="line">            moduleName = options.get(KEY_MODULE_NAME);</span><br><span class="line">            generateDoc = VALUE_ENABLE.equals(options.get(KEY_GENERATE_DOC_NAME));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// KEY_MODULE_NAME 必须指定，否则这里会抛出 异常</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(moduleName)) &#123;</span><br><span class="line">            moduleName = moduleName.replaceAll(<span class="string">&quot;[^0-9a-zA-Z_]+&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;The user has configuration the module name, it was [&quot;</span> + moduleName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(NO_MODULE_NAME_TIPS);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ARouter::Compiler &gt;&gt;&gt; No module name, for more information, look at gradle log.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。</span></span><br><span class="line"><span class="comment">     * 然而，如果你有足够的理由只支持Java 7的话，你也可以返回SourceVersion.RELEASE_7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SourceVersion <span class="title function_">getSupportedSourceVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getSupportedOptions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">            <span class="built_in">this</span>.add(KEY_MODULE_NAME);</span><br><span class="line">            <span class="built_in">this</span>.add(KEY_GENERATE_DOC_NAME);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BaseProcessor 继承自 AbstractProcessor ，而 AbstractProcessor 是属于 javax.annotation.processing 包下的，它是实现注解处理器的必经之路，一般都是继承自AbstractProcessor  的，而这里的 BaseProcessor  中，从其父类的 init() 方法中读取出mFiler、types 等属性，这些是注解处理器提供的，详细作用可以看看这篇文章去熟悉下注解处理器的编写流程：<a target="_blank" rel="noopener" href="https://www.race604.com/annotation-processing/">Java注解处理器</a>  。</p>
<p>接着会在构造方法中读取出外部的配置信息：KEY_MODULE_NAME 和 KEY_GENERATE_DOC_NAME ，这俩在getSupportedOptions() 方法中指定并返回，外部可以在 gradle 文件中指定。比如ARouter官方的示例：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="attr">AROUTER_MODULE_NAME:</span> project.getName()]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是通过 AROUTER_MODULE_NAME 指定了模块名。这里拿到了 模块名，后面在生成类时就可以使用它来作为生成类的一部分。</p>
<p>接着回到 RouteProcessor 中接着看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService(Processor.class)</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&#123;ANNOTATION_TYPE_ROUTE, ANNOTATION_TYPE_AUTOWIRED&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteProcessor</span> <span class="keyword">extends</span> <span class="title class_">BaseProcessor</span> &#123;</span><br><span class="line">   <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 RouteProcessor 类定定义中，使用了两个注解：</p>
<p>① @AutoService ：可以自动注册该注解处理器，不然的话需要去MATE-INF文件夹下的指定文件中去指定它才行。</p>
<p>② @SupportedAnnotationTypes：指定当前注解处理器要处理的注解，，不使用它的话，你就得去实现 getSupportedAnnotationTypes() 方法来返回要处理的注解。</p>
<p>接着在 init() 方法中只是做了一些属性的初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.init(processingEnv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (generateDoc) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                docWriter = mFiler.createResource(</span><br><span class="line">                        StandardLocation.SOURCE_OUTPUT,</span><br><span class="line">                        PACKAGE_OF_GENERATE_DOCS,</span><br><span class="line">                        <span class="string">&quot;arouter-map-of-&quot;</span> + moduleName + <span class="string">&quot;.json&quot;</span></span><br><span class="line">                ).openWriter();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Create doc writer failed, because &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iProvider = elementUtils.getTypeElement(Consts.IPROVIDER).asType();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt; RouteProcessor init. &lt;&lt;&lt;&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接着往下来看 process() 方法，该方法是实现注解处理器的核心方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(annotations)) &#123;</span><br><span class="line">        Set&lt;? <span class="keyword">extends</span> <span class="title class_">Element</span>&gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt; Found routes, start... &lt;&lt;&lt;&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.parseRoutes(routeElements);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 process() 方法中，首先会调用 roundEnv.getElementsAnnotatedWith() 方法，传入 Route.class ，表示返回所有被注解了<code>@Route</code>的元素的列表 。接着将其传入到  parseRoutes() 方法中去遍历处理。</p>
<p>接下来要分析 parseRoutes() 中的代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseRoutes</span><span class="params">(Set&lt;? extends Element&gt; routeElements)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(routeElements)) &#123;</span><br><span class="line">        <span class="comment">// prepare the type an so on.</span></span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt; Found routes, size is &quot;</span> + routeElements.size() + <span class="string">&quot; &lt;&lt;&lt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始处理之前，将其内容清空</span></span><br><span class="line">        rootMap.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续可能会用到类型判断，所以这里提前准备好类型，后续直接用来比对就行了</span></span><br><span class="line">        <span class="type">TypeMirror</span> <span class="variable">type_Activity</span> <span class="operator">=</span> elementUtils.getTypeElement(ACTIVITY).asType();</span><br><span class="line">        <span class="type">TypeMirror</span> <span class="variable">type_Service</span> <span class="operator">=</span> elementUtils.getTypeElement(SERVICE).asType();</span><br><span class="line">        <span class="type">TypeMirror</span> <span class="variable">fragmentTm</span> <span class="operator">=</span> elementUtils.getTypeElement(FRAGMENT).asType();</span><br><span class="line">        <span class="type">TypeMirror</span> <span class="variable">fragmentTmV4</span> <span class="operator">=</span> elementUtils.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ARouter 中的接口类型</span></span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">type_IRouteGroup</span> <span class="operator">=</span> elementUtils.getTypeElement(IROUTE_GROUP);</span><br><span class="line">        <span class="type">TypeElement</span> <span class="variable">type_IProviderGroup</span> <span class="operator">=</span> elementUtils.getTypeElement(IPROVIDER_GROUP);</span><br><span class="line">        <span class="type">ClassName</span> <span class="variable">routeMetaCn</span> <span class="operator">=</span> ClassName.get(RouteMeta.class);</span><br><span class="line">        <span class="type">ClassName</span> <span class="variable">routeTypeCn</span> <span class="operator">=</span> ClassName.get(RouteType.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个参数类型Map：Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ParameterizedTypeName</span> <span class="variable">inputMapTypeOfRoot</span> <span class="operator">=</span> ParameterizedTypeName.get(</span><br><span class="line">                ClassName.get(Map.class),</span><br><span class="line">                ClassName.get(String.class),</span><br><span class="line">                ParameterizedTypeName.get(</span><br><span class="line">                        ClassName.get(Class.class),</span><br><span class="line">                        WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个参数类型Map：Map&lt;String, RouteMeta&gt;</span></span><br><span class="line">        <span class="type">ParameterizedTypeName</span> <span class="variable">inputMapTypeOfGroup</span> <span class="operator">=</span> ParameterizedTypeName.get(</span><br><span class="line">                ClassName.get(Map.class),</span><br><span class="line">                ClassName.get(String.class),</span><br><span class="line">                ClassName.get(RouteMeta.class)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 对上面创建的参数类型，创建一个对应的参数名，</span></span><br><span class="line"><span class="comment">         * 比如这里的 rootParamSpec 表示：Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ParameterSpec</span> <span class="variable">rootParamSpec</span> <span class="operator">=</span> ParameterSpec.builder(inputMapTypeOfRoot, <span class="string">&quot;routes&quot;</span>).build();</span><br><span class="line">        <span class="type">ParameterSpec</span> <span class="variable">groupParamSpec</span> <span class="operator">=</span> ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">&quot;atlas&quot;</span>).build();</span><br><span class="line">        <span class="type">ParameterSpec</span> <span class="variable">providerParamSpec</span> <span class="operator">=</span> ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">&quot;providers&quot;</span>).build();  <span class="comment">// Ps</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建对应的方法。</span></span><br><span class="line"><span class="comment">         * 方法名是：loadInto</span></span><br><span class="line"><span class="comment">         * 方法签名是：loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MethodSpec.<span class="type">Builder</span> <span class="variable">loadIntoMethodOfRootBuilder</span> <span class="operator">=</span> MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">                .addAnnotation(Override.class)</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addParameter(rootParamSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历入参 routeElements，并为每个创建对应类型的 RouteMeta 实例，</span></span><br><span class="line"><span class="comment">         * 并且会将创建的 RouteMeta 存入到上面的 groupMap 属性中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Element element : routeElements) &#123;</span><br><span class="line">            <span class="type">TypeMirror</span> <span class="variable">tm</span> <span class="operator">=</span> element.asType();</span><br><span class="line">            <span class="type">Route</span> <span class="variable">route</span> <span class="operator">=</span> element.getAnnotation(Route.class);</span><br><span class="line">            RouteMeta routeMeta;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是 Activity 或者 Fragment 时</span></span><br><span class="line">            <span class="keyword">if</span> (types.isSubtype(tm, type_Activity) || types.isSubtype(tm, fragmentTm) || types.isSubtype(tm,</span><br><span class="line">                    fragmentTmV4)) &#123;</span><br><span class="line">                <span class="comment">// 此时其内部可能有使用 @Autowired 注解，所以此时获取这些变量</span></span><br><span class="line">                Map&lt;String, Integer&gt; paramsType = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                Map&lt;String, Autowired&gt; injectConfig = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                injectParamCollector(element, paramsType, injectConfig);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建对应的 RouteMeta 实例</span></span><br><span class="line">                <span class="keyword">if</span> (types.isSubtype(tm, type_Activity)) &#123;</span><br><span class="line">                    <span class="comment">// Activity</span></span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt; Found activity route: &quot;</span> + tm.toString() + <span class="string">&quot; &lt;&lt;&lt;&quot;</span>);</span><br><span class="line">                    routeMeta = <span class="keyword">new</span> <span class="title class_">RouteMeta</span>(route, element, RouteType.ACTIVITY, paramsType);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Fragment</span></span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt; Found fragment route: &quot;</span> + tm.toString() + <span class="string">&quot; &lt;&lt;&lt;&quot;</span>);</span><br><span class="line">                    routeMeta = <span class="keyword">new</span> <span class="title class_">RouteMeta</span>(route, element, RouteType.parse(FRAGMENT), paramsType);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                routeMeta.setInjectConfig(injectConfig);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, iProvider)) &#123;         <span class="comment">// IProvider</span></span><br><span class="line">                <span class="comment">// 是  IProvider 时</span></span><br><span class="line">                logger.info(<span class="string">&quot;&gt;&gt;&gt; Found provider route: &quot;</span> + tm.toString() + <span class="string">&quot; &lt;&lt;&lt;&quot;</span>);</span><br><span class="line">                routeMeta = <span class="keyword">new</span> <span class="title class_">RouteMeta</span>(route, element, RouteType.PROVIDER, <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, type_Service)) &#123;           <span class="comment">// Service</span></span><br><span class="line">                logger.info(<span class="string">&quot;&gt;&gt;&gt; Found service route: &quot;</span> + tm.toString() + <span class="string">&quot; &lt;&lt;&lt;&quot;</span>);</span><br><span class="line">                routeMeta = <span class="keyword">new</span> <span class="title class_">RouteMeta</span>(route, element, RouteType.parse(SERVICE), <span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The @Route is marked on unsupported class, look at [&quot;</span> + tm.toString() + <span class="string">&quot;].&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 按照当前 Route 注解指定的 group 来进行分类 存入到 groupMap 中</span></span><br><span class="line">            categories(routeMeta);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构建 IProvider 相关的 loadInto 方法：</span></span><br><span class="line"><span class="comment">         * 最终方法签名是：loadInto(Map&lt;String，RouteMeta&gt; providers)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MethodSpec.<span class="type">Builder</span> <span class="variable">loadIntoMethodOfProviderBuilder</span> <span class="operator">=</span> MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">                .addAnnotation(Override.class)</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addParameter(providerParamSpec);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;RouteDoc&gt;&gt; docSource = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前面的循环中已经将入参 routeElements 中的元素处理完毕了，</span></span><br><span class="line"><span class="comment">         * 并且已经将其按照当时 <span class="doctag">@Route</span> 注解时的 group 分组了存入到了 groupMap 中</span></span><br><span class="line"><span class="comment">         * 接下来就处理 groupMap</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;RouteMeta&gt;&gt; entry : groupMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"></span><br><span class="line">            MethodSpec.<span class="type">Builder</span> <span class="variable">loadIntoMethodOfGroupBuilder</span> <span class="operator">=</span> MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">                    .addAnnotation(Override.class)</span><br><span class="line">                    .addModifiers(PUBLIC)</span><br><span class="line">                    .addParameter(groupParamSpec);</span><br><span class="line"></span><br><span class="line">            List&lt;RouteDoc&gt; routeDocList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Build group method body</span></span><br><span class="line">            Set&lt;RouteMeta&gt; groupData = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 遍历同一个 group 的信息，构建对应的方法体</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (RouteMeta routeMeta : groupData) &#123;</span><br><span class="line">                <span class="type">RouteDoc</span> <span class="variable">routeDoc</span> <span class="operator">=</span> extractDocInfo(routeMeta);</span><br><span class="line"></span><br><span class="line">                <span class="type">ClassName</span> <span class="variable">className</span> <span class="operator">=</span> ClassName.get((TypeElement) routeMeta.getRawType());</span><br><span class="line">                <span class="comment">// 处理 IProvider 类型的</span></span><br><span class="line">                <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> PROVIDER:  <span class="comment">// Need cache provider&#x27;s super class</span></span><br><span class="line">                        List&lt;? <span class="keyword">extends</span> <span class="title class_">TypeMirror</span>&gt; interfaces =</span><br><span class="line">                                ((TypeElement) routeMeta.getRawType()).getInterfaces();</span><br><span class="line">                        <span class="keyword">for</span> (TypeMirror tm : interfaces) &#123;</span><br><span class="line">                            routeDoc.addPrototype(tm.toString());</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (types.isSameType(tm, iProvider)) &#123;   <span class="comment">// Its implements iProvider interface himself.</span></span><br><span class="line">                                <span class="comment">// This interface extend the IProvider, so it can be used for mark provider</span></span><br><span class="line">                                loadIntoMethodOfProviderBuilder.addStatement(</span><br><span class="line">                                        <span class="string">&quot;providers.put($S, $T.build($T.&quot;</span> + routeMeta.getType() + <span class="string">&quot;, $T.class, $S,&quot;</span> +</span><br><span class="line">                                                <span class="string">&quot; $S, null, &quot;</span> + routeMeta.getPriority() + <span class="string">&quot;, &quot;</span> + routeMeta.getExtra() + <span class="string">&quot;))&quot;</span>,</span><br><span class="line">                                        (routeMeta.getRawType()).toString(),</span><br><span class="line">                                        routeMetaCn,</span><br><span class="line">                                        routeTypeCn,</span><br><span class="line">                                        className,</span><br><span class="line">                                        routeMeta.getPath(),</span><br><span class="line">                                        routeMeta.getGroup());</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, iProvider)) &#123;</span><br><span class="line">                                <span class="comment">// This interface extend the IProvider, so it can be used for mark provider</span></span><br><span class="line">                                loadIntoMethodOfProviderBuilder.addStatement(</span><br><span class="line">                                        <span class="string">&quot;providers.put($S, $T.build($T.&quot;</span> + routeMeta.getType() + <span class="string">&quot;, $T.class, $S,&quot;</span> +</span><br><span class="line">                                                <span class="string">&quot; $S, null, &quot;</span> + routeMeta.getPriority() + <span class="string">&quot;, &quot;</span> + routeMeta.getExtra() + <span class="string">&quot;))&quot;</span>,</span><br><span class="line">                                        tm.toString(),    <span class="comment">// So stupid, will duplicate only save class name.</span></span><br><span class="line">                                        routeMetaCn,</span><br><span class="line">                                        routeTypeCn,</span><br><span class="line">                                        className,</span><br><span class="line">                                        routeMeta.getPath(),</span><br><span class="line">                                        routeMeta.getGroup());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Make map body for paramsType</span></span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">mapBodyBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class="line">                Map&lt;String, Autowired&gt; injectConfigs = routeMeta.getInjectConfig();</span><br><span class="line">                <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                    List&lt;RouteDoc.Param&gt; paramList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; types : paramsType.entrySet()) &#123;</span><br><span class="line">                        mapBodyBuilder.append(<span class="string">&quot;put(\&quot;&quot;</span>).append(types.getKey()).append(<span class="string">&quot;\&quot;, &quot;</span>).append(types.getValue()).append(<span class="string">&quot;); &quot;</span>);</span><br><span class="line"></span><br><span class="line">                        RouteDoc.<span class="type">Param</span> <span class="variable">param</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteDoc</span>.Param();</span><br><span class="line">                        <span class="type">Autowired</span> <span class="variable">injectConfig</span> <span class="operator">=</span> injectConfigs.get(types.getKey());</span><br><span class="line">                        param.setKey(types.getKey());</span><br><span class="line">                        param.setType(TypeKind.values()[types.getValue()].name().toLowerCase());</span><br><span class="line">                        param.setDescription(injectConfig.desc());</span><br><span class="line">                        param.setRequired(injectConfig.required());</span><br><span class="line"></span><br><span class="line">                        paramList.add(param);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    routeDoc.setParams(paramList);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">mapBody</span> <span class="operator">=</span> mapBodyBuilder.toString();</span><br><span class="line"></span><br><span class="line">                loadIntoMethodOfGroupBuilder.addStatement(</span><br><span class="line">                        <span class="string">&quot;atlas.put($S, $T.build($T.&quot;</span> + routeMeta.getType() + <span class="string">&quot;, $T.class, $S, $S, &quot;</span> + (StringUtils.isEmpty(mapBody) ? <span class="literal">null</span> : (<span class="string">&quot;new java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;&quot;</span> + mapBodyBuilder.toString() + <span class="string">&quot;&#125;&#125;&quot;</span>)) + <span class="string">&quot;, &quot;</span> + routeMeta.getPriority() + <span class="string">&quot;, &quot;</span> + routeMeta.getExtra() + <span class="string">&quot;))&quot;</span>,</span><br><span class="line">                        routeMeta.getPath(),</span><br><span class="line">                        routeMetaCn,</span><br><span class="line">                        routeTypeCn,</span><br><span class="line">                        className,</span><br><span class="line">                        routeMeta.getPath().toLowerCase(),</span><br><span class="line">                        routeMeta.getGroup().toLowerCase());</span><br><span class="line"></span><br><span class="line">                routeDoc.setClassName(className.toString());</span><br><span class="line">                routeDocList.add(routeDoc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Generate groups</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">groupFileName</span> <span class="operator">=</span> NAME_OF_GROUP + groupName;</span><br><span class="line">            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,</span><br><span class="line">                    TypeSpec.classBuilder(groupFileName)</span><br><span class="line">                            .addJavadoc(WARNING_TIPS)</span><br><span class="line">                            .addSuperinterface(ClassName.get(type_IRouteGroup))</span><br><span class="line">                            .addModifiers(PUBLIC)</span><br><span class="line">                            .addMethod(loadIntoMethodOfGroupBuilder.build())</span><br><span class="line">                            .build()</span><br><span class="line">            ).build().writeTo(mFiler);</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt; Generated group: &quot;</span> + groupName + <span class="string">&quot;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">            rootMap.put(groupName, groupFileName);</span><br><span class="line">            docSource.put(groupName, routeDocList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isNotEmpty(rootMap)) &#123;</span><br><span class="line">            <span class="comment">// Generate root meta by group name, it must be generated before root, then I can find out the class</span></span><br><span class="line">            <span class="comment">// of group.</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : rootMap.entrySet()) &#123;</span><br><span class="line">                loadIntoMethodOfRootBuilder.addStatement(<span class="string">&quot;routes.put($S, $T.class)&quot;</span>, entry.getKey(),</span><br><span class="line">                        ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Output route doc</span></span><br><span class="line">        <span class="keyword">if</span> (generateDoc) &#123;</span><br><span class="line">            docWriter.append(JSON.toJSONString(docSource, SerializerFeature.PrettyFormat));</span><br><span class="line">            docWriter.flush();</span><br><span class="line">            docWriter.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write provider into disk</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">providerMapFileName</span> <span class="operator">=</span> NAME_OF_PROVIDER + SEPARATOR + moduleName;</span><br><span class="line">        JavaFile.builder(PACKAGE_OF_GENERATE_FILE,</span><br><span class="line">                TypeSpec.classBuilder(providerMapFileName)</span><br><span class="line">                        .addJavadoc(WARNING_TIPS)</span><br><span class="line">                        .addSuperinterface(ClassName.get(type_IProviderGroup))</span><br><span class="line">                        .addModifiers(PUBLIC)</span><br><span class="line">                        .addMethod(loadIntoMethodOfProviderBuilder.build())</span><br><span class="line">                        .build()</span><br><span class="line">        ).build().writeTo(mFiler);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt; Generated provider map, name is &quot;</span> + providerMapFileName + <span class="string">&quot; &lt;&lt;&lt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write root meta into disk.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rootFileName</span> <span class="operator">=</span> NAME_OF_ROOT + SEPARATOR + moduleName;</span><br><span class="line">        JavaFile.builder(PACKAGE_OF_GENERATE_FILE,</span><br><span class="line">                TypeSpec.classBuilder(rootFileName)</span><br><span class="line">                        .addJavadoc(WARNING_TIPS)</span><br><span class="line">                        .addSuperinterface(ClassName.get(elementUtils.getTypeElement(ITROUTE_ROOT)))</span><br><span class="line">                        .addModifiers(PUBLIC)</span><br><span class="line">                        .addMethod(loadIntoMethodOfRootBuilder.build())</span><br><span class="line">                        .build()</span><br><span class="line">        ).build().writeTo(mFiler);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt; Generated root, name is &quot;</span> + rootFileName + <span class="string">&quot; &lt;&lt;&lt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的代码属实是有些长啊，这里就不细致的分析了，它这里主要的作用是完成了上面所说的：中间类生成。在生成代码时，使用到了：<a target="_blank" rel="noopener" href="https://github.com/square/javapoet">javapoet</a> 这个库，建议可以去了解下其基础使用方式再去看源码会更好理解些。</p>
<p>所以我们跳过生成的过程，直接看生成之后的中间类的结果吧。在看结果之前，先贴一下对应的使用示例，方便做对比：</p>
<p>使用实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route(path = &quot;/main/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test_normal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Route(path = &quot;/main/testNormal&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNormalActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_test_normal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里为两个 Activity 加上了 @Route 注解，分别指定的路径是：“&#x2F;main&#x2F;test” 和 “&#x2F;main&#x2F;testNormal” ，接下来看生成的中间类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ARouter$$Group$$main</span> <span class="keyword">implements</span> <span class="title class_">IRouteGroup</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法呢，到时候会有一个 Map&lt;String, RouteMeta&gt; 参数传进来的，然后本方法内部会将该group下的路由信息add进去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> &#123;</span><br><span class="line">        atlas.put(<span class="string">&quot;/main/test&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, TestActivity.class, <span class="string">&quot;/main/test&quot;</span>, <span class="string">&quot;main&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">        atlas.put(<span class="string">&quot;/main/testNormal&quot;</span>, RouteMeta.build(RouteType.ACTIVITY, TestNormalActivity.class, <span class="string">&quot;/main/testnormal&quot;</span>, <span class="string">&quot;main&quot;</span>, <span class="literal">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x下面分为几个点来介绍下这个中间类：</p>
<p>① 首先看这个生成的中间类的类名是符合一定格式的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter$$Group$$main</span><br></pre></td></tr></table></figure>

<p>即以 ARouter 开头，中间拼接 Group ，最终加上路由地址的group名：main，因为这里俩路由 “&#x2F;main&#x2F;test” 和 “&#x2F;main&#x2F;testNormal” 都是以 main 开头的。</p>
<p>② 这个类是继承自 IRouteGroup 接口的，看看这个接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRouteGroup</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fill the atlas with routes in group.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 接着看该 loadInto 方法的实现，到方法体内会将 “&#x2F;main&#x2F;test” 和 “&#x2F;main&#x2F;testNormal” 路由对应的信息保存起来，其中包括类的Class信息，比如：TestActivity.class 和 TestNormalActivity.class 。后续就可以通过该 Class 类来实例化并返回这些类了。</p>
<blockquote>
<p>注意这里生成的中间类头部还有导包部分的，导包中是包括 TestActivity和 TestNormalActivity 的全路径的，这样保证这个生成的类是可以编译过的，不然编译器不知道这俩类哪儿来的。</p>
</blockquote>
<p>与此同时，还会额外再生成一个中间类，用于将同一模块中这些分组了的中间类注册进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ARouter$$Root$$modulekotlin</span> <span class="keyword">implements</span> <span class="title class_">IRouteRoot</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意此时入参是 ： Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes 类型的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> &#123;</span><br><span class="line">        routes.put(<span class="string">&quot;main&quot;</span>, ARouter$$Group$$main.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面还是分为几个点来介绍这个中间类：</p>
<p>①首先来看这个中间类的命名规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter$$Root$$modulekotlin</span><br></pre></td></tr></table></figure>

<p>即以 ARouter 开头，中间拼接 Root ，最终加上当前模块名modulekotlin 。而这个模块名就是前面讲 BaseProcessor 时通过获取 AROUTER_MODULE_NAME 来拿到的。</p>
<p>② 这里的类是实现了 IRouteRoot 接口的，下面看看这个接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRouteRoot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Load routes to input</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routes input</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时需要注意这里生成的方法虽然还是  loadInto ，但是入参Map的类型变了，变成了 Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; ，即value值是 IRouteGroup 接口的实例了，不就是上面的中间类嘛？</p>
<p>③ 接着看它对于该方法的实现，进入到方法体内，会将上面生成的中间类放入进去，key 是 “main” ，也就是该中间类对应的 group 值。</p>
<p>所以总结下来说：在一个模块中，会有很多个路由信息，在最终生成的中间类中：</p>
<p>① 会首先将这些路由路径按照第一层 group 分类，每个group 都对应一个中间类。并且生成的中间类都是实现自 IRouteGroup 接口，并且会实现其 loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) 方法，在该实现的方法体中，会将所有该 group 的路由信息，包括类信息保存给入参 Map。</p>
<p>② 还会再生成一个模块级别的中间类，该中间类实现了IRouteRoot 接口，并且会实现其 loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) 方法，在该实现的方法体中，会将上面 ① 中生成的所有的中间类保存给入参 Map。</p>
<p>因此，一个模块中生成的中间类被分为两层：模块级别的和GROUP级别的。</p>
<p>当然这里只举了 @Route 注解会生成的中间类，同样还有 @Provider 、@Interceptor ，而他俩和上面的生成规则类似。但是还有一个额外的和上面这三个原理不太一样的注解：@Autowired ，它的简单使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1Activity</span> extend Activity&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    onCreate() &#123;</span><br><span class="line">        Arouter.inject(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式可以在页面进入时，内部的属性，比如这里示例中的 name 被自动赋值。</p>
<p>对于 @Autowired 注解，还是会给它生成一个中间类，下面来看看这个中间类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1Activity$$ARouter$$Autowired</span> <span class="keyword">implements</span> <span class="title class_">ISyringe</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SerializationService serializationService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是实现了 ISyringe 接口的 inject()</span></span><br><span class="line"><span class="comment">     * 而 inject 是在对应Activity启动后需要注入数据时调用的，比如上面 Test1Activity 中</span></span><br><span class="line"><span class="comment">     * 所以说这里的入参 target 就是要注入数据的 Test1Activity 实例</span></span><br><span class="line"><span class="comment">     * 所以 Autowired 这个注解其实就是减少了 genIntent 取值那些操作而已</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        serializationService = ARouter.getInstance().navigation(SerializationService.class);</span><br><span class="line">        <span class="type">Test1Activity</span> <span class="variable">substitute</span> <span class="operator">=</span>(Test1Activity) target;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开始给  Test1Activity 实例赋值了。从intent中读取</span></span><br><span class="line"><span class="comment">         * 所以说你的属性不能是 private 的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        substitute.name = substitute.getIntent().getExtras() == <span class="literal">null</span> ? substitute.name :</span><br><span class="line">        substitute.getIntent().getExtras().getString(<span class="string">&quot;name&quot;</span>, substitute.name);</span><br><span class="line">        substitute.age = substitute.getIntent().getIntExtra(<span class="string">&quot;age&quot;</span>, substitute.age);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个之后，是不是就明白了这个注解的原理了。其实这种实现方式，之前也有库用到过，比如大名鼎鼎的<a target="_blank" rel="noopener" href="https://github.com/JakeWharton/butterknife">butterknife</a> 。</p>
<blockquote>
<p>AndroidStudio 3.6新推出的 ViewBinding 也是差不多的原理，生成中间类。但是它不需要注解，是去遍历layout目录下的布局文件。</p>
<p>但是也还是生成中间文件，中间文件去完成 findViewById 操作。</p>
</blockquote>
<p>注意，这些生成的中间类代码都是存储在：com.alibaba.android.arouter.routes 包路径下的。所以后续在运行时就可以去加载这个包下面的中间类，实例化他们，接着调用其 loadInto() 方法传入一个 Map，loadInto 方法执行完毕之后，这个Map中就会存储着路由相关的信息了。</p>
<h3 id="路由信息的读取"><a href="#路由信息的读取" class="headerlink" title="路由信息的读取"></a>路由信息的读取</h3><p>前面通过注解处理器生成的中间类什么时候使用呢？运行时。更准确来说是当你调用： ARouter 的 init() 方法来初始化时。所以从该方法开始作为切入点，看看运行时怎么处理这些中间类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Application application)</span> &#123;</span><br><span class="line">    <span class="comment">// 避免重复初始化，这里使用 hasInit 来标记</span></span><br><span class="line">    <span class="keyword">if</span> (!hasInit) &#123;</span><br><span class="line">        logger = _ARouter.logger;</span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">&quot;ARouter init start.&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 _ARouter 的 init 方法去初始化</span></span><br><span class="line">        hasInit = _ARouter.init(application);</span><br><span class="line">        <span class="keyword">if</span> (hasInit) &#123;</span><br><span class="line">            _ARouter.afterInit();</span><br><span class="line">        &#125;</span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">&quot;ARouter init over.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">init</span><span class="params">(Application application)</span> &#123;</span><br><span class="line">        mContext = application;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 初始化读取路由信息</span></span><br><span class="line">        LogisticsCenter.init(mContext, executor);</span><br><span class="line">        logger.info(Consts.TAG, <span class="string">&quot;ARouter init success!&quot;</span>);</span><br><span class="line">        hasInit = <span class="literal">true</span>;</span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际的路由信息加载工作是在：LogisticsCenter.init() 方法中处理的，接下来就来看具体的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        executor = tpe;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">startInit</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// load by plugin first</span></span><br><span class="line">            <span class="comment">// 如果在Gradle plugin中成功插入了注册代码，那么在loadRouterMap方法中会调用 register 然后在该方法中将registerByPlugin置为true</span></span><br><span class="line">            <span class="comment">// 表示通过plugin已经注入过了，就不需要走else里面的了  1.3.0版本开始增加plugin的吧</span></span><br><span class="line">            loadRouterMap();</span><br><span class="line">            <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 老的版本吧，这种需要从dex中读取指定 package 下的类，读取到之后通过反射实例化并且调用其中的 loadInto 方法，将对应的类注册到 Warehouse中</span></span><br><span class="line">                Set&lt;String&gt; routerMap;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// It will rebuild router map every times when debuggable.</span></span><br><span class="line">                <span class="comment">// 如果是debug模式或者是新版本，从apt生成的包中加载类</span></span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">                    logger.info(TAG, <span class="string">&quot;Run with debug mode or new install, rebuild router map.&quot;</span>);</span><br><span class="line">                    <span class="comment">// These class was generated by arouter-compiler.</span></span><br><span class="line">                    routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class="line">                    <span class="comment">// 加入sp缓存</span></span><br><span class="line">                    <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class="line">                        context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 更新版本</span></span><br><span class="line">                    PackageUtils.updateVersion(context);    <span class="comment">// Save new version name when router map update finishes.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则从缓存读取类名</span></span><br><span class="line">                    logger.info(TAG, <span class="string">&quot;Load router map from cache.&quot;</span>);</span><br><span class="line">                    routerMap = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY,</span><br><span class="line">                            Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(TAG,</span><br><span class="line">                        <span class="string">&quot;Find router map finished, map size = &quot;</span> + routerMap.size() + <span class="string">&quot;, cost &quot;</span> + (System.currentTimeMillis() - startInit) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">                startInit = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断类型，使用反射实例化对象，并调用方法</span></span><br><span class="line">                <span class="keyword">for</span> (String className : routerMap) &#123;</span><br><span class="line">                    <span class="comment">// 先处理 IRouteRoot</span></span><br><span class="line">                    <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class="line">                        <span class="comment">// This one of root elements, load root.</span></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 调用其 loadInto 方法，传入的值是  Warehouse.groupsIndex ，它是一个 HashMap ，</span></span><br><span class="line"><span class="comment">                         * 关于 IRouteRoot 的可以先看看 RouteExplain.kt 中的解释</span></span><br><span class="line"><span class="comment">                         * 其实就是调用 APT 生成的类，然后将 Warehouse 中对应对应的HashMap传进去，执行完毕后这些HashMap中就会有那些APT生成类的路径那些了</span></span><br><span class="line"><span class="comment">                         * 有了类路径那就可以在后续调用时通过反射new出类实例然后调用了。</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class="line">                        <span class="comment">// Load interceptorMeta</span></span><br><span class="line">                        ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class="line">                        <span class="comment">// Load providerIndex</span></span><br><span class="line">                        ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.info(TAG, <span class="string">&quot;Load root element finished, cost &quot;</span> + (System.currentTimeMillis() - startInit) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Warehouse.groupsIndex.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(TAG, <span class="string">&quot;No mapping files were found, check your configuration please!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">&quot;LogisticsCenter has already been loaded, &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]&quot;</span>, Warehouse.groupsIndex.size(),</span><br><span class="line">                        Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HandlerException</span>(TAG + <span class="string">&quot;ARouter init logistics center exception! [&quot;</span> + e.getMessage() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在LogisticsCenter.init() 方法中，首先会调用 loadRouterMap() 方法，接下来看看先看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRouterMap</span><span class="params">()</span> &#123;</span><br><span class="line">    registerByPlugin = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中只做了一件事儿，那就是将 registerByPlugin 属性值置为 false。</p>
<p>接着回到 LogisticsCenter.init() 方法中 ，往下会判断 registerByPlugin 的值，如果是true的话则只打印日志，其他操作就没了。而结合上面的 loadRouterMap() 方法可知，这里 registerByPlugin 肯定是 false 呀，因为前面刚将其置为 false 。有些奇怪呀是不是？没事先接着往下看吧。</p>
<p>此时会执行到 else 中，此时会判断当前是否是调试模式，或者当前是该版本第一次执行到这里的：</p>
<p>①满足条件的话，则需要去遍历 dex 文件，查找包路径是 com.alibaba.android.arouter.routes 的类。具体是通过调用 ClassUtils.getFileNameByPackageName() 方法，传入参数：ROUTE_ROOT_PAKCAGE &#x3D; com.alibaba.android.arouter.routes 来实现的。</p>
<p>接着会将这个 Set 集合以及将当前包的版本保存到 SP 中，那么下一次执行当前方法时，就可以直接走下面第二步了。</p>
<p>② 从 SP 中读取出之前保存的 结果，这样的话就避免了再次遍历dex文件查找了，因为该操作是比较耗时的。</p>
<p>接着往下，拿到了前面注解处理器所生成中间类信息之后，接下来就开始遍历这些信息，使用反射将其实例化，然后调用其对应的  loadInto() 方法来完成路由信息的注入。</p>
<p>而由于前面生成的中间类的命名是有一定规则的，所以通过类名就可以知道这个中间类是哪种类型的，比如类文件名称是以：com.alibaba.android.arouter.routes.ARouter$$Root 开头的，那么他就是：IRouteRoot 类型，也就是模块中生成的唯一的那个中间类，比如前面举例中的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARouter$$Root$$modulekotlin</span><br></pre></td></tr></table></figure>

<p>当然后续都可以使用该例子来理解。</p>
<p>此时反射实例化该类，接着调用其 loadInto() 方法，传入：Warehouse.groupsIndex ，那么该方法执行完毕之后， Warehouse.groupsIndex 中就存储着对应的路由信息了。</p>
<p>下面看看这个Warehouse.groupsIndex 是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Warehouse</span> &#123;</span><br><span class="line">    <span class="comment">// Cache route and metas</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Class&lt;? <span class="keyword">extends</span> <span class="title class_">IRouteGroup</span>&gt;&gt; groupsIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; routes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache provider</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class, IProvider&gt; providers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; providersIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache interceptor</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, Class&lt;? <span class="keyword">extends</span> <span class="title class_">IInterceptor</span>&gt;&gt; interceptorsIndex = <span class="keyword">new</span> <span class="title class_">UniqueKeyTreeMap</span>&lt;&gt;(<span class="string">&quot;More than one interceptors use same priority [%s]&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> List&lt;IInterceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        routes.clear();</span><br><span class="line">        groupsIndex.clear();</span><br><span class="line">        providers.clear();</span><br><span class="line">        providersIndex.clear();</span><br><span class="line">        interceptors.clear();</span><br><span class="line">        interceptorsIndex.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Warehouse 类中定义了好几个Map，分别用来存储不同种类的数据。而前面提及的 Warehouse.groupsIndex 的类型是：Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; 。</p>
<p>所以说，至此，我们就完成了前面所说的，将这些路由信息读取保存起来的逻辑。</p>
<p>前面还有一个问题没有解决，即那个奇奇怪怪的 loadRouterMap() 方法。</p>
<p>其实这个方法是给  Android Gradle Plugin 中的  Transform 环节来使用的，对于 Transform 简单来说，就是在 Gradle 打包流程中，会在编译完 class 文件准备合并成 dex文件时，允许开发者插入逻辑去修改 class 文件，更多的关于 Transform 的介绍和使用可以查看其他博客。</p>
<p>在 ARouter 中也使用到了 Transform ，它会修改 LogisticsCenter 类中的 loadRouterMap() 方法，即自动在编译完成后，修改该方法，为该方法中插入代码逻辑。至于它是怎么插入的，详见 arouter-gradle-plugin模块中的逻辑，建议在看之前先熟悉 Transform API和 ASM。我们接下来只讲最终的结果。</p>
<p>在Transform操作之后，LogisticsCenter 类中的 loadRouterMap() 方法会插入如下代码（示例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRouterMap</span><span class="params">()</span> &#123;</span><br><span class="line">    registerByPlugin = <span class="literal">false</span>;</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin&quot;</span>);</span><br><span class="line">    register(<span class="string">&quot;com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即会插入多个 register() 方法的调用，并且在每次调用中都会将对应在编译时通过注解处理器生成的中间类的路径传入进去，注意此时 registerByPlugin 还是 false：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String className)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(className)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getConstructor().newInstance();</span><br><span class="line">            <span class="comment">// 这里都反射拿到实例类了，那么就可以使用 instanceof 了</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IRouteRoot) &#123;</span><br><span class="line">                registerRouteRoot((IRouteRoot) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IProviderGroup) &#123;</span><br><span class="line">                registerProvider((IProviderGroup) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IInterceptorGroup) &#123;</span><br><span class="line">                registerInterceptor((IInterceptorGroup) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">&quot;register failed, class name: &quot;</span> + className</span><br><span class="line">                        + <span class="string">&quot; should implements one of IRouteRoot/IProviderGroup/IInterceptorGroup.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(TAG, <span class="string">&quot;register class error:&quot;</span> + className, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerRouteRoot</span><span class="params">(IRouteRoot routeRoot)</span> &#123;</span><br><span class="line">    markRegisteredByPlugin();</span><br><span class="line">    <span class="keyword">if</span> (routeRoot != <span class="literal">null</span>) &#123;</span><br><span class="line">        routeRoot.loadInto(Warehouse.groupsIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">markRegisteredByPlugin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将 registerByPlugin 置为 true </span></span><br><span class="line">    <span class="keyword">if</span> (!registerByPlugin) &#123;</span><br><span class="line">        registerByPlugin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 register() 方法中，首先会将传入的中间类通过反射实例化，接着判断其类型，比如是 IRouteRoot 时，则调用 registerRouteRoot() 方法来调用其 loadInto() 方法并且还是传入的 Warehouse.groupsIndex。与此同时还会调用 markRegisteredByPlugin() 方法来将 registerByPlugin 置为 true 。</p>
<p>所以总结下这种方式：在编译时，注解处理器会生成对应的中间类，接着等所有的类都编译完成准备合并成 dex 时，会执行 Transform 操作，此时会将对应的中间类拿到，接着往 LogisticsCenter 类中的 loadRouterMap() 方法内插入逻辑，将这些中间类关联进去。</p>
<p>接着完成打包工作，运行app时，ARouter.init() 方法被执行，进而 LogisticsCenter 类中的 loadRouterMap() 方法被执行，此时该方法内部的逻辑执行，完成中间类反射实例化，以及其内部方法的执行，进而完成路由信息的加载。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此，对于 ARouter 的原理的分析就结束了，它内部通过 注解处理器完成中间类生成，保存好路由信息。接着会通过 Transfrom API 或者遍历 dex 文件的方式来将这些中间类收集起来，并且完成反射实例化，进而执行其对应的方法，完成其内部保存的路由信息的读取。</p>
<p>另外，本文对于ARouter 中的源码逻辑分析的比较少，主要侧重于其原理方面的介绍。而具体的源码我觉得比较简单，不想花费精力，也没必要花费时间去加注释贴出来，望见谅。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Android/">Android</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/898ecc0a.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">OkHttp 请求创建</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/8f14e4f4.html">
        <span class="next-text nav-default">Android Activity 启动流程全解析</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
