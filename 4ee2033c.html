<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="传送门"/>








  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/4ee2033c.html"/>


<meta name="description" content="断断续续的好几年，写了挺多，也比较杂，这里作为总的引导来将这些杂七杂八的文章分类下，方便查阅。   ijkplayer当时刚大学毕业，接到一个音视频相关的需求，组内没有其他人熟悉，所以就只能自己去学习。期间看完了 B站开源的 ijkplayer 开源项目 和 google的 ExoPlayer  中的部分源码。但是在后面需求做完之后就没有再往下看了，也算是烂尾了，不过对于音视频的理解还是有的，捡起">
<meta property="og:type" content="article">
<meta property="og:title" content="传送门">
<meta property="og:url" content="https://youngkaaa.github.io/4ee2033c.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="断断续续的好几年，写了挺多，也比较杂，这里作为总的引导来将这些杂七杂八的文章分类下，方便查阅。   ijkplayer当时刚大学毕业，接到一个音视频相关的需求，组内没有其他人熟悉，所以就只能自己去学习。期间看完了 B站开源的 ijkplayer 开源项目 和 google的 ExoPlayer  中的部分源码。但是在后面需求做完之后就没有再往下看了，也算是烂尾了，不过对于音视频的理解还是有的，捡起">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2096-04-24T16:00:01.000Z">
<meta property="article:modified_time" content="2023-03-16T12:39:20.707Z">
<meta property="article:author" content="咔咔咔">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 传送门 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          传送门
        
      </h1>

      <time class="post-time">
          4月 25 2096
      </time>
    </header>



    
            <div class="post-content">
            <p>断断续续的好几年，写了挺多，也比较杂，这里作为总的引导来将这些杂七杂八的文章分类下，方便查阅。</p>
<hr>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><hr>
<h3 id="ijkplayer"><a href="#ijkplayer" class="headerlink" title="ijkplayer"></a>ijkplayer</h3><p>当时刚大学毕业，接到一个音视频相关的需求，组内没有其他人熟悉，所以就只能自己去学习。期间看完了 B站开源的 <a target="_blank" rel="noopener" href="https://github.com/bilibili/ijkplayer">ijkplayer 开源项目</a> 和 google的 <a target="_blank" rel="noopener" href="https://github.com/google/ExoPlayer">ExoPlayer </a> 中的部分源码。但是在后面需求做完之后就没有再往下看了，也算是烂尾了，不过对于音视频的理解还是有的，捡起来这些东西接着往后学习也是很快的。下面贴出当时写的一些文章(文章太多就只贴出来总的列表)。</p>
<p><a href="https://youngkaaa.github.io/tags/ijkplayer/">ijkplayer 所有文章</a> </p>
<hr>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><hr>
<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>Binder 这个东西，在 Android 中是一个很重要的角色，但是绝大多数Android应用层开发人员都很少使用它，更准确来说是很少能感知到它的存在，顶多使用官方提供的 AIDL 来完成匿名Binder通讯，或者使用提供好的方法获取系统服务。但是它作为一个优秀的跨进程方案实现，还是很值得学习的，尤其是当你进入到Native Framework学习时，会经常遇到 BpBinder ，BBinder 等类，不先学习它的话，后续会总感觉懵懵懂懂的。</p>
<ol>
<li>简要介绍 Binder 是啥，为啥要使用它？不牵扯代码，只是概念介绍： <a href="4edb72cd.html">Binder - 简介</a> </li>
<li>学习之前，先了解下其内部相关的类定义，类属性，为后续看源码打好基础：<a href="5d545083.html">Binder - 类介绍</a></li>
<li>从作为数据发送方的进程开始，分析数据是怎么通过 Binder 发送出去的 ：<a href="5b9837b1.html">Binder - Client数据发送</a></li>
<li>分析Binder驱动中接收到来自发送方进程的数据之后，在内核态中是怎么处理的：<a href="9a74aa64.html">Binder - Binder驱动数据处理</a></li>
<li>分析接收方进程怎么接受来自其他进程的数据，也就是怎么处理来自Binder驱动的数据：<a href="1d5df811.html">Binder - Server数据处理</a></li>
<li>分析应用开发中常见的 AIDL 原理，即匿名Binder ：<a href="2af50710.html">Binder - Java Framework</a></li>
</ol>
<hr>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><hr>
<h3 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h3><p>在学习 SurfaceFlinger 中的 Surface ，以及 Layer 时，建议先了解下 Framework 中的 生产消费队列，对后续的学习大有裨益。</p>
<ol>
<li>BufferQueue 简介，先对其牵扯到的接口类有个大概认识：<a href="98c274c6.html">BufferQueue 简介</a></li>
<li>BufferQueue 源码分析，包括了生产者 BufferQueueProducer 和消费者 BufferQueueConsumer ：<a href="dff29dd0.html">BufferQueue 分析</a></li>
</ol>
<hr>
<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><hr>
<h3 id="Surface-amp-Layer"><a href="#Surface-amp-Layer" class="headerlink" title="Surface &amp; Layer"></a>Surface &amp; Layer</h3><p>在学习完 BufferQueue 之后，趁热打铁，看看 Surface 及其相关的 SurfaceControl 、ComposerService 、Layer 等知识。这里会从上层 Java Framework 讲到底层 Native Framework，打通上下层知识。</p>
<ol>
<li>预备知识，学习下怎么与 SurfaceFlinger 进程进程交互通讯：<a href="99318d8c.html">Surface学习(一)–ComposerService</a></li>
<li>学习 Layer ，及其对应常用的子类源码实现：<a href="25fde216.html">Surface学习(二)–Layer简介</a></li>
<li>学习 Surface ，及其相关的属性，如 SurfaceSession、SurfaceControl 等：<a href="91da79fe.html">Surface学习(三)–Layer简介</a></li>
</ol>
<hr>
<h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><hr>
<h3 id="EGL-amp-GLES"><a href="#EGL-amp-GLES" class="headerlink" title="EGL &amp; GLES"></a>EGL &amp; GLES</h3><p>学习它是为了更好的理解Android渲染系统，也是为后续  SurfaceFlinger 中 Layer 合成 以及 开机动画 BootAnimation 做铺垫。在学习EGL过程中，会让你对EGL，以及它和 GLES 的关系 有更深的认识，而不是永远停留在别人博客中的八股文介绍。</p>
<ol>
<li>简单介绍下 EGL 和 GLES 这俩的概念，让你对它有简单的认识：<a href="c4a594c7.html">GLES&amp;EGL-总述</a></li>
<li>介绍 EGL 中的基础概念，以及其 eglGetDisplay() 等方法原理：<a href="aa48ac49.html">GLES&amp;EGL-EGL-01</a></li>
<li>介绍 EGL 中的驱动加载逻辑，需要搭配上面的 <a href="aa48ac49.html">GLES&amp;EGL-EGL-01</a>文章一起看：<a href="3c88db7.html">GLES&amp;EGL-Loader-驱动加载</a></li>
<li>介绍 EGL 中的 EGLSurface 和 EGLContext ：<a href="3341fdf3.html">GLES&amp;EGL-EGL-02</a></li>
<li>介绍 EGL 中怎么完成 EGLSurface 和 EGLContext 的绑定，以及怎么完成数据帧的提交：<a href="4446cd65.html">GLES&amp;EGL-EGL-03</a></li>
<li>介绍 GLES 中的纹理生成，绑定，参数设置等逻辑：<a href="e803de1e.html">GLES&amp;EGL-GLES-01</a></li>
<li>介绍 GLES 中像素输入的输入，激活纹理等逻辑：<a href="710a8fa4.html">GLES&amp;EGL-GLES-02</a></li>
<li>介绍 GLES 中最重要的一步，完成渲染工作的逻辑：<a href="60dbf32.html">GLES&amp;EGL-GLES-03</a></li>
</ol>
<hr>
<h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><hr>
<h3 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h3><p>做久了应用层，对其底层的原理越来越感兴趣，在看完了 Java Frameworks 中的 ViewRootImpl 以及 Choreographer 之后，对 Vsync信号处理，以及屏幕刷新机制变得愈发好奇，因此开始了对 SurfaceFlinger 相关知识的学习。</p>
<ol>
<li>SurfaceFlinger 的初始化：<a href="2fa835ad.html">SurfaceFlinger - INIT</a></li>
<li>SurfaceFlinger 中处理事件的EventThread ：<a href="7b339bd2.html">SurfaceFlinger - EventThread</a></li>
<li>SurfaceFlinger 中控制 HWC Vsync信号的 EventControlThread ：<a href="5e3d97eb.html">SurfaceFlinger - EventControlThread</a></li>
<li>SurfaceFlinger 中 Vsync 信号的模拟和处理 ：<a href="6caea16d.html">SurfaceFlinger - DispSync &amp; DispSyncSource</a></li>
<li>SurfaceFlinger 中的 DisplayDevice 介绍，了解它可以更方便的学习后续知识：<a href="127ce872.html">SurfaceFlinger - DisplayDevice</a></li>
<li>SurfaceFlinger 中合成 Layer 前的 INVALIDATE 逻辑 ：<a href="5440e75b.html">SurfaceFlinger - INVALIDATE</a></li>
<li>SurfaceFlinger 中合成 Layer 时的刷新预操作 ：<a href="7cbfb0e.html">SurfaceFlinger - REFRESH - (1)</a></li>
<li>SurfaceFlinger 中合成 Layer 的逻辑： <a href="bf779c6b.html">SurfaceFlinger - REFRESH - (2)</a></li>
<li>持续学习，待续输出中…</li>
</ol>
<hr>
<h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><hr>
<h3 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h3><p>介绍应用层 Jetpack 系列库的源码，这些都是在实际项目开发中使用到的，在使用时就对其感兴趣，所以就抽空都看了源码。有些Jetpack 中的库暂时还没有用到，所以先放着，等待后续补充…..</p>
<ol>
<li>Jetpack 中的 Lifecycle 库，它可以说是好多库的基础 ：<a href="8dd4bfe0.html">Jetpack- Lifecycle</a></li>
<li>Jetpack 中为 MVVM 出的库 ViewModel ： <a href="6d1e424c.html">Jetpack- ViewModel</a></li>
<li>Jetpack 中 MVVM 框架中另外一个重要的部分 ：<a href="84ecfaa3.html">Jetpack- LiveData</a></li>
<li>Jetpack 中为了替代传统 onActivityResult 方法，降低业务耦合的库： <a href="c801eba.html">Jetpack- Activity Result Api</a></li>
<li>持续补充中….</li>
</ol>
<hr>
<hr>
<h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h3 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h3><p>实际在项目中使用 Kotlin 已经有两三年了(没错，练习时长两年半了)，它提供的协程库 Coroutine 也正式投产使用一年多了，使用起来确实很舒服。一开始对协程这个概念就有不同的理解，看了很多的博客都感觉各说各的，所以自己去看了一遍它的源码，对它和线程池有了新的认识，以及对Kotlin编译器黑魔法有了简单的认识。</p>
<ol>
<li>协程简介，以及对协程中的关键接口、类所起的作用，担任的角色做讲解：<a href="64b5b134.html">Kotlin协程 - 概述</a></li>
<li>对协程中一些基础概念，基础类做源码分析，为后续正式学习做好铺垫：<a href="ec1be5bf.html">Kotlin协程 - 基础概念介绍</a></li>
<li>分析协程的启动，主要以 launch 方法作为切入点开始分析：<a href="b72a4fb1.html">Kotlin协程 - 协程启动原理</a></li>
<li>介绍协程中的“挂起”概念，对“挂起”做原理分析：<a href="e2cf098c.html">Kotlin协程 - 协程挂起原理</a></li>
<li>介绍协程中的拦截器概念，及其原理分析：<a href="ff74222f.html">Kotlin协程 - 拦截器原理</a></li>
</ol>
<hr>
<h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><hr>
<h3 id="其他优秀开源库"><a href="#其他优秀开源库" class="headerlink" title="其他优秀开源库"></a>其他优秀开源库</h3><p>在应用层开发中遇到了很多优秀的开源库，在平时对于他们的使用中，就会经常习惯性的点进源码看实现，有时候看着看着会陷入进去。有时候遇到一些厉害的、好用的库，总会想：这是怎么实现的？会不会是这样实现的？所以会情不自禁的看看别的怎么实现的，看完之后频频咂舌，拍掌叫好，这人代码写的真牛逼。当然看多了这些，对于自己的编程思路也会大有裨益。</p>
<ol>
<li>ARouter，解决模块间通讯、路由等能力，主要学习其思想：<a href="d414997b.html">ARouter 原理分析</a></li>
<li>OkHttp , Android开发中基本都在用的一个网络库，主要从三个方面进行简单分析：<ul>
<li>分析OkHttp中请求创建的流程，以及其内部的 RealCall ，AsyncCall 等： <a href="898ecc0a.html">OkHttp 请求创建</a></li>
<li>分析OkHttp中的拦截链，包括其中的拦截器流程分析：<a href="52da40ac.html">OkHttp 拦截器介绍</a></li>
<li>分析OkHttp中的连接池复用逻辑，以及连接的复用规则：<a href="a4b11ed8.html">OkHttp 连接缓存池</a></li>
</ul>
</li>
<li>Retrofit，基于OkHttp二次封装的网络库，主要通过两篇文章来分析：<ul>
<li>分析 Retrofit 中的动态代理使用，以及 ServiceMethod  的创建流程：<a href="b80024b2.html">Retrofit-动态代理中的秘密</a></li>
<li>分析 Retrofit 中的常用接口和实现类，以及 ServiceMethod  的执行流程：<a href="3e87a46f.html">Retrofit-执行中的秘密</a></li>
</ul>
</li>
<li>leakcanary，一款可以实现内存泄露监测的库：<ul>
<li>分析 leakcanary 库的安装准备工作流程： <a href="7e3c732d.html">leakcanary install 分析</a> </li>
<li>分析 leakcanary 中内存泄露检测的原理： <a href="4f3e124f.html">leakcanary回收检测原理</a></li>
</ul>
</li>
</ol>
<hr>
<hr>
<h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><h3 id="其他零散的Java知识点"><a href="#其他零散的Java知识点" class="headerlink" title="其他零散的Java知识点"></a>其他零散的Java知识点</h3><p>在学习其他开源库时，总会遇到一些Java中我不太熟悉的知识点，所以会趁着看开源库的功夫，把它们也一起研究了，一是对自己算是查漏补缺，另外也有助于对开源库代码的学习，正所谓磨刀不误砍柴工。而这里主要讲这些零散的知识点整理汇总起来</p>
<ol>
<li>经常在开源库中遇到动态代理，比如 Retrofit；以及在后端 Spring 中的 AOP 等：<a href="4d381682.html">Java 动态代理原理分析</a></li>
<li>经常会在并发编程中遇到一些 Lock ，为了能更好的理解它们，所以学了了 JUC 包下的一些常用类：<ul>
<li>通过ReentrantLock中的 Lock，来学习AQS :  <a href="3fecc955.html">AQS-ReentrantLock-Lock-源码分析</a>  </li>
<li>通过ReentrantLock中的 Condition，来学习AQS : <a href="591e1c31.html">AQS-ReentrantLock-Condition-源码分析</a></li>
<li>了解 CountDownLatch  中的那些事儿 : <a href="591e1c31.html">AQS-CountDownLatch </a></li>
</ul>
</li>
</ol>
<hr>
<hr>
<h3 id="其他零散的Android知识点"><a href="#其他零散的Android知识点" class="headerlink" title="其他零散的Android知识点"></a>其他零散的Android知识点</h3><p>在学习Android Framework 时，总会遇到一些不知道来由的知识点，有时候并不影响自己当时的源码学习，但总觉得缺点什么。所以遇到这种情况我一般会先去学习好这些知识点，再回来看源码，这样可以加深我后续的学习理解。当然这些知识点就跟小鸡啄米一样，东一块西一块，并不成体系，所以零散的把它们堆在这里吧。</p>
<ol>
<li><p>Android Java Framework 层的系统服务加载流程 ：<a href="d663666b.html">Android 系统服务加载启动</a></p>
</li>
<li><p>Android Service 启动流程全解析 ： <a href="49929abd.html">Android Service 启动流程全解析</a></p>
</li>
<li><p>Android Activity 启动流程全解析：<a href="8f14e4f4.html">Android Activity 启动流程全解析</a></p>
</li>
</ol>
<hr>
<hr>
<h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><hr>
<h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><hr>
<h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><p>当然，学习还是在进行中，对 Android 世界的探索还在继续中。</p>
<p>另外：以上都是我学习过程中的记录，难免会有理解上的偏差和错误，因为毕竟是在分析别人的代码，猜测别人的意图还是不太容易的(ಥ﹏ಥ)，所以说如果有不对敬请见谅，敬请斧正 &#x3D;&#x3D;&gt; <a href="mailto:&#121;&#111;&#117;&#x6e;&#103;&#107;&#x61;&#x61;&#x61;&#64;&#113;&#113;&#46;&#x63;&#111;&#109;">&#121;&#111;&#117;&#x6e;&#103;&#107;&#x61;&#x61;&#x61;&#64;&#113;&#113;&#46;&#x63;&#111;&#109;</a> !</p>

            </div>
          

    
      <footer class="post-footer">
		

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/3c88db7.html">
        <span class="next-text nav-default">GLES&EGL-Loader-驱动加载</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
