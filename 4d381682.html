<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Java 动态代理原理分析"/>




  <meta name="keywords" content="Java," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/4d381682.html"/>


<meta name="description" content="在设计模式中存在一种：代理模式，其定义为：为其他对象提供一种代理以控制对这个对象的访问 。它的好处是可以在不修改被代理对象的基础上，通过扩展新的代理类，来进行一些功能的附加与增强。 但是值得注意的是，代理类和被代理类应该共同实现同一个接口，或者是共同继承某个类。 而对于代理的实现方式中有很多种，包括静态代理和动态代理，而动态代理中又分为好几类，比如基于 Java 的动态代理、基于cglib 等开源">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 动态代理原理分析">
<meta property="og:url" content="https://youngkaaa.github.io/4d381682.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="在设计模式中存在一种：代理模式，其定义为：为其他对象提供一种代理以控制对这个对象的访问 。它的好处是可以在不修改被代理对象的基础上，通过扩展新的代理类，来进行一些功能的附加与增强。 但是值得注意的是，代理类和被代理类应该共同实现同一个接口，或者是共同继承某个类。 而对于代理的实现方式中有很多种，包括静态代理和动态代理，而动态代理中又分为好几类，比如基于 Java 的动态代理、基于cglib 等开源">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-04T13:48:56.000Z">
<meta property="article:modified_time" content="2023-03-08T13:53:11.307Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Java 动态代理原理分析 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Java 动态代理原理分析
        
      </h1>

      <time class="post-time">
          5月 04 2021
      </time>
    </header>



    
            <div class="post-content">
            <p>在设计模式中存在一种：代理模式，其定义为：为其他对象提供一种代理以控制对这个对象的访问 。它的好处是可以在不修改被代理对象的基础上，通过扩展新的代理类，来进行一些功能的附加与增强。</p>
<p>但是值得注意的是，代理类和被代理类应该共同实现同一个接口，或者是共同继承某个类。</p>
<p>而对于代理的实现方式中有很多种，包括静态代理和动态代理，而动态代理中又分为好几类，比如基于 Java 的动态代理、基于<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">cglib</a> 等开源库的动态代理。而本文主要介绍动态代理中的前者，即基于 Java 的动态代理 。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>在看动态代理之前，首先先看看静态代理怎么实现。比如目前有一个接口 UserManager：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t同时对于该接口，提供了一个实现类 UserManagerImpl：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;selecting.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;updating.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其实现中没有过多的逻辑，仅仅只是做了日志打印。此时，我们假如想要对这个 UserManagerImpl 中的方法做一些额外处理，比如调用统计，外部每调用一次 UserManagerImpl 的 select() 或者 update() 方法，都会记录下来，这里使用日志输出来代替。</p>
<p>遇到这种变动，一种方式是直接改 UserManagerImpl 的源码，在他内部这俩方法中加上统计逻辑日志输出即可，这种方式需要动原实现类。但是仔细想想，当前这个需求相当于是为原先的 UserManagerImpl 做逻辑增强，而不是逻辑变更。所以我们可以尝试使用另外一种方式，即代理方式来完成这个工作。</p>
<p>新建一个 UserManagerProxy 类，它也实现自 UserManager 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserManagerProxy</span> <span class="keyword">implements</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserManager userManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将被代理的对象实例传入进来，保存起来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserManagerProxy</span><span class="params">(UserManager userManager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userManager = userManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这是增强的代码</span></span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 执行被代理对象原来的逻辑</span></span><br><span class="line">        userManager.select();</span><br><span class="line">        <span class="comment">// 这是增强的代码</span></span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        userManager.update();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; ------ Static Before ------ &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; ------ Static After ------ &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在代理实现类 UserManagerProxy 中，首先在入参中接收一个 UserManager 实例，也就是被代理对象实例。在这里他就是 UserManagerImpl 实例。</p>
<p>接着在重写自 UserManager 的这俩方法中分别编写新逻辑，即在方法调用开始和结束时输出日志，在这俩中间还是调用被代理类的对应方法。而外部则使用这个 UserManagerProxy 实例，后续在调用该 UserManagerProxy 实例的对应方法时，就可以执行逻辑增强后的代码了。</p>
<p>很容易理解吧。但是当后续还要有其他逻辑修改时，我们又得创建一个其他的代理类，如此下来，静态代理的弊端就显露出来了，那就是你得提前自己去编写好代理类，如果代理类很多，你也得一个个提前编写好，这也正是“静态” 的意思了。不想自己写？那么我们就需要使用动态代理了。</p>
<h3 id="Java-动态代理"><a href="#Java-动态代理" class="headerlink" title="Java 动态代理"></a>Java 动态代理</h3><p>目前只讲 Java 中提供的动态代理方式，而基于 cglib 等库实现的动态代理暂时不讲，后续有机会的话会单开文章来分析。</p>
<p>下面先看看 Java 动态代理是怎么用的：</p>
<p>先编写一个类实现 InvocationHandler 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存被代理的对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 插入增强的代码</span></span><br><span class="line">        before();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行被代理类中原来的业务逻辑</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入增强的代码</span></span><br><span class="line">        after();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; ------ Dynamic Before ------ &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; ------ Dynamic After ------ &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InvocationHandler 接口中就只有一个 invoke() 方法，他会包括三个参数：</p>
<p>① proxy ：类型是 Object 类型的，它表示的是动态代理自动帮我们生成的代理类实例。</p>
<p>② method ：当前外部调用，或者说是触发的是接口中的哪个方法。这里说的接口在后面调用 Proxy.newProxyInstance() 方法时会指定。简单来说就是用来区分你调用了哪个方法。</p>
<p>③ args：和上面 method 对应是一组，这里表示的是外部调用该 method 时对应传入的参数列表。</p>
<p>而在 invoke() 方法的实现中，会调用 method.invoke(target, args) 来执行 target 中的该方法，而这里的 target 就是被代理的对象实例，也就是调用到被代理对象中去，完成被代理类中原来的业务逻辑。</p>
<p>当然在 method.invoke(target, args) 调用之外的地方，你可以插入任何你想插入的逻辑，比如这里还是日志输出。</p>
<p>接着看当前 LogHandler 是怎么被使用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建被代理的对象，UserManager 接口的实现类</span></span><br><span class="line"><span class="type">UserManager</span> <span class="variable">userManagerImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserManagerImpl</span>();</span><br><span class="line"><span class="comment">// 2. 获取对应的 ClassLoader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> UserManagerImpl.class.getClassLoader();</span><br><span class="line"><span class="comment">// 3. 获取所有接口的Class，这里的 UserServiceImpl 只实现了一个接口 UserManager</span></span><br><span class="line">Class&lt;?&gt;[] interfaces = UserManagerImpl.class.getInterfaces();</span><br><span class="line"><span class="comment">// 4. 创建一个 LogHandler 实例，并且将真正被代理的类实例传入进去</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogHandler</span>(userManagerImpl);</span><br><span class="line"><span class="comment">// 5. 调用 Proxy.newProxyInstance 来动态生成一个代理类</span></span><br><span class="line"><span class="type">UserManager</span> <span class="variable">userManagerProxy</span> <span class="operator">=</span> (UserManager) Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line"><span class="comment">// 调用代理类的方法就行了</span></span><br><span class="line">userManagerProxy.select();</span><br><span class="line">userManagerProxy.update();</span><br></pre></td></tr></table></figure>

<p>这是一个通用流程，用多了就记住了。这里接下来主要看：Proxy.newProxyInstance() 方法是怎么实现动态生成代理类的。</p>
<h4 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h4><p>在正是看源码之前，先看看最终自动生成的代理类是什么样的，方便后续分析源码逻辑的分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名是 $Proxy0 ，继承自 Proxy 类，实现了 UserManager 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">UserManager</span> &#123;</span><br><span class="line">    <span class="comment">// 这些 method 的赋值在最下面 static 代码块中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于继承自 Proxy ，所以这里会实现其构造方法，接收一个 InvocationHandler 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写父类的 equals 方法，内部还是会执行其父类的 equals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写父类的 toString 方法，内部还是会执行其父类的 toString</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 UserManager 接口的 select 方法，内部会调用 h.invoke()</span></span><br><span class="line"><span class="comment">     * 也就是调用到 InvocationHandler.invoke() 方法中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行到 invoke 中，由于当前方法没有参数，所以最后一个传的是 null</span></span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m4, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写父类的 hashCode 方法，内部会调用到 InvocationHandler 中去</span></span><br><span class="line"><span class="comment">     * 所以外部在编写 InvocationHandler 实例是可以处理该 method 来设置其对应的 hashCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 UserManager 接口的 update 方法，内部会调用 h.invoke()</span></span><br><span class="line"><span class="comment">     * 也就是调用到 InvocationHandler.invoke() 方法中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行到 invoke 中，由于当前方法没有参数，所以最后一个传的是 null</span></span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// m0 对应其父类 Object 中的 hashCode 方法</span></span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            <span class="comment">// m1 对应其父类 Object 中的 equals 方法</span></span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            <span class="comment">// m2 对应其父类 Object 中的 toString 方法</span></span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            <span class="comment">// m3 对应它实现接口中的 update 方法</span></span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;cn.youngkaaa.UserManager&quot;</span>).getMethod(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">            <span class="comment">// m4 对应它实现接口中的 select 方法</span></span><br><span class="line">            m4 = Class.forName(<span class="string">&quot;cn.youngkaaa.UserManager&quot;</span>).getMethod(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f生成的中间类名称为：$Proxy0 ，而其实这个文件名也是有格式的，具体格式后面源码分析中会讲。生成的类是继承自 Proxy 并且实现了 UserManager 接口的，其他详见上面注释。</p>
<p>其实看完这个最终生成的代理类就可以明白前面  InvocationHandler.invoke() 方法是是干啥的了。</p>
<p>当外部开发者使用 Proxy.newProxyInstance() 方法返回拿到这个 $Proxy0 类实例之后，调用其方法，比如 update()，此时会执行到上面生成的类中，进而执行：super.h.invoke() 方法，传入 m3 ，而m3 其实就对应的是 update() 方法的 Method 实例，这样的话外部的 LogHandler 中的 invoke() 方法就会收到回调，进而执行后续逻辑。这便是动态代理的流程。</p>
<p>接下来看 Proxy.newProxyInstance() 源码中是怎么生成这个类实例的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proxy.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">        InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入的 InvocationHandler 实例不能为空</span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆代理类实现的所有接口</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全校验</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 loader 和 intfs 参数来查找一个对应的代理类，而这个类就是内部自动生成的代理类</span></span><br><span class="line"><span class="comment">     * 而这里直接拿到的是 Class ，说明该文件目前已生成完毕且装载了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射拿到这个动态生成的类中的构造方法，这个构造方法接收一个 InvocationHandler 参数</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="comment">// 如果该构造方法不是 public 的，则将其改为可访问的</span></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用动态生成类中的构造方法，传入参数 h ，也就是当前 newProxyInstance 的入参 h</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newProxyInstance() 方法它接收三个参数：</p>
<p>① loader ：当前被代理类，也就是  UserManagerImpl 对应的 ClassLoader 实例。</p>
<p>② interfaces ：当前被代理类，也就是  UserManagerImpl 所实现的接口列表，即它实现了哪些接口，这里只有 UserManager 一个。</p>
<p>③ h ：外部开发者实现好的 InvocationHandler 接口实例。</p>
<p>接着往下看逻辑，newProxyInstance() 方法中的主要逻辑概括为三步：</p>
<p>① 调用 getProxyClass0() 方法拿到该 loader 和 interfaces 所对应的，动态生成的类的 Class 实例。能拿到 Class 实例，则表示已经 动态生成完毕了，并且已经完成了装载工作。</p>
<p>② 拿到这个 动态生成 的类中定义的构造方法，这个构造方法只接收一个 InvocationHandler 参数。</p>
<p>③ 调用该构造方法，将当前 newProxyInstance() 方法传入的 InvocationHandler 实例设置进去，进而创建出这个动态生成的类的实例并返回出去给外部调用。</p>
<p>其中后两步都比较简单，核心在第一步 getProxyClass0() 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proxy.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> <span class="title class_">WeakCache</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Proxy</span>.KeyFactory(), <span class="keyword">new</span> <span class="title class_">Proxy</span>.ProxyClassFactory());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">        Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxyClassCache 中去获取 loader 、interfaces 对应的，动态生成的类</span></span><br><span class="line"><span class="comment">     * 如果没有的话，会去创建一个；有的话则直接返回之前创建的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要逻辑还是交给 Proxy 类中定义的 proxyClassCache 中了。</p>
<p>先看看这个 WeakCache 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakCache.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WeakCache</span>&lt;K, P, V&gt; &#123;    </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, ?&gt; subKeyFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, V&gt; valueFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeakCache</span><span class="params">(BiFunction&lt;K, P, ?&gt; subKeyFactory,</span></span><br><span class="line"><span class="params">            BiFunction&lt;K, P, V&gt; valueFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subKeyFactory = Objects.requireNonNull(subKeyFactory);</span><br><span class="line">        <span class="built_in">this</span>.valueFactory = Objects.requireNonNull(valueFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里将传进去的 KeyFactory 实例和 ProxyClassFactory 实例分别保存给 WeakCache 中的 subKeyFactory 和 valueFactory 属性中。</p>
<p>并且 WeakCache 是一个泛型类，它支持三个泛型： K、P、V ，分别代表 Key ，Params 和 Value ，结合前面 Proxy 中的定义可知，Proxy 中的 proxyClassCache 接受的key 是 ClassLoader ，参数param是 Class&lt;?&gt;[] ，返回的结果 value 是 Class 实例。</p>
<p>接下来看它的 get() 方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakCache.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key, P parameter)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查入参 parameter 不能为 null ，也就是传入的接口列表不能为空</span></span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除过期的缓存</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时入参 key 类型是 ClassLoader</span></span><br><span class="line"><span class="comment">     * 使用入参 key，也就是 ClassLoader 实例，来构建一个 CacheKey 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 map 中获取出 cacheKey 对应的 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; 实例</span></span><br><span class="line"><span class="comment">     * 即一个 ClassLoader 对应一个 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="comment">// 如果该 ClassLoader 是第一次，则为其创建一个新的</span></span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">                = map.putIfAbsent(cacheKey, valuesMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时入参 parameter 类型是  Class&lt;?&gt;[] ，即被代理类所实现的接口列表</span></span><br><span class="line"><span class="comment">     * 使用前面设置进来的 subKeyFactory 来为 parameter 创建一个 key ，这个key叫做 subKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">subKey</span> <span class="operator">=</span> Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    <span class="comment">// 获取 subKey 对应的 Supplier 实例</span></span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为可能是多线程并发的，所以这里自旋处理，一直处理到 supplier.get() 不为空为止</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 subKey 对应的 Supplier 实例不为空，则使用它来拿到结果返回出去</span></span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">            <span class="comment">// 当然如果 supplier 实例此时拿到的结果还可能是空的</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上面没有拿到结果，此时创建一个 Factory 实例，来将这里的 key ，subkey 入参都保存起来</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> <span class="title class_">Factory</span>(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将该 Factory 实例保存起来，后续使用 subKey 就能查到这个 Factory 实例了</span></span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="literal">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="comment">// 将新的 factory 保存起来</span></span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="literal">null</span>) &#123;</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 替换掉之前的</span></span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// 替换成功了，使用新的</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 替换失败，使用旧的再试一次</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>概括下当前方法中的步骤：</p>
<p>① 先调用 expungeStaleEntries()  方法来清理掉那些目前已被GC回收的 CacheKey 。</p>
<p>② 调用 CacheKey.valueOf() 方法来为 key 创建一个 CacheKey 实例。下面看看这个 CacheKey 是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakCache.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自 WeakReference ，所以会被后续 GC 回收</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CacheKey</span>&lt;K&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;K&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a replacement for null keys</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">NULL_KEY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;K&gt; Object <span class="title function_">valueOf</span><span class="params">(K key, ReferenceQueue&lt;K&gt; refQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span></span><br><span class="line">                <span class="comment">// null key means we can&#x27;t weakly reference it,</span></span><br><span class="line">                <span class="comment">// so we use a NULL_KEY singleton as cache key</span></span><br><span class="line">                ? NULL_KEY</span><br><span class="line">                <span class="comment">// non-null key requires wrapping with a WeakReference</span></span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">CacheKey</span>&lt;&gt;(key, refQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承自 WeakReference ，并且制定了一个 ReferenceQueue ，所以后续该实例被回收时会将其放入到 refQueue 中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CacheKey</span><span class="params">(K key, ReferenceQueue&lt;K&gt; refQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(key, refQueue);</span><br><span class="line">        <span class="comment">// 使用key来创建一个 hash</span></span><br><span class="line">        <span class="built_in">this</span>.hash = System.identityHashCode(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        K key;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="built_in">this</span> ||</span><br><span class="line">                obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        obj.getClass() == <span class="built_in">this</span>.getClass() &amp;&amp;</span><br><span class="line">                        <span class="comment">// cleared CacheKey is only equal to itself</span></span><br><span class="line">                        (key = <span class="built_in">this</span>.get()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        <span class="comment">// compare key by identity</span></span><br><span class="line">                        key == ((WeakCache.CacheKey&lt;K&gt;) obj).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里创建的 CacheKey 是继承自 WeakReference ，并且为其指定了一个 ReferenceQueue 实例，所以后期等GC垃圾回收时，该 CacheKey  会被回收掉，并且会将回收掉的 CacheKey  放入到 ReferenceQueue 队列中，所以后续遍历这个队列就可以知道哪些 CacheKey 被回收掉了。</p>
<p>而 CacheKey  中仅仅就是使用入参 key 来生成hash而已。而这里的 key 实际是 ClassLoader 实例，所以说使用同一个 ClassLoader 创建的  CacheKey  是“相等”的。</p>
<p>接着这里补充一下前面的  expungeStaleEntries()  方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakCache.java</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    WeakCache.CacheKey&lt;K&gt; cacheKey;</span><br><span class="line">    <span class="comment">// 从 refQueue 中取出 cacheKey ，这些取出的 cacheKey 是被回收掉的</span></span><br><span class="line">    <span class="keyword">while</span> ((cacheKey = (WeakCache.CacheKey&lt;K&gt;)refQueue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除这些 cacheKey 对应的 value</span></span><br><span class="line">        cacheKey.expungeFrom(map, reverseMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">expungeFrom</span><span class="params">(ConcurrentMap&lt;?, ? extends ConcurrentMap&lt;?, ?&gt;&gt; map,</span></span><br><span class="line"><span class="params">                 ConcurrentMap&lt;?, Boolean&gt; reverseMap)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前 cacheKey 对应的 valuesMap 移除掉</span></span><br><span class="line">    ConcurrentMap&lt;?, ?&gt; valuesMap = map.remove(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 同时将这些移除掉的对象从 reverseMap 中删掉</span></span><br><span class="line">    <span class="keyword">if</span> (valuesMap != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object cacheValue : valuesMap.values()) &#123;</span><br><span class="line">            reverseMap.remove(cacheValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为前面创建 CacheKey 时指定的 ReferenceQueue 是 refQueue ，所以此时可以从 refQueue 中遍历取出目前已被回收的 CacheKey 。</p>
<p>所以这里创建的 CacheKey 实际之和入参key，也就是 ClassLoader 有关。</p>
<p>③ 使用创建好的 CacheKey 从 map 中取出对应的 ConcurrentMap&lt;Object, Supplier<V>&gt; 实例，即一个 ClassLoader 对应一个 ConcurrentMap&lt;Object, Supplier<V>&gt; 实例，如果该 ClassLoader 是第一次执行 get() 方法，或者之前创建的被回收掉了，此时会再为其创建一个 ConcurrentMap 实例。</p>
<p>④ 调用 subKeyFactory.apply() 来创建 subKey。而这个 subKeyFactory 是前面在构造方法中传入进来的，实际对应的 Proxy.KeyFactory 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proxy.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyFactory</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BiFunction</span>&lt;ClassLoader, Class&lt;?&gt;[], Object&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据入参 interfaces 列表的长度来创建不用的对象实例</span></span><br><span class="line">        <span class="keyword">switch</span> (interfaces.length) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Key1</span>(interfaces[<span class="number">0</span>]); </span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Key2</span>(interfaces[<span class="number">0</span>], interfaces[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> key0;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyX</span>(interfaces);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样是继承自 WeakReference 的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Key1</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Class&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">    Key1(Class&lt;?&gt; intf) &#123;</span><br><span class="line">        <span class="built_in">super</span>(intf);</span><br><span class="line">        <span class="comment">// 使用入参 来创建hash</span></span><br><span class="line">        <span class="built_in">this</span>.hash = intf.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; intf;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> == obj ||</span><br><span class="line">                obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        obj.getClass() == Proxy.Key1.class &amp;&amp;</span><br><span class="line">                        (intf = get()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        intf == ((Proxy.Key1) obj).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 KeyFactory 中会根据入参 interfaces 数组的长度来创建不同的对象实例，比如长度为1时创建的是 Key1 实例，长度为2时创建的是 Key2 实例，大于2时创建的是 KeyX 实例，这里只挑其中一个来Key1来分析，它是最常用的，也是当前示例中实际用到的。</p>
<p>Key1也是继承自 WeakReference ，但是和前面 CacheKey 不同的是它没有指定 ReferenceQueue ，所以它被GC回收时并没有人知道，当然这里也不 care ，外面底层主key：CacheKey 回收会做清理工作，包括了subKey。而Key1 也是相同的接口入参时，创建出来的 Key1 实例也是相等的。</p>
<blockquote>
<p>注意这里的 subKey  是和get()方法的入参：接口列表 有关的，而前面的 CacheKey 是和get() 方法的入参：ClassLoader 有关的。</p>
<p>CacheKey ，也就是 ClassLoader 是一级缓存，而subKey 也就是接口列表 是二级缓存。</p>
</blockquote>
<p>⑤ 使用 subKey 去前面拿到的 ConcurrentMap 中查找对应的 supplier 。如果拿到的 supplier 不为空，则会调用其 get() 方法来拿到最终的返回值 value ，也就是一个 Class 实例；如果为空则会为其创建一个 Factory 实例并保存起来，然后开始下一次循环执行其 get() 方法来拿到最终的返回值。</p>
<p>注意这里是在一个 while 循环中轮询的，如果遇到其中一次失败了，会一直执行，直到拿到结果。</p>
<p>下面看看这里创建的 Factory 是什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakCache.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Factory</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> P parameter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object subKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key ： ClassLoader 实例</span></span><br><span class="line"><span class="comment">     * parameter : 接口列表</span></span><br><span class="line"><span class="comment">     * subKey ：使用 parameter 创建的Key1实例</span></span><br><span class="line"><span class="comment">     * valuesMap ： ClassLoader 对应的 ConcurrentMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Factory(K key, P parameter, Object subKey,</span><br><span class="line">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.parameter = parameter;</span><br><span class="line">        <span class="built_in">this</span>.subKey = subKey;</span><br><span class="line">        <span class="built_in">this</span>.valuesMap = valuesMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">()</span> &#123; <span class="comment">// serialize access</span></span><br><span class="line">        <span class="comment">// 再次检查下 supplier 现在是不是非空</span></span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        <span class="comment">// double check</span></span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// V 其实就是 Class 类型</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 调用  valueFactory.apply(key, parameter) 方法来返回最终的结果 Class</span></span><br><span class="line"><span class="comment">             * valueFactory 在前面构造方法中赋值为：ProxyClassFactory</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果生成结果失败，则将当前 Supplier 实例移除掉</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                valuesMap.remove(subKey, <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">assert</span> value != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 CacheValue 来讲返回值包装起来</span></span><br><span class="line">        CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> <span class="title class_">CacheValue</span>&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最终的结果缓存起来，后期回收时会用到</span></span><br><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="built_in">this</span>, cacheValue)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Should not reach here&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 get() 方法中会调用 valueFactory.apply() 来返回最终的结果，也就是自动生成的 Class 实例。而这个 valueFactory 的赋值就是之前在 WeakCache 构造方法中设置的，实际对应的是 ProxyClassFactory 实例，接着看ProxyClassFactory 中的 apply() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proxy.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProxyClassFactory</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BiFunction</span>&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态生成的中间类的前缀名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">proxyClassNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成中间类的序号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextUniqueNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">// 遍历接口进行验证</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加载接口类，获得接口类的类对象，第二个参数为false表示不进行实例化</span></span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="literal">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 验证 interfaceClass 是否是一个接口.</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// interfaceClass 在数组中是否有重复</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终生成代理类的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 生成代理类的访问标志, 默认是public final的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">// 获取接口的权限修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> intf.getModifiers();</span><br><span class="line">            <span class="comment">// 如果接口不是 public, 那么生成代理类的包名和接口包名相同</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                <span class="comment">// 生成的代理类的访问标志设置为 final</span></span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                <span class="comment">// 获取接口全限定名, 例如：java.util.Collection</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> intf.getName();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="comment">// 剪裁后得到包名:java.util</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 生成的代理类的包名和接口包名一样</span></span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="comment">// 代理类如果实现不同包的接口, 并且接口都不是 public 的, 在这里报错</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果接口访问标志都是 public 的话,</span></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 生成的代理类都放到默认的包下：com.sun.proxy</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代理类的序号</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> nextUniqueNumber.getAndIncrement();</span><br><span class="line">        <span class="comment">// 生成代理类的全限定名, 包名+前缀+序号, 例如：com.sun.proxy.$Proxy0</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 ProxyGenerator 来生成代理类 class 文件</span></span><br><span class="line">        <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据二进制文件生成并返回返回代理类对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">             * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">             * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">             * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">             * exceeded).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，这里的 ProxyClassFactory 类就是负责生成代理类的。在 get() 方法中，会计算出最终生成代理类的路径、代理类名，接着调用 ProxyGenerator.generateProxyClass() 方法来生成最终的代理类，生成之后，会调用 native 的 defineClass0() 方法来返回生成类对应的 Class 实例。</p>
<p>而且在生成代理类名是可以看出来，类名是以 “$Proxy” 开头的，并且后面会拼上数字，从 0开始，往后递增。</p>
<p>而关于  ProxyGenerator.generateProxyClass() 方法中是怎么生成代理类的，可以留作读者自行思考和学习。至此，可以翻回上面，再去看看最终生成的 $Proxy0 文件中的内容长啥样，脑袋里再对Java动态代理做一个串联思考。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Java/">Java</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/d663666b.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Android 系统服务加载启动</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/a6d96fd1.html">
        <span class="next-text nav-default">Ijkplayer-SDL_AudioCallback</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
