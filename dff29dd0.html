<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="BufferQueue 分析"/>




  <meta name="keywords" content="BufferQueue," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/dff29dd0.html"/>


<meta name="description" content="前面介绍了 BufferQueue 中的基础类，对于BufferQueue 中常见的一些类有了基础的了解之后，接下来就开始源码逻辑分析。 BufferQueueProducerBufferQueueProducer在BufferQueue中担当的是生产者的角色。 先看其定义： 1234567891011121314151617181920212223242526272829303132333435">
<meta property="og:type" content="article">
<meta property="og:title" content="BufferQueue 分析">
<meta property="og:url" content="https://youngkaaa.github.io/dff29dd0.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="前面介绍了 BufferQueue 中的基础类，对于BufferQueue 中常见的一些类有了基础的了解之后，接下来就开始源码逻辑分析。 BufferQueueProducerBufferQueueProducer在BufferQueue中担当的是生产者的角色。 先看其定义： 1234567891011121314151617181920212223242526272829303132333435">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-06T02:48:56.000Z">
<meta property="article:modified_time" content="2023-02-07T12:24:23.586Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="BufferQueue">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> BufferQueue 分析 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          BufferQueue 分析
        
      </h1>

      <time class="post-time">
          7月 06 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>前面介绍了 BufferQueue 中的基础类，对于BufferQueue 中常见的一些类有了基础的了解之后，接下来就开始源码逻辑分析。</p>
<h3 id="BufferQueueProducer"><a href="#BufferQueueProducer" class="headerlink" title="BufferQueueProducer"></a>BufferQueueProducer</h3><p>BufferQueueProducer在BufferQueue中担当的是生产者的角色。</p>
<p>先看其定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferQueueProducer</span> :</span> public BnGraphicBufferProducer,</span><br><span class="line">                            private IBinder::DeathRecipient &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit <span class="title function_">BufferQueueProducer</span><span class="params">(<span class="type">const</span> sp&lt;BufferQueueCore&gt;&amp; core,</span></span><br><span class="line"><span class="params">                                 <span class="type">bool</span> consumerIsSurfaceFlinger = <span class="literal">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">requestBuffer</span><span class="params">(<span class="type">int</span> slot, sp&lt;GraphicBuffer&gt; *buf)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// see IGraphicsBufferProducer::setAsyncMode</span></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">setAsyncMode</span><span class="params">(<span class="type">bool</span> async)</span>;</span><br><span class="line">  </span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">dequeueBuffer</span><span class="params">(<span class="type">int</span> *outSlot, sp&lt;Fence&gt; *outFence, <span class="type">uint32_t</span> width,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> height, PixelFormat format, <span class="type">uint64_t</span> usage,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint64_t</span> *outBufferAge,</span></span><br><span class="line"><span class="params">                                    FrameEventHistoryDelta *outTimestamps)</span> override;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">queueBuffer</span><span class="params">(<span class="type">int</span> slot,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">connect</span><span class="params">(<span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> api, <span class="type">bool</span> producerControlledByApp, QueueBufferOutput* output)</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">disconnect</span><span class="params">(<span class="type">int</span> api, DisconnectMode mode = DisconnectMode::Api)</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">FreeSlotCaller</span> &#123;</span></span><br><span class="line">        Dequeue,</span><br><span class="line">        Attach,</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    sp&lt;BufferQueueCore&gt; mCore;</span><br><span class="line">  </span><br><span class="line">    BufferQueueDefs::SlotsType&amp; mSlots;</span><br><span class="line"></span><br><span class="line">    String8 mConsumerName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它实现了 BnGraphicBufferProducer 接口，说明它是IGraphicBufferProducer 的Binder server 端的实现。更多Binder详见[待补充]</p>
<p>然后扩充了几个额外的字段：</p>
<p>1、mCore：BufferQueueCore 实例，后续在 BufferQueueProducer 构造方法中被传入并保存。后续使用这个 mCore 就可以访问 BufferQueueCore 中的那些容器列表了。</p>
<p>2、mSlots：它也是BufferQueueDefs::SlotsType 类型的。即 是一个BufferSlot数组。对于它的赋值同样是在BufferQueueProducer 构造方法中的，会将入参 BufferQueueCore 中的 mSlots 赋值给它。也就是说：BufferQueueProducer中的 mSlots 是 BufferQueueCore中mSlots的一个副本，他俩都指向同一个地址。</p>
<p>介绍完其属性，接下来看它的实现。</p>
<h4 id="dequeueBuffer"><a href="#dequeueBuffer" class="headerlink" title="dequeueBuffer"></a>dequeueBuffer</h4><p>对于生产者 BufferQueueProducer 来说，它在生产数据之前，要从BufferQueue 中拿到一个“容器”来存放这些生产出来的数据。而这个过程叫做：dequeueBuffer。</p>
<p>下面 dequeueBuffer 的逻辑分为3步。</p>
<p><strong>第一步：</strong><br>先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,</span></span><br><span class="line"><span class="params">                                            <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format,</span></span><br><span class="line"><span class="params">                                            <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge,</span></span><br><span class="line"><span class="params">                                            FrameEventHistoryDelta* outTimestamps)</span> &#123;</span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(mCore-&gt;mMutex)</span>;</span><br><span class="line">        mConsumerName = mCore-&gt;mConsumerName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前 BufferQueue 的合法性，是否还在使用中，如果被弃用则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: BufferQueue has been abandoned&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_INIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mConnectedApi == BufferQueueCore::NO_CONNECTED_API) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: BufferQueue has no connected producer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_INIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">    BQ_LOGV(<span class="string">&quot;dequeueBuffer: w=%u h=%u format=%#x, usage=%#&quot;</span> PRIx64, width, height, format, usage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断生产者所需要的宽高是否合法，要不都是0，要不都不能为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((width &amp;&amp; !height) || (!width &amp;&amp; height)) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;dequeueBuffer: invalid size: w=%u h=%u&quot;</span>, width, height);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">status_t</span> returnFlags = NO_ERROR;</span><br><span class="line">    EGLDisplay eglDisplay = EGL_NO_DISPLAY;</span><br><span class="line">    EGLSyncKHR eglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">    <span class="type">bool</span> attachedByConsumer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(mCore-&gt;mMutex)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果 mFreeBuffers 为空，并且当前正在分配，则等待分配成功</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mFreeBuffers.empty() &amp;&amp; mCore-&gt;mIsAllocating) &#123; </span><br><span class="line">            mDequeueWaitingForAllocation = <span class="literal">true</span>;</span><br><span class="line">            mCore-&gt;waitWhileAllocatingLocked(lock);</span><br><span class="line">            mDequeueWaitingForAllocation = <span class="literal">false</span>;</span><br><span class="line">            mDequeueWaitingForAllocationCondition.notify_all();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (format == <span class="number">0</span>) &#123;</span><br><span class="line">            format = mCore-&gt;mDefaultBufferFormat;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enable the usage bits the consumer requested</span></span><br><span class="line">        usage |= mCore-&gt;mConsumerUsageBits;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> useDefaultSize = !width &amp;&amp; !height;</span><br><span class="line">        <span class="keyword">if</span> (useDefaultSize) &#123;</span><br><span class="line">            width = mCore-&gt;mDefaultWidth;</span><br><span class="line">            height = mCore-&gt;mDefaultHeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步比较简单，就是做一些合法性的判断，比如当前BufferQueue是否已被抛弃，即：BufferQueueCore.mIsAbandoned 是否为true，它默认是false。<br>以及入参 宽高 的判断，如果宽高都是0，内部则使用默认的宽高。</p>
<p><strong>第二步：</strong></p>
<p>先看下相关代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,</span></span><br><span class="line"><span class="params">                                            <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format,</span></span><br><span class="line"><span class="params">                                            <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge,</span></span><br><span class="line"><span class="params">                                            FrameEventHistoryDelta* outTimestamps)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> found = BufferItem::INVALID_BUFFER_SLOT;</span><br><span class="line">       <span class="comment">// 这里会一直循环去查找合适的 buffer</span></span><br><span class="line">       <span class="keyword">while</span> (found == BufferItem::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 寻找可用的 Slot，可用指： Buffer 状态为 FREE , 这里传入的是 FreeSlotCaller::Dequeue</span></span><br><span class="line"><span class="comment">            * 该方法内部会自旋，直到找到合适的，或者异常直接结束</span></span><br><span class="line"><span class="comment">            * BufferQueueProducer::waitForFreeSlotThenRelock</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">          <span class="type">status_t</span> status = waitForFreeSlotThenRelock(FreeSlotCaller::Dequeue, lock, &amp;found);</span><br><span class="line">          <span class="comment">// waitForFreeSlotThenRelock 方法执行返回了，判断下返回值是否正常，不正常的话表示获取 buffer 失败了</span></span><br><span class="line">          <span class="keyword">if</span> (status != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// This should not happen</span></span><br><span class="line">          <span class="keyword">if</span> (found == BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">              BQ_LOGE(<span class="string">&quot;dequeueBuffer: no available buffer slots&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> -EBUSY;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// waitForFreeSlotThenRelock 方法之后，会给 found 中赋值为对应找到的 slot 索引</span></span><br><span class="line">          <span class="comment">// 所以此时是从 mSlots 中拿到该 BufferSlot 对象实例，而 mSlots 其实就是 BufferQueueCore 中的那个 mSlots</span></span><br><span class="line">          <span class="comment">// mSlots 是 BufferQueueDefs::SlotsType 类型，BufferQueueDefs::SlotsType 是 BufferSlot 数组</span></span><br><span class="line">          <span class="comment">// 所以这里 buffer 拿到的是 BufferSlot 中的 mGraphicBuffer</span></span><br><span class="line">          <span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title function_">buffer</span><span class="params">(mSlots[found].mGraphicBuffer)</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// If we are not allowed to allocate new buffers,</span></span><br><span class="line">          <span class="comment">// waitForFreeSlotThenRelock must have returned a slot containing a</span></span><br><span class="line">          <span class="comment">// buffer. If this buffer would require reallocation to meet the</span></span><br><span class="line">          <span class="comment">// requested attributes, we free it and attempt to get another one.</span></span><br><span class="line">          <span class="comment">// mAllowAllocation ： 是否允许在 dequeueBuffer 时新创建 buffer 对象 。在当前类构造方法中赋予默认值 true</span></span><br><span class="line">          <span class="keyword">if</span> (!mCore-&gt;mAllowAllocation) &#123;</span><br><span class="line">              <span class="keyword">if</span> (buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (mCore-&gt;mSharedBufferSlot == found) &#123;</span><br><span class="line">                      BQ_LOGE(<span class="string">&quot;dequeueBuffer: cannot re-allocate a sharedbuffer&quot;</span>);</span><br><span class="line">                      <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">                  &#125;</span><br><span class="line">                  mCore-&gt;mFreeSlots.insert(found);</span><br><span class="line">                  mCore-&gt;clearBufferSlotLocked(found);</span><br><span class="line">                  found = BufferItem::INVALID_BUFFER_SLOT;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">BufferQueueProducer::waitForFreeSlotThenRelock</span><span class="params">(FreeSlotCaller caller,</span></span><br><span class="line"><span class="params">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, <span class="type">int</span>* found)</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// 注意前面传入的是 FreeSlotCaller::Dequeue</span></span><br><span class="line">    <span class="keyword">auto</span> callerString = (caller == FreeSlotCaller::Dequeue) ?</span><br><span class="line">            <span class="string">&quot;dequeueBuffer&quot;</span> : <span class="string">&quot;attachBuffer&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> tryAgain = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 一直循环重试去查找合适的 BufferSlot </span></span><br><span class="line">    <span class="keyword">while</span> (tryAgain) &#123;</span><br><span class="line">        <span class="comment">// 同样还是先判断合法性</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;%s: BufferQueue has been abandoned&quot;</span>, callerString);</span><br><span class="line">            <span class="keyword">return</span> NO_INIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dequeuedCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> acquiredCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// mActiveBuffers 中存储了所有的非 FREE 状态的 buffer index。</span></span><br><span class="line">        <span class="comment">// 因此遍历 mActiveBuffers 集合，计算出当前已经被生产者出队dequeue 和 消费者获取acquire 的buffer个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s : mCore-&gt;mActiveBuffers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mSlots[s].mBufferState.isDequeued()) &#123;</span><br><span class="line">                ++dequeuedCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mSlots[s].mBufferState.isAcquired()) &#123;</span><br><span class="line">                ++acquiredCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * mCore-&gt;mBufferHasBeenQueued : 表示当前有生产者调用过 queueBuffer 入队过 buffer</span></span><br><span class="line"><span class="comment">         * mCore-&gt;mMaxDequeuedBufferCount : 当前生产者一次最多能出队的 buffer 个数，默认是1</span></span><br><span class="line"><span class="comment">         * mDequeueTimeout : 生产者出队等待时间，当没有可用的buffer时，生产者出队需要阻塞等待，默认是-1</span></span><br><span class="line"><span class="comment">         * 所以说这里也是做出队dequeue的合法性检查</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mBufferHasBeenQueued &amp;&amp;</span><br><span class="line">                dequeuedCount &gt;= mCore-&gt;mMaxDequeuedBufferCount) &#123;</span><br><span class="line">            <span class="comment">// Supress error logs when timeout is non-negative.</span></span><br><span class="line">            <span class="keyword">if</span> (mDequeueTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                BQ_LOGE(<span class="string">&quot;%s: attempting to exceed the max dequeued buffer &quot;</span></span><br><span class="line">                        <span class="string">&quot;count (%d)&quot;</span>, callerString,</span><br><span class="line">                        mCore-&gt;mMaxDequeuedBufferCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *found = BufferQueueCore::INVALID_BUFFER_SLOT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we disconnect and reconnect quickly, we can be in a state where</span></span><br><span class="line">        <span class="comment">// our slots are empty but we have many buffers in the queue. This can</span></span><br><span class="line">        <span class="comment">// cause us to run out of memory if we outrun the consumer. Wait here if</span></span><br><span class="line">        <span class="comment">// it looks like we have too many buffers queued up.</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> maxBufferCount = mCore-&gt;getMaxBufferCountLocked();</span><br><span class="line">        <span class="type">bool</span> tooManyBuffers = mCore-&gt;mQueue.size() &gt; static_cast&lt;<span class="type">size_t</span>&gt;(maxBufferCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tooManyBuffers) &#123;</span><br><span class="line">            BQ_LOGV(<span class="string">&quot;%s: queue size is %zu, waiting&quot;</span>, callerString, mCore-&gt;mQueue.size());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// mCore-&gt;mSharedBufferMode : 当前是否处于共享模式下。一般都是false，可以不用考虑</span></span><br><span class="line">            <span class="keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">                *found = mCore-&gt;mSharedBufferSlot;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 从 dequeueBuffer 调用过来的话 caller 就是 FreeSlotCaller::Dequeue</span></span><br><span class="line">                <span class="keyword">if</span> (caller == FreeSlotCaller::Dequeue) &#123;</span><br><span class="line">                    <span class="comment">// 优先从 mFreeBuffers 中查找有无可以使用的slot。因为mFreeBuffers 中是处于 FREE 状态并且关联了 GraphicBuffer 的</span></span><br><span class="line">                    <span class="type">int</span> slot = getFreeBufferLocked();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 如果从 mFreeBuffers 找到了，那么就将其赋值给 found 表示找到了会返回出去</span></span><br><span class="line"><span class="comment">                     * mCore-&gt;mAllowAllocation : 是否允许 BufferQueue 在 dequeueBuffer 时分配GraphicBuffer缓冲区，默认是 true</span></span><br><span class="line"><span class="comment">                     * 如果没有找到，则下一步可能从 mFreeSlots 中查找</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">                        *found = slot;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCore-&gt;mAllowAllocation) &#123; </span><br><span class="line">                        *found = getFreeSlotLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// If we&#x27;re calling this from attach, prefer free slots</span></span><br><span class="line">                    <span class="type">int</span> slot = getFreeSlotLocked();</span><br><span class="line">                    <span class="keyword">if</span> (slot != BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">                        *found = slot;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        *found = getFreeBufferLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 found 等于 INVALID_BUFFER_SLOT ，则表示上面没找到对应的 slot ，那么需要在下次循环中再试试</span></span><br><span class="line">        tryAgain = (*found == BufferQueueCore::INVALID_BUFFER_SLOT) || tooManyBuffers;</span><br><span class="line">        <span class="comment">// 如果需要再试</span></span><br><span class="line">        <span class="keyword">if</span> (tryAgain) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在下次重试之前，可能存在一些阻塞时间 mDequeueTimeout，因此如果当前是异步模式下，或者明确指定了不允许阻塞(mCore-&gt;mDequeueBufferCannotBlock)</span></span><br><span class="line"><span class="comment">             * 那么则不阻塞直接返回 WOULD_BLOCK </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((mCore-&gt;mDequeueBufferCannotBlock || mCore-&gt;mAsyncMode) &amp;&amp;</span><br><span class="line">                    (acquiredCount &lt;= mCore-&gt;mMaxAcquiredBufferCount)) &#123;</span><br><span class="line">                <span class="keyword">return</span> WOULD_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果设置了 dequeue 超时时间的话，那么就阻塞等待指定时长</span></span><br><span class="line">            <span class="keyword">if</span> (mDequeueTimeout &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">std</span>::cv_status result = mCore-&gt;mDequeueCondition.wait_for(lock,</span><br><span class="line">                        <span class="built_in">std</span>::chrono::nanoseconds(mDequeueTimeout));</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">std</span>::cv_status::timeout) &#123;</span><br><span class="line">                    <span class="keyword">return</span> TIMED_OUT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没设置 dequeue 超时时间的话则一直等待，直到被唤醒</span></span><br><span class="line">                mCore-&gt;mDequeueCondition.wait(lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// while (tryAgain)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BufferQueueProducer::getFreeBufferLocked</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">  <span class="comment">// 要从 mFreeBuffers 中查找了，如果它为空就直接返回吧  </span></span><br><span class="line">  <span class="keyword">if</span> (mCore-&gt;mFreeBuffers.empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> BufferQueueCore::INVALID_BUFFER_SLOT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// mFreeBuffers不为空，则返回 mFreeBuffers 中第一个索引</span></span><br><span class="line">  <span class="type">int</span> slot = mCore-&gt;mFreeBuffers.front();</span><br><span class="line">  <span class="comment">// 同时移除该索引</span></span><br><span class="line">  mCore-&gt;mFreeBuffers.pop_front();</span><br><span class="line">  <span class="keyword">return</span> slot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BufferQueueProducer::getFreeSlotLocked</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// 同上 getFreeBufferLocked ，唯一不同的是这里是从 mFreeSlots 中查找的</span></span><br><span class="line">    <span class="keyword">if</span> (mCore-&gt;mFreeSlots.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> BufferQueueCore::INVALID_BUFFER_SLOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有的话，则返回 mFreeSlots 中第一个，然后移除第一个</span></span><br><span class="line">    <span class="type">int</span> slot = *(mCore-&gt;mFreeSlots.begin());</span><br><span class="line">    mCore-&gt;mFreeSlots.erase(slot);</span><br><span class="line">    <span class="keyword">return</span> slot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第二步中，就完成了对BufferSlot的查找，查找是通过waitForFreeSlotThenRelock() 方法来实现的。在实际查找中，首先是从 mFreeBuffers 中查找，如果找到了则直接返回其 slot索引，如果没找到，则可能从 mFreeSlots 中查找。</p>
<p>而这俩的区别是：mFreeBuffers 中的 slot 都是绑定过GraphicBuffer 缓冲区的，一般可以直接复用。而 mFreeSlots 中是没有绑定GraphicBuffer 缓冲区的，需要重新申请分配才能使用。</p>
<p>如果没找到的话，则对于同步BufferQueue来说是阻塞等待，等待后期有了数据被唤醒再查找。对于异步方式来说是直接返回。而阻塞等待是在 mCore-&gt;mDequeueCondition 上等待的，等到了后期，比如在 消费者端调用 releaseBuffer() 时，它就会被唤醒。</p>
<p><strong>第三步：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,</span></span><br><span class="line"><span class="params">                                            <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format,</span></span><br><span class="line"><span class="params">                                            <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge,</span></span><br><span class="line"><span class="params">                                            FrameEventHistoryDelta* outTimestamps)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 到这里的话，表示上面 while 执行完毕了，也就是 found 不等于 BufferItem::INVALID_BUFFER_SLOT 了，</span></span><br><span class="line"><span class="comment">         * 即找到了一个 slot 。 那么此时先取出该 slot 对应的 GraphicBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title function_">buffer</span><span class="params">(mSlots[found].mGraphicBuffer)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享模式下一个 buffer 是可能有多个生产者在使用的，所以不能修改其原尺寸，不能重新分配</span></span><br><span class="line">        <span class="comment">// 如果返回的是共享模式下的 buffer ，并且该 buffer 不满足当前尺寸要求时，直接返回错误码</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mSharedBufferSlot == found &amp;&amp;</span><br><span class="line">                buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage)) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: cannot re-allocate a shared&quot;</span></span><br><span class="line">                    <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前找到的不是共享模式下的 buffer。共享模式可以不考虑。</span></span><br><span class="line"><span class="comment">         * 在前面查找slot时，是会从 mFreeBuffers 或者 mFreeSlots 中查找并移除该 slot的，所以此时该 slot 属于游离状态</span></span><br><span class="line"><span class="comment">         * 因此此时可以将其保存在 mActiveBuffers 中 ，因为它马上就是 DEQUEUE 状态了，非 free 状态了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mSharedBufferSlot != found) &#123;</span><br><span class="line">            mCore-&gt;mActiveBuffers.insert(found);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给outSlot 赋值，当方法返回时，就可以在 outSlot 中拿到对应的 slot 索引了</span></span><br><span class="line">        *outSlot = found;</span><br><span class="line"></span><br><span class="line">        attachedByConsumer = mSlots[found].mNeedsReallocation;</span><br><span class="line">        mSlots[found].mNeedsReallocation = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 修改找到的 slot 索引所对应的 BufferSlot 中的 mBufferState 属性，即调用其 dequeue 方法表示其已出队</span></span><br><span class="line"><span class="comment">         * 此时它的状态会变成 DEQUEUED，这一步完成了 FREE 到 DEQUEUED 的状态切换</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mSlots[found].mBufferState.dequeue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * buffer 指的是找到的slot所对应的 BufferSlot 中的 mGraphicBuffer</span></span><br><span class="line"><span class="comment">         * 而如果 buffer == null ，表示该 BufferSlot 是对应从 mFreeSlots 中查找到的</span></span><br><span class="line"><span class="comment">         * 如果该 buffer 不满足当前生产者的要求的话(通过 needsReallocation 方法来判断)，也需要重新分配</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((buffer == nullptr) ||</span><br><span class="line">              buffer-&gt;needsReallocation(width, height, format, BQ_LAYER_COUNT, usage))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 清除掉其他字段</span></span><br><span class="line">            mSlots[found].mAcquireCalled = <span class="literal">false</span>;</span><br><span class="line">            mSlots[found].mGraphicBuffer = nullptr;</span><br><span class="line">            mSlots[found].mRequestBufferCalled = <span class="literal">false</span>;</span><br><span class="line">            mSlots[found].mEglDisplay = EGL_NO_DISPLAY;</span><br><span class="line">            mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">            mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line">            mCore-&gt;mBufferAge = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改为true 表示马上要为对应的 slot 分配 GraphicBuffer 了</span></span><br><span class="line">            mCore-&gt;mIsAllocating = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 增加 BUFFER_NEEDS_REALLOCATION 标识，表示该 Slot 的 GraphicBuffer 需要初始化</span></span><br><span class="line">            returnFlags |= BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We add 1 because that will be the frame number when this buffer</span></span><br><span class="line">            <span class="comment">// is queued</span></span><br><span class="line">            mCore-&gt;mBufferAge = mCore-&gt;mFrameCounter + <span class="number">1</span> - mSlots[found].mFrameNumber;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eglDisplay = mSlots[found].mEglDisplay;</span><br><span class="line">        eglFence = mSlots[found].mEglFence;</span><br><span class="line">        <span class="comment">// Don&#x27;t return a fence in shared buffer mode, except for the first</span></span><br><span class="line">        <span class="comment">// frame.</span></span><br><span class="line">        *outFence = (mCore-&gt;mSharedBufferMode &amp;&amp;</span><br><span class="line">                mCore-&gt;mSharedBufferSlot == found) ?</span><br><span class="line">                Fence::NO_FENCE : mSlots[found].mFence;</span><br><span class="line">        <span class="comment">// 将这俩参数重置掉</span></span><br><span class="line">        mSlots[found].mEglFence = EGL_NO_SYNC_KHR;</span><br><span class="line">        mSlots[found].mFence = Fence::NO_FENCE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果共享模式刚被打开，那么此时将刚拿出来的 buffer 作为 共享buffer 来使用</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot ==</span><br><span class="line">                BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">            mCore-&gt;mSharedBufferSlot = found;</span><br><span class="line">            mSlots[found].mBufferState.mShared = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// GraphicBuffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GraphicBuffer::needsReallocation</span><span class="params">(<span class="type">uint32_t</span> inWidth, <span class="type">uint32_t</span> inHeight,</span></span><br><span class="line"><span class="params">        PixelFormat inFormat, <span class="type">uint32_t</span> inLayerCount, <span class="type">uint64_t</span> inUsage)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 宽、高、格式等信息只要有任意一个不一样，那么就返回true，表示需要重新分配缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (static_cast&lt;<span class="type">int</span>&gt;(inWidth) != width) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (static_cast&lt;<span class="type">int</span>&gt;(inHeight) != height) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (inFormat != format) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (inLayerCount != layerCount) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((usage &amp; inUsage) != inUsage) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((usage &amp; USAGE_PROTECTED) != (inUsage &amp; USAGE_PROTECTED)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步中会对查找到的 slot 进行状态转移以及合法性判断。</p>
<p>状态转移是将其从 FREE 状态转换为 DEQUEUE 状态，并将其转移到 mActiveBuffers 集合中去，表示该 slot 位置目前正在使用中。</p>
<p>合法性判断主要是判断其 GraphicBuffer 缓存区是否合法，因为这个 slot 可能是从 mFreeBuffers 中查找到的，也可能是从 mFreeSlots 中查找到的，因此其 GraphicBuffer 可能已经被绑定过了，也可能没有被绑定过，即它的 mGraphicBuffer 是否为null。</p>
<p>mGraphicBuffer &#x3D;&#x3D; null 时那自然需要重新申请分配 GraphicBuffer 实例。</p>
<p>mGraphicBuffer !&#x3D; null 时，还得额外判断其原缓存区是否满足新的要求，即通过 GraphicBuffer::needsReallocation() 方法来判断，不满足要求时同样需要重新申请分配缓存区。</p>
<p>如果需要重新分配缓存区的话，则会为返回值 returnFlags 增加 BUFFER_NEEDS_REALLOCATION 位标识。</p>
<p><strong>第四步：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">BufferQueueProducer::dequeueBuffer</span><span class="params">(<span class="type">int</span>* outSlot, sp&lt;android::Fence&gt;* outFence,</span></span><br><span class="line"><span class="params">                                            <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format,</span></span><br><span class="line"><span class="params">                                            <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge,</span></span><br><span class="line"><span class="params">                                            FrameEventHistoryDelta* outTimestamps)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上面查找到的 slot 需要重新分配缓存区，那么这里就开始初始化</span></span><br><span class="line">    <span class="keyword">if</span> (returnFlags &amp; BUFFER_NEEDS_REALLOCATION) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 GraphicBuffer 实例 , 这里开始走到 GraphicBuffer 构造方法中去</span></span><br><span class="line">        <span class="comment">// 关于 GraphicBuffer 初始化话，以及 共享内存 后续再讲</span></span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer = new GraphicBuffer(</span><br><span class="line">                width, height, format, BQ_LAYER_COUNT, usage,</span><br><span class="line">                &#123;mConsumerName.<span class="built_in">string</span>(), mConsumerName.size()&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查GraphicBuffer 初始化结果，是否成功</span></span><br><span class="line">        <span class="type">status_t</span> error = graphicBuffer-&gt;initCheck();</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">            <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(mCore-&gt;mMutex)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// GraphicBuffer初始化成功，那么将其赋值给该 slot 的 mGraphicBuffer</span></span><br><span class="line">            <span class="comment">// 这样的话后续该 slot 位置的 BufferSlot 的 mGraphicBuffer 就有值了</span></span><br><span class="line">            <span class="keyword">if</span> (error == NO_ERROR &amp;&amp; !mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">                graphicBuffer-&gt;setGenerationNumber(mCore-&gt;mGenerationNumber);</span><br><span class="line">                mSlots[*outSlot].mGraphicBuffer = graphicBuffer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分配 GraphicBuffer 结束，置为false</span></span><br><span class="line">            mCore-&gt;mIsAllocating = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 还记得第一步中的阻塞嘛？这里分配完缓存区之后，会唤醒它</span></span><br><span class="line">            mCore-&gt;mIsAllocatingCondition.notify_all();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果创建 GraphicBuffer 失败了，那么将其插入到 mFreeSlots 里面直接返回错误</span></span><br><span class="line">            <span class="comment">// 因为 mFreeSlots 中存储的都是没有分配过 GraphicBuffer 的</span></span><br><span class="line">            <span class="keyword">if</span> (error != NO_ERROR) &#123;</span><br><span class="line">                mCore-&gt;mFreeSlots.insert(*outSlot);</span><br><span class="line">                mCore-&gt;clearBufferSlotLocked(*outSlot);</span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 BufferQueue 已经被抛弃了，那么还是放到 mFreeSlots 中返回 NO_INIT 。</span></span><br><span class="line">            <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">                mCore-&gt;mFreeSlots.insert(*outSlot);</span><br><span class="line">                mCore-&gt;clearBufferSlotLocked(*outSlot);</span><br><span class="line">                <span class="keyword">return</span> NO_INIT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="comment">// Autolock scope</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attachedByConsumer) &#123;</span><br><span class="line">        returnFlags |= BUFFER_NEEDS_REALLOCATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fence 同步的先不看，后续再讲</span></span><br><span class="line">    <span class="keyword">if</span> (eglFence != EGL_NO_SYNC_KHR) &#123;</span><br><span class="line">        EGLint result = eglClientWaitSyncKHR(eglDisplay, eglFence, <span class="number">0</span>,</span><br><span class="line">                <span class="number">1000000000</span>);</span><br><span class="line">        <span class="comment">// If something goes wrong, log the error, but return the buffer without</span></span><br><span class="line">        <span class="comment">// synchronizing access to it. It&#x27;s too late at this point to abort the</span></span><br><span class="line">        <span class="comment">// dequeue operation.</span></span><br><span class="line">        <span class="keyword">if</span> (result == EGL_FALSE) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: error %#x waiting for fence&quot;</span>,</span><br><span class="line">                    eglGetError());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == EGL_TIMEOUT_EXPIRED_KHR) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;dequeueBuffer: timeout waiting for fence&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        eglDestroySyncKHR(eglDisplay, eglFence);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outBufferAge) &#123;</span><br><span class="line">        *outBufferAge = mCore-&gt;mBufferAge;</span><br><span class="line">    &#125;</span><br><span class="line">    addAndGetFrameTimestamps(nullptr, outTimestamps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步可以知道，取出的 slot 的缓存区可能不可用，需要重新按照生产者的要求来分配，而最后一步最主要的就是完成缓存区 GraphicBuffer 的申请分配工作。</p>
<p>至此就可以返回当前 slot 给生产者去使用了。至此完成了生产者 dequeueBuffer 的逻辑分析。</p>
<h4 id="requestBuffer"><a href="#requestBuffer" class="headerlink" title="requestBuffer"></a>requestBuffer</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">BufferQueueProducer::requestBuffer</span><span class="params">(<span class="type">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(mCore-&gt;mMutex)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同样还是先进行合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;requestBuffer: BufferQueue has been abandoned&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCore-&gt;mConnectedApi == BufferQueueCore::NO_CONNECTED_API) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;requestBuffer: BufferQueue has no connected producer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slot &lt; <span class="number">0</span> || slot &gt;= BufferQueueDefs::NUM_BUFFER_SLOTS) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;requestBuffer: slot index %d out of range [0, %d)&quot;</span>,</span><br><span class="line">                slot, BufferQueueDefs::NUM_BUFFER_SLOTS);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mSlots[slot].mBufferState.isDequeued()) &#123; </span><br><span class="line">        <span class="comment">// 对应slot位置的 BufferSlot 不是处于 DEQUEUE 状态的</span></span><br><span class="line">        <span class="comment">// 因此需要先调用 dequeueBuffer 方法后才能再调用当前方法的</span></span><br><span class="line">        BQ_LOGE(<span class="string">&quot;requestBuffer: slot %d is not owned by the producer &quot;</span></span><br><span class="line">                <span class="string">&quot;(state = %s)&quot;</span>, slot, mSlots[slot].mBufferState.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将slot对应的BufferSlot 中的mRequestBufferCalled其置为 true ，表示其被调用过 requestBuffer 方法了</span></span><br><span class="line">    mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// buf 指向  slot 位置的 BufferSlot 对象中的  mGraphicBuffer</span></span><br><span class="line">    <span class="comment">// 那么后续生产者就操作 buf 来放入数据了</span></span><br><span class="line">    *buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面调用 dequeueBuffer() 方法时，拿到的只是对应的 slot 值，并没有拿到其 BufferSlot 或者其 GraphicBuffer 缓存区。所以此时可以调用 requestBuffer() 方法，传入 slot 值，获取其对应的 GraphicBuffer 缓存区地址，接下来就可以往该缓存区内填充生产的数据了。</p>
<h4 id="queueBuffer"><a href="#queueBuffer" class="headerlink" title="queueBuffer"></a>queueBuffer</h4><p>经过前面 dequeueBuffer ，再 requestBuffer 拿到对应的 GraphicBuffer缓存区之后，生产者就可以往该缓存区中填充数据了，等到其数据填充完成之后，就需要调用 queueBuffer() 方法来将其入队到 BufferQueue 中等待消费者去消费处理。</p>
<p>先看看源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">BufferQueueProducer::queueBuffer</span><span class="params">(<span class="type">int</span> slot,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output)</span> &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ATRACE_BUFFER_INDEX(slot);</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> requestedPresentTimestamp;</span><br><span class="line">    <span class="type">bool</span> isAutoTimestamp;</span><br><span class="line">    android_dataspace dataSpace;</span><br><span class="line">    Rect <span class="title function_">crop</span><span class="params">(Rect::EMPTY_RECT)</span>;</span><br><span class="line">    <span class="type">int</span> scalingMode;</span><br><span class="line">    <span class="type">uint32_t</span> transform;</span><br><span class="line">    <span class="type">uint32_t</span> stickyTransform;</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    <span class="type">bool</span> getFrameTimestamps = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * QueueBufferInput 中是将生产者生产的数据的额外信息封装起来的</span></span><br><span class="line"><span class="comment">     * 比如其期望的展现时间戳pts，其图像缩放、变换模式等</span></span><br><span class="line"><span class="comment">     * 这里将其读取挨个读取出来，赋值给当前方法中对应的属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    input.deflate(&amp;requestedPresentTimestamp, &amp;isAutoTimestamp, &amp;dataSpace,</span><br><span class="line">            &amp;crop, &amp;scalingMode, &amp;transform, &amp;acquireFence, &amp;stickyTransform,</span><br><span class="line">            &amp;getFrameTimestamps);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Region&amp; surfaceDamage = input.getSurfaceDamage();</span><br><span class="line">    <span class="type">const</span> HdrMetadata&amp; hdrMetadata = input.getHdrMetadata();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acquireFence == nullptr) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;queueBuffer: fence is NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> acquireFenceTime = <span class="built_in">std</span>::make_shared&lt;FenceTime&gt;(acquireFence);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断输入的缩放模式。如果是不支持的缩放模式，那么直接返回</span></span><br><span class="line">    <span class="keyword">switch</span> (scalingMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_SCALING_MODE_FREEZE:</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW:</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_SCALING_MODE_SCALE_CROP:</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_SCALING_MODE_NO_SCALE_CROP:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;queueBuffer: unknown scaling mode %d&quot;</span>, scalingMode);</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这两个用来区分最后调用的是 mCore-&gt;mConsumerListener 中的哪个方法</span></span><br><span class="line"><span class="comment">     * 实际只会有一个被赋值为 mCore-&gt;mConsumerListener ，另外一个就是null了</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * frameAvailableListener不为空时，最后会调用 onFrameAvailable() 方法，表示有新的 BufferItem 是插入到了空的 mQueue 队列中了</span></span><br><span class="line"><span class="comment">     * frameReplacedListener不为空时，最后会调用 onFrameReplaced() 方法，表示当前插入了新的 BufferItem 到mQueue队尾，将原来最后一个 item 替换成了新的 Item，也就是replace</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sp&lt;IConsumerListener&gt; frameAvailableListener;</span><br><span class="line">    sp&lt;IConsumerListener&gt; frameReplacedListener;</span><br><span class="line">    <span class="type">int</span> callbackTicket = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> currentFrameNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 BufferItem ，接下来准备为其赋值</span></span><br><span class="line">    BufferItem item;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(mCore-&gt;mMutex)</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 同样还是先进行合法性判断</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;queueBuffer: BufferQueue has been abandoned&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_INIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mConnectedApi == BufferQueueCore::NO_CONNECTED_API) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;queueBuffer: BufferQueue has no connected producer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> NO_INIT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slot &lt; <span class="number">0</span> || slot &gt;= BufferQueueDefs::NUM_BUFFER_SLOTS) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;queueBuffer: slot index %d out of range [0, %d)&quot;</span>,</span><br><span class="line">                    slot, BufferQueueDefs::NUM_BUFFER_SLOTS);</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mSlots[slot].mBufferState.isDequeued()) &#123; </span><br><span class="line">            <span class="comment">// 必须处于 DEQUEUE 状态的 slot 才能被 queue</span></span><br><span class="line">            BQ_LOGE(<span class="string">&quot;queueBuffer: slot %d is not owned by the producer &quot;</span></span><br><span class="line">                    <span class="string">&quot;(state = %s)&quot;</span>, slot, mSlots[slot].mBufferState.<span class="built_in">string</span>());</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mSlots[slot].mRequestBufferCalled) &#123;</span><br><span class="line">            <span class="comment">// 必须调用过 requestBuffer 的 slot 才能被 queue ，即必须先 dequeueBuffer 出队然后调用 requestBuffer()，才能 queueBuffer</span></span><br><span class="line">            BQ_LOGE(<span class="string">&quot;queueBuffer: slot %d was queued without requesting &quot;</span></span><br><span class="line">                    <span class="string">&quot;a buffer&quot;</span>, slot);</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享模式刚被打开了，那么其之后第一个入队的 slot 就作为共享slot，将其赋值给 mCore-&gt;mSharedBufferSlot</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot ==</span><br><span class="line">                BufferQueueCore::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">            mCore-&gt;mSharedBufferSlot = slot;</span><br><span class="line">            mSlots[slot].mBufferState.mShared = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// graphicBuffer 表示是要入队的 slot 对应的 GraphicBuffer 缓存区，也就是生产者已经填充好数据的缓存区</span></span><br><span class="line">        <span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title function_">graphicBuffer</span><span class="params">(mSlots[slot].mGraphicBuffer)</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 检查入参指定的 crop 和该缓存区区域是否存在重合区域，没有的话就表示入参 crop 不合法。</span></span><br><span class="line">        Rect <span class="title function_">bufferRect</span><span class="params">(graphicBuffer-&gt;getWidth(), graphicBuffer-&gt;getHeight())</span>;</span><br><span class="line">        Rect <span class="title function_">croppedRect</span><span class="params">(Rect::EMPTY_RECT)</span>;</span><br><span class="line">        crop.intersect(bufferRect, &amp;croppedRect);</span><br><span class="line">        <span class="keyword">if</span> (croppedRect != crop) &#123;</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;queueBuffer: crop rect is not contained within the &quot;</span></span><br><span class="line">                    <span class="string">&quot;buffer in slot %d&quot;</span>, slot);</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Override UNKNOWN dataspace with consumer default</span></span><br><span class="line">        <span class="keyword">if</span> (dataSpace == HAL_DATASPACE_UNKNOWN) &#123;</span><br><span class="line">            dataSpace = mCore-&gt;mDefaultBufferDataSpace;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSlots[slot].mFence = acquireFence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将该 BufferSlot 设置为 QUEUE 状态，此时相当于将该 slot 的状态从 DEQUEUE 变成了 QUEUE</span></span><br><span class="line">        mSlots[slot].mBufferState.<span class="built_in">queue</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每次 queue 入队一个 slot，都会将这个 mFrameCounter 自增1 ，然后保存到 currentFrameNumber 中</span></span><br><span class="line"><span class="comment">         * 因此 mCore-&gt;mFrameCounter 表示的是当前已经入队了多少个 slot 了</span></span><br><span class="line"><span class="comment">         * 如果把生产者每次入队的数据当做图像的一帧来看的话，那这里的 mFrameCounter 表示已经生产并且入队的图像帧数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ++mCore-&gt;mFrameCounter;</span><br><span class="line">        currentFrameNumber = mCore-&gt;mFrameCounter;</span><br><span class="line">        <span class="comment">// 将自增后的帧数赋值给该 slot ，表示该 slot 当前是第几帧，等到后面消费者获取待处理数据时，可以依赖该帧数来做丢帧操作</span></span><br><span class="line">        mSlots[slot].mFrameNumber = currentFrameNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 slot 位置的 BufferSlot 中属性赋值给 BufferItem</span></span><br><span class="line">        item.mAcquireCalled = mSlots[slot].mAcquireCalled;</span><br><span class="line">        item.mGraphicBuffer = mSlots[slot].mGraphicBuffer;</span><br><span class="line">        item.mCrop = crop;</span><br><span class="line">        item.mTransform = transform &amp;</span><br><span class="line">                ~static_cast&lt;<span class="type">uint32_t</span>&gt;(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);</span><br><span class="line">        item.mTransformToDisplayInverse =</span><br><span class="line">                (transform &amp; NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != <span class="number">0</span>;</span><br><span class="line">        item.mScalingMode = static_cast&lt;<span class="type">uint32_t</span>&gt;(scalingMode);</span><br><span class="line">        <span class="comment">// 外部生产者指定进来的该帧的展示时间戳pts。这里将其赋值给 BufferItem ，后期丢帧操作时要用</span></span><br><span class="line">        item.mTimestamp = requestedPresentTimestamp;</span><br><span class="line">        <span class="comment">// 是否是自动时间戳，即生产者不知道它要展示的时间戳，这个为true的话则不会触发后期的丢帧操作。</span></span><br><span class="line">        item.mIsAutoTimestamp = isAutoTimestamp;</span><br><span class="line">        item.mDataSpace = dataSpace;</span><br><span class="line">        item.mHdrMetadata = hdrMetadata;</span><br><span class="line">        <span class="comment">// 当前入队的 BufferItem 对应的是第几帧</span></span><br><span class="line">        item.mFrameNumber = currentFrameNumber;</span><br><span class="line">        <span class="comment">// 当前入队的 BufferItem 对应的是 mSlots 数组中的第几个 BufferSlot</span></span><br><span class="line">        item.mSlot = slot;</span><br><span class="line">        item.mFence = acquireFence;</span><br><span class="line">        item.mFenceTime = acquireFenceTime;</span><br><span class="line">        <span class="comment">// 该帧是否可丢弃</span></span><br><span class="line">        item.mIsDroppable = mCore-&gt;mAsyncMode ||</span><br><span class="line">                (mConsumerIsSurfaceFlinger &amp;&amp; mCore-&gt;mQueueBufferCanDrop) ||</span><br><span class="line">                (mCore-&gt;mLegacyBufferDrop &amp;&amp; mCore-&gt;mQueueBufferCanDrop) ||</span><br><span class="line">                (mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mSharedBufferSlot == slot);</span><br><span class="line">        item.mSurfaceDamage = surfaceDamage;</span><br><span class="line">        item.mQueuedBuffer = <span class="literal">true</span>;</span><br><span class="line">        item.mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp; mCore-&gt;mAutoRefresh;</span><br><span class="line">        item.mApi = mCore-&gt;mConnectedApi;</span><br><span class="line"></span><br><span class="line">        mStickyTransform = stickyTransform;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache the shared buffer data so that the BufferItem can be recreated.</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mSharedBufferMode) &#123;</span><br><span class="line">            mCore-&gt;mSharedBufferCache.crop = crop;</span><br><span class="line">            mCore-&gt;mSharedBufferCache.transform = transform;</span><br><span class="line">            mCore-&gt;mSharedBufferCache.scalingMode = static_cast&lt;<span class="type">uint32_t</span>&gt;(</span><br><span class="line">                    scalingMode);</span><br><span class="line">            mCore-&gt;mSharedBufferCache.dataspace = dataSpace;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        output-&gt;bufferReplaced = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 前面完成了 BufferItem 的创建和赋值，那么接下来就要将其放入到 mQueue 队列中了</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 1、如果mQueue 队列为空，那么此时的BufferItem是第一个，将其放入进去。mQueue 此时从 空变成了非空 </span></span><br><span class="line"><span class="comment">         * -  将frameAvailableListener赋值为mCore-&gt;mConsumerListener，后续可以回调 onFrameAvailable 方法</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 2、如果mQueue 队列不为空，那么此时将该 BufferItem 放入到队列的最后一位。</span></span><br><span class="line"><span class="comment">         * -  在放入前如果该队列的最后一个BufferItem是可丢弃的，那么就使用新的替换它，给 frameReplacedListener赋值，最后回调onFrameReplaced方法</span></span><br><span class="line"><span class="comment">         * -  否则直接将其插入队列即可，此时还是给 frameAvailableListener 赋值，后续可以回调 onFrameAvailable 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;</span><br><span class="line">            <span class="comment">// When the queue is empty, we can ignore mDequeueBufferCannotBlock</span></span><br><span class="line">            <span class="comment">// and simply queue this buffer</span></span><br><span class="line">            mCore-&gt;mQueue.push_back(item);</span><br><span class="line">            frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When the queue is not empty, we need to look at the last buffer</span></span><br><span class="line">            <span class="comment">// in the queue to see if we need to replace it</span></span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> BufferItem&amp; last = mCore-&gt;mQueue.itemAt(</span><br><span class="line">                    mCore-&gt;mQueue.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (last.mIsDroppable) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!last.mIsStale) &#123;</span><br><span class="line">                    mSlots[last.mSlot].mBufferState.freeQueued();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// After leaving shared buffer mode, the shared buffer will</span></span><br><span class="line">                    <span class="comment">// still be around. Mark it as no longer shared if this</span></span><br><span class="line">                    <span class="comment">// operation causes it to be free.</span></span><br><span class="line">                    <span class="keyword">if</span> (!mCore-&gt;mSharedBufferMode &amp;&amp;</span><br><span class="line">                            mSlots[last.mSlot].mBufferState.isFree()) &#123;</span><br><span class="line">                        mSlots[last.mSlot].mBufferState.mShared = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Don&#x27;t put the shared buffer on the free list.</span></span><br><span class="line">                    <span class="keyword">if</span> (!mSlots[last.mSlot].mBufferState.isShared()) &#123;</span><br><span class="line">                        mCore-&gt;mActiveBuffers.erase(last.mSlot);</span><br><span class="line">                        mCore-&gt;mFreeBuffers.push_back(last.mSlot);</span><br><span class="line">                        output-&gt;bufferReplaced = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Make sure to merge the damage rect from the frame we&#x27;re about</span></span><br><span class="line">                <span class="comment">// to drop into the new frame&#x27;s damage rect.</span></span><br><span class="line">                <span class="keyword">if</span> (last.mSurfaceDamage.bounds() == Rect::INVALID_RECT ||</span><br><span class="line">                    item.mSurfaceDamage.bounds() == Rect::INVALID_RECT) &#123;</span><br><span class="line">                    item.mSurfaceDamage = Region::INVALID_REGION;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    item.mSurfaceDamage |= last.mSurfaceDamage;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Overwrite the droppable buffer with the incoming one</span></span><br><span class="line">                mCore-&gt;mQueue.editItemAt(mCore-&gt;mQueue.size() - <span class="number">1</span>) = item;</span><br><span class="line">                frameReplacedListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mCore-&gt;mQueue.push_back(item);</span><br><span class="line">                frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里，当前BufferItem 就已经放入到了 mQueue 中了，那么将 mBufferHasBeenQueued 置为true</span></span><br><span class="line">        mCore-&gt;mBufferHasBeenQueued = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 唤醒在 mDequeueCondition 上的等待，比如之前的 dequeueBuffer 时会等待</span></span><br><span class="line">        mCore-&gt;mDequeueCondition.notify_all();</span><br><span class="line">        <span class="comment">// 记录一下本次入队的 slot 索引，后面可以方便通过它来获取上一次入队的BufferSlot</span></span><br><span class="line">        mCore-&gt;mLastQueuedSlot = slot;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队成功之后，准备返回了。返回值通过 output 传递出去</span></span><br><span class="line">        <span class="comment">// 入队参数通过 input 传入进来，返回值通过output 传递出去</span></span><br><span class="line">        output-&gt;width = mCore-&gt;mDefaultWidth;</span><br><span class="line">        output-&gt;height = mCore-&gt;mDefaultHeight;</span><br><span class="line">        output-&gt;transformHint = mCore-&gt;mTransformHint;</span><br><span class="line">        output-&gt;numPendingBuffers = static_cast&lt;<span class="type">uint32_t</span>&gt;(mCore-&gt;mQueue.size());</span><br><span class="line">        output-&gt;nextFrameNumber = mCore-&gt;mFrameCounter + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ATRACE_INT(mCore-&gt;mConsumerName.<span class="built_in">string</span>(),</span><br><span class="line">                static_cast&lt;<span class="type">int32_t</span>&gt;(mCore-&gt;mQueue.size()));</span><br><span class="line">        mCore-&gt;mOccupancyTracker.registerOccupancyChange(mCore-&gt;mQueue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Take a ticket for the callback functions</span></span><br><span class="line">        callbackTicket = mNextCallbackTicket++;</span><br><span class="line"></span><br><span class="line">        VALIDATE_CONSISTENCY();</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It is okay not to clear the GraphicBuffer when the consumer is SurfaceFlinger because</span></span><br><span class="line">    <span class="comment">// it is guaranteed that the BufferQueue is inside SurfaceFlinger&#x27;s process and</span></span><br><span class="line">    <span class="comment">// there will be no Binder call</span></span><br><span class="line">    <span class="keyword">if</span> (!mConsumerIsSurfaceFlinger) &#123;</span><br><span class="line">        item.mGraphicBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call back without the main BufferQueue lock held, but with the callback</span></span><br><span class="line">    <span class="comment">// lock held so we can ensure that callbacks occur in order</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> connectedApi;</span><br><span class="line">    sp&lt;Fence&gt; lastQueuedFence;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(mCallbackMutex)</span>;</span><br><span class="line">        <span class="keyword">while</span> (callbackTicket != mCurrentCallbackTicket) &#123;</span><br><span class="line">            mCallbackCondition.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回调监听listener</span></span><br><span class="line">        <span class="comment">// 关于这俩的赋值前面讲过了。他俩就是为了区分调用哪个方法</span></span><br><span class="line">        <span class="keyword">if</span> (frameAvailableListener != nullptr) &#123;</span><br><span class="line">            frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != nullptr) &#123;</span><br><span class="line">            frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        connectedApi = mCore-&gt;mConnectedApi;</span><br><span class="line">        lastQueuedFence = <span class="built_in">std</span>::move(mLastQueueBufferFence);</span><br><span class="line"></span><br><span class="line">        mLastQueueBufferFence = <span class="built_in">std</span>::move(acquireFence);</span><br><span class="line">        mLastQueuedCrop = item.mCrop;</span><br><span class="line">        mLastQueuedTransform = item.mTransform;</span><br><span class="line"></span><br><span class="line">        ++mCurrentCallbackTicket;</span><br><span class="line">        mCallbackCondition.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update and get FrameEventHistory.</span></span><br><span class="line">    <span class="type">nsecs_t</span> postedTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// currentFrameNumber:每当进入queueBuffer，就会自动添加一次mFrameCounter，这个参数代表这是当前Surface诞生以来第几帧</span></span><br><span class="line">    <span class="comment">// postedTime:完成queue时候的时间</span></span><br><span class="line">    <span class="comment">// requestedPresentTimestamp:应用端调用Binder通信时候的时刻</span></span><br><span class="line">    <span class="comment">// acquireFenceTime:同步栅</span></span><br><span class="line">    NewFrameEventsEntry newFrameEventsEntry = &#123;</span><br><span class="line">        currentFrameNumber,</span><br><span class="line">        postedTime,</span><br><span class="line">        requestedPresentTimestamp,</span><br><span class="line">        <span class="built_in">std</span>::move(acquireFenceTime)</span><br><span class="line">    &#125;;</span><br><span class="line">    addAndGetFrameTimestamps(&amp;newFrameEventsEntry,</span><br><span class="line">            getFrameTimestamps ? &amp;output-&gt;frameTimestamps : nullptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait without lock held</span></span><br><span class="line">    <span class="keyword">if</span> (connectedApi == NATIVE_WINDOW_API_EGL) &#123;</span><br><span class="line">        <span class="comment">// Waiting here allows for two full buffers to be queued but not a</span></span><br><span class="line">        <span class="comment">// third. In the event that frames take varying time, this makes a</span></span><br><span class="line">        <span class="comment">// small trade-off in favor of latency rather than throughput.</span></span><br><span class="line">        lastQueuedFence-&gt;waitForever(<span class="string">&quot;Throttling EGL Production&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单概述下上面的入队流程：</p>
<p>1、解析传入的 input 参数，并做参数的合法性校验。</p>
<p>2、创建 BufferItem 实例，并且给它的属性字段赋值。</p>
<p>在赋值时，首先会将 mCore-&gt;mFrameCounter 自增，然后将自增后的值赋值给对应 BufferSlot.mFrameNumber 和 BufferItem.mFrameNumber 。此处可以使用视频场景来理解，mFrameCount 是当前已解码 (此时的生产者是 <strong>解码器</strong>) 完成的帧数，而mFrameNumber 表示当前要入队的是第几帧。</p>
<p>同样的还有 BufferItem.mTimestamp ，它可以理解为是每一帧的展示时间戳，即pts。该属性所赋予的值是从当前方法的入参 input 中读取出来的，也就是由生产者入队时指定的。如果生产者不清楚其应该展示的时间的话，可以通过另外一个字段：mIsAutoTimestamp 来指定，将这个字段指定为 true 的话，表示该帧数据的展示时间是自动的，等它在 mQueue 队列中排队轮到它的话就直接展示就行了。</p>
<p>这俩值等到后面消费者 acquireBuffer 时，会有丢帧操作，那个时候就会用到他俩了。</p>
<p>3、修改其状态从 DEQUEUE 到 QUEUE。然后将其插入到 mQueue 中。</p>
<p>4、完成最后的收尾工作，比如给返回值output赋值，回调给消费者callback等。</p>
<p>至此就完成了入队操作。总结来说入队操作就是生产者将自身生产的数据放入到 BufferQueueCore.mQueue 队列中，等待后续消费者去从去获取数据处理。在入队之后， BufferQueueCore.mSlots 中对应 slot位置的 BufferSlot 的状态会从 DEQUEUE 变成 QUEUE ，对应BufferSlot 的控制权从 生产者转移成 BufferQueue。</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>在使用 BufferQueueProducer 之前先要调用其connect() 方法来设置对应的 listener ，以及获取一些关于BufferQueue 的信息，比如其默认宽高等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">BufferQueueProducer::connect</span><span class="params">(<span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> api, <span class="type">bool</span> producerControlledByApp, QueueBufferOutput *output)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(mCore-&gt;mMutex)</span>;</span><br><span class="line">    mConsumerName = mCore-&gt;mConsumerName;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 同样还是先进行合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;connect: BufferQueue has been abandoned&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该 BufferQueueCore 是否已经绑定了消费者。具体是在 BufferQueueConsumer::connect 中绑定</span></span><br><span class="line">    <span class="comment">// 所以说得先绑定消费者，再绑定生产者</span></span><br><span class="line">    <span class="keyword">if</span> (mCore-&gt;mConsumerListener == nullptr) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;connect: BufferQueue has no consumer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (output == nullptr) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;connect: output was NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以前已经 connect 过了，则不能再次 connect。必须先 disconnect </span></span><br><span class="line">    <span class="keyword">if</span> (mCore-&gt;mConnectedApi != BufferQueueCore::NO_CONNECTED_API) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;connect: already connected (cur=%d req=%d)&quot;</span>,</span><br><span class="line">                mCore-&gt;mConnectedApi, api);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> delta = mCore-&gt;getMaxBufferCountLocked(mCore-&gt;mAsyncMode,</span><br><span class="line">            mDequeueTimeout &lt; <span class="number">0</span> ?</span><br><span class="line">            mCore-&gt;mConsumerControlledByApp &amp;&amp; producerControlledByApp : <span class="literal">false</span>,</span><br><span class="line">            mCore-&gt;mMaxBufferCount) -</span><br><span class="line">            mCore-&gt;getMaxBufferCountLocked();</span><br><span class="line">    <span class="keyword">if</span> (!mCore-&gt;adjustAvailableSlotsLocked(delta)) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">&quot;connect: BufferQueue failed to adjust the number of available &quot;</span></span><br><span class="line">                <span class="string">&quot;slots. Delta = %d&quot;</span>, delta);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = NO_ERROR;</span><br><span class="line">    <span class="comment">// 根据 connect 的 api 来处理。这里的api可以理解为生产者的种类</span></span><br><span class="line">    <span class="keyword">switch</span> (api) &#123;</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_API_EGL:</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_API_CPU:</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_API_MEDIA:</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_API_CAMERA:</span><br><span class="line">            <span class="comment">// 在这里给它赋值，表示其调用过 connect 方法了</span></span><br><span class="line">            mCore-&gt;mConnectedApi = api;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将默认宽高等配置信息传递出去</span></span><br><span class="line">            output-&gt;width = mCore-&gt;mDefaultWidth;</span><br><span class="line">            output-&gt;height = mCore-&gt;mDefaultHeight;</span><br><span class="line">            output-&gt;transformHint = mCore-&gt;mTransformHint;</span><br><span class="line">            output-&gt;numPendingBuffers =</span><br><span class="line">                    static_cast&lt;<span class="type">uint32_t</span>&gt;(mCore-&gt;mQueue.size());</span><br><span class="line">            output-&gt;nextFrameNumber = mCore-&gt;mFrameCounter + <span class="number">1</span>;</span><br><span class="line">            output-&gt;bufferReplaced = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 注册 binder 死亡监听，当远程生产者 死亡时这边可以自动 disconnect</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (listener != nullptr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (IInterface::asBinder(listener)-&gt;remoteBinder() != nullptr) &#123;</span><br><span class="line">                    status = IInterface::asBinder(listener)-&gt;linkToDeath(</span><br><span class="line">                            static_cast&lt;IBinder::DeathRecipient*&gt;(this));</span><br><span class="line">                    <span class="keyword">if</span> (status != NO_ERROR) &#123;</span><br><span class="line">                        BQ_LOGE(<span class="string">&quot;connect: linkToDeath failed: %s (%d)&quot;</span>,</span><br><span class="line">                                strerror(-status), status);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mCore-&gt;mLinkedToDeath = listener;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (listener-&gt;needsReleaseNotify()) &#123;</span><br><span class="line">                    mCore-&gt;mConnectedProducerListener = listener;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            BQ_LOGE(<span class="string">&quot;connect: unknown API %d&quot;</span>, api);</span><br><span class="line">            status = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存此时 connect 的生产者信息，比如其进程号</span></span><br><span class="line">    mCore-&gt;mConnectedPid = BufferQueueThreadState::getCallingPid();</span><br><span class="line">    mCore-&gt;mBufferHasBeenQueued = <span class="literal">false</span>;</span><br><span class="line">    mCore-&gt;mDequeueBufferCannotBlock = <span class="literal">false</span>;</span><br><span class="line">    mCore-&gt;mQueueBufferCanDrop = <span class="literal">false</span>;</span><br><span class="line">    mCore-&gt;mLegacyBufferDrop = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mCore-&gt;mConsumerControlledByApp &amp;&amp; producerControlledByApp) &#123;</span><br><span class="line">        mCore-&gt;mDequeueBufferCannotBlock = mDequeueTimeout &lt; <span class="number">0</span>;</span><br><span class="line">        mCore-&gt;mQueueBufferCanDrop = mDequeueTimeout &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将其置为true,其实 mAllowAllocation 它在构造方法中默认就置为 true了</span></span><br><span class="line">    mCore-&gt;mAllowAllocation = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者方可以位于另外一个进程，通过 Binder调用 connect 方法来注册自身，并且在 connect 中会注册Binder 死亡监听等其远端生产者死亡是会自动disconnect。</p>
<h4 id="disconnect"><a href="#disconnect" class="headerlink" title="disconnect"></a>disconnect</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueProducer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">status_t</span> <span class="title function_">BufferQueueProducer::disconnect</span><span class="params">(<span class="type">int</span> api, DisconnectMode mode)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = NO_ERROR;</span><br><span class="line">    sp&lt;IConsumerListener&gt; listener;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(mCore-&gt;mMutex)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mode == DisconnectMode::AllLocal) &#123;</span><br><span class="line">            <span class="keyword">if</span> (BufferQueueThreadState::getCallingPid() != mCore-&gt;mConnectedPid) &#123;</span><br><span class="line">                <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">            api = BufferQueueCore::CURRENTLY_CONNECTED_API;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 BufferQueue 正在分配 GraphicBuffer ，那么等待它分配完成</span></span><br><span class="line">        mCore-&gt;waitWhileAllocatingLocked(lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合法性检查</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s not really an error to disconnect after the surface has</span></span><br><span class="line">            <span class="comment">// been abandoned; it should just be a no-op.</span></span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (api == BufferQueueCore::CURRENTLY_CONNECTED_API) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCore-&gt;mConnectedApi == NATIVE_WINDOW_API_MEDIA) &#123;</span><br><span class="line">                ALOGD(<span class="string">&quot;About to force-disconnect API_MEDIA, mode=%d&quot;</span>, mode);</span><br><span class="line">            &#125;</span><br><span class="line">            api = mCore-&gt;mConnectedApi;</span><br><span class="line">            <span class="comment">// If we&#x27;re asked to disconnect the currently connected api but</span></span><br><span class="line">            <span class="comment">// nobody is connected, it&#x27;s not really an error.</span></span><br><span class="line">            <span class="keyword">if</span> (api == BufferQueueCore::NO_CONNECTED_API) &#123;</span><br><span class="line">                <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (api) &#123;</span><br><span class="line">            <span class="keyword">case</span> NATIVE_WINDOW_API_EGL:</span><br><span class="line">            <span class="keyword">case</span> NATIVE_WINDOW_API_CPU:</span><br><span class="line">            <span class="keyword">case</span> NATIVE_WINDOW_API_MEDIA:</span><br><span class="line">            <span class="keyword">case</span> NATIVE_WINDOW_API_CAMERA:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mCore-&gt;mConnectedApi == api) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 清除 BufferQueueCore 中的集合，mFreeBuffers 那些，以及 mQueue 中的</span></span><br><span class="line">                    mCore-&gt;freeAllBuffersLocked();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移除之前的 binder 监听</span></span><br><span class="line">                    <span class="keyword">if</span> (mCore-&gt;mLinkedToDeath != nullptr) &#123;</span><br><span class="line">                        sp&lt;IBinder&gt; token =</span><br><span class="line">                                IInterface::asBinder(mCore-&gt;mLinkedToDeath);</span><br><span class="line">                        token-&gt;unlinkToDeath(</span><br><span class="line">                                static_cast&lt;IBinder::DeathRecipient*&gt;(this));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 清除其他属性字段</span></span><br><span class="line">                    mCore-&gt;mSharedBufferSlot =</span><br><span class="line">                            BufferQueueCore::INVALID_BUFFER_SLOT;</span><br><span class="line">                    mCore-&gt;mLinkedToDeath = nullptr;</span><br><span class="line">                    mCore-&gt;mConnectedProducerListener = nullptr;</span><br><span class="line">                    mCore-&gt;mConnectedApi = BufferQueueCore::NO_CONNECTED_API;</span><br><span class="line">                    mCore-&gt;mConnectedPid = <span class="number">-1</span>;</span><br><span class="line">                    mCore-&gt;mSidebandStream.clear();</span><br><span class="line">                    mCore-&gt;mDequeueCondition.notify_all();</span><br><span class="line">                    listener = mCore-&gt;mConsumerListener;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCore-&gt;mConnectedApi == BufferQueueCore::NO_CONNECTED_API) &#123;</span><br><span class="line">                    BQ_LOGE(<span class="string">&quot;disconnect: not connected (req=%d)&quot;</span>, api);</span><br><span class="line">                    status = NO_INIT;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    BQ_LOGE(<span class="string">&quot;disconnect: still connected to another API &quot;</span></span><br><span class="line">                            <span class="string">&quot;(cur=%d req=%d)&quot;</span>, mCore-&gt;mConnectedApi, api);</span><br><span class="line">                    status = BAD_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                BQ_LOGE(<span class="string">&quot;disconnect: unknown API %d&quot;</span>, api);</span><br><span class="line">                status = BAD_VALUE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调 onDisconnect 监听 </span></span><br><span class="line">    <span class="keyword">if</span> (listener != nullptr) &#123;</span><br><span class="line">        listener-&gt;onBuffersReleased();</span><br><span class="line">        listener-&gt;onDisconnect();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和前面 connect 类似，这里是断开 生产者与 BufferQueue 队列的联系。</p>
<p>上面代码可以看出，当断开联系之后，内部的 mFreeBuffers、mFreeSlots、mActiveBuffers 以及 mQueue 这些集合都会被清空。</p>
<p>最后会回调消费者的监听，通知这边已经断开了。</p>
<p>对于 BufferQueueProducer 的 connect 和 disconnect 来说，作用是使生产者与 BufferQueue 队列连接起来，或者断开连接。</p>
<h3 id="BufferQueueConsumer"><a href="#BufferQueueConsumer" class="headerlink" title="BufferQueueConsumer"></a>BufferQueueConsumer</h3><p>BufferQueueConsumer 在BufferQueue中担当的是消费者的角色。</p>
<p>先看其定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueConsumer.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferQueueConsumer</span> :</span> public BnGraphicBufferConsumer &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit <span class="title function_">BufferQueueConsumer</span><span class="params">(<span class="type">const</span> sp&lt;BufferQueueCore&gt;&amp; core)</span>;</span><br><span class="line">    ~BufferQueueConsumer() override;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">acquireBuffer</span><span class="params">(BufferItem* outBuffer,</span></span><br><span class="line"><span class="params">            <span class="type">nsecs_t</span> expectedPresent, <span class="type">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> override;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">detachBuffer</span><span class="params">(<span class="type">int</span> slot)</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">attachBuffer</span><span class="params">(<span class="type">int</span>* slot, <span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">releaseBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">uint64_t</span> frameNumber,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence, EGLDisplay display,</span></span><br><span class="line"><span class="params">            EGLSyncKHR fence)</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">connect</span><span class="params">(<span class="type">const</span> sp&lt;IConsumerListener&gt;&amp; consumerListener,</span></span><br><span class="line"><span class="params">            <span class="type">bool</span> controlledByApp)</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">disconnect</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"> </span><br><span class="line">    sp&lt;BufferQueueCore&gt; mCore;</span><br><span class="line"></span><br><span class="line">    BufferQueueDefs::SlotsType&amp; mSlots;</span><br><span class="line"></span><br><span class="line">    String8 mConsumerName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它和生产者 BufferQueueProducer 定义的属性一样，都有 mCore 和 mSlots ，这俩含义和上面一样。</p>
<p>这里也就能看出来了，一个 BufferQueueCore 实例同时被BufferQueueProducer 和 BufferQueueConsumer 持有，这两者都可以操作BufferQueueCore 中的数据，比如mSlots ，生产者生产的数据放置到 mQueue 中，消费者从 mQueue 中取就行了。</p>
<h4 id="acquireBuffer"><a href="#acquireBuffer" class="headerlink" title="acquireBuffer"></a>acquireBuffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueConsumer::acquireBuffer</span><span class="params">(BufferItem *outBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">nsecs_t</span> expectedPresent, <span class="type">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numDroppedBuffers = <span class="number">0</span>;</span><br><span class="line">    sp&lt;IProducerListener&gt; listener;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> numAcquiredBuffers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * mActiveBuffers 中保存的是所有非 FREE 状态的 BufferSlot 索引</span></span><br><span class="line"><span class="comment">         * 遍历该集合，计算出所有处于 ACQUIRE 状态的 BufferSlot 个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s: mCore-&gt;mActiveBuffers) &#123;</span><br><span class="line">          <span class="comment">// 如果是 ACCQUIRE 状态的话，则计数。所以 numAcquiredBuffers 就是所有目前处于 ACCQUIRE 状态的 BufferSlot</span></span><br><span class="line">          <span class="keyword">if</span> (mSlots[s].mBufferState.<span class="built_in">isAcquired</span>()) &#123;</span><br><span class="line">            ++numAcquiredBuffers;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前 acquire 的 buffer 个数是否超出最大个数。</span></span><br><span class="line">        <span class="comment">// 消费队列可以通过 mMaxAcquiredBufferCount 来控制同时被消费者端 acquire 的最大 Buffer 个数</span></span><br><span class="line">        <span class="keyword">if</span> (numAcquiredBuffers &gt;= mCore-&gt;mMaxAcquiredBufferCount + <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="built_in">BQ_LOGE</span>(<span class="string">&quot;acquireBuffer: max acquired buffer count reached: %d (max %d)&quot;</span>,</span><br><span class="line">                  numAcquiredBuffers, mCore-&gt;mMaxAcquiredBufferCount);</span><br><span class="line">          <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前是否是 共享Buffer 模式，且共享模式是可用的(即存在共享的Buffer slot 索引)</span></span><br><span class="line">        <span class="type">bool</span> sharedBufferAvailable = mCore-&gt;mSharedBufferMode &amp;&amp;</span><br><span class="line">                mCore-&gt;mAutoRefresh &amp;&amp; mCore-&gt;mSharedBufferSlot !=</span><br><span class="line">                BufferQueueCore::INVALID_BUFFER_SLOT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In asynchronous mode the list is guaranteed to be one buffer deep,</span></span><br><span class="line">        <span class="comment">// while in synchronous mode we use the oldest buffer.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mQueue 中存储的是生产者生产的 BufferItem ，如果为空则表示没有待消费的，此时直接返回吧</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mQueue.<span class="built_in">empty</span>() &amp;&amp; !sharedBufferAvailable) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_BUFFER_AVAILABLE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里的话，表示待消费的 mQueue 不为空，则拿到mQueue队列的第一个BufferItem</span></span><br><span class="line">        BufferQueueCore::<span class="function">Fifo::iterator <span class="title">front</span><span class="params">(mCore-&gt;mQueue.begin())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指定了 expectedPresent 的话，则尝试看看是否需要有丢帧操作</span></span><br><span class="line">        <span class="keyword">if</span> (expectedPresent != <span class="number">0</span> &amp;&amp; !mCore-&gt;mQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// The &#x27;expectedPresent&#x27; argument indicates when the buffer is expected</span></span><br><span class="line">            <span class="comment">// to be presented on-screen. If the buffer&#x27;s desired present time is</span></span><br><span class="line">            <span class="comment">// earlier (less) than expectedPresent -- meaning it will be displayed</span></span><br><span class="line">            <span class="comment">// on time or possibly late if we show it as soon as possible -- we</span></span><br><span class="line">            <span class="comment">// acquire and return it. If we don&#x27;t want to display it until after the</span></span><br><span class="line">            <span class="comment">// expectedPresent time, we return PRESENT_LATER without acquiring it.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// To be safe, we don&#x27;t defer acquisition if expectedPresent is more</span></span><br><span class="line">            <span class="comment">// than one second in the future beyond the desired present time</span></span><br><span class="line">            <span class="comment">// (i.e., we&#x27;d be holding the buffer for a long time).</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> Code assumes monotonic time values from the system clock</span></span><br><span class="line">            <span class="comment">// are positive.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start by checking to see if we can drop frames. We skip this check if</span></span><br><span class="line">            <span class="comment">// the timestamps are being auto-generated by Surface. If the app isn&#x27;t</span></span><br><span class="line">            <span class="comment">// generating timestamps explicitly, it probably doesn&#x27;t want frames to</span></span><br><span class="line">            <span class="comment">// be discarded based on them.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果app不能生成对应帧数据的 pts ，那么可以将 mIsAutoTimestamp 置为 true ，即此时不会触发丢帧操作，而是挨个挨个消费</span></span><br><span class="line">            <span class="comment">// 否则的话，则判断 mQueue 列表中待消费数据超过1个时才会去检查是否要触发丢帧操作</span></span><br><span class="line">            <span class="keyword">while</span> (mCore-&gt;mQueue.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; !mCore-&gt;mQueue[<span class="number">0</span>].mIsAutoTimestamp) &#123;</span><br><span class="line">                <span class="comment">// 消费队列中的第一帧不会丢弃，只会是从第二帧开始往后检查的</span></span><br><span class="line">                <span class="function"><span class="type">const</span> BufferItem&amp; <span class="title">bufferItem</span><span class="params">(mCore-&gt;mQueue[<span class="number">1</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If dropping entry[0] would leave us with a buffer that the</span></span><br><span class="line">                <span class="comment">// consumer is not yet ready for, don&#x27;t drop it.</span></span><br><span class="line">                <span class="comment">// 如果指定了当前所需要的最大帧数，那么如果此时第二个BufferItem 的帧数已经超过它了，就表示不需要丢帧操作</span></span><br><span class="line">                <span class="comment">// mFrameNumber 前面生产者 queueBuffer 时讲过了，它表示该BufferItem的数据是第几帧</span></span><br><span class="line">                <span class="keyword">if</span> (maxFrameNumber &amp;&amp; bufferItem.mFrameNumber &gt; maxFrameNumber) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If entry[1] is timely, drop entry[0] (and repeat). We apply an</span></span><br><span class="line">                <span class="comment">// additional criterion here: we only drop the earlier buffer if our</span></span><br><span class="line">                <span class="comment">// desiredPresent falls within +/- 1 second of the expected present.</span></span><br><span class="line">                <span class="comment">// Otherwise, bogus desiredPresent times (e.g., 0 or a small</span></span><br><span class="line">                <span class="comment">// relative timestamp), which normally mean &quot;ignore the timestamp</span></span><br><span class="line">                <span class="comment">// and acquire immediately&quot;, would cause us to drop frames.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// We may want to add an additional criterion: don&#x27;t drop the</span></span><br><span class="line">                <span class="comment">// earlier buffer if entry[1]&#x27;s fence hasn&#x27;t signaled yet.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这一帧需要展示的时间戳，即到了该时间戳就应该展示该帧。</span></span><br><span class="line">                <span class="comment">// mTimestamp 在前面生产者 queueBuffer 时讲过了。</span></span><br><span class="line">                <span class="type">nsecs_t</span> desiredPresent = bufferItem.mTimestamp;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果当前这一帧的期望展示时间 pts 落在了：</span></span><br><span class="line"><span class="comment">                 *  1.比expectedPresent小1s，即 (-∞ , expectedPresent-1s)  </span></span><br><span class="line"><span class="comment">                 *  2.比expectedPresent大，即  (expectedPresent , +∞)</span></span><br><span class="line"><span class="comment">                 * 落在上面两个区间之一都会走进 if 条件体内从而 break 掉 while 循环，从而避免丢帧</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (desiredPresent &lt; expectedPresent - MAX_REASONABLE_NSEC ||</span><br><span class="line">                        desiredPresent &gt; expectedPresent) &#123;</span><br><span class="line">                    <span class="comment">// This buffer is set to display in the near future, or</span></span><br><span class="line">                    <span class="comment">// desiredPresent is garbage. Either way we don&#x27;t want to drop</span></span><br><span class="line">                    <span class="comment">// the previous buffer just to get this on the screen sooner.</span></span><br><span class="line">                    <span class="built_in">BQ_LOGV</span>(<span class="string">&quot;acquireBuffer: nodrop desire=%&quot;</span> PRId64 <span class="string">&quot; expect=%&quot;</span></span><br><span class="line">                            PRId64 <span class="string">&quot; (%&quot;</span> PRId64 <span class="string">&quot;) now=%&quot;</span> PRId64,</span><br><span class="line">                            desiredPresent, expectedPresent,</span><br><span class="line">                            desiredPresent - expectedPresent,</span><br><span class="line">                            <span class="built_in">systemTime</span>(CLOCK_MONOTONIC));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 能走到这里的话，表示 bufferItem 没有落在上面的 1、2 区间内，也就是此时 bufferItem 的 pts 落在了</span></span><br><span class="line"><span class="comment">                 * [ expectedPresent-1s , expectedPresent ] 区间内，也就是大于等于 expectedPresent-1s ，并且小于等于 expectedPresent </span></span><br><span class="line"><span class="comment">                 * </span></span><br><span class="line"><span class="comment">                 * 此时会认为当前 bufferItem 的展示时间已经到了，因为 bufferItem 的 pts 小于等于 expectedPresent ，到了它该展示的时候了</span></span><br><span class="line"><span class="comment">                 * 而此时 bufferItem 是 mQueue[1] ，front 是它前面那个，所以此时将 front（也就是 mQueue[0]）丢弃释放掉 </span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!front-&gt;mIsStale) &#123;</span><br><span class="line">                    <span class="comment">// 释放掉mQueue[0] ，也就是将其状态从 QUEUE 变成了 FREE</span></span><br><span class="line">                    mSlots[front-&gt;mSlot].mBufferState.<span class="built_in">freeQueued</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果释放的 buffer 索引对应的是共享模式的那个，那么此时需要将共享模式关闭掉</span></span><br><span class="line">                    <span class="keyword">if</span> (!mCore-&gt;mSharedBufferMode &amp;&amp;</span><br><span class="line">                            mSlots[front-&gt;mSlot].mBufferState.<span class="built_in">isFree</span>()) &#123;</span><br><span class="line">                        mSlots[front-&gt;mSlot].mBufferState.mShared = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将其从原本的 mActiveBuffers 中移除，加入到 mFreeBuffers 中去</span></span><br><span class="line">                    <span class="comment">// 因为front它是在 mQueues 中的，所以肯定它的graphicBuffer 是绑定了的，因此是放到 mFreeBuffers 中</span></span><br><span class="line">                    <span class="keyword">if</span> (!mSlots[front-&gt;mSlot].mBufferState.<span class="built_in">isShared</span>()) &#123;</span><br><span class="line">                        mCore-&gt;mActiveBuffers.<span class="built_in">erase</span>(front-&gt;mSlot);</span><br><span class="line">                        mCore-&gt;mFreeBuffers.<span class="built_in">push_back</span>(front-&gt;mSlot);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    listener = mCore-&gt;mConnectedProducerListener;</span><br><span class="line">                    <span class="comment">// 丢帧计数</span></span><br><span class="line">                    ++numDroppedBuffers;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 front 从mQueue中移除掉，前面只是将其索引从 mActiveBuffers 中移除而已</span></span><br><span class="line">                mCore-&gt;mQueue.<span class="built_in">erase</span>(front);</span><br><span class="line">                <span class="comment">// 再此获取 mQueue 队列的第一个，也就是上次的第二个，因为上次的第一个刚被移除掉了，完成了丢帧操作</span></span><br><span class="line">                <span class="comment">// 接着循环下去...</span></span><br><span class="line">                front = mCore-&gt;mQueue.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上面 while 丢帧操作完成后，此时的 front 就是针对 expectedPresent 时刻要展示的帧数据了</span></span><br><span class="line">            <span class="type">nsecs_t</span> desiredPresent = front-&gt;mTimestamp;</span><br><span class="line">            <span class="comment">// 如果 desiredPresent 落在了 (-∞,expectedPresent] 或者  (expectedPresent+1s,+∞) 这俩区间之一的话，则 bufferIsDue = true</span></span><br><span class="line">            <span class="type">bool</span> bufferIsDue = desiredPresent &lt;= expectedPresent ||</span><br><span class="line">                    desiredPresent &gt; expectedPresent + MAX_REASONABLE_NSEC;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// mFrameNumber 表示该数据是第几帧。如果它小于 maxFrameNumber 表示已经到了它这帧显示的时间了</span></span><br><span class="line">            <span class="type">bool</span> consumerIsReady = maxFrameNumber &gt; <span class="number">0</span> ?</span><br><span class="line">                    front-&gt;mFrameNumber &lt;= maxFrameNumber : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * bufferIsDue=false : 即 buffer 的 pts 落在了：(expectedPresent,expectedPresent+1s] 区间内的话，也就是还没到buffer的展示时间</span></span><br><span class="line"><span class="comment">             * consumerIsReady =false : 还没到这帧的显示时间</span></span><br><span class="line"><span class="comment">             * 这种情况则返回 PRESENT_LATER 表示需要等会儿再展示，过会儿再来 acquireBuffer </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!bufferIsDue || !consumerIsReady) &#123;</span><br><span class="line">                <span class="built_in">BQ_LOGV</span>(<span class="string">&quot;acquireBuffer: defer desire=%&quot;</span> PRId64 <span class="string">&quot; expect=%&quot;</span> PRId64</span><br><span class="line">                        <span class="string">&quot; (%&quot;</span> PRId64 <span class="string">&quot;) now=%&quot;</span> PRId64 <span class="string">&quot; frame=%&quot;</span> PRIu64</span><br><span class="line">                        <span class="string">&quot; consumer=%&quot;</span> PRIu64,</span><br><span class="line">                        desiredPresent, expectedPresent,</span><br><span class="line">                        desiredPresent - expectedPresent,</span><br><span class="line">                        <span class="built_in">systemTime</span>(CLOCK_MONOTONIC),</span><br><span class="line">                        front-&gt;mFrameNumber, maxFrameNumber);</span><br><span class="line">                <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;PRESENT_LATER&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> PRESENT_LATER;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 执行到这里，表示 mQueue 中的第一个 Buffer 满足要展示的时间要求</span></span><br><span class="line">        <span class="type">int</span> slot = BufferQueueCore::INVALID_BUFFER_SLOT;</span><br><span class="line">        <span class="comment">// 这是共享 buffer 模式，可以暂时不考虑</span></span><br><span class="line">        <span class="keyword">if</span> (sharedBufferAvailable &amp;&amp; mCore-&gt;mQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// make sure the buffer has finished allocating before acquiring it</span></span><br><span class="line">            mCore-&gt;<span class="built_in">waitWhileAllocatingLocked</span>(lock);</span><br><span class="line"></span><br><span class="line">            slot = mCore-&gt;mSharedBufferSlot;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Recreate the BufferItem for the shared buffer from the data that</span></span><br><span class="line">            <span class="comment">// was cached when it was last queued.</span></span><br><span class="line">            outBuffer-&gt;mGraphicBuffer = mSlots[slot].mGraphicBuffer;</span><br><span class="line">            outBuffer-&gt;mFence = Fence::NO_FENCE;</span><br><span class="line">            outBuffer-&gt;mFenceTime = FenceTime::NO_FENCE;</span><br><span class="line">            outBuffer-&gt;mCrop = mCore-&gt;mSharedBufferCache.crop;</span><br><span class="line">            outBuffer-&gt;mTransform = mCore-&gt;mSharedBufferCache.transform &amp;</span><br><span class="line">                    ~<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(</span><br><span class="line">                    NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);</span><br><span class="line">            outBuffer-&gt;mScalingMode = mCore-&gt;mSharedBufferCache.scalingMode;</span><br><span class="line">            outBuffer-&gt;mDataSpace = mCore-&gt;mSharedBufferCache.dataspace;</span><br><span class="line">            outBuffer-&gt;mFrameNumber = mCore-&gt;mFrameCounter;</span><br><span class="line">            outBuffer-&gt;mSlot = slot;</span><br><span class="line">            outBuffer-&gt;mAcquireCalled = mSlots[slot].mAcquireCalled;</span><br><span class="line">            outBuffer-&gt;mTransformToDisplayInverse =</span><br><span class="line">                    (mCore-&gt;mSharedBufferCache.transform &amp;</span><br><span class="line">                    NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != <span class="number">0</span>;</span><br><span class="line">            outBuffer-&gt;mSurfaceDamage = Region::INVALID_REGION;</span><br><span class="line">            <span class="comment">// 将 mQueuedBuffer 置为 false ，以为它在BufferItem 中默认是 true，而共享模式下它是false</span></span><br><span class="line">            outBuffer-&gt;mQueuedBuffer = <span class="literal">false</span>;  </span><br><span class="line">            outBuffer-&gt;mIsStale = <span class="literal">false</span>;</span><br><span class="line">            outBuffer-&gt;mAutoRefresh = mCore-&gt;mSharedBufferMode &amp;&amp;</span><br><span class="line">                    mCore-&gt;mAutoRefresh;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 将 mQueue 中第一个 Buffer 赋值给 outBuffer 作为 acquireBuffer 成功的输出结果 </span></span><br><span class="line">            slot = front-&gt;mSlot;</span><br><span class="line">            *outBuffer = *front;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里的话，outBuffer 指向的就是满足外部消费者要求的 BufferItem</span></span><br><span class="line">        <span class="comment">// slot 就是 outBuffer BufferItem 中的 slot，也就是对应到 mSlots 中 BufferSlot 索引</span></span><br><span class="line">        <span class="comment">// outBuffer 被 acquire 成功了，此时修改该 buffer 的状态为 ACQUIRE</span></span><br><span class="line">        <span class="keyword">if</span> (!outBuffer-&gt;mIsStale) &#123;</span><br><span class="line">            <span class="comment">// 该 BufferSlot 当前已经调用过 acquireBuffer 方法了</span></span><br><span class="line">            mSlots[slot].mAcquireCalled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// mQueue 为空的话，表示该 BufferItem 不在该队列中，也就是目前处于共享模式下</span></span><br><span class="line">            <span class="keyword">if</span> (mCore-&gt;mQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                mSlots[slot].mBufferState.<span class="built_in">acquireNotInQueue</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 将对应的 BufferSlot 由 QUEUE 状态变为 ACQUIRE</span></span><br><span class="line">                mSlots[slot].mBufferState.<span class="built_in">acquire</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            mSlots[slot].mFence = Fence::NO_FENCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outBuffer-&gt;mAcquireCalled) &#123;</span><br><span class="line">            outBuffer-&gt;mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该 BufferItem 从 mQueue 中移除掉，因为它已经被消费者选中即将要消费了</span></span><br><span class="line">        mCore-&gt;mQueue.<span class="built_in">erase</span>(front);</span><br><span class="line"></span><br><span class="line">        mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">        mCore-&gt;mOccupancyTracker.<span class="built_in">registerOccupancyChange</span>(mCore-&gt;mQueue.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有丢帧操作的话，回调通知给外部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numDroppedBuffers; ++i) &#123;</span><br><span class="line">            listener-&gt;<span class="built_in">onBufferReleased</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquireBuffer 是针对消费者端而言的。简单概括其流程为：</p>
<p>1、进行合法性判断，比如判断当前已被acquire的数量是否超过了 mMaxAcquiredBufferCount</p>
<p>2、遍历生产者生产的数据集合：mQueue。从中找出一个满足消费者需求的数据来处理。</p>
<p>在查找过程中，会存在一个丢帧操作，即丢弃一些过期过时的生产者数据。</p>
<p>3、将找到的 slot 的状态从QUEUE修改为ACQUIRE。并将对应的BufferItem 从mQueue 中移除掉。</p>
<p>至此，消费者就从 BufferQueue 中获取到了一个待消费的数据了。接下来消费者会将拿到的数据消费处理掉。</p>
<h4 id="releaseBuffer"><a href="#releaseBuffer" class="headerlink" title="releaseBuffer"></a>releaseBuffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueConsumer::releaseBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">uint64_t</span> frameNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence, EGLDisplay eglDisplay,</span></span></span><br><span class="line"><span class="params"><span class="function">        EGLSyncKHR eglFence)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (slot &lt; <span class="number">0</span> || slot &gt;= BufferQueueDefs::NUM_BUFFER_SLOTS ||</span><br><span class="line">            releaseFence == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">BQ_LOGE</span>(<span class="string">&quot;releaseBuffer: slot %d out of range or fence %p NULL&quot;</span>, slot,</span><br><span class="line">                releaseFence.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;IProducerListener&gt; listener;</span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// frameNumber 发生变化，无视掉</span></span><br><span class="line">        <span class="keyword">if</span> (frameNumber != mSlots[slot].mFrameNumber &amp;&amp;</span><br><span class="line">                !mSlots[slot].mBufferState.<span class="built_in">isShared</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> STALE_BUFFER_SLOT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前要释放的slot之前没有被 acquire 过，调用不合法直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!mSlots[slot].mBufferState.<span class="built_in">isAcquired</span>()) &#123;</span><br><span class="line">            <span class="built_in">BQ_LOGE</span>(<span class="string">&quot;releaseBuffer: attempted to release buffer slot %d &quot;</span></span><br><span class="line">                    <span class="string">&quot;but its state was %s&quot;</span>, slot,</span><br><span class="line">                    mSlots[slot].mBufferState.<span class="built_in">string</span>());</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSlots[slot].mEglDisplay = eglDisplay;</span><br><span class="line">        mSlots[slot].mEglFence = eglFence;</span><br><span class="line">        mSlots[slot].mFence = releaseFence;</span><br><span class="line">        <span class="comment">// 修改 BufferSlot 的状态从 ACQUIRE 状态修改为 FREE</span></span><br><span class="line">        mSlots[slot].mBufferState.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mCore-&gt;mSharedBufferMode &amp;&amp; mSlots[slot].mBufferState.<span class="built_in">isFree</span>()) &#123;</span><br><span class="line">            mSlots[slot].mBufferState.mShared = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 release 的这个 slot 从 mActiveBuffers 中移除掉，因为它之前的 ACQUIRE 状态，是存储在 mActiveBuffers 中的</span></span><br><span class="line">        <span class="comment">// 同时还需要将其放入 mFreeBuffers 中去，因为它的 mGraphicBuffer 已经被分配内存了，所以不能放入到 mFreeSlots</span></span><br><span class="line">        <span class="keyword">if</span> (!mSlots[slot].mBufferState.<span class="built_in">isShared</span>()) &#123;</span><br><span class="line">            mCore-&gt;mActiveBuffers.<span class="built_in">erase</span>(slot);</span><br><span class="line">            mCore-&gt;mFreeBuffers.<span class="built_in">push_back</span>(slot);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listener = mCore-&gt;mConnectedProducerListener;</span><br><span class="line"></span><br><span class="line">        mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call back without lock held</span></span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        listener-&gt;<span class="built_in">onBufferReleased</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当消费者消费完成之后，就需要将对应的 slot 释放掉，将其所有权归还给 BufferQueue，等待后续生产者再复用。</p>
<p>而从上面的代码中也可以看出。release 时会将对应的 BufferSlot 的状态从 ACQUIRE 改为 FREE，并将其放入到 mFreeBuffers 中，等待后期dequeue时复用。</p>
<h4 id="connect-1"><a href="#connect-1" class="headerlink" title="connect"></a>connect</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueConsumer::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IConsumerListener&gt;&amp; consumerListener, <span class="type">bool</span> controlledByApp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入参合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (consumerListener == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">BQ_LOGE</span>(<span class="string">&quot;connect: consumerListener may not be NULL&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCore-&gt;mIsAbandoned) &#123;</span><br><span class="line">        <span class="built_in">BQ_LOGE</span>(<span class="string">&quot;connect: BufferQueue has been abandoned&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存一下入参而已</span></span><br><span class="line">    mCore-&gt;mConsumerListener = consumerListener;</span><br><span class="line">    mCore-&gt;mConsumerControlledByApp = controlledByApp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者的connect 很简单，就是将回调等属性保存起来而已。</p>
<h4 id="disconnect-1"><a href="#disconnect-1" class="headerlink" title="disconnect"></a>disconnect</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueConsumer::disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有 connect 过，那么本次 disconnect 不合法</span></span><br><span class="line">    <span class="keyword">if</span> (mCore-&gt;mConsumerListener == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">BQ_LOGE</span>(<span class="string">&quot;disconnect: no consumer is connected&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理数据，比如将 BufferQueueCore 中所有的集合数据都清空</span></span><br><span class="line">    mCore-&gt;mIsAbandoned = <span class="literal">true</span>;</span><br><span class="line">    mCore-&gt;mConsumerListener = <span class="literal">nullptr</span>;</span><br><span class="line">    mCore-&gt;mQueue.<span class="built_in">clear</span>();</span><br><span class="line">    mCore-&gt;<span class="built_in">freeAllBuffersLocked</span>();</span><br><span class="line">    mCore-&gt;mSharedBufferSlot = BufferQueueCore::INVALID_BUFFER_SLOT;</span><br><span class="line">    mCore-&gt;mDequeueCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于BufferQueueConsumer的 connect 和 disconnect 方法来说，它是消费者与BufferQueue建立联系和断开联系的方法。</p>
<h3 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h3><p>额外还提供了一个 BufferQueue 类来完成一些工具类的逻辑。</p>
<h4 id="createBufferQueue"><a href="#createBufferQueue" class="headerlink" title="createBufferQueue"></a>createBufferQueue</h4><p>创建一个生产者消费者模型，返回一个 BufferQueueProducer 和 BufferQueueConsumer 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueue.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferQueue::createBufferQueue</span><span class="params">(sp&lt;IGraphicBufferProducer&gt; *outProducer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    sp&lt;IGraphicBufferConsumer&gt; *outConsumer, <span class="type">bool</span> consumerIsSurfaceFlinger)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * new 出来一个 BufferQueueCore 对象实例</span></span><br><span class="line"><span class="comment">   * BufferQueueCore才是buffer queue的核心，真正干活的其实是 BufferQueueCore 这个类，BufferQueue只是个外壳而已</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">sp&lt;BufferQueueCore&gt; <span class="title">core</span><span class="params">(<span class="keyword">new</span> BufferQueueCore())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(core == <span class="literal">nullptr</span>,</span><br><span class="line">                      <span class="string">&quot;BufferQueue: failed to create BufferQueueCore&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * new 出来一个 BufferQueueProducer 对象实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core, consumerIsSurfaceFlinger))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * new 出来一个 BufferQueueConsumer 对象实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将创建好的对象赋值给入参，等方法返回后，入参中就指向新建的对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  *outProducer = producer;</span><br><span class="line">  *outConsumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该方法就可以很方便的创建出一个 生产消费者模型。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/BufferQueue/">BufferQueue</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/c4a594c7.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">GLES&EGL-总述</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/98c274c6.html">
        <span class="next-text nav-default">BufferQueue 简介</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
