<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="OkHttp 拦截器介绍"/>




  <meta name="keywords" content="okhttp," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/52da40ac.html"/>


<meta name="description" content="正如 OkHttp 请求创建 中讲到的，OkHttpClient 请求完成的主要逻辑是在那些拦截器中的，所以本文主要介绍这些拦截器。 在前面 OkHttp 请求创建 中的 getResponseWithInterceptorChain() 方法中，按顺序加入了一些拦截器，按照先后顺序来说，这些拦截器分别就是：① 外部开发者 OkHttpClient 设置 Interceptors 、② Retry">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp 拦截器介绍">
<meta property="og:url" content="https://youngkaaa.github.io/52da40ac.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="正如 OkHttp 请求创建 中讲到的，OkHttpClient 请求完成的主要逻辑是在那些拦截器中的，所以本文主要介绍这些拦截器。 在前面 OkHttp 请求创建 中的 getResponseWithInterceptorChain() 方法中，按顺序加入了一些拦截器，按照先后顺序来说，这些拦截器分别就是：① 外部开发者 OkHttpClient 设置 Interceptors 、② Retry">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-21T13:49:56.000Z">
<meta property="article:modified_time" content="2023-03-08T11:48:29.850Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="okhttp">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> OkHttp 拦截器介绍 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          OkHttp 拦截器介绍
        
      </h1>

      <time class="post-time">
          1月 21 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>正如 <a href="898ecc0a.html">OkHttp 请求创建</a> 中讲到的，OkHttpClient 请求完成的主要逻辑是在那些拦截器中的，所以本文主要介绍这些拦截器。</p>
<p>在前面 <a href="898ecc0a.html">OkHttp 请求创建</a> 中的 getResponseWithInterceptorChain() 方法中，按顺序加入了一些拦截器，按照先后顺序来说，这些拦截器分别就是：① 外部开发者 OkHttpClient 设置 Interceptors 、② RetryAndFollowUpInterceptor 、③ BridgeInterceptor、④ CacheInterceptor、⑤ ConnectInterceptor、⑥ 外部开发者 OkHttpClient 设置 NetworkInterceptors  、⑦ CallServerInterceptor 。所以下面基于这个顺序来分析。</p>
<h3 id="OkHttpClient-Interceptors"><a href="#OkHttpClient-Interceptors" class="headerlink" title="OkHttpClient.Interceptors"></a>OkHttpClient.Interceptors</h3><p>它的设置是通过外部构建 OkHttpClient.Builder 时，通过其 addInterceptor() 方法来添加的拦截器，这些拦截器被率先执行，他们被执行完毕之后，才有可能去执行后续的拦截器。</p>
<h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>主要负责请求重试、重定向等操作逻辑。</p>
<p>下面先看其源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RetryAndFollowUpInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 拿到请求信息</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">    <span class="type">RealInterceptorChain</span> <span class="variable">realChain</span> <span class="operator">=</span> (RealInterceptorChain) chain;</span><br><span class="line">    <span class="type">Transmitter</span> <span class="variable">transmitter</span> <span class="operator">=</span> realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">followUpCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Response</span> <span class="variable">priorResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是个死循环，内部会做判断终止循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 准备连接，内部会将这个 request 保存起来</span></span><br><span class="line">        transmitter.prepareToConnect(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查该请求是否已经被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Response response;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 拦截链继续往下走，也就是调用当前 Interceptor 之后的那些来执行操作</span></span><br><span class="line"><span class="comment">             * 下一个 Interceptor 是：&#123;<span class="doctag">@link</span> BridgeInterceptor&#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            response = realChain.proceed(request, transmitter, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 执行成功</span></span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当前路由下出错了，判断是否需要重试，不需要再次重试的话就直接抛出异常，</span></span><br><span class="line"><span class="comment">             * 否则就 continue 接着执行 while ，进行下次重试</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="literal">false</span>, request)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getFirstConnectException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">requestSendStarted</span> <span class="operator">=</span> !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 遇到io异常，判断是否需要重试</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// The network call threw an exception. Release any resources.</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                transmitter.exchangeDoneDueToException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次的时候 priorResponse==null</span></span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                            .body(<span class="literal">null</span>)</span><br><span class="line">                            .build())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Exchange</span> <span class="variable">exchange</span> <span class="operator">=</span> Internal.instance.exchange(response);</span><br><span class="line">        <span class="type">Route</span> <span class="variable">route</span> <span class="operator">=</span> exchange != <span class="literal">null</span> ? exchange.connection().route() : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到这里表示：请求成功了，拿到了返回结果，那么这里检查下响应码</span></span><br><span class="line"><span class="comment">         * 根据响应码判断这里的返回结果是否可以直接使用，但是如果遇到重定向时就需要重新请求</span></span><br><span class="line"><span class="comment">         * 3xx 的响应码中会在response的header中携带Location的字段用来标识新的地址，此时需要重定向</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">followUp</span> <span class="operator">=</span> followUpRequest(response, route);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回 null 表示不需要重定向等重试请求了，那么直接返回这次的结果就行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; exchange.isDuplex()) &#123;</span><br><span class="line">                transmitter.timeoutEarlyExit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里表示还需要重新请求</span></span><br><span class="line">        <span class="type">RequestBody</span> <span class="variable">followUpBody</span> <span class="operator">=</span> followUp.body();</span><br><span class="line">        <span class="keyword">if</span> (followUpBody != <span class="literal">null</span> &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将这次的 Response 关闭掉，因为没用了 ，马上要开始新的请求重试了</span></span><br><span class="line">        closeQuietly(response.body());</span><br><span class="line">        <span class="keyword">if</span> (transmitter.hasExchange()) &#123;</span><br><span class="line">            exchange.detachWithViolence();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求重试次数有限制，超过 MAX_FOLLOW_UPS 也就是20次时就不再重试了。</span></span><br><span class="line">        <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ProtocolException</span>(<span class="string">&quot;Too many follow-up requests: &quot;</span> + followUpCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 赋值新的request，准备下一次请求</span></span><br><span class="line">        request = followUp;</span><br><span class="line">        priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 RetryAndFollowUpInterceptor 中存在一个死循环，在这个循环内部，首先会调用：transmitter.prepareToConnect() 方法来为这次请求做好准备工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transmitter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepareToConnect</span><span class="params">(Request request)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个实例第二次调用时，this.request!=null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.request != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前Request和之前的Request是类似可重用的，直接return吧</span></span><br><span class="line">        <span class="keyword">if</span> (sameConnection(<span class="built_in">this</span>.request.url(), request.url()) &amp;&amp; exchangeFinder.hasRouteToTry()) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Already ready.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为不是同一个链接了，所以释放上一个请求对应的链接就可以尝试释放掉了</span></span><br><span class="line">        <span class="keyword">if</span> (exchangeFinder != <span class="literal">null</span>) &#123;</span><br><span class="line">            maybeReleaseConnection(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">            exchangeFinder = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.request = request;</span><br><span class="line">    <span class="comment">// 这里会新建初始化 ExchangeFinder</span></span><br><span class="line">    <span class="built_in">this</span>.exchangeFinder = <span class="keyword">new</span> <span class="title class_">ExchangeFinder</span>(<span class="built_in">this</span>, connectionPool, createAddress(request.url()),</span><br><span class="line">            call, eventListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里是从入参 chain 中取出的 Transmitter 实例，而由前面  <a href="898ecc0a.html">OkHttp 请求创建</a>  中创建 RealInterceptorChain 的逻辑可知：这个 Transmitter 实例实际是在OkHttpClient 类中的 newRealCall() 方法内，创建 RealCall 时一起创建的并赋值给 RealCall 的，接着在 getResponseWithInterceptorChain() 方法中保存给 RealInterceptorChain 实例的，接着后续创建其他 RealInterceptorChain 实例中也会有这个属性，他们都对应同一个实例。所以说这里取出的 Transmitter 实例实际就是 RealCall 中的那个实例。</p>
<p>接着看 prepareToConnect() 方法内部的逻辑，首先它会判断其内部的 request 是否为空，request 为空的情况是当第二次及其之后调用 prepareToConnect() 方法时出现的，因为前一次调用时会给这个 request 赋值。对于当前拦截器来说，就是在 while 循环中执行下一次循环时。</p>
<p>这种情况时，会判断本次传进来的 request 和上一次保存的是不是一样的，这里说的一样的意思是：两个request请求对应的协议，host以及端口相同。如果不同的话，则会调用 maybeReleaseConnection() 方法来尝试释放上一个 Request 对应的连接，这个连接指的是上一个Request请求时于服务端建立的 Socket 连接。</p>
<p>对于当前拦截器来说，这种情况触发的场景是第一次请求成功了，但是拿到的结果告诉我们需要重定向，此时我们需要再次请求新的地址。所以这种情况时可能要释放前一个连接。</p>
<p>接着往下会将本次新的 request 保存到当前  Transmitter 实例中等待后续使用，接着会创建一个新的 ExchangeFinder 实例。</p>
<p>所以说，当前 prepareToConnect() 每调用一次，内部都会新建一个新的ExchangeFinder 实例。而代入到当前拦截器中就是：每重试、重定向一次，都会新建一个 ExchangeFinder 实例，因为每次 Request 都会变化，所以需要保证 ExchangeFinder 实例是最新的。</p>
<p>回到 intercept() 方法中，接下来会在请求正式开始之前判断下当前 RealCall 是否已被取消。</p>
<p>接着往下走会执行：realChain.proceed() 方法，该方法去执行拦截链中剩余的拦截器，最终拿到一个返回结果 response。</p>
<p>而如果在执行过程中遇到了异常，比如 RouteException 或者 IOException ，表示上面的拦截链在处理后续逻辑时失败了，此时会通过调用 recover() 方法来判断要不要尝试再次请求重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RetryAndFollowUpInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recover</span><span class="params">(IOException e, Transmitter transmitter, <span class="type">boolean</span> requestSendStarted, Request userRequest)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果将重试能力关闭了，那么直接返回false不重试了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求的body已经发出了，那么不进行重试了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遇到了一些致命的异常，那么不进行重试了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有其他的 route 路由来重试了，那么就不重试了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!transmitter.canRetry()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRecoverable</span><span class="params">(IOException e, <span class="type">boolean</span> requestSendStarted)</span> &#123;</span><br><span class="line">    <span class="comment">// If there was a protocol problem, don&#x27;t recover.</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ProtocolException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was an interruption don&#x27;t recover, but if there was a timeout connecting to a route</span></span><br><span class="line">    <span class="comment">// we should try the next route (if there is one).</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InterruptedIOException) &#123;</span><br><span class="line">        <span class="keyword">return</span> e <span class="keyword">instanceof</span> SocketTimeoutException &amp;&amp; !requestSendStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look for known client-side or negotiation errors that are unlikely to be fixed by trying</span></span><br><span class="line">    <span class="comment">// again with a different route.</span></span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLHandshakeException) &#123;</span><br><span class="line">        <span class="comment">// If the problem was a CertificateException from the X509TrustManager,</span></span><br><span class="line">        <span class="comment">// do not retry.</span></span><br><span class="line">        <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> CertificateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> SSLPeerUnverifiedException) &#123;</span><br><span class="line">        <span class="comment">// e.g. a certificate pinning error.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An example of one we might want to retry with a different route is a problem connecting to a</span></span><br><span class="line">    <span class="comment">// proxy and would manifest as a standard IOException. Unless it is one we know we should not</span></span><br><span class="line">    <span class="comment">// retry, we return true and try a new route.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是判断当前失败的原因，如果是很严重的错误没法重试的话，则不会去尝试重试，否则会进行下一次重试。</p>
<p>如果执行后续拦截器没有异常，也就是正常拿到了返回结果，此时会调用 followUpRequest() 方法来判断是否需要重定向等操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RetryAndFollowUpInterceptor.java</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> Request <span class="title function_">followUpRequest</span><span class="params">(Response userResponse, <span class="meta">@Nullable</span> Route route)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (userResponse == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">responseCode</span> <span class="operator">=</span> userResponse.code();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> userResponse.request().method();</span><br><span class="line">    <span class="keyword">switch</span> (responseCode) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> HTTP_MULT_CHOICE: <span class="comment">// 300</span></span><br><span class="line">        <span class="keyword">case</span> HTTP_MOVED_PERM:  <span class="comment">// 301</span></span><br><span class="line">        <span class="keyword">case</span> HTTP_MOVED_TEMP:  <span class="comment">// 302</span></span><br><span class="line">        <span class="keyword">case</span> HTTP_SEE_OTHER:   <span class="comment">// 303</span></span><br><span class="line">            <span class="keyword">if</span> (!client.followRedirects()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 拿到重定向新的地址</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> userResponse.header(<span class="string">&quot;Location&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (location == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">HttpUrl</span> <span class="variable">url</span> <span class="operator">=</span> userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (url == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// http 和 https 之间的重定向</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">sameScheme</span> <span class="operator">=</span> url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">            <span class="keyword">if</span> (!sameScheme &amp;&amp; !client.followSslRedirects()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            Request.<span class="type">Builder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> userResponse.request().newBuilder();</span><br><span class="line">            <span class="keyword">if</span> (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">maintainBody</span> <span class="operator">=</span> HttpMethod.redirectsWithBody(method);</span><br><span class="line">                <span class="keyword">if</span> (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">                    requestBuilder.method(<span class="string">&quot;GET&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> maintainBody ? userResponse.request().body() : <span class="literal">null</span>;</span><br><span class="line">                    requestBuilder.method(method, requestBody);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!maintainBody) &#123;</span><br><span class="line">                    requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">                    requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">                    requestBuilder.removeHeader(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!sameConnection(userResponse.request().url(), url)) &#123;</span><br><span class="line">                requestBuilder.removeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果返回值 followUp 为空则表示不需要重定向，此时就可以将当前 response 返回出去作为当前拦截器处理之后的最终结果了。而它如果不为空时，后续会尝试去做下一次重试工作，最后的最后还会判断一个条件：当前重试次数是否超限，即最大重试次数不能超过 MAX_FOLLOW_UPS &#x3D; 20 次。满足这个条件的话就可以开始下一次的重试工作了，即开始下一次循环，再次一次循环中就会再次执行前面所说的 prepareToConnect() 方法了。</p>
<p>所以总的来说，当前 RetryAndFollowUpInterceptor 的作用就是完成重试和重定向工作，而它之前的拦截器（比如前面说的 OkHttpClient.Interceptors）只会拿到一个重试重定向之后的最终结果，而对中间的重试、重定向请求无任何感知。</p>
<h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><p>在前面 RetryAndFollowUpInterceptor 中，会执行 realChain.proceed() 方法来执行后续的拦截器逻辑，也就是会执行到当前拦截器中。</p>
<p>接下来看源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BridgeInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">userRequest</span> <span class="operator">=</span> chain.request();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建一个 Request ，将用户传入的 Request 转换成后面 Interceptor 所能处理的 Request</span></span><br><span class="line"><span class="comment">     * 注意这里使用的是 userRequest.newBuilder() 本方法中会将 userRequest 中的值复制一份到新的 requestBuilder 中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Request.<span class="type">Builder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拿到用户设置的 RequestBody</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">body</span> <span class="operator">=</span> userRequest.body();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将设置的 MediaType 转换为 header 中的 &quot;Content-Type&quot;</span></span><br><span class="line">        <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> body.contentType();</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">contentLength</span> <span class="operator">=</span> body.contentLength();</span><br><span class="line">        <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, Long.toString(contentLength));</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补上HOST</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Host&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Host&quot;</span>, hostHeader(userRequest.url(), <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补上 Connection</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Connection&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">transparentGzip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;Accept-Encoding&quot;</span>) == <span class="literal">null</span> &amp;&amp; userRequest.header(<span class="string">&quot;Range&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        transparentGzip = <span class="literal">true</span>;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补上 cookie</span></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Cookie&quot;</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补上UA</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">&quot;User-Agent&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">&quot;User-Agent&quot;</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将新的 request 传入到下一层的 Interceptor 中去处理， 因为当前Interceptor的前置任务完成了</span></span><br><span class="line"><span class="comment">     * 也就是说已经将用户设置在 Request 中的那些字段转换成了 http 中的 header 等属性了 ，此时就是 HTTP 认识的那些数据类型了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 下一个 Interceptor 是：&#123;<span class="doctag">@link</span> okhttp3.internal.cache.CacheInterceptor&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">networkResponse</span> <span class="operator">=</span> chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是拿到返回结果之后的操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先保存cookie</span></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样是先将 网络返回的 Response 复制一份到新建的 responseBuilder 中去</span></span><br><span class="line">    Response.<span class="type">Builder</span> <span class="variable">responseBuilder</span> <span class="operator">=</span> networkResponse.newBuilder()</span><br><span class="line">            .request(userRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理gzip 保证上一层拦截器拿到的就是解压之后的</span></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">            &amp;&amp; <span class="string">&quot;gzip&quot;</span>.equalsIgnoreCase(networkResponse.header(<span class="string">&quot;Content-Encoding&quot;</span>))</span><br><span class="line">            &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">        <span class="type">GzipSource</span> <span class="variable">responseBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GzipSource</span>(networkResponse.body().source());</span><br><span class="line">        <span class="type">Headers</span> <span class="variable">strippedHeaders</span> <span class="operator">=</span> networkResponse.headers().newBuilder()</span><br><span class="line">                .removeAll(<span class="string">&quot;Content-Encoding&quot;</span>)</span><br><span class="line">                .removeAll(<span class="string">&quot;Content-Length&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        responseBuilder.headers(strippedHeaders);</span><br><span class="line">        <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> networkResponse.header(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">        responseBuilder.body(<span class="keyword">new</span> <span class="title class_">RealResponseBody</span>(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完其实现逻辑，可以知道当前 BridgeInterceptor 拦截器的作用是：</p>
<p>① 负责将用户构建的一个 Request 请求转化为能够进行网络访问的请求。因为此时传入的 Request 中的属性都是些具体的Java 类实例，比如 MediaType 。这里需要将其转换为对应的 HTTP 属性字段，比如转换为 header 中的 Content-Type 属性。</p>
<p>② 调用 chain.proceed() 方法来将这个新的 Request 传入进去，去完成后续拦截器的执行，执行完毕之后拿到最终的结果。</p>
<p>③ 将这个刚拿到的 Response 中的一些字段转换为对应的 Java类对象实例。比如 Cache 保存，GZip 的处理等。</p>
<p>这个拦截器中的逻辑相对简单些，一句话概括来说就是：请求前将 Request 转换为 HTTP 相关字段值，拿到结果后将HTTP相关字段值转换为对应的 Java 对象实例。</p>
<h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>当前拦截器的作用主要是完成之前缓存读取，以及新请求的缓存更新工作。</p>
<p>下面先看其源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CacheInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先从缓存中查找该 request 对应的缓存 Response，如果之前没有缓存的话拿到的就是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">cacheCandidate</span> <span class="operator">=</span> cache != <span class="literal">null</span> ? cache.get(chain.request()) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将从缓存中读取出来的 Response 和当前入参 Request 、以及当前时间 一起封装到 CacheStrategy.Factory 中</span></span><br><span class="line"><span class="comment">     * 然后调用  CacheStrategy.Factory 的 get() 方法拿到一个对应的 CacheStrategy 实例</span></span><br><span class="line"><span class="comment">     * 这个 get() 方法中会根据时间、以及之前的 cacheCandidate 等字段来判断该缓存是否可用进而返回不同的 CacheStrategy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">CacheStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * networkRequest 为 null 的话表示不需要再去网络请求了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">networkRequest</span> <span class="operator">=</span> strategy.networkRequest;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cacheResponse 表示最终可用的缓存 Response 对象。</span></span><br><span class="line"><span class="comment">     * 如果为空则表示 cacheCandidate 不能用在本次的 Request 上，</span></span><br><span class="line"><span class="comment">     * 否则表示 cacheCandidate 可以使用，已将其转化为 cacheResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">cacheResponse</span> <span class="operator">=</span> strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cacheCandidate 在当前 Request 上用不了，把这个 cacheCandidate 释放掉吧</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果缓存策略中设置禁止使用网络，并且缓存又为空，则构建一个Response直接返回，注意返回码 = 504</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>.Builder()</span><br><span class="line">                .request(chain.request())</span><br><span class="line">                .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                .code(<span class="number">504</span>)</span><br><span class="line">                .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  到这里的话，cacheResponse 肯定不为null，所以直接使用这个 cacheResponse 作为结果吧，</span></span><br><span class="line"><span class="comment">     *  也就是 缓存命中了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Response</span> <span class="variable">networkResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到这里表示 networkRequest 不为空，此时需要去做实际的网络请求了</span></span><br><span class="line"><span class="comment">         * 下一个 Interceptor 是：&#123;<span class="doctag">@link</span> okhttp3.internal.connection.ConnectInterceptor&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 网络返回失败时，也就是 networkResponse = null，表示没法再缓存了，此时释放掉 cacheCandidate</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果之前存在缓存，网络请求之后还返回了 304 则将网络请求结果和之前缓存的结果合并下，</span></span><br><span class="line"><span class="comment">     * 生成一个新的 Response 返回。并且使用新的 Response 来更新下缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> cacheResponse.newBuilder()</span><br><span class="line">                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .networkResponse(stripBody(networkResponse))</span><br><span class="line">                    .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            <span class="comment">// 更新缓存</span></span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cacheResponse == null，那么就只用网络请求的返回结果即可</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> networkResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将网络请求结果缓存起来。注意这里是新增缓存，上面是更新已有的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="type">CacheRequest</span> <span class="variable">cacheRequest</span> <span class="operator">=</span> cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前 CacheInterceptor 中，首先会从其内部的 cache 实例中取出当前 Request 对应的缓存。</p>
<p>而其内部的 cache 的赋值是在 CacheInterceptor 的构造方法中，也就是在前面的 getResponseWithInterceptorChain() 方法中传入进来的，实际对应着 OkHttpClient 中的，也就是  OkHttpClient.Builder 中的cache 和 internalCache ，外部如果没有设置的话则是 null 。</p>
<p>而在 OkHttp 中提供了一个 okhttp3.Cache 类，内部使用 DiskLruCache 来完成响应结果的磁盘LRU缓存，如果你如果想要开启这里的缓存，可以在构建 OkHttpClient 实例时，通过 Builder 来指定它。</p>
<p>接着往下，会将这个读取出来的之前的缓存结果 cacheCandidate ，连同当前 Request 实例，和当前系统时间一起传入到 CacheStrategy.Factory 实例中，然后调用其 get() 方法，拿到缓存判断处理之后的 CacheStrategy 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CacheStrategy.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CacheStrategy <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CacheStrategy</span> <span class="variable">candidate</span> <span class="operator">=</span> getCandidate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidate.networkRequest != <span class="literal">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CacheStrategy <span class="title function_">getCandidate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 之前传入的缓存 Response 为空，即没有缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(request, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前是 https 的请求，但是之前缓存结果时不是 https 的，前后协议不一样</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(request, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前的这个缓存结果是否可被用于后续缓存</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(request, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求中的 &quot;Cache-Control&quot; 设置的值，如果禁止使用缓存</span></span><br><span class="line">    <span class="type">CacheControl</span> <span class="variable">requestCaching</span> <span class="operator">=</span> request.cacheControl();</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(request, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面开始处理上次返回结果中的的header</span></span><br><span class="line">    <span class="type">CacheControl</span> <span class="variable">responseCaching</span> <span class="operator">=</span> cacheResponse.cacheControl();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">ageMillis</span> <span class="operator">=</span> cacheResponseAge();</span><br><span class="line">    <span class="type">long</span> <span class="variable">freshMillis</span> <span class="operator">=</span> computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">minFreshMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxStaleMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断响应结果是否过期，如果没过期的话则最终的 CacheStrategy 实例中  networkRequest = null</span></span><br><span class="line">    <span class="comment">// 表示不需要再去网络请求了</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">oneDayMillis</span> <span class="operator">=</span> <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(<span class="literal">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="comment">// 执行到这里表示之前缓存的已过期了</span></span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="literal">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-None-Match&quot;</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="literal">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="literal">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">&quot;If-Modified-Since&quot;</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(request, <span class="literal">null</span>); <span class="comment">// No condition! Make a regular request.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Headers.<span class="type">Builder</span> <span class="variable">conditionalRequestHeaders</span> <span class="operator">=</span> request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">    <span class="type">Request</span> <span class="variable">conditionalRequest</span> <span class="operator">=</span> request.newBuilder()</span><br><span class="line">            .headers(conditionalRequestHeaders.build())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其返回的 CacheStrategy 中会有两个字段：networkRequest 和 cacheResponse ，如果前者不为空则表示还是需要网络请求，如果后者不为空则表示之前从 cache 中读取出来的 cacheCandidate 可用，并且已将其转换为  Response 了。</p>
<p>接着往下就会判断这俩属性的值做不同的处理，详见代码注释。</p>
<p>如果没有命中缓存，则还是需要走后面的逻辑，即调用拦截链的 chain.proceed() 方法来完成后续的请求逻辑。</p>
<p>chain.proceed() 执行完毕，拿到网络请求的结果 networkResponse 会做缓存的更新，或者是缓存的新增。</p>
<p>至此 CacheInterceptor 分析完毕，可以看到它主要是完成缓存相关的逻辑，比如在请求前尝试去本地查询缓存，如果命中缓存则返回缓存的内容，省掉了后续的 chain.proceed() 逻辑，也就是省掉了后续的网络请求逻辑，这便是拦截器中断拦截链的一个实例；当然如果没有命中缓存，则还是会老老实实的请求网络。</p>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>下面先看其代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConnectInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RealInterceptorChain</span> <span class="variable">realChain</span> <span class="operator">=</span> (RealInterceptorChain) chain;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> realChain.request();</span><br><span class="line">    <span class="type">Transmitter</span> <span class="variable">transmitter</span> <span class="operator">=</span> realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">doExtensiveHealthChecks</span> <span class="operator">=</span> !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个 Exchange 实例，然后传给下一个 拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Exchange</span> <span class="variable">exchange</span> <span class="operator">=</span> transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个是 client.networkInterceptors()，但是一般没设置，所以下一个是 CallServerInterceptor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ConnectInterceptor 中，首先会通过 Transmitter 实例来创建一个 Exchange 实例。而这个Transmitter 实例的赋值在上面 RetryAndFollowUpInterceptor 中讲过了。拿到这个 Exchange 实例之后会将其传入到拦截链中，进而在下一个拦截器中就可以用到了。所以当前方法的重心就是这个 Exchange 的创建，而关于它的分析详见： <a href="a4b11ed8.html">OkHttp 连接缓存池</a></p>
<h3 id="OkHttpClient-NetworkInterceptors"><a href="#OkHttpClient-NetworkInterceptors" class="headerlink" title="OkHttpClient.NetworkInterceptors"></a>OkHttpClient.NetworkInterceptors</h3><p>它的设置是通过外部构建 OkHttpClient.Builder 时，通过其 addNetworkInterceptor() 方法来添加的拦截器，这些拦截器此时才会被执行，也就是说这些是在 ConnectInterceptor 执行之后才执行的，而在前面 ConnectInterceptor  中创建 Exchange  时就会创建或者获取一个对应的 Socket 链接。所以所到当前 NetworkInterceptors 中时就可以拿到前面已创建的 Socket 了，因此它被称为 NetworkInterceptors 。</p>
<blockquote>
<p>当然前面的OkHttpClient.Interceptors 被称为应用拦截器，即应用层面的拦截器，最终只会被调用一次，不论内部有多少次请求。而这里的NetworkInterceptors 则不同，它会在一次请求中被调用多次，因为一次请求可能会遇到重定向、重试等操作，所以会有多次网络请求发生，因此当前NetworkInterceptors 可能会被调用多次。</p>
</blockquote>
<h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>先看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CallServerInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RealInterceptorChain</span> <span class="variable">realChain</span> <span class="operator">=</span> (RealInterceptorChain) chain;</span><br><span class="line">    <span class="type">Exchange</span> <span class="variable">exchange</span> <span class="operator">=</span> realChain.exchange();</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> realChain.request();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">sentRequestMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先写入header信息</span></span><br><span class="line">    exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">responseHeadersStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Response.<span class="type">Builder</span> <span class="variable">responseBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前请求的方法类型是否允许携带 body，允许的话并且 request 还携带了body 那么就传输 body</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equalsIgnoreCase(request.header(<span class="string">&quot;Expect&quot;</span>))) &#123;</span><br><span class="line">            exchange.flushRequest();</span><br><span class="line">            responseHeadersStarted = <span class="literal">true</span>;</span><br><span class="line">            exchange.responseHeadersStart();</span><br><span class="line">            responseBuilder = exchange.readResponseHeaders(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">                <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">                exchange.flushRequest();</span><br><span class="line">                <span class="type">BufferedSink</span> <span class="variable">bufferedRequestBody</span> <span class="operator">=</span> Okio.buffer(</span><br><span class="line">                        exchange.createRequestBody(request, <span class="literal">true</span>));</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">                <span class="type">BufferedSink</span> <span class="variable">bufferedRequestBody</span> <span class="operator">=</span> Okio.buffer(</span><br><span class="line">                        exchange.createRequestBody(request, <span class="literal">false</span>));</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exchange.noRequestBody();</span><br><span class="line">            <span class="keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">                exchange.noNewExchangesOnConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.body() == <span class="literal">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">        exchange.finishRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">        exchange.responseHeadersStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始读取 response 的 header</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 response header的返回来构建一个 Response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> responseBuilder</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(exchange.connection().handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> response.code();</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">        <span class="comment">// try again to read the actual response</span></span><br><span class="line">        response = exchange.readResponseHeaders(<span class="literal">false</span>)</span><br><span class="line">                .request(request)</span><br><span class="line">                .handshake(exchange.connection().handshake())</span><br><span class="line">                .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        code = response.code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果有 response body 则处理body</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">                .body(exchange.openResponseBody(response))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.request().header(<span class="string">&quot;Connection&quot;</span>))</span><br><span class="line">            || <span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.header(<span class="string">&quot;Connection&quot;</span>))) &#123;</span><br><span class="line">        exchange.noNewExchangesOnConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ProtocolException</span>(</span><br><span class="line">                <span class="string">&quot;HTTP &quot;</span> + code + <span class="string">&quot; had non-zero Content-Length: &quot;</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为拦截器中的最后一个，它的作用就是用来往服务端写入要发送的数据，因为前面已经创建好 Sokcet 链接了，这里只需要往内部写入数据即可。接着拿到响应结果读取响应结果即可。</p>
<p>至此完成了对 OkHttp 中的拦截器的简单分析，在细节并没有做过多解释，但实际上，每个拦截器中都有很多逻辑，每个单拿出来作为一篇文章来讲都可以，而本文只是做总的流程介绍，起抛砖引玉的作用，细节可以留作后续TODO吧。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/okhttp/">okhttp</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/a4b11ed8.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">OkHttp 连接缓存池</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/898ecc0a.html">
        <span class="next-text nav-default">OkHttp 请求创建</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
