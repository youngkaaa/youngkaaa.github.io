<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Retrofit-执行中的秘密"/>




  <meta name="keywords" content="retrofit," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/3e87a46f.html"/>


<meta name="description" content="正如前文 动态代理中的秘密 所讲的，我们创建好了 HttpServiceMethod 实例，接下来就应该执行它的 invoke() 方法来将外部开发者传入的参数传入进去，完成内部逻辑的执行了。但在讲这些之前，我想先介绍下 Retrofit 中的一些类和概念，以方便后续逻辑的分析。 Call在 Retrofit 中也定义了一个 Call 接口： 123456789101112131415161718">
<meta property="og:type" content="article">
<meta property="og:title" content="Retrofit-执行中的秘密">
<meta property="og:url" content="https://youngkaaa.github.io/3e87a46f.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="正如前文 动态代理中的秘密 所讲的，我们创建好了 HttpServiceMethod 实例，接下来就应该执行它的 invoke() 方法来将外部开发者传入的参数传入进去，完成内部逻辑的执行了。但在讲这些之前，我想先介绍下 Retrofit 中的一些类和概念，以方便后续逻辑的分析。 Call在 Retrofit 中也定义了一个 Call 接口： 123456789101112131415161718">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-25T13:49:58.000Z">
<meta property="article:modified_time" content="2023-03-10T14:04:25.786Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="retrofit">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Retrofit-执行中的秘密 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Retrofit-执行中的秘密
        
      </h1>

      <time class="post-time">
          1月 25 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>正如前文 <a href="b80024b2">动态代理中的秘密</a> 所讲的，我们创建好了 HttpServiceMethod 实例，接下来就应该执行它的 invoke() 方法来将外部开发者传入的参数传入进去，完成内部逻辑的执行了。但在讲这些之前，我想先介绍下 Retrofit 中的一些类和概念，以方便后续逻辑的分析。</p>
<h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p>在 Retrofit 中也定义了一个 Call 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Call</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Response&lt;T&gt; <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isExecuted</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCanceled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    retrofit2.Call&lt;T&gt; <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Request <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Timeout <span class="title function_">timeout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么这个接口看着这么熟悉呢？没错，在 OkHttp 中也有一个类似的同名接口，这俩接口的类名一样，再看其内部定义的方法，也不能说是一模一样，但可以说是基本相同了。建议你可以先去看看  <a href="898ecc0a.html">OkHttp 请求创建</a> 来熟悉下 OkHttp 。</p>
<p>Retrofit 中的这个 Call 有什么用呢？我们在使用 OkHttp 时，会使用创建出来的 OkHttpClient 实例，来调用其 newCall() 方法，拿到一个 okhttp3.Call 实例，然后再调用它的 execute() 方法或者 enqueue() 方法来完成后续的网络请求逻辑。而前面 <a href="b80024b2">动态代理中的秘密</a>  中讲到 Retrofit 简单使用方法时，会在调用 github.contributors() 方法之后拿到的也是一个 Call 实例，接着就可以调用其 execute() 方法来拿到最终的结果了，这两者是不是有些相似呢？这种方式也可以降低对一个新的库的学习成本，比如你要是熟悉 OkHttp 的话，那么使用 Retrofit 就可以按照 OkHttp 的方式来用了。更何况这俩库还是同一家公司的。</p>
<p>其实这个 Call 和 OkHttp 中的 Call 还有一些其他的联系，现在还看不大出来，接着往后看就明白了。</p>
<blockquote>
<p>后续使用 Call 的话就代表是 Retrofit 中的 Call ，使用 okhttp3.Call 的话那自然就是 okhttp 中的那个了</p>
</blockquote>
<p>接下来来看这个接口的两个实现类：</p>
<h4 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OkHttpCall.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OkHttpCall</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Call</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 以下这四个参数是 final 的，会在构造方法中被赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestFactory requestFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前 Call 是否被取消了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对应一个 okhttp3 中的 Call 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span></span><br><span class="line">    okhttp3.Call rawCall;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建上面 rawCall 时如果遇到异常，则当前属性会保存起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span></span><br><span class="line">    Throwable creationFailure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 Call 实例是否已经被执行过了，用来防止重复执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> executed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将入参保存起来</span></span><br><span class="line">    OkHttpCall(</span><br><span class="line">            RequestFactory requestFactory,</span><br><span class="line">            Object[] args,</span><br><span class="line">            okhttp3.Call.Factory callFactory,</span><br><span class="line">            Converter&lt;ResponseBody, T&gt; responseConverter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.requestFactory = requestFactory;</span><br><span class="line">        <span class="built_in">this</span>.args = args;</span><br><span class="line">        <span class="built_in">this</span>.callFactory = callFactory;</span><br><span class="line">        <span class="built_in">this</span>.responseConverter = responseConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OkHttpCall 是 Call 最主要的一个子类。同时它内部还定义了一些属性，看这些属性就越看越像是 OkHttp 中的 RealCall 中的属性，比如 executed 都是用来避免重复调用；而 canceled 这里是作为 Call 中的属性，在 RealCall 中则是存在其内部的 Transmitter 实例中的，都代表着当前 Call 是否已被调用过取消方法。</p>
<p>其他属性这里先不讲，等到后面遇到时再做分析。下面来看看 OkHttpCall 中比较重要的几个方法：</p>
<h5 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OkHttpCall.java</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response&lt;T&gt; <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 避免重复调用，使用 executed 来标识</span></span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already executed.&quot;</span>);</span><br><span class="line">        executed = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取或者创建一个 okhttp3.Call</span></span><br><span class="line">        call = getRawCall();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑并发情况，检查是否此时就已经取消了</span></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 call.execute() 拿到返回的 okhttp3.Response </span></span><br><span class="line">    <span class="comment">// 接着调用 parseResponse()方法来解析这个 okhttp3.Response</span></span><br><span class="line">    <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> okhttp3.Call <span class="title function_">getRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    okhttp3.<span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> rawCall;</span><br><span class="line">    <span class="comment">// 如果该 call 之前已经创建过了，那么就直接使用</span></span><br><span class="line">    <span class="keyword">if</span> (call != <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 rawCall 是 null，此时在正式创建之前先检查下之前创建过吗？之前创建时是不是遇到异常了？</span></span><br><span class="line">    <span class="comment">// 如果之前尝试创建过但是出现异常了，那么此时直接抛出之前的异常，不去重试了</span></span><br><span class="line">    <span class="keyword">if</span> (creationFailure != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) creationFailure;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 okhttp call</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">rawCall</span> <span class="operator">=</span> createRawCall();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error | IOException e) &#123;</span><br><span class="line">        throwIfFatal(e); <span class="comment">// Do not assign a fatal error to creationFailure.</span></span><br><span class="line">        creationFailure = e;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> okhttp3.Call <span class="title function_">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 使用 callFactory 来创建 okhttp3.Call 实例</span></span><br><span class="line">    <span class="comment">// 使用 requestFactory 结合用户传入的实际参数值来构建 okhttp3.Request</span></span><br><span class="line">    okhttp3.<span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> callFactory.newCall(requestFactory.create(args));</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Call.Factory returned null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 execute() 方法中，会先拿到其内部的 okhttp3.Call 实例，当然如果它是空的，则会去创建一个。在创建时，先使用 requestFactory 实例结合用户传入的实际参数值来构建 okhttp3.Request 实例，然后再通过 callFactory 来创建 okhttp3.Call 实例 。</p>
<p>这里的 requestFactory 和 callFactory  都是构造方法中传入进来的，前者在之前 <a href="b80024b2">动态代理中的秘密</a> 中讲过，它内部存储着从方法头、方法参数上的注释中解析来的数据，比如 url，get 还是 post 等，此时结合外部用户传来的实际参数值就可以来构建okhttp3.Request 实例了，下面看看代码是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestFactory.java</span></span><br><span class="line"></span><br><span class="line">okhttp3.Request <span class="title function_">create</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到内部之前从方法参数中解析来的 ParameterHandler 列表</span></span><br><span class="line">    ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 然后和外部传入的实际参数值做比对，是不是长度一样的</span></span><br><span class="line">    <span class="comment">// 不一样的话则抛出异常。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">argumentCount</span> <span class="operator">=</span> args.length;</span><br><span class="line">    <span class="keyword">if</span> (argumentCount != handlers.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;Argument count (&quot;</span></span><br><span class="line">                        + argumentCount</span><br><span class="line">                        + <span class="string">&quot;) doesn&#x27;t match expected count (&quot;</span></span><br><span class="line">                        + handlers.length</span><br><span class="line">                        + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始构建 RequestBuilder ，使用它来创建okhttp3.Request 实例</span></span><br><span class="line">    <span class="type">RequestBuilder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestBuilder</span>(</span><br><span class="line">                    httpMethod,</span><br><span class="line">                    baseUrl,</span><br><span class="line">                    relativeUrl,</span><br><span class="line">                    headers,</span><br><span class="line">                    contentType,</span><br><span class="line">                    hasBody,</span><br><span class="line">                    isFormEncoded,</span><br><span class="line">                    isMultipart);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断当前是不是协程挂起方法，是的话则最后一位参数 Continuation 不用管，它归 kotlin 编译器来处理</span></span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">        argumentCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    List&lt;Object&gt; argumentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(argumentCount);</span><br><span class="line">    <span class="comment">// 开始遍历 handlers 列表，注意此时如果是挂起方法则最后一位不处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; argumentCount; p++) &#123;</span><br><span class="line">        argumentList.add(args[p]);</span><br><span class="line">        handlers[p].apply(requestBuilder, args[p]); <span class="comment">// 挨个的将真正的参数 args[p]放置进去，其实就是替换里面的 &#123;key&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建出最终的  okhttp3.Request 实例</span></span><br><span class="line">    <span class="keyword">return</span> requestBuilder.get().tag(Invocation.class, <span class="keyword">new</span> <span class="title class_">Invocation</span>(method, argumentList)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里有针对协程挂起方法做了单独处理，即最后一位参数不用管。如果不理解的话可以看看：<a href="4ee2033c.html">这篇文章中的 Coroutine部分</a> 。</p>
<p>而另外一个 callFactory  它一般就是 OkHttpClient 实例，当然你可以自定义，即在 Retrofit.Builder 的 client() 方法来定制你自己的 callFactory 实例。</p>
<p>回到 execute() 方法中接着往下看，拿到 okhttp3.Call 实例之后，会先调用其 execute() 方法来发起HTTP请求拿到返回的 okhttp3.Response ，然后调用 parseResponse() 方法来将其解析成最终的类型的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OkHttpCall.java</span></span><br><span class="line"></span><br><span class="line">Response&lt;T&gt; <span class="title function_">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ResponseBody</span> <span class="variable">rawBody</span> <span class="operator">=</span> rawResponse.body();</span><br><span class="line"></span><br><span class="line">    rawResponse =</span><br><span class="line">            rawResponse</span><br><span class="line">                    .newBuilder()</span><br><span class="line">                    .body(<span class="keyword">new</span> <span class="title class_">OkHttpCall</span>.NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">                    .build();</span><br><span class="line">    <span class="comment">// 判断 HTTP 返回的结果中的响应码看它是否是成功的</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> rawResponse.code();</span><br><span class="line">    <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123; <span class="comment">// 判断响应码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ResponseBody</span> <span class="variable">bufferedBody</span> <span class="operator">=</span> Utils.buffer(rawBody);</span><br><span class="line">            <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rawBody.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">        rawBody.close();</span><br><span class="line">        <span class="keyword">return</span> Response.success(<span class="literal">null</span>, rawResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行到这里表示他是成功的请求结果，那么接下来开始类型转换</span></span><br><span class="line">    <span class="comment">// 使用 responseConverter 来将返回结果转换为最终所需要的类型</span></span><br><span class="line">    <span class="type">ExceptionCatchingResponseBody</span> <span class="variable">catchingBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionCatchingResponseBody</span>(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">body</span> <span class="operator">=</span> responseConverter.convert(catchingBody); <span class="comment">// 使用 Converter来将http返回的response解析成为最终需要的值</span></span><br><span class="line">        <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        catchingBody.throwIfCaught();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在解析结果时，是使用外部传入的 Converter 来完成解析和类型转换的。至于这个 Converter 的分析后面再讲。</p>
<p>这就是 Call 中 execute() 方法的执行流程分析了，小结一下就是：Call 中 execute() 方法中会使用内部被代理的 okhttp3.Call 实例来完成HTTP请求，拿到返回结果之后调用其内部的  Converter 来完成解析和类型转换，最后返回解析之后的结果。</p>
<h5 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OkHttpCall.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> &#123;</span><br><span class="line">    <span class="comment">// 入参 Callback 不能为空</span></span><br><span class="line">    Objects.requireNonNull(callback, <span class="string">&quot;callback == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 还是先判断 executed 避免重复调用</span></span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already executed.&quot;</span>);</span><br><span class="line">        executed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        call = rawCall;</span><br><span class="line">        failure = creationFailure;</span><br><span class="line">        <span class="comment">// 如果其内部的 okhttp3.Call 为空，则创建一个新的</span></span><br><span class="line">        <span class="keyword">if</span> (call == <span class="literal">null</span> &amp;&amp; failure == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                call = rawCall = createRawCall();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                throwIfFatal(t);</span><br><span class="line">                failure = creationFailure = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 okhttp3.Call 失败的话，则回调异常</span></span><br><span class="line">    <span class="keyword">if</span> (failure != <span class="literal">null</span>) &#123;</span><br><span class="line">        callback.onFailure(<span class="built_in">this</span>, failure);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是再检查下是否当前已被取消</span></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">        call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 okhttp3.Call 的 enqueue 方法来进行异步请求</span></span><br><span class="line">    call.enqueue(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">okhttp3</span>.Callback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> &#123;</span><br><span class="line">                    Response&lt;T&gt; response;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 在最终拿到返回结果之后，调用 parseResponse 方法来解析成对应类型的结果</span></span><br><span class="line">                        response = parseResponse(rawResponse);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        throwIfFatal(e);</span><br><span class="line">                        callFailure(e);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 然后再把最终的结果回调出去</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        callback.onResponse(<span class="built_in">this</span>, response);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        throwIfFatal(t);</span><br><span class="line">                        t.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> &#123;</span><br><span class="line">                    callFailure(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callFailure</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        callback.onFailure(<span class="built_in">this</span>, e);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        throwIfFatal(t);</span><br><span class="line">                        t.printStackTrace(); <span class="comment">// TODO this is not great</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你懂了前面的 execute() 方法的话，那么这里的 enqueue() 方法就很好理解了。简单来说就是 Call 的 enqueue() 方法中会使用其内部被代理的 okhttp3.Call 实例来完成HTTP请求，拿到返回结果之后调用其内部的  Converter 来完成解析和类型转换，最后返回解析之后的结果。</p>
<p>所以说，这里的 OkHttpCall 可以说是 RealCall 的增强版，如果把 Call 和 okhttp3.Call  看做同一个接口的话，是不是就可以把 OkHttpCall  看做是 RealCall 的代理类了呀？</p>
<p>####ExecutorCallbackCall </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultCallAdapterFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ExecutorCallbackCall</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Call</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后续 callback 在该线程池中去执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际逻辑实现的Call ，一般就是 OkHttpCall  实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查</span></span><br><span class="line">        Objects.requireNonNull(callback, <span class="string">&quot;callback == null&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用被代理的 Call 来执行真正的操作，等待成功后切换到指定的线程池中去执行callback逻辑</span></span><br><span class="line">        delegate.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 使用 callback来 执行对应的回调</span></span><br><span class="line"><span class="comment">                 * 在Android平台中这是 MainThreadExecutor 会切换到主线程去执行</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                callbackExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                        <span class="comment">// Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on</span></span><br><span class="line">                        <span class="comment">// cancellation.</span></span><br><span class="line">                        callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        callback.onResponse(ExecutorCallbackCall.<span class="built_in">this</span>, response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> &#123;</span><br><span class="line">                callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExecuted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.isExecuted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;T&gt; <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他的方法，都是使用 delegate 去完成的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 Call 的实现类 ExecutorCallbackCall，只是给 DefaultCallAdapterFactory 来使用的，而这里为了后面分析时流程顺畅，所以放在这里一起讲了。</p>
<p>在 DefaultCallAdapterFactory  中接受两个参数，一个是 Executor 实例，用于指定其 enqueue() 方法中的 callbakc 最后在哪个线程中来执行的，这种就很适合Android开发人员了，因为在 Android 中要求对于 UI 的更新要在主线程中完成，而 OkHttp 异步请求的 callback 是在其内部的线程池中执行的，非主线程。而这里就可以通过指定 Executor  来使得最终回调在主线程中执行。</p>
<p>而这个 Executor 怎么设置呢？还是在 Retrofit.Builder 中，不过这次是通过 callbackExecutor() 方法来设置的，不过如果你没设置，Retrofit 也会判断你当前系统如果是Android的话则会自动为你添加一个 MainThreadExecutor ，在 MainThreadExecutor 中会使用主线程 Handler.post 来保证回调在主线程中去执行的。</p>
<p>而 ExecutorCallbackCall 中还有一个参数 delegate ，它一般就是 OkHttpCall 实例，往后接着看你就能知道为什么了。</p>
<h3 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h3><p>先看看该接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CallAdapter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CallAdapter</span>&lt;R, T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口方法最终需要的类型</span></span><br><span class="line"><span class="comment">     * 例如 方法的返回类型(returnType)为 Call&lt;User&gt; ，那么 responseType  为 User</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Type <span class="title function_">responseType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前入参 call 来转换为 T 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">adapt</span><span class="params">(Call&lt;R&gt; call)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工厂接口，用来创建 CallAdapter 实例</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据入参来判断当前 Factory 是否能处理，能处理的话则返回一个 CallAdapter 实例，否则返回null</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> returnType  方法的返回值类型</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> annotations 方法头上的注解</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> Type <span class="title function_">getParameterUpperBound</span><span class="params">(<span class="type">int</span> index, ParameterizedType type)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">            <span class="keyword">return</span> Utils.getRawType(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CallAdapter 接口中，就定义了俩方法，这俩方法都是用来干什么的现在先不讲，后面用其子类来讲。</p>
<p>在 CallAdapter 接口中额外还定义了对应的工厂接口，用于创建 CallAdapter 实例，所以后续讲 CallAdapter  子类时，会顺带着将其工厂接口的子类一起讲了。</p>
<p>对于 CallAdapter  来说，其子类比较多，但是这里只讲一个最常用的 ，也就是 DefaultCallAdapterFactory 中的实现。</p>
<h4 id="DefaultCallAdapterFactory"><a href="#DefaultCallAdapterFactory" class="headerlink" title="DefaultCallAdapterFactory"></a>DefaultCallAdapterFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultCallAdapterFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title class_">CallAdapter</span>.Factory &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callbackExecutor 默认情况下：</span></span><br><span class="line"><span class="comment">     *                         java项目中是null</span></span><br><span class="line"><span class="comment">     *                         android项目中是：&#123;<span class="doctag">@link</span> retrofit2.Platform.Android.MainThreadExecutor&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DefaultCallAdapterFactory(<span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span></span><br><span class="line">    CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 只处理返回类型时 Call 的方法</span></span><br><span class="line">        <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值类型必须是带泛型的,因为泛型的类型就是最终要返回的类型</span></span><br><span class="line">        <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到泛型类型</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否还使用了 <span class="doctag">@SkipCallbackExecutor</span> 注解，是的话则会忽略外部设置的 callbackExecutor</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">                Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class) ? <span class="literal">null</span> : callbackExecutor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个匿名 CallAdapter 子类实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CallAdapter</span>&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Type <span class="title function_">responseType</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> responseType;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Call&lt;Object&gt; <span class="title function_">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果指定了 callbackExecutor 的话，则将入参 call 包装成 ExecutorCallbackCall 返回出去</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> executor == <span class="literal">null</span> ? call : <span class="keyword">new</span> <span class="title class_">ExecutorCallbackCall</span>&lt;&gt;(executor, call);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 ExecutorCallbackCall 的定义</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 DefaultCallAdapterFactory 构造方法中会接受一个 Executor 实例，它就是在前面 ExecutorCallbackCall 中讲到的那个 Executor ，这里就不赘述了。</p>
<p>接着在其 get() 方法中，会判断当前要处理的方法的返回值是不是 Call 类型的，不是的话则直接返回 null 表示自己不能处理这种方法。</p>
<p>然后接着取出返回值 Call 中的泛型类型，作为最终的返回值类型，也就是后续在 CallAdapter 子类的 responseType()方法要返回的值，比如外部定义的返回值类型是：Call&lt;List<User>&gt; ，那么这里拿到的返回值类型就是 List<User> 。当然如果返回值 Call 没有指定泛型，就会抛出异常。</p>
<p>最后会返回一个 CallAdapter 的子类，实现其方法，responseType()方法刚讲过了，这里看看 adapt() 方法的实现，它内部会根据外部传入的 Executor 是否为空，不为空则会将 入参 call 包装成 ExecutorCallbackCall 实例返回给外部的开发者，后续外部开发者拿到这个 ExecutorCallbackCall 实例之后，调用其 enqueue() 方法时，接收到的回调就会在指定的线程内执行了。</p>
<p>对 CallAdapter  子类的分析我觉得这一个就够了，足以让你要明白 responseType() 方法和 adapt() 方法是干嘛的了，你知道了他俩是干嘛的，还能看不懂其他的 CallAdapter 子类？还能不会自己自定义 CallAdapter ？（鲁豫式）不会吧不会吧…. 哈哈哈开玩笑的O(∩_∩)O，其实就是单纯的我懒得写了 ￣□￣｜｜</p>
<h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Converter.java</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;F, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Converter 泛型中的 F 类型的值转换为 T 类型的结果返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">convert</span><span class="params">(F value)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Converter 的工厂类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回一个将 OkHttp 的 Response Body 转换为 Type 类型的 Convert</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="meta">@Nullable</span></span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">                Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回一个将 Type 类型的实例转换为 OkHttp Request Body 的Convert</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="meta">@Nullable</span></span><br><span class="line">        Converter&lt;?, RequestBody&gt; requestBodyConverter(</span><br><span class="line">                Type type,</span><br><span class="line">                Annotation[] parameterAnnotations,</span><br><span class="line">                Annotation[] methodAnnotations,</span><br><span class="line">                Retrofit retrofit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于对 Field、FieldMap、Header、Path、Query、QueryMap 等注解的处理</span></span><br><span class="line"><span class="comment">         * 将其转换为对应的 string</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="meta">@Nullable</span></span><br><span class="line">        Converter&lt;?, String&gt; stringConverter(</span><br><span class="line">                Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> Type <span class="title function_">getParameterUpperBound</span><span class="params">(<span class="type">int</span> index, ParameterizedType type)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">            <span class="keyword">return</span> Utils.getRawType(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Converter 其实在前面 OkHttpCall 中遇到过了，当时是使用它来将 OkHttp 的返回结果转换为对应类型的实例的，当然他的作用也就是这。</p>
<p>下面介绍下它的一个常用的子类 GsonConverterFactory ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GsonConverterFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GsonConverterFactory</span> <span class="keyword">extends</span> <span class="title class_">Converter</span>.Factory &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> retrofit2.converter.gson.GsonConverterFactory <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> create(<span class="keyword">new</span> <span class="title class_">Gson</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;ConstantConditions&quot;)</span> <span class="comment">// Guarding public API nullability.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> retrofit2.converter.gson.GsonConverterFactory <span class="title function_">create</span><span class="params">(Gson gson)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (gson == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;gson == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个 GsonConverterFactory 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">retrofit2</span>.converter.gson.GsonConverterFactory(gson);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GsonConverterFactory</span><span class="params">(Gson gson)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gson = gson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">            Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        <span class="comment">// 使用最终需要的类型来创建一个 TypeAdapter</span></span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        <span class="comment">// 然后返回 GsonResponseBodyConverter 实例，内部会使用它来完成解析和填充</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GsonResponseBodyConverter</span>&lt;&gt;(gson, adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(</span><br><span class="line">            Type type,</span><br><span class="line">            Annotation[] parameterAnnotations,</span><br><span class="line">            Annotation[] methodAnnotations,</span><br><span class="line">            Retrofit retrofit) &#123;</span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GsonRequestBodyConverter</span>&lt;&gt;(gson, adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// GsonResponseBodyConverter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GsonResponseBodyConverter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;ResponseBody, T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeAdapter&lt;T&gt; adapter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到 Gson 实例，以及最终所需要的类型</span></span><br><span class="line">    GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.gson = gson;</span><br><span class="line">        <span class="built_in">this</span>.adapter = adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用 gson 来完成解析并返回</span></span><br><span class="line">        <span class="type">JsonReader</span> <span class="variable">jsonReader</span> <span class="operator">=</span> gson.newJsonReader(value.charStream());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> adapter.read(jsonReader);</span><br><span class="line">            <span class="keyword">if</span> (jsonReader.peek() != JsonToken.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JsonIOException</span>(<span class="string">&quot;JSON document was not fully consumed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            value.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 GsonConverterFactory 中的 GsonResponseBodyConverter 主要是借助 <a target="_blank" rel="noopener" href="https://github.com/google/gson">gson</a> 开源库来完成的类型转换。所以建议可以先去熟悉下 gson 的使用再来看这里的代码会更好理解些。</p>
<h3 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h3><p>好了，回到正题，即接着前面 <a href="b80024b2">动态代理中的秘密</a> 中讲到的，通过 loadServiceMethod() 方法拿到最终创建出来的 ServiceMethod 实例，更准确来说是 HttpServiceMethod 实例，更更准确来说是 HttpServiceMethod  的子类实例。接着就会去调用其 invoke() 方法，来将开发者设置的实际参数值传入进去。</p>
<p>而 ServiceMethod 中的 invoke() 方法实际是在其子类 HttpServiceMethod   中实现了的，所以我们直接看它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServiceMethod.java</span></span><br><span class="line"></span><br><span class="line">ReturnT <span class="title function_">invoke</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用入参 args 以及之前创建并初始化好的 requestFactory ，responseConverter等实例来创建 OkHttpCall 实例</span></span><br><span class="line">    Call&lt;ResponseT&gt; call = <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="comment">// 接着调用其自身的 adapt() 方法</span></span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span></span><br><span class="line"> ReturnT <span class="title function_">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span>;</span><br></pre></td></tr></table></figure>

<p> 首先就是创建一个 OkHttpCall 实例，接着会调用其内部的抽象方法，也就是调用其它的子类中去，而正如前面  <a href="b80024b2">动态代理中的秘密</a> 中最后讲到的，最终创建的 HttpServiceMethod   子类实例一共有三个：</p>
<ol>
<li><p>如果当前不是挂起方法时，此时会将 callFactory 、callAdapter 以及 Converter  实例保存到 CallAdapted 实例中返回。</p>
</li>
<li><p>如果当前是挂起方法并且拿到了其返回值时，此时会将 callFactory 、callAdapter 以及 Converter  实例保存到 SuspendForResponse 实例中返回。</p>
</li>
<li><p>如果当前是挂起方法但没有拿到其返回值时，此时会将 callFactory 、callAdapter 以及 Converter  实例保存到 SuspendForBody  实例中返回。</p>
</li>
</ol>
<p>也就是 CallAdapted 、SuspendForResponse 和 SuspendForBody   三个子类实例，我们这里着重分析前两个最常用的情况。</p>
<h4 id="CallAdapted"><a href="#CallAdapted" class="headerlink" title="CallAdapted"></a>CallAdapted</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServiceMethod.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CallAdapted</span>&lt;ResponseT, ReturnT&gt; <span class="keyword">extends</span> <span class="title class_">HttpServiceMethod</span>&lt;ResponseT, ReturnT&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存之前查找到的 CallAdapter 实例</span></span><br><span class="line">    CallAdapted(</span><br><span class="line">            RequestFactory requestFactory,</span><br><span class="line">            okhttp3.Call.Factory callFactory,</span><br><span class="line">            Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">            CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;</span><br><span class="line">        <span class="built_in">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">        <span class="built_in">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ReturnT <span class="title function_">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实际交给其 callAdapter 的 adapt 方法来处理</span></span><br><span class="line">        <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况是当前不是挂起方法时，此时会将 callFactory 、callAdapter 以及 Converter  实例保存到 CallAdapted 实例中的，我们假设这里的 callAdapter 是前面讲到的 DefaultCallAdapterFactory 中创建并返回的那个 CallAdapter  实例，那么这里会将入参 call ，也就是 OkHttpCall 实例传入进去，内部会将其包装到 ExecutorCallbackCall 中再返回出来（这里是默认假设 executor 不为空了）。然后外部开发者拿到这个 ExecutorCallbackCall 实例，再去调用其execute() 方法或者 enqueue() 方法了。</p>
<p>我们假设外部开发者调用的是enqueue() 方法，此时会先调用到 ExecutorCallbackCall 中的 enqueue() 方法内，内部会调用 OkHttpCall 的 enqueue() 方法来执行，进而会去调用其内部的 okhttp3.Call 的 enqueue() 方法来完成异步HTTP请求，最终拿到结果后，会在 OkHttpCall 中调用 parseResponse() 方法来使用对应的 Converter 来将结果转化为最终的实例类型，然后回调到 ExecutorCallbackCall 中，此时他会切换到线程池中执行回调，最终在指定的线程中回调通知给外部开发者，此时外部开发者就拿到了最终的结果。</p>
<h4 id="SuspendForResponse"><a href="#SuspendForResponse" class="headerlink" title="SuspendForResponse"></a>SuspendForResponse</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServiceMethod.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuspendForResponse</span>&lt;ResponseT&gt; <span class="keyword">extends</span> <span class="title class_">HttpServiceMethod</span>&lt;ResponseT, Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">    SuspendForResponse(</span><br><span class="line">            RequestFactory requestFactory,</span><br><span class="line">            okhttp3.Call.Factory callFactory,</span><br><span class="line">            Converter&lt;ResponseBody, ResponseT&gt; responseConverter,</span><br><span class="line">            CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt; callAdapter) &#123;</span><br><span class="line">        <span class="built_in">super</span>(requestFactory, callFactory, responseConverter);</span><br><span class="line">        <span class="built_in">this</span>.callAdapter = callAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先使用 callAdapter 拿到最终包装适配之后的 call</span></span><br><span class="line">        call = callAdapter.adapt(call);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拿到当前方法的最终一位参数，也就是 Continuation ，因为当前是挂起方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Continuation&lt;Response&lt;ResponseT&gt;&gt; continuation =</span><br><span class="line">                (Continuation&lt;Response&lt;ResponseT&gt;&gt;) args[args.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将最终的 call 和 Continuation 实例传入进去来完成 enqueue ，以及协程挂起恢复</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> KotlinExtensions.awaitResponse(call, continuation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> KotlinExtensions.suspendAndThrow(e, continuation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 SuspendForResponse 中，我们同样假设其内部的 callAdapter 是前面讲到的 DefaultCallAdapterFactory 中创建并返回的那个 CallAdapter  实例。</p>
<p>额外补充一点，在前面  <a href="b80024b2">动态代理中的秘密</a>  中讲到 HttpServiceMethod 的 parseAnnotations() 方法时，会判断如果是挂起方法的话，则会给对应的  annotations 赋值为 SkipCallbackExecutorImpl.ensurePresent(annotations) ，该方法内部会往原注解中插入一个 @SkipCallbackExecutor 注解，而等到后面 DefaultCallAdapterFactory  中处理 executor 时，会判断如果有这个注解就会忽略外部设置的 callbackExecutor ，从而在最终 adapt() 方法中由于 executor &#x3D;&#x3D; null ，所以不会返回 ExecutorCallbackCall 实例，即不需要线程切换。</p>
<p>因为协程挂起方法，不需要做线程切换工作，开发者可以通过 withContext() 等方法来指定线程。</p>
<p>所以这里 callAdapter.adapt() 方法会将入参原封不动的返回出来，接着会拿到入参中的最后一位，它肯定是 Continuation 类型的实例，因为当前方法是挂起方法，而外部开发者对这个 Continuation 是无感的，这个只有在“协程世界”才会存在。</p>
<p>最后会调用 KotlinExtensions.awaitResponse() 方法来完成 Java世界和 协程世界的切换，下面来看看该方法是怎么实现的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KotlinExtensions.kt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里定义的是 Call.XXXx</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Call<span class="type">&lt;T&gt;</span>.<span class="title">awaitResponse</span><span class="params">()</span></span>: Response&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// 拿到当前协程执行的上下文</span></span><br><span class="line">  <span class="keyword">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">    <span class="comment">// 切换到协程世界中，给当前协程注册一个取消的监听</span></span><br><span class="line">    <span class="comment">// 如果它后续被取消了，则同步调用 call.cancel()</span></span><br><span class="line">    continuation.invokeOnCancellation &#123;</span><br><span class="line">      cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用 call.enqueue 方法来执行异步请求</span></span><br><span class="line">    enqueue(<span class="keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, response: <span class="type">Response</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在最终拿到结果时调用 continuation.resume() 来恢复挂起方法的执行</span></span><br><span class="line">        continuation.resume(response)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>&lt;<span class="type">T</span>&gt;, t: <span class="type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        continuation.resumeWithException(t)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里定义的 awaitResponse() 方法前面是 Call. 。所以前面调用该方法是需要第一个参数中传入 call 实例。接着回在内部执行 call 的 enqueue() 方法来进行异步请求不阻塞当前线程，因为当前是挂起方法，要和他的特性一致不能阻塞。也就是调用到 OkHttpCall 中的 euqueue() 方法中，进而会去调用其内部的 okhttp3.Call 的 enqueue() 方法来完成异步HTTP请求，最终拿到结果后，会在 OkHttpCall 中调用 parseResponse() 方法来使用对应的 Converter 来将结果转化为最终的实例类型，然后回调到这里来，这里再调用 continuation.resume() 方法恢复协程挂起方法的执行，并且将最终的结果返回给他，这样的话外部开发者那边调用的挂起方法就会执行完毕了，此时拿到了最终的返回的数据，而给外部开发者来看者就是一个同步的请求，但是其内部实际是异步的，也就是说：在普通的非协程的世界中看来是同步的请求，在协程世界中其实是异步的，是不是听着有点迷糊？你可以去看看这些文章： <a href="4ee2033c.html">这篇文章中的 Coroutine部分对应的文章</a> </p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/retrofit/">retrofit</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/64b5b134.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Kotlin协程 - 概述</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/b80024b2.html">
        <span class="next-text nav-default">Retrofit-动态代理中的秘密</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
