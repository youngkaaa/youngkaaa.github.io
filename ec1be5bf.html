<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Kotlin协程 - 基础概念介绍"/>




  <meta name="keywords" content="Kotlin Coroutine," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/ec1be5bf.html"/>


<meta name="description" content="正如前文所说，在kotlin中可以以同步的方式编写异步代码，这也是我认为的kotlin协程最大的优点。 下面先铺垫介绍一些Kotlin协程中的基础概念。 CoroutineContext协程上下文。Android开发人员的话对Context应该很了解了,可以用来获取资源，启动四大组件等，贯穿整个应用，可以说是无所不能了。而也正如上下文这个词一样，代表了上下文(这不废话么….)，可以在上下文进行传递">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin协程 - 基础概念介绍">
<meta property="og:url" content="https://youngkaaa.github.io/ec1be5bf.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="正如前文所说，在kotlin中可以以同步的方式编写异步代码，这也是我认为的kotlin协程最大的优点。 下面先铺垫介绍一些Kotlin协程中的基础概念。 CoroutineContext协程上下文。Android开发人员的话对Context应该很了解了,可以用来获取资源，启动四大组件等，贯穿整个应用，可以说是无所不能了。而也正如上下文这个词一样，代表了上下文(这不废话么….)，可以在上下文进行传递">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/ec1be5bf/pic_01.png">
<meta property="article:published_time" content="2022-05-05T06:48:56.000Z">
<meta property="article:modified_time" content="2022-11-02T13:20:32.926Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Kotlin Coroutine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/ec1be5bf/pic_01.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Kotlin协程 - 基础概念介绍 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Kotlin协程 - 基础概念介绍
        
      </h1>

      <time class="post-time">
          5月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>正如前文所说，在kotlin中可以以同步的方式编写异步代码，这也是我认为的kotlin协程最大的优点。</p>
<p>下面先铺垫介绍一些Kotlin协程中的基础概念。</p>
<h4 id="CoroutineContext"><a href="#CoroutineContext" class="headerlink" title="CoroutineContext"></a>CoroutineContext</h4><p>协程上下文。Android开发人员的话对Context应该很了解了,可以用来获取资源，启动四大组件等，贯穿整个应用，可以说是无所不能了。而也正如上下文这个词一样，代表了上下文(这不废话么….)，可以在上下文进行传递，里面存储着上下文相关信息。这里的CoroutineContext也是类似的，其定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineContext</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the element with the given [key] from this context or `null`.</span></span><br><span class="line"><span class="comment">     * 通过指定 key 来获取其对应的context，如果key不对的话则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E?</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Accumulates entries of this context starting with [initial] value and applying [operation]</span></span><br><span class="line"><span class="comment">     * from left to right to current accumulator value and each element of this context.</span></span><br><span class="line"><span class="comment">     * 迭代操作元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a context containing elements from this context and elements from  other [context].</span></span><br><span class="line"><span class="comment">     * The elements from this context with the same key as in the other one are dropped.</span></span><br><span class="line"><span class="comment">     * 将两个 context 合并起来。这里重载的是 + 操作符，比如 A + B ，此时如果 A B 中存在同一个Key的话，则B中的会覆盖掉A中的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext =</span><br><span class="line">        <span class="keyword">if</span> (context === EmptyCoroutineContext) <span class="keyword">this</span> <span class="keyword">else</span> <span class="comment">// fast path -- avoid lambda creation</span></span><br><span class="line">            context.fold(<span class="keyword">this</span>) &#123; acc, element -&gt;</span><br><span class="line">                <span class="keyword">val</span> removed = acc.minusKey(element.key)</span><br><span class="line">                <span class="keyword">if</span> (removed === EmptyCoroutineContext) element <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// make sure interceptor is always last in the context (and thus is fast to get when present)</span></span><br><span class="line">                    <span class="keyword">val</span> interceptor = removed[ContinuationInterceptor]</span><br><span class="line">                    <span class="keyword">if</span> (interceptor == <span class="literal">null</span>) CombinedContext(removed, element) <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">val</span> left = removed.minusKey(ContinuationInterceptor)</span><br><span class="line">                        <span class="keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="keyword">else</span></span><br><span class="line">                            CombinedContext(CombinedContext(left, element), interceptor)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a context containing elements from this context, but without an element with</span></span><br><span class="line"><span class="comment">     * the specified [key].</span></span><br><span class="line"><span class="comment">     * 删除key，如果要删除的key是当前context所对应的key则会返回 EmptyCoroutineContext ，否则返回this表示删除不成功</span></span><br><span class="line"><span class="comment">     * 所以这里的返回值表示的是删除之后的 context ，EmptyCoroutineContext 表示删除之后为空了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Key</span>&lt;<span class="type">E : Element</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> : <span class="type">CoroutineContext</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A key of this coroutine context element.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">val</span> key: Key&lt;*&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E? =</span><br><span class="line">            <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) <span class="keyword">this</span> <span class="keyword">as</span> E <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">fold</span><span class="params">(initial: <span class="type">R</span>, operation: (<span class="type">R</span>, <span class="type">Element</span>) -&gt; <span class="type">R</span>)</span></span>: R =</span><br><span class="line">            operation(initial, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext =</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.key == key) EmptyCoroutineContext <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到CoroutineContext是一个接口，它提供了get、fold、plus、minusKey方法，基本就像是把它当做集合来使用了，提供了增删查和迭代的操作。它有点类似Map或者Set，内部存储着若干个Element元素，支持通过指定的Key来完成查询，且同一个key只存在一个。</p>
<p>另外其内部还有两个接口：Key 和 Element ，而 Element又继承自CoroutineContext，以此类推，CoroutineContext中的元素都实现了CoroutineContext.Element接口，而键类型都实现了CoroutineContext.Key接口，且每种键类型只存在一个元素，所以更像是一种Set数据集。</p>
<p>常见的可以放置进去的Element元素有：Dispatchers.Default 、CoroutineId、Job 等，一次传入多个时可以使用重载符号 + 来实现。所以只要遇到CoroutineContext入参的，这些都可以传入。</p>
<p>CoroutineContext的一个实现是是 Element，里面实现了 fold 、minusKey、get 这三个方法。另外它的一个最主要的实现是 CombinedContext，里面可以包括多个 CoroutineContext。</p>
<p>下面分析下CoroutineContext中的plus方法：</p>
<blockquote>
<p>CoroutineContext.plus</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext =</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比如 A + B（下面注释都以这个为例） ,此时入参 context = B ，this = A</span></span><br><span class="line"><span class="comment">         * 这里的判断意思就是当 A + EmptyCoroutineContext 时，直接返回this=A 即可</span></span><br><span class="line"><span class="comment">         * 否则则会调用 context.fold</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (context === EmptyCoroutineContext) <span class="keyword">this</span> <span class="keyword">else</span> <span class="comment">// fast path -- avoid lambda creation</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里 context.fold 就类似于 B.fold(A)，将 A 作为遍历迭代初始值传入进去</span></span><br><span class="line"><span class="comment">         * 那么此时 acc = A ，element = B （详见 Element.fold 方法）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            context.fold(<span class="keyword">this</span>) &#123; acc, element -&gt;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 此时 acc = A ，element = B</span></span><br><span class="line"><span class="comment">                 * 先从 A 中减去 B 的 key 对应的元素，如果A 和 B key一样的话，则返回 EmptyCoroutineContext ，否则返回 A</span></span><br><span class="line"><span class="comment">                 * 比如 CoroutineName(&quot;first&quot;) + CoroutineName(&quot;second&quot;) 时，都是相同类型的 Element ，</span></span><br><span class="line"><span class="comment">                 * 其内部对应的key是同一个，此时minusKey之后返回的是 EmptyCoroutineContext</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 这一步是从 A 中剔除和 B 一样的 Key，即如果 A B 的key相同的话使用B的来覆盖A</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">val</span> removed = acc.minusKey(element.key)</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果 minusKey 之后是 EmptyCoroutineContext 则表示A B 的key重复了，直接返回B即可</span></span><br><span class="line"><span class="comment">                 * 比如 CoroutineName(&quot;first&quot;) + CoroutineName(&quot;second&quot;) 时直接在这里就返回结果CoroutineName(&quot;second&quot;)</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (removed === EmptyCoroutineContext) element <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// make sure interceptor is always last in the context (and thus is fast to get when present)</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 到这里表示 A B 不是同类型的context，即Key不相同。此时 removed = acc = A != EmptyCoroutineContext</span></span><br><span class="line"><span class="comment">                     * 这里是判断 A 内部是否包括 ContinuationInterceptor ，比如包括了 Dispatchers.Default 之类的</span></span><br><span class="line"><span class="comment">                     * 如果是的话则返回的 interceptor = removed = A ，不是的话 interceptor = null</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">val</span> interceptor = removed[ContinuationInterceptor]</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 如果 A 内部不包括 Interceptor 的话，则返回 CombinedContext(A,B) ,即将＋左右的context按顺序包装起来</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (interceptor == <span class="literal">null</span>) CombinedContext(removed, element) <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 如果 A 内部包括了 Interceptor 的话，则删除其内部的 Interceptor ，删除了 Interceptor 之后剩余的作为 left</span></span><br><span class="line"><span class="comment">                         * 分为两种情况：</span></span><br><span class="line"><span class="comment">                         * 1、删除了 Interceptor 之后是 EmptyCoroutineContext ，表示A(removed)就是一个 ContinuationInterceptor 的实现类对象</span></span><br><span class="line"><span class="comment">                         * -  也就是 removed = interceptor = A ，比如是一个 Dispatchers.Default。此时调用的 minusKey 就是 Element 中的实现</span></span><br><span class="line"><span class="comment">                         * -  此时直接返回了 CombinedContext(B, A=interceptor)</span></span><br><span class="line"><span class="comment">                         * 2、删除了 Interceptor 之后不是 EmptyCoroutineContext ，则表示A(removed)是一个 CombinedContext ，其内部包括了一个 Interceptor</span></span><br><span class="line"><span class="comment">                         * -  此时 left 表示删除了 Interceptor 之后剩余的 context ，此时调用的 minusKey 就是 CombinedContext 中的实现</span></span><br><span class="line"><span class="comment">                         * -  此时返回了 CombinedContext(CombinedContext(left, element),interceptor)</span></span><br><span class="line"><span class="comment">                         *</span></span><br><span class="line"><span class="comment">                         * 也就是说如果 A 是一个 Interceptor 或者它是一个 CombinedContext 但是内部包括了一个 Interceptor 的话，</span></span><br><span class="line"><span class="comment">                         * 则会返回一个 CombinedContext 实例，并且将interceptor实例其提到最外层CombinedContext 中返回出去</span></span><br><span class="line"><span class="comment">                         * 这样做的目的可能是为了后续在 get() 时，提升速度，因为 Interceptor 的很常用的key，要经常查询</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">val</span> left = removed.minusKey(ContinuationInterceptor)</span><br><span class="line">                        <span class="keyword">if</span> (left === EmptyCoroutineContext) CombinedContext(element, interceptor) <span class="keyword">else</span></span><br><span class="line">                            CombinedContext(CombinedContext(left, element), interceptor)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>代码中的注释已经很清晰了，总结下就是主要它分为两个部分：</p>
<p>1、返回的结果一般就是一个 CombinedContext ，它内部有两个属性 left 和 element ，可以理解为它内部可以包括两个 Context，可以理解为链表解构。</p>
<p>比如</p>
<ol>
<li>Job() + CoroutineName(“name”) 的话，则会返回CombinedContext[JobImpl{Active}@42d80b78, CoroutineName(name)]</li>
<li>CoroutineName(“first”) + Job() + CoroutineName(“second”) 时，返回的是 CombinedContext[JobImpl{Active}@1a968a59, CoroutineName(second)] ，second会把first 覆盖掉，因为他俩是同类型的。</li>
</ol>
<p>2、如果原context是(或者内部包括)Interceptor的话，则会将其从原context中提出来放在最外层，应该是为了优化读取速度。</p>
<p>比如：</p>
<p>Dispatchers.Default + CoroutineName(“first”) + Job()的话，返回的是 CombinedContext[CombinedContext[CoroutineName(first), JobImpl{Active}@6f1fba17] , Dispatchers.Default] 。即先将 CoroutineName 和 Job 封装成一个 CombinedContext，然后在将其和 Dispatchers.Default 封装成最终的 CombinedContext。</p>
<p>而 CoroutineContext 作为接口，以及继承自它的 Key 和 Element 接口，都存在多个实现类，比如管理协程生命周期的 Job 、处理协程线程调度的 ContinuationInterceptor、处理协程异常的CoroutineExceptionHandler、指定协程名的 CoroutineName 等等。这些后续都会有介绍到。</p>
<h4 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h4><p>代表的是协程域,它是一个接口，其定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoroutineScope</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of this scope.</span></span><br><span class="line"><span class="comment">     * Context is encapsulated by the scope and used for implementation of coroutine builders that are extensions on the scope.</span></span><br><span class="line"><span class="comment">     * Accessing this property in general code is not recommended for any purposes except accessing the [Job] instance for advanced usages.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * By convention, should contain an instance of a [job][Job] to enforce structured concurrency.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其内部只有一个变量：CoroutineContext coroutineContext，用来表示该协程域内的上下文，也就是说有协程域自己的上下文，也有协程的上下文。</p>
<p>在使用该协程域启动的协程，他们的上下文都会受到该协程域上下文的影响。比如你在 CoroutineScopeA 中（对应的上下文是 contextA）启动协程1时，假设通过launch启动协程1了，launch启动时传入的context为context1，那么最终启动的协程内部的上下文context就会是：contextA+context1 。即合并这俩context，如果有重复的则使用context1的来覆盖contextA的，即使用launch传入的context来覆盖协程域的context。</p>
<p>正是由于这个特性，定义一个协程域之后，假如为其指定了固定的Dispathcers的话，后续使用该协程域默认启动的协程都会在同一个Dispatchers线程中，这正是因为内部协程继承了协程域的上下文引起的。比如在Android中的viewModelScope和lifecycleScope，指定的是Dispatchers.Main，即主线程，那么后续使用他俩启动的协程默认都是运行在主线程内的，除非单独再指定别的Dispatchers。</p>
<p>而为什么要有协程域这个概念呢？我的理解是因为协程环境和线程环境还是有差异的，协程中的挂起方法其必须和线程环境中的普通方法隔离开，所以使用协程域来进行隔离，相当于在线程环境中为协程隔离出一片空间来运行。另外一个原因是可以使用协程域来管理零散的这些协程任务，比如启动时，默认就可以通过协程域context来指定好一些默认配置信息(如Dispatchers、CoroutineExceptionHandler等)；取消时，可以直接取消协程域，则其内部运行的所被他管理的协程都会被自动取消掉。有点类似进程和进程组的概念。</p>
<p>而CoroutineScope也是有一些默认实现的，比如全局唯一的GlobalScope,或者Android中特有的viewModelScope和lifecycleScope。或者你可以自己实现CoroutineScope来编写适合自己的协程域。</p>
<h4 id="suspend-fun"><a href="#suspend-fun" class="headerlink" title="suspend fun"></a>suspend fun</h4><p>挂起方法。定义挂起方式时，只需要在其定义前加上 suspend 关键字即可。挂起方法只可以在协程域内或者其他挂起方法中被调用，不能在普通方法内被调用，在它内部可以调用其他挂起方法以实现代码逻辑的挂起，而不阻塞当前线程的继续执行。</p>
<p>协程之所以可以以同步的方式编写异步代码(省去callback)，正是因为挂起方法的”非阻塞式挂起”。通俗来讲就是当执行一段挂起方法时，执行到某处之后该方法会被暂停执行从而挂起，释放当前线程让其去处理其他的任务，等待一段时间之后（比如其一个挂起方法结束了）再接着让该线程去执行剩余的逻辑。举个可能不恰当的例子，比如在Android中，执行一个方法到一半，然后往主线程postDelay一个Runnable，该Runnable内部包着剩余的代码逻辑，等一段时间之后，主线程接着执行该Runnable以完成剩余逻辑的执行。</p>
<p>所以我们可以感觉到这种挂起方法有点类似于传统意义上的异步。因为它没有阻塞当前线程，而是等一段时间时候再接着执行剩余的逻辑，这不就是异步Callback的效果嘛？但是为啥协程里面没有看到任何Callback的东西呢？其实是有的，不过是你编写协程代码时不可见而已，一切都是编译器帮开发者做好了而已，开发者需要按照同步的方式来写就行了，里面的异步结果回调等操作会自动生成，下面看一个例子：</p>
<p>定义这样一个挂起方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.coroutines.Continuation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">helloCoroutine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    delay(<span class="number">1000</span>)</span><br><span class="line">    println(<span class="string">&quot;hello coroutine&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其反编译之后（至于反编译的方法很多，可以是在IEDA中顶部Tools &gt; Kotlin &gt; Show Kotlin Bytecode 之后再点击其内部的 Decompile ，也可以通过jadx工具来看）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object helloCoroutine(<span class="meta">@NotNull</span> String str, <span class="meta">@NotNull</span> Continuation var2) &#123;</span><br><span class="line">   <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到反编译之后的结果会自动为挂起方法增加一个Continuation参数，而该Continuation类的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of the coroutine that corresponds to this continuation.</span></span><br><span class="line"><span class="comment">     * 协程上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the</span></span><br><span class="line"><span class="comment">     * return value of the last suspension point.</span></span><br><span class="line"><span class="comment">     * 用于协程启动及挂起的恢复，另外也可以作为协程运行完成的回调</span></span><br><span class="line"><span class="comment">     * 协程体的运行，其实就是执行当前方法 -&gt; [BaseContinuationImpl]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它内部只提供了一个方法 resumeWith ，存在一个入参 Result 实例，该Result类内包装了一个Any value作为真正的结果，并且额外还有两个标识用来表示是成功还是失败，也就是说 resumeWith 方法可以替代常规Callback中的 onSuccess 和 onFailure 了。所以说这个入参 Continuation 就可以理解为传统意义上的 Callback。所以将其替换为 Callback 之后就是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object helloCoroutine(<span class="meta">@NotNull</span> String str, <span class="meta">@NotNull</span> Callback callback) &#123;   </span><br><span class="line">   <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换成这个样子是不是就很眼熟了？可以在该方法内部调用 callback 的onSuccess 或者 onFailure 来通知外部当前异步逻辑的执行结果。而上面的传入 Continuation 也是一样的，内部调用其 resumeWith 方法就行了，然后通过传入的 Result 来表示是否成功即可。</p>
<p>另外一点，自动添加的 Continuation 参数是添加到方法的末尾的，即作为最后一个参数的。而产生这个效果是因为我们增加的 suspend 关键字起了作用。这也正好解释了为什么不能在普通方法中调用 suspend 挂起方法了，因为它有一个 Continuation 入参，而普通方法不会自动传入它。这种转换方式有一个专有术语：CPS(Continuation-Passing-Style,续体传递风格)。</p>
<h4 id="Continuation"><a href="#Continuation" class="headerlink" title="Continuation"></a>Continuation</h4><p>正如上面所说，它担任的是协程内的一个回调角色。另外一个它是作为协程的基础接口，代表着协程还没执行完的代码，内部resumeWith()方法实现时，会包括着未执行完的代码。先再看看这个接口的内容：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Continuation.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Continuation</span>&lt;<span class="type">in T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The context of the coroutine that corresponds to this continuation.</span></span><br><span class="line"><span class="comment">     * 当前协程的CoroutineContext上下文对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the</span></span><br><span class="line"><span class="comment">     * return value of the last suspension point.</span></span><br><span class="line"><span class="comment">     * 用一个Result来恢复对应的协程的执行，而这个 Result 表示的是上一个挂起点的结果返回值</span></span><br><span class="line"><span class="comment">     * 下面还额外提供了 resume 和 resumeWithException 方法来快捷的设置result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为该接口额外的还提供了扩展方法,用于方便的回调其成功或者失败状态：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Continuation.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resume</span><span class="params">(value: <span class="type">T</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">    resumeWith(Result.success(value))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the</span></span><br><span class="line"><span class="comment"> * last suspension point.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="meta">@InlineOnly</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeWithException</span><span class="params">(exception: <span class="type">Throwable</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">    resumeWith(Result.failure(exception))</span><br></pre></td></tr></table></figure>

<p>所以 Continuation 主要是两个作用：</p>
<p>1、作为协程内的Callback 来使用，调用其 resumeWith 方法之后可以接着执行剩下的代码。</p>
<blockquote>
<p>这一点在上面 suspend fun 中 CPS 已经得到解释了</p>
</blockquote>
<p>2、作为协程的基类实现，后续创建的协程实例类都会继承自它，其 resumeWith 方法的实现中会包裹着待执行的后续代码逻辑</p>
<p>可以先看看 Continuation 的继承关系：</p>
<p><img src="/ec1be5bf/pic_01.png" alt="pic01"></p>
<p>自 Continuation 接口往后会有好几层的继承关系，挨个为：</p>
<h5 id="BaseContinuationImpl"><a href="#BaseContinuationImpl" class="headerlink" title="BaseContinuationImpl"></a>BaseContinuationImpl</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseContinuationImpl.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseContinuationImpl</span>(</span><br><span class="line">    <span class="comment">// This is `public val` so that it is private on JVM and cannot be modified by untrusted code, yet</span></span><br><span class="line">    <span class="comment">// it has a public getter (since even untrusted code is allowed to inspect its call stack).</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;</span><br><span class="line">    <span class="comment">// This implementation is final. This fact is used to unroll resumeWith recursion.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume</span></span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> param = result</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Invoke &quot;resume&quot; debug probe on every resumed continuation, so that a debugging library infrastructure</span></span><br><span class="line">            <span class="comment">// can precisely track what part of suspended callstack was already resumed</span></span><br><span class="line">            probeCoroutineResumed(current)</span><br><span class="line">            with(current) &#123;</span><br><span class="line">                <span class="keyword">val</span> completion = completion!! <span class="comment">// fail fast when trying to resume continuation without completion</span></span><br><span class="line">                <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                        <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                        Result.success(outcome)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                        Result.failure(exception)</span><br><span class="line">                    &#125;</span><br><span class="line">                releaseIntercepted() <span class="comment">// this state machine instance is terminating</span></span><br><span class="line">                <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                    <span class="comment">// unrolling recursion via loop</span></span><br><span class="line">                    current = completion</span><br><span class="line">                    param = outcome</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// top-level completion reached -- invoke and return</span></span><br><span class="line">                    completion.resumeWith(outcome)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">releaseIntercepted</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// does nothing here, overridden in ContinuationImpl</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(completion: <span class="type">Continuation</span>&lt;*&gt;)</span></span>: Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;create(Continuation) has not been overridden&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(value: <span class="type">Any</span>?, completion: <span class="type">Continuation</span>&lt;*&gt;)</span></span>: Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;create(Any?;Continuation) has not been overridden&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String =</span><br><span class="line">        <span class="string">&quot;Continuation at <span class="subst">$&#123;getStackTraceElement() ?: this::class.java.name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- CoroutineStackFrame implementation</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> callerFrame: CoroutineStackFrame?</span><br><span class="line">        <span class="keyword">get</span>() = completion <span class="keyword">as</span>? CoroutineStackFrame</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStackTraceElement</span><span class="params">()</span></span>: StackTraceElement? =</span><br><span class="line">        getStackTraceElementImpl()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类实现自 Continuation 接口，并做了如下操作：</p>
<p>1、实现了其 resumeWith 方法，并且将其标记为 final 不允许后续子类再次实现，同时暴露出 invokeSuspend() 抽象方法供子类实现。</p>
<blockquote>
<p>这里新增的 invokeSuspend 抽象方法也是在 resumeWith 方法中被调用的，而resumeWith 被标记为final不让后续再次实现。相当于就是将 resumeWith 的功能转移到了 invokeSuspend 中去，后续 kotlin 编译器会自动实现该方法并将待执行的逻辑代码编译到其中。后续调用 resumeWith 也就相当于调用了 invokeSuspend ，也就相当于执行了后续的剩余代码逻辑。</p>
</blockquote>
<p>2、增加了额外的 complete Continuation 属性</p>
<blockquote>
<p>该属性用来保存的后续创建的协程对象，比如在 launch 方法中创建的StandaloneCoroutine 等。后续源码分析时会看到它。</p>
</blockquote>
<p>3、增加了 create() 等方法</p>
<blockquote>
<p>后续在二次创建 SuspendLamabda 实例时会调用它。它基本都是交给编译期去实现的。</p>
</blockquote>
<p>所以 BaseContinuationImpl 这一层主要是实现了 resumeWith 方法并暴露出 invokeSuspend 方法供后续编译器填充实现。</p>
<h5 id="ContinuationImpl"><a href="#ContinuationImpl" class="headerlink" title="ContinuationImpl"></a>ContinuationImpl</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseContinuationImpl.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContinuationImpl</span>(</span><br><span class="line">    completion: Continuation&lt;Any?&gt;?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _context: CoroutineContext?</span><br><span class="line">) : BaseContinuationImpl(completion) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(completion: Continuation&lt;Any?&gt;?) : <span class="keyword">this</span>(completion, completion?.context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = _context!!</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> intercepted: Continuation&lt;Any?&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">releaseIntercepted</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> intercepted = intercepted</span><br><span class="line">        <span class="keyword">if</span> (intercepted != <span class="literal">null</span> &amp;&amp; intercepted !== <span class="keyword">this</span>) &#123;</span><br><span class="line">            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.intercepted = CompletedContinuation <span class="comment">// just in case</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类继承自 BaseContinuationImpl ，在其基础上做了如下操作：</p>
<p>1、新增 context CoroutineContext 属性</p>
<blockquote>
<p>ContinuationImpl 提供两个构造方法，如果 context 没有传入的话，则使用 completion Continuation 的 context 属性作为替补。正是因为在这一层开始增加了 context ，协程才变得更加灵活。</p>
</blockquote>
<p>2、新增 intercepted Continuation 属性和 intercepted() 方法</p>
<blockquote>
<p>由于在这一层继承开始有了 context ，那么可操作的区间就变大了。比如这里新增的 intercepted() 方法可以将当前 Continuation(因为当前最终还是继承自Continuation的)转换为另外一个 Continuation 返回出去。而这里最主要的用途是取出 context 中的 Interceptor 然后通过 interceptContinuation() 方法将其包装成 DispatchedContinuation 返回，这样的话该协程就支持 线程调度 了。</p>
</blockquote>
<p>所以说 ContinuationImpl 这一层主要是增加了拦截器intercept()方法，支持 线程调度 了。</p>
<h5 id="SuspendLambda"><a href="#SuspendLambda" class="headerlink" title="SuspendLambda"></a>SuspendLambda</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseContinuationImpl.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SuspendLambda</span>(</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> arity: <span class="built_in">Int</span>,</span><br><span class="line">    completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : ContinuationImpl(completion), FunctionBase&lt;Any?&gt;, SuspendFunction &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(arity: <span class="built_in">Int</span>) : <span class="keyword">this</span>(arity, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String =</span><br><span class="line">        <span class="keyword">if</span> (completion == <span class="literal">null</span>)</span><br><span class="line">            Reflection.renderLambdaToString(<span class="keyword">this</span>) <span class="comment">// this is lambda</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">super</span>.toString() <span class="comment">// this is continuation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类继承自 ContinuationImpl ，额外的还实现了 SuspendFunction 等接口。在该抽象类中只是额外的新增了 arity Int 以及重写了 toString 方法而已。但是实际当编写带有 suspend 关键字的 lambda 语句时，在编译时会创建出一个类来继承自 SuspendLambda。这个后续看反编译代码时可以看出来。</p>
<h4 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h4><p>在后续看源码时会经常看到类似于下面的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="params"><span class="function">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Job &#123;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中入参 block 的类型为：suspend CoroutineScope.() -&gt; Unit 。起初看到这个类型时十分诧异，不过这也正是kotlin的特点了。</p>
<p>可以看到 block 同时使用 suspend 和 CoroutineScope.() -&gt; Unit 。我们知道 suspend 表示这是一个挂起函数，而后面的我们需要拆2个部分来看。先说 CoroutineScope.() -&gt; Unit ：</p>
<h5 id="1）CoroutineScope-gt-Unit-："><a href="#1）CoroutineScope-gt-Unit-：" class="headerlink" title="1）CoroutineScope.() -&gt; Unit ："></a>1）CoroutineScope.() -&gt; Unit ：</h5><p>() -&gt; Unit 是一个函数类型，但是它前面又多了一个 CoroutineScope. 前缀，即 CoroutineScope.() -&gt; Unit ，表示这个是一个扩展函数（<a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/extensions.html%EF%BC%89">https://www.kotlincn.net/docs/reference/extensions.html）</a></p>
<p>它和我们常用的 with、apply、let 等扩展函数类似，表示允许在函数体内部访问接收者对象的成员。而 ()-&gt;Unit 或者 ()-&gt;Int 亦或者 (Int,Boolean)-&gt;Unit … 这些都是属于 lambda 表达式，当在 kotlin 里面这样定义时，在编<br>译时会被编译为指定的 class，并且会自动继承自 kotlin&#x2F;jvm&#x2F;internal&#x2F;Lambda 。</p>
<p>举例说明：</p>
<h6 id="1-1-无参lambda"><a href="#1-1-无参lambda" class="headerlink" title="1.1 无参lambda"></a>1.1 无参lambda</h6><p>比如在 Kotlin 中这样写时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> normalFun1: () -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;normalFun1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        normalFun1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo01().test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其编译之后会产生三个class：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo01Kt.<span class="keyword">class</span> 、 Demo01.<span class="keyword">class</span> 和 Demo01$normalFun1$<span class="number">1.</span><span class="keyword">class</span></span><br></pre></td></tr></table></figure>

<p>首先会对 main() 方法产生一个 Demo01Kt.class ，其内容反编译之后为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01Kt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">        new Demo01().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次是为 class Demo01 类产生的 Demo01.class，反编译之后：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Function0&lt;<span class="built_in">Unit</span>&gt; normalFun1 = Demo01$normalFun1$<span class="number">1.</span>INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> void test() &#123;</span><br><span class="line">        <span class="keyword">this</span>.normalFun1.invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即首先是针对原来的 normalFun1 lambda 定义在编译之后变成了一个 Function0<Unit> 接口实例，具体是 <code>Demo01$normalFun1$1.INSTANCE</code><br>然后就是 test 方法的描述，调用了 Function0<Unit> normalFun1 的 invoke 方法。</p>
<p>所以重点还得是 <code>Demo01$normalFun1$1</code> 类，因为最后还有一个class文件为：Demo01$normalFun1$1.class，反编译之后：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">normalFun1</span>$1 <span class="title">extends</span> <span class="title">Lambda</span> <span class="title">implements</span> <span class="title">Function0</span>&lt;<span class="type">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> Demo01$normalFun1$<span class="number">1</span> INSTANCE = new Demo01$normalFun1$<span class="number">1</span>();</span><br><span class="line"></span><br><span class="line">    Demo01$normalFun1$<span class="number">1</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> void invoke() &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;normalFun1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在kotlin中，针对 lambda 语句会为其自动创建一个中间类，继承 kotlin.jvm.internal.Lambda ，并实现对应的 Function 接口。<br>比如这里由于原lambda 是无参的，所以这里实现的是Function0<Unit>，实现了其 invoke 方法，输出了”normalFun1”。<br>并且这里是将 <code>Demo01$normalFun1$1</code> 类作为单例来使用的，即外部都是直接使用其 INSTANCE 实例就行了，即只会存在一个中间类的实例。</p>
<h6 id="1-2-有参lambda"><a href="#1-2-有参lambda" class="headerlink" title="1.2 有参lambda"></a>1.2 有参lambda</h6><p>比如在 Kotlin 中这样写时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01.kt</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> normalFun2: (<span class="built_in">Int</span>, <span class="built_in">Boolean</span>) -&gt; String = &#123; int, bool -&gt;</span><br><span class="line">        println(<span class="string">&quot;normalFun2&quot;</span>)</span><br><span class="line">        <span class="string">&quot;result&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        normalFun2(<span class="number">0</span>,<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo01().test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后还是会产生三个class：<code>Demo01Kt.class</code> 、<code> Demo01.class</code> 和 <code>Demo01$normalFun2$1.class</code><br>和前面一样，唯一不同的是最后一个文件名中的 Fun1 变成了 Fun2 ，也就是以Lambda的变量名为准的。前俩文件不看了，基本上和前面一样，<br>只看<code>Demo01$normalFun2$1.class</code> 反编译之后的内容：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">normalFun2</span>$1 <span class="title">extends</span> <span class="title">Lambda</span> <span class="title">implements</span> <span class="title">Function2</span>&lt;<span class="type">Integer, Boolean, String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> Demo01$normalFun2$<span class="number">1</span> INSTANCE = new Demo01$normalFun2$<span class="number">1</span>();</span><br><span class="line"></span><br><span class="line">    Demo01$normalFun2$<span class="number">1</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法应该是兼容kotlin的吧</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/* bridge */</span> <span class="comment">/* synthetic */</span> Object invoke(Object p1, Object p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> invoke(((Number) p1).intValue(), ((<span class="built_in">Boolean</span>) p2).booleanValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String invoke(int i, boolean bool) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;normalFun2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 lambda 有两个入参，所以实现的时 Function2 ，在 invoke 方法的签名中也能看出来。通过这个可以对比出 Function2 这些接口的规律了吧。</p>
<h6 id="1-3-函数扩展类型："><a href="#1-3-函数扩展类型：" class="headerlink" title="1.3 函数扩展类型："></a>1.3 函数扩展类型：</h6><p>比如在 Kotlin 中这样写时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> normalFun3: GlobalScope.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;normalFun3&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        GlobalScope.normalFun3()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo01().test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后还是会产生三个class：<code>Demo01Kt.class </code>、 <code>Demo01.class</code> 和 <code>Demo01$normalFun3$1.class</code><br>和前面一样，唯一不同的是最后一个文件名中变成了 Fun3 ，也就是以Lambda的变量名为准的。前俩文件不看了，基本上和前面一样，<br>只看 <code>Demo01$normalFun3$1.class</code> 反编译之后的内容：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">normalFun3</span>$1 <span class="title">extends</span> <span class="title">Lambda</span> <span class="title">implements</span> <span class="title">Function1</span>&lt;<span class="type">GlobalScope, Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> Demo01$normalFun3$<span class="number">1</span> INSTANCE = new Demo01$normalFun3$<span class="number">1</span>();</span><br><span class="line"></span><br><span class="line">    Demo01$normalFun3$<span class="number">1</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/* bridge */</span> <span class="comment">/* synthetic */</span> Object invoke(Object p1) &#123;</span><br><span class="line">        invoke((GlobalScope) p1);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> void invoke(<span class="meta">@NotNull</span> GlobalScope $<span class="keyword">this</span>$<span class="literal">null</span>) &#123;</span><br><span class="line">        Intrinsics.checkNotNullParameter($<span class="keyword">this</span>$<span class="literal">null</span>, <span class="string">&quot;<span class="variable">$this</span><span class="variable">$null</span>&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;normalFun3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GlobalScope.() 这种方式定义最后会被编译为： invoke(@NotNull GlobalScope $this$null) 即带一个GlobalScope入参的函数，所以实现的是 Function1<br>所以也就是说 GlobalScope.() 这种接受者类型的时，会自动为函数中插入一个该对象类型的参数作为入参传入进去。内部调用 this 时实际是对该入参对象做操作。</p>
<h6 id="1-4-带参数的函数扩展"><a href="#1-4-带参数的函数扩展" class="headerlink" title="1.4 带参数的函数扩展"></a>1.4 带参数的函数扩展</h6><p>比如在 Kotlin 中这样写时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> normalFun4: GlobalScope.(<span class="built_in">Boolean</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> = &#123; bool, int -&gt;</span><br><span class="line">        println(<span class="string">&quot;normalFun4&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        GlobalScope.normalFun4(<span class="literal">false</span>,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo01().test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后和上面一样，(也能猜到了吧，按照规律来推断也推的出来了)，直接看<code>Demo01$normalFun4$1.class</code> 反编译之后的内容 ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">normalFun4</span>$1 <span class="title">extends</span> <span class="title">Lambda</span> <span class="title">implements</span> <span class="title">Function3</span>&lt;<span class="type">GlobalScope, Boolean, Integer, Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> Demo01$normalFun4$<span class="number">1</span> INSTANCE = new Demo01$normalFun4$<span class="number">1</span>();</span><br><span class="line"></span><br><span class="line">    Demo01$normalFun4$<span class="number">1</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/* bridge */</span> <span class="comment">/* synthetic */</span> Object invoke(Object p1, Object p2, Object p3) &#123;</span><br><span class="line">        invoke((GlobalScope) p1, ((<span class="built_in">Boolean</span>) p2).booleanValue(), ((Number) p3).intValue());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> void invoke(<span class="meta">@NotNull</span> GlobalScope $<span class="keyword">this</span>$<span class="literal">null</span>, boolean bool, int i) &#123;</span><br><span class="line">        Intrinsics.checkNotNullParameter($<span class="keyword">this</span>$<span class="literal">null</span>, <span class="string">&quot;<span class="variable">$this</span><span class="variable">$null</span>&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;normalFun4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 invoke 中有三个参数，第一个当然是给 GlobalScope 实例来用的，后俩才分别是给 Boolean 和 Int 来使用的。这次加上参数是为了体现 GlobalScope 永远是作为第一个参数插入的。</p>
<p>2）suspend：</p>
<p>使用 suspend 描述的话，表示该函数是一个 挂起函数，可以在协程域内调用。而它本质上和1中的扩展函数差不多，都是kotlin编译器魔法是的他生效。即：使用它会使得最终的 class 继承自 SuspendLambda 。</p>
<p>举例说明：</p>
<h6 id="2-1-无参"><a href="#2-1-无参" class="headerlink" title="2.1 无参"></a>2.1 无参</h6><p>比如在 Kotlin 中这样写时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> suspendFun1: <span class="keyword">suspend</span> () -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;suspendFun1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            suspendFun1()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo01().test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后会产生4个 class 文件，这里只看和 suspendFun1相关的<code>Demo01$suspendFun1$1.class</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">suspendFun1</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function1</span>&lt;<span class="type">Continuation&lt;? super Unit</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX INFO: Access modifiers changed from: package-private */</span></span><br><span class="line">    <span class="keyword">public</span> Demo01$suspendFun1$<span class="number">1</span>(Continuation&lt;? <span class="keyword">super</span> Demo01$suspendFun1$<span class="number">1</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>, continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation&lt;<span class="built_in">Unit</span>&gt; create(<span class="meta">@NotNull</span> Continuation&lt;?&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">return</span> new Demo01$suspendFun1$<span class="number">1</span>(continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以看到，增加了一个 Continuation 参数</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@Nullable</span> Continuation&lt;? <span class="keyword">super</span> <span class="built_in">Unit</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">return</span> create(continuation).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object obj) &#123;</span><br><span class="line">        IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">            case <span class="number">0</span>:</span><br><span class="line">                ResultKt.throwOnFailure(obj);</span><br><span class="line">                System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;suspendFun1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-2-带参数"><a href="#2-2-带参数" class="headerlink" title="2.2 带参数"></a>2.2 带参数</h6><p>比如在 Kotlin 中这样写时：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> suspendFun2: <span class="keyword">suspend</span> (String,<span class="built_in">Int</span>) -&gt; <span class="built_in">Boolean</span> = &#123; str,int -&gt;</span><br><span class="line">        println(<span class="string">&quot;suspendFun2&quot;</span>)</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        runBlocking &#123;</span><br><span class="line">            suspendFun2(<span class="string">&quot;&quot;</span>,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo01().test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后还是只看关键的 <code>Demo01$suspendFun2$1.class</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">suspendFun2</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function3</span>&lt;<span class="type">String, Integer, Continuation&lt;? super Boolean</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX INFO: Access modifiers changed from: package-private */</span></span><br><span class="line">    <span class="keyword">public</span> Demo01$suspendFun2$<span class="number">1</span>(Continuation&lt;? <span class="keyword">super</span> Demo01$suspendFun2$<span class="number">1</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">3</span>, continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@NotNull</span> String p1, int p2, <span class="meta">@Nullable</span> Continuation&lt;? <span class="keyword">super</span> <span class="built_in">Boolean</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">return</span> new Demo01$suspendFun2$<span class="number">1</span>(continuation).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/* bridge */</span> <span class="comment">/* synthetic */</span> Object invoke(Object p1, Object p2, Object p3) &#123;</span><br><span class="line">        <span class="keyword">return</span> invoke((String) p1, ((Number) p2).intValue(), (Continuation) p3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object obj) &#123;</span><br><span class="line">        IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">            case <span class="number">0</span>:</span><br><span class="line">                ResultKt.throwOnFailure(obj);</span><br><span class="line">                System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;suspendFun2&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Boxing.boxBoolean(<span class="literal">false</span>);</span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面2.1分析之后就可以想到这里为啥实现的是 Function3 了，还是先看 invoke 中，一共三个参数，前俩就是原本入参 String,Int ，最后一个是为 suspend 增加的 Continuation 参数。这里对比2.1是确定 Continuation 是加在最后一位的，而跟1中的扩展函数相比的话，一个在最前面插入参数，一个在最后面插入参数。</p>
<p>所以说，当这样写的时候：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> suspendFun3: <span class="keyword">suspend</span> CoroutineScope.(String, <span class="built_in">Int</span>) -&gt; <span class="built_in">Boolean</span> = &#123; str, int -&gt;</span><br><span class="line">        println(<span class="string">&quot;suspendFun3&quot;</span>)</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            suspendFun3(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo01().test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其最终编译之后的<code>Demo01$suspendFun3$1.class</code> ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">suspendFun3</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function4</span>&lt;<span class="type">CoroutineScope, String, Integer, Continuation&lt;? super Boolean</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX INFO: Access modifiers changed from: package-private */</span></span><br><span class="line">    <span class="keyword">public</span> Demo01$suspendFun3$<span class="number">1</span>(Continuation&lt;? <span class="keyword">super</span> Demo01$suspendFun3$<span class="number">1</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">4</span>, continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@NotNull</span> CoroutineScope p1, <span class="meta">@NotNull</span> String p2, int p3, <span class="meta">@Nullable</span> Continuation&lt;? <span class="keyword">super</span> <span class="built_in">Boolean</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">return</span> new Demo01$suspendFun3$<span class="number">1</span>(continuation).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/* bridge */</span> <span class="comment">/* synthetic */</span> Object invoke(Object p1, Object p2, Object p3, Object p4) &#123;</span><br><span class="line">        <span class="keyword">return</span> invoke((CoroutineScope) p1, (String) p2, ((Number) p3).intValue(), (Continuation) p4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object obj) &#123;</span><br><span class="line">        IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">            case <span class="number">0</span>:</span><br><span class="line">                ResultKt.throwOnFailure(obj);</span><br><span class="line">                System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;suspendFun3&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Boxing.boxBoolean(<span class="literal">false</span>);</span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合之前的知识来分析的话，这里的 Function4 就不难理解了吧。其中 invoke 中第一个参数是给 CoroutineScope 的，中间俩是原本入参 String,Int ，<br>而最后一个是为 suspend 增加的 Continuation 参数了。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Kotlin-Coroutine/">Kotlin Coroutine</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/b72a4fb1.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Kotlin协程 - 协程启动原理</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/64b5b134.html">
        <span class="next-text nav-default">Kotlin协程 - 概述</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
