<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Jetpack- Activity Result Api"/>




  <meta name="keywords" content="Jetpack," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/c801eba.html"/>


<meta name="description" content="Jetpack 还存在一个 Activity Result Api 库，可以用来替代传统的 onActivityResult() 方法。而现在对于这些传统的 onActivityResult() 方式获取返回结果的，官方已经不推荐了，这些方法已经被标记为废弃了。 对于 Activity Result Api 的使用的话，很简单：①调用 registerForActivityResult() 方法来">
<meta property="og:type" content="article">
<meta property="og:title" content="Jetpack- Activity Result Api">
<meta property="og:url" content="https://youngkaaa.github.io/c801eba.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="Jetpack 还存在一个 Activity Result Api 库，可以用来替代传统的 onActivityResult() 方法。而现在对于这些传统的 onActivityResult() 方式获取返回结果的，官方已经不推荐了，这些方法已经被标记为废弃了。 对于 Activity Result Api 的使用的话，很简单：①调用 registerForActivityResult() 方法来">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-04T02:48:56.000Z">
<meta property="article:modified_time" content="2023-01-13T13:15:51.273Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Jetpack">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Jetpack- Activity Result Api - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Jetpack- Activity Result Api
        
      </h1>

      <time class="post-time">
          7月 04 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>Jetpack 还存在一个<a target="_blank" rel="noopener" href="https://developer.android.com/training/basics/intents/result"> Activity Result Api 库</a>，可以用来替代传统的 onActivityResult() 方法。而现在对于这些传统的 onActivityResult() 方式获取返回结果的，官方已经不推荐了，这些方法已经被标记为废弃了。</p>
<p>对于 Activity Result Api 的使用的话，很简单：①调用 registerForActivityResult() 方法来传入对应的参数实例，比如回调等。拿到该方法的返回结果ActivityResultLauncher实例②在合适的时候调用①中返回的ActivityResultLauncher实例的 launch() 方法来完成真正启动工作。等到后续有返回结果时，会在你设置的回调中通知你。</p>
<p>其实简单来说，就是将之前onActivityResult() 方式改成了接口回调的方式，这种方式更加灵活。另外不需要去定义requestCode 等那些属性了。</p>
<p>具体的代码使用方式很简单，不再贴代码了，可以翻看官方文档：<a target="_blank" rel="noopener" href="https://developer.android.com/training/basics/intents/result">https://developer.android.com/training/basics/intents/result</a></p>
<h3 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h3><h4 id="ActivityResultRegistryOwner"><a href="#ActivityResultRegistryOwner" class="headerlink" title="ActivityResultRegistryOwner"></a>ActivityResultRegistryOwner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.result.ActivityResultRegistryOwner</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActivityResultRegistryOwner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the ActivityResultRegistry of the provider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The activity result registry of the provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ActivityResultRegistry <span class="title function_">getActivityResultRegistry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该接口也是只有一个方法，用来返回一个ActivityResultRegistry实例。这个接口跟前面的 LifecycleOwner 、ViewModelStoreOwner 这些接口都是差不多的。</p>
<p>而对于 Activity Result Api 来说，这个接口它的实现类也还是 ComponentActivity 。</p>
<h4 id="ActivityResultCaller"><a href="#ActivityResultCaller" class="headerlink" title="ActivityResultCaller"></a>ActivityResultCaller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.result.ActivityResultCaller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActivityResultCaller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a request to &#123;<span class="doctag">@link</span> Activity#startActivityForResult start an activity for result&#125;,</span></span><br><span class="line"><span class="comment">     * designated by the given &#123;<span class="doctag">@link</span> ActivityResultContract contract&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This creates a record in the &#123;<span class="doctag">@link</span> ActivityResultRegistry registry&#125; associated wit this</span></span><br><span class="line"><span class="comment">     * caller, managing request code, as well as conversions to/from &#123;<span class="doctag">@link</span> Intent&#125; under the hood.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This *must* be called unconditionally, as part of initialization path, typically as a field</span></span><br><span class="line"><span class="comment">     * initializer of an Activity or Fragment.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;I&gt; the type of the input(if any) required to call the activity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;O&gt; the type of output returned as an activity result</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> contract the contract, specifying conversions to/from &#123;<span class="doctag">@link</span> Intent&#125;s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback the callback to be called on the main thread when activity result</span></span><br><span class="line"><span class="comment">     *                 is available</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the launcher that can be used to start the activity or dispose of the prepared call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">registerForActivityResult</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> ActivityResultCallback&lt;O&gt; callback)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a request to &#123;<span class="doctag">@link</span> Activity#startActivityForResult start an activity for result&#125;,</span></span><br><span class="line"><span class="comment">     * designated by the given &#123;<span class="doctag">@link</span> ActivityResultContract contract&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This creates a record in the given &#123;<span class="doctag">@link</span> ActivityResultRegistry registry&#125;, managing request</span></span><br><span class="line"><span class="comment">     * code, as well as conversions to/from &#123;<span class="doctag">@link</span> Intent&#125; under the hood.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This *must* be called unconditionally, as part of initialization path, typically as a field</span></span><br><span class="line"><span class="comment">     * initializer of an Activity or Fragment.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;I&gt; the type of the input(if any) required to call the activity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;O&gt; the type of output returned as an activity result</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> contract the contract, specifying conversions to/from &#123;<span class="doctag">@link</span> Intent&#125;s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry the registry where to hold the record.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback the callback to be called on the main thread when activity result</span></span><br><span class="line"><span class="comment">     *                 is available</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the launcher that can be used to start the activity or dispose of the prepared call.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">registerForActivityResult</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> ActivityResultRegistry registry,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> ActivityResultCallback&lt;O&gt; callback)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口表示当前是否支持 ActivityResult Api 能力，即调用registerForActivityResult() 这种风格来获取返回结果。某个类如果想要支持这种能力，那么可以实现该接口。同样的，该接口的主要是实现类还是ComponentActivity ，额外的增加了 Fragment 。即在 Fragment 内也可以调用registerForActivityResult() 方法来实现数据接收处理。</p>
<h4 id="ActivityResultContract"><a href="#ActivityResultContract" class="headerlink" title="ActivityResultContract"></a>ActivityResultContract</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.result.contract.ActivityResultContract</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ActivityResultContract</span>&lt;I, O&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create an intent that can be used for &#123;<span class="doctag">@link</span> Activity#startActivityForResult&#125; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@NonNull</span> Intent <span class="title function_">createIntent</span><span class="params">(<span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">            <span class="meta">@SuppressLint(&quot;UnknownNullness&quot;)</span> I input)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Convert result obtained from &#123;<span class="doctag">@link</span> Activity#onActivityResult&#125; to O */</span></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;UnknownNullness&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> O <span class="title function_">parseResult</span><span class="params">(<span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent intent)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optional method you can implement that can be used to potentially provide a result in</span></span><br><span class="line"><span class="comment">     * lieu of starting an activity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result wrapped in a &#123;<span class="doctag">@link</span> SynchronousResult&#125; or &#123;<span class="doctag">@code</span> null&#125; if the call</span></span><br><span class="line"><span class="comment">     * should proceed to start an activity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> SynchronousResult&lt;O&gt; <span class="title function_">getSynchronousResult</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> Context context,</span></span><br><span class="line"><span class="params">            <span class="meta">@SuppressLint(&quot;UnknownNullness&quot;)</span> I input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The wrapper for a result provided in &#123;<span class="doctag">@link</span> #getSynchronousResult&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; type of the result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SynchronousResult</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@SuppressLint(&quot;UnknownNullness&quot;)</span> T mValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Create a new result wrapper</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value the result value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SynchronousResult</span><span class="params">(<span class="meta">@SuppressLint(&quot;UnknownNullness&quot;)</span> T value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.mValue = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the result value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="meta">@SuppressLint(&quot;UnknownNullness&quot;)</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接口类，该接口占据着 Activity Result Api 中很重要的位置，使用它可以完成 Intent 的创建，返回结果的解析等工作。</p>
<p>在该接口中，定义了如下几个方法和类：</p>
<p>1、createIntent()：用于创建Intent实例，该Intent 实例会被用于 startActivityForResult() 方法调用时传入的参数。注意这里的 input 是泛型 I，后续不同实现类可以指定不同的入参input类型。</p>
<p>2、parseResult(): 该方法用来解析返回的数据。比如从 onActivityResult() 中，会返回上一页面的结果到 Intent data 中，此时在 Activity Result Api框架中会自动将返回的int resultCode 和 Intent data传入到该方法中，该方法中可以将该 Intent 转换为对应的类型返回。要返回的类型也是个泛型O，子类可以指定返回类型，比如你自定义的一个类。</p>
<p>3、getSynchronousResult()：从方法名上来看：获取同步结果。何为同步结果，就是在调用 ActivityResultLauncher.launch() 方法时就可以即刻拿到返回结果，而不是等新页面或者权限弹框操作之后再拿到返回结果。因为后者这种方式的回调时机是不可预料的。</p>
<p>就像同步方式，对应代码执行完成就能拿到结果；异步方式就是等在未来的某个时刻被回调才能拿到结果。</p>
<p>而该方法有什么用呢？即在【真正的操作】进行之前，就能知道结果，那么此时可以重写它来立马返回结果，从而跳过【真正的操作】。这里说的【真正的操作】可能是启动Activity拿到其最后返回的值；也可能是请求权限，拿到用户操作完的权限允许情况(即允许和不允许)。</p>
<p>应该不存在：在不启动Activity就可以知道其返回结果的场景吧。</p>
<p>而对于请求权限来说，在正式请求权限之前，可以检查该权限是否之前已经允许了，如果已允许的话，则可以直接通知回调监听者：当前申请该权限成功！而如果检查当前没有赋予该权限的话，再去请求权限也OK。毕竟第一次就同意或者拒绝不再提醒权限的比例还是挺多的。</p>
<p>正如上面的描述，该方法一般是在使用 Activity Result Api请求权限时重写。而另外一种启动Activity并获取其返回值的方式就可以忽略掉该方法了。</p>
<blockquote>
<p>当然该方法只是预留着这样的用处。后续可能Activity Result Api 还会有其他扩充，亦或者存在不启动Activity 就可以拿到结果的场景呢。</p>
</blockquote>
<p>另外该方法返回一个 SynchronousResult 实例，该类中存在一个泛型值value，用于储存返回值。</p>
<h4 id="ActivityResultCallback"><a href="#ActivityResultCallback" class="headerlink" title="ActivityResultCallback"></a>ActivityResultCallback</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.result.ActivityResultCallback</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActivityResultCallback</span>&lt;O&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when result is available</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="meta">@SuppressLint(&quot;UnknownNullness&quot;)</span> O result)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样是接口，它就是前面一直说的接收Activity Result Api 结果的回调。</p>
<p>该类也存在一个泛型，该泛型是作为其内部唯一方法 onActivityResult() 的入参来使用。用来指定最终接收到结果的类型。</p>
<p>正如前面所讲的，在 ActivityResultContract 中存在 parseResult() 方法会将Intent转换为对应的类实例来返回，它返回的结果就是作为这里onActivityResult() 的入参来使用的。</p>
<p>而这俩泛型是怎么关联起来呢？得归功于 ActivityResultCaller 里面那俩方法的定义了，即在其内部方法的定义中，通过入参 ActivityResultContract的I、O泛型类型就可以推断出 ActivityResultCallback 泛型O的类型了。</p>
<h4 id="ActivityResultRegistry"><a href="#ActivityResultRegistry" class="headerlink" title="ActivityResultRegistry"></a>ActivityResultRegistry</h4><p>该类是一个抽象类，作用是用来存储 Activity Result Api 库请求过程中的数据的，比如传入进来的ActivityResultCallback 、ActivityResultContract那些，以及内部为每次请求所分配的requestCode 等。</p>
<p>其内部只有一个抽象方法：onLaunch()，该方法交给子类来实现，用来实现真正的 startActivity() 或者 requestPermissions() 逻辑。</p>
<p>该抽象类目前只有一个实现类，位于ComponentActivity 中的 mActivityResultRegistry，此处实现了 onLaunch()方法。在此处的实现中，完成了真正的 startActivity() 或者 requestPermissions() 逻辑。</p>
<p>另外，你也可以直接继承自 ActivityResultRegistry ，实现该方法来自定义适合自己的逻辑，比如用于测试，可以在该方法内部不跳转，只是用于打点日志之类的。</p>
<p>而自定义的 ActivityResultRegistry 实例，怎么使用呢？通过三个参数的 ActivityResultCaller.registerForActivityResult() 方法即可。</p>
<p>当然我们一般使用的是两个参数的那个重载版本，其中它会使用一个默认的 ActivityResultRegistry 实例。比如 使用 ComponentActivity 中的 mActivityResultRegistry 。</p>
<h3 id="相关源码分析-Activity"><a href="#相关源码分析-Activity" class="headerlink" title="相关源码分析 - Activity"></a>相关源码分析 - Activity</h3><p>对于Activity 中 Activity Result Api 的使用来说，只要是位于ComponentActivity 的子类中，都可以直接调用其 registerForActivityResult() 方法来提前注册一个 Activity Result 请求，因为ComponentActivity 实现了 ActivityResultCaller 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.ComponentActivity</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentActivity</span> <span class="keyword">extends</span> <span class="title class_">androidx</span>.core.app.ComponentActivity <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ContextAware</span>,</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        HasDefaultViewModelProviderFactory,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner,</span><br><span class="line">        ActivityResultRegistryOwner,</span><br><span class="line">        ActivityResultCaller &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一直自增的索引，用于生成 ActivityResultRegistry 的 key</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">mNextLocalRequestCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ActivityResultRegistry</span> <span class="variable">mActivityResultRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityResultRegistry</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;I, O&gt; <span class="keyword">void</span> <span class="title function_">onLaunch</span><span class="params">(</span></span><br><span class="line"><span class="params">                    <span class="keyword">final</span> <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">                    <span class="meta">@NonNull</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">                    I input,</span></span><br><span class="line"><span class="params">                    <span class="meta">@Nullable</span> ActivityOptionsCompat options)</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 省略详细代码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">registerForActivityResult</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultRegistry registry,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> registry.register(</span><br><span class="line">                    <span class="string">&quot;activity_rq#&quot;</span> + mNextLocalRequestCode.getAndIncrement(), <span class="built_in">this</span>, contract, callback);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一般最常用的是这个方法，在该方法中会默认指定 ActivityResultRegistry 为当前类中定义的 mActivityResultRegistry 实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">registerForActivityResult</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> ActivityResultCallback&lt;O&gt; callback)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> registerForActivityResult(contract, mActivityResultRegistry, callback);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对于 registerForActivityResult() 方法的调用最终是交给 ActivityResultRegistry 来处理的。正如前面所言，绝大多数情况下这里的 ActivityResultRegistry实例都是使用的ComponentActivity 中的mActivityResultRegistry实现类，这次从上面代码中也可以看出来。</p>
<p>接下来，剩余的大部分逻辑都在ActivityResultRegistry 中了。前面调用到了ActivityResultRegistry.register() 中，并且额外拼接了一个String key ，该key 的格式是：activity_rq#0、activity_rq#1 …等，借助mNextLocalRequestCode属性完成索引的自增，每次调用 registerForActivityResult() 方法都会为其生成一个唯一key。</p>
<p>在正式看其内部逻辑之前，先简单分析下其内部属性的含义：</p>
<p>1、Map&lt;Integer, String&gt; mRcToKey：每一次通过 registerForActivityResult() 方法注册进来的请求，会执行到ActivityResultRegistry.register() 中，此时内部会为其分配一个唯一的requestCode，用于最终调用 startActivityForResult() 方法时传入，该请求码是随机的(利用其内部的另外一个 Random mRandom来完成请求码的生成)。</p>
<p>生成的请求码和传入进来的String key(类似activity_rq#0这种格式的 )是一一对应的。所以这里的mRcToKey 就是用来存储生成的随机 RequestCode 到String Key的映射的。(下面使用简写 Key 来代替)</p>
<p>2、Map&lt;String, Integer&gt; mKeyToRc：同上，但是它存储的是 Key 到 RequestCode 的映射的。</p>
<p>3、Map&lt;String, LifecycleContainer&gt; mKeyToLifecycleContainers：存储的是 Key 到 LifecycleContainer 的映射，而LifecycleContainer 是其一个内部类，主要作用是将Lifecycle相关的属性封装起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.result.ActivityResultRegistry.LifecycleContainer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LifecycleContainer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管理 Lifecycle</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Lifecycle mLifecycle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将注册给该 Lifecycle 的观察者列表单独持有，后续方面统一移除,</span></span><br><span class="line"><span class="comment">     * 虽然在 ActivityResultRegistry 一般只会add一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;LifecycleEventObserver&gt; mObservers;</span><br><span class="line"></span><br><span class="line">    LifecycleContainer(<span class="meta">@NonNull</span> Lifecycle lifecycle) &#123;</span><br><span class="line">        mLifecycle = lifecycle;</span><br><span class="line">        mObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleEventObserver observer)</span> &#123;</span><br><span class="line">        mLifecycle.addObserver(observer);</span><br><span class="line">        mObservers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clearObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleEventObserver observer: mObservers) &#123;</span><br><span class="line">            mLifecycle.removeObserver(observer);</span><br><span class="line">        &#125;</span><br><span class="line">        mObservers.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、<code>ArrayList&lt;String&gt;mLaunchedKeys</code>：储存着当前所有已启动的请求。对于Activity Result Api来说，大致有两步：先注册，再调用launch方法。只有launch方法调用后，真正的启动Activity等逻辑才会被执行。而当前mLaunchedKeys 列表中就存储着已经调用过 launch() 方法的那些key。更准确来说是：当你launch()方法调用后，会将key加入到该列表中；等最后的结果回调出去之后，对应的key会从该列表中移除。</p>
<p>5、Map&lt;String, CallbackAndContract&lt;?&gt;&gt; mKeyToCallback：存储的是 Key 到 CallbackAndContract的映射。而 CallbackAndContract 类则是对 ActivityResultCallback 和 ActivityResultContract 入参的封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.result.ActivityResultRegistry.CallbackAndContract</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallbackAndContract</span>&lt;O&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; mCallback;</span><br><span class="line">    <span class="keyword">final</span> ActivityResultContract&lt;?, O&gt; mContract;</span><br><span class="line"></span><br><span class="line">    CallbackAndContract(</span><br><span class="line">            ActivityResultCallback&lt;O&gt; callback,</span><br><span class="line">            ActivityResultContract&lt;?, O&gt; contract) &#123;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mContract = contract;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类很简单，没啥需要解释的。</p>
<p>6、Map&lt;String, Object&gt; mParsedPendingResults：暂存着已经经过 ActivityResultContract.parseResult() 方法解析过的结果。这些结果可能由于某些原因当时没有回调出去。比如接收结果的页面在后台被杀掉了，那么此时需要将结果暂存起来，等返回到该页面，该页面被恢复时再通知给它。</p>
<p>7、Bundle mPendingResults：Bundle 对象，内部主要是存储那些没被 ActivityResultContract.parseResult() 方法解析过的Intent 数据。</p>
<p>实际上，会将从 Activity.onActivityResult() 返回回来的 resultCode 和 intent data 保存到 ActivityResult 类实例中，然后将其作为一个 Parcelable 对象存入到 mPendingResults 这个 Bundle 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.result.ActivityResult</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ActivityResult</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mResultCode;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Intent mData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new instance</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode status to indicate the success of the operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data an intent that carries the result data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ActivityResult</span><span class="params">(<span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> &#123;</span><br><span class="line">        mResultCode = resultCode;</span><br><span class="line">        mData = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityResult(Parcel in) &#123;</span><br><span class="line">        mResultCode = in.readInt();</span><br><span class="line">        mData = in.readInt() == <span class="number">0</span> ? <span class="literal">null</span> : Intent.CREATOR.createFromParcel(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the resultCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getResultCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mResultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the intent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Intent <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ActivityResult&#123;&quot;</span></span><br><span class="line">                + <span class="string">&quot;resultCode=&quot;</span> + resultCodeToString(mResultCode)</span><br><span class="line">                + <span class="string">&quot;, data=&quot;</span> + mData</span><br><span class="line">                + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A readable representation of standard activity result codes</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode the result code</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RESULT_OK, RESULT_CANCELED, or the number otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">resultCodeToString</span><span class="params">(<span class="type">int</span> resultCode)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (resultCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> Activity.RESULT_OK: <span class="keyword">return</span> <span class="string">&quot;RESULT_OK&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> Activity.RESULT_CANCELED: <span class="keyword">return</span> <span class="string">&quot;RESULT_CANCELED&quot;</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> String.valueOf(resultCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(<span class="meta">@NonNull</span> Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        dest.writeInt(mResultCode);</span><br><span class="line">        dest.writeInt(mData == <span class="literal">null</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mData != <span class="literal">null</span>) &#123;</span><br><span class="line">            mData.writeToParcel(dest, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;ActivityResult&gt; CREATOR = <span class="keyword">new</span> <span class="title class_">Creator</span>&lt;ActivityResult&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ActivityResult <span class="title function_">createFromParcel</span><span class="params">(<span class="meta">@NonNull</span> Parcel in)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActivityResult</span>(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ActivityResult[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActivityResult</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类很简单就是一个容器类，不做解释了。</p>
<p>所以说，对于 mParsedPendingResults 和 mPendingResults 来说，他俩都是用来暂存返回结果的，区别是一个暂存的是经过解析的结果类实例，另外一个是没经过解析的ActivityResult数据。</p>
<p>另外，往这俩容器中存储结果的逻辑分别只有一处，即：</p>
<p>①对于 mParsedPendingResults 来说，是ActivityResultRegistry.dispatchResult() (两个参数版本的)方法，该方法中会往 mParsedPendingResults容器中存放值。而该dispatchResult()方法正是ActivityResultRegistry 暴露给开发者，用来回调结果的。比如在该类的注释中这样写到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">You can create your own instance <span class="keyword">for</span> testing by overriding &#123;<span class="meta">@link</span> #onLaunch&#125; and calling</span><br><span class="line"> &#123;<span class="meta">@link</span> #dispatchResult&#125; immediately within it, thus skipping the actual</span><br><span class="line"> &#123;<span class="meta">@link</span> Activity#startActivityForResult&#125; call.</span><br></pre></td></tr></table></figure>

<p>②对于mPendingResults 来说，是ActivityResultRegistry.dispatchResult() (三个参数版本的)方法，该方法中会调用 doDispatch() 方法往mPendingResults容器中存放值。而该dispatchResult() 方法是交给 Activity.onActivityResult() 方法去调用的。这种情况下，如果没有找到对应的ActivityResultCallback(比如页面被销毁了) ，那么此时只有未解析的Intent data数据，只能存入 mPendingResults Bundle 中了。</p>
<p>而关于这俩属性中存储的数据的存储和恢复，详见后面章节。</p>
<h4 id="注册请求"><a href="#注册请求" class="headerlink" title="注册请求"></a>注册请求</h4><p>前面讲到了外部调用  ComponentActivity.registerForActivityResult() 方法之后，会转到 ActivityResultRegistry.register() 方法来执行。接下来就顺着该方法往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.result.ActivityResultRegistry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ActivityResultRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">register</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> String key,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> LifecycleOwner lifecycleOwner,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 通过传入的 lifecycleOwner 拿到对应的 Lifecycle 对象，后续用它来监测LifecycleOwner的生命周期变化</span></span><br><span class="line">        <span class="type">Lifecycle</span> <span class="variable">lifecycle</span> <span class="operator">=</span> lifecycleOwner.getLifecycle();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前是处于 ActivityResultApi 的第一步；注册，还没到启动的时候</span></span><br><span class="line"><span class="comment">         * 可以先注册，等到后续合适的时机再启动。</span></span><br><span class="line"><span class="comment">         * 对于注册来说，对它的要求是；必须在 onStart 之前完成，因为后续要统一在 onStart 中完成数据的存储</span></span><br><span class="line"><span class="comment">         * 一般是在 onCreate 或者是在成员属性定义时注册</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;LifecycleOwner &quot;</span> + lifecycleOwner + <span class="string">&quot; is &quot;</span></span><br><span class="line">                    + <span class="string">&quot;attempting to register while current state is &quot;</span></span><br><span class="line">                    + lifecycle.getCurrentState() + <span class="string">&quot;. LifecycleOwners must call register before &quot;</span></span><br><span class="line">                    + <span class="string">&quot;they are STARTED.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据传入的 key 来生成对应的 requestCode ，并且将其互相绑定起来</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">requestCode</span> <span class="operator">=</span> registerKey(key);</span><br><span class="line">        <span class="comment">// 为该key生成对应的 LifecycleContainer 实例，生成之前先检查之前是否已经为其生成过了</span></span><br><span class="line">        <span class="comment">// LifecycleContainer 其实就是将 Lifecycle 封装起来了而已，后期使用它就可以操作 Lifecycle 相关的注册和解除注册工作</span></span><br><span class="line">        <span class="type">LifecycleContainer</span> <span class="variable">lifecycleContainer</span> <span class="operator">=</span> mKeyToLifecycleContainers.get(key);</span><br><span class="line">        <span class="keyword">if</span> (lifecycleContainer == <span class="literal">null</span>) &#123;</span><br><span class="line">            lifecycleContainer = <span class="keyword">new</span> <span class="title class_">LifecycleContainer</span>(lifecycle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建个 LifecycleEventObserver ，用来检测生命周期</span></span><br><span class="line">        <span class="type">LifecycleEventObserver</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner lifecycleOwner, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Lifecycle.Event.ON_START.equals(event)) &#123;</span><br><span class="line">                    <span class="comment">// onStart 时，将注册进来的 ActivityResultContract 和 ActivityResultCallback 保存到 mKeyToCallback 中</span></span><br><span class="line">                    <span class="comment">// 这是代码层面的，具体分析见后续</span></span><br><span class="line">                    mKeyToCallback.put(key, <span class="keyword">new</span> <span class="title class_">CallbackAndContract</span>&lt;&gt;(callback, contract));</span><br><span class="line">                    <span class="comment">// 判断该key目前存在 有待分发出去的结果的话，那么将其结果分发出去吧</span></span><br><span class="line">                    <span class="comment">// 写在这里是因为 onActivityResult 一般是在 onResume 之前的，所以这里在 onStart 中回调</span></span><br><span class="line">                    <span class="keyword">if</span> (mParsedPendingResults.containsKey(key)) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="type">O</span> <span class="variable">parsedPendingResult</span> <span class="operator">=</span> (O) mParsedPendingResults.get(key);</span><br><span class="line">                        mParsedPendingResults.remove(key);</span><br><span class="line">                        callback.onActivityResult(parsedPendingResult);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 同上，分发结果。不同的是这里的结果是需要额外再解析一次的</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">ActivityResult</span> <span class="variable">pendingResult</span> <span class="operator">=</span> mPendingResults.getParcelable(key);</span><br><span class="line">                    <span class="keyword">if</span> (pendingResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                        mPendingResults.remove(key);</span><br><span class="line">                        callback.onActivityResult(contract.parseResult(</span><br><span class="line">                                pendingResult.getResultCode(),</span><br><span class="line">                                pendingResult.getData()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Lifecycle.Event.ON_STOP.equals(event)) &#123;</span><br><span class="line">                    <span class="comment">// 当 onStop 时，将 ActivityResultContract 和 ActivityResultCallback移除掉</span></span><br><span class="line">                    <span class="comment">// 因为当前页面 onStop 之后新页面压上来了，此时当前页面在后台可能会被杀掉后续重新创建</span></span><br><span class="line">                    mKeyToCallback.remove(key);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Lifecycle.Event.ON_DESTROY.equals(event)) &#123;</span><br><span class="line">                    <span class="comment">// 自动移除相关回调</span></span><br><span class="line">                    unregister(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将该观察者注册进去，后续就可以观察当前页面的生命周期变化了</span></span><br><span class="line">        lifecycleContainer.addObserver(observer);</span><br><span class="line">        mKeyToLifecycleContainers.put(key, lifecycleContainer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个 ActivityResultLauncher 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActivityResultLauncher</span>&lt;I&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(I input, <span class="meta">@Nullable</span> ActivityOptionsCompat options)</span> &#123;</span><br><span class="line">                <span class="comment">// 实现其 launch 方法，在该方法中会首先将 key 保存到 mLaunchedKeys 中，</span></span><br><span class="line">                <span class="comment">// 表示该 key 对应的 ActivityResultLauncher 已经启动过了</span></span><br><span class="line">                mLaunchedKeys.add(key);</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">innerCode</span> <span class="operator">=</span> mKeyToRc.get(key);</span><br><span class="line">                <span class="comment">// 执行真正的 launch 逻辑。交给子类来实现，比如 ComponentActivity 中的实现类，绝大多数情况也是它。</span></span><br><span class="line">                onLaunch((innerCode != <span class="literal">null</span>) ? innerCode : requestCode, contract, input, options);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 解除注册。可以不用手动调用，上面 LifecycleEventObserver 中帮你做过了</span></span><br><span class="line">                ActivityResultRegistry.<span class="built_in">this</span>.unregister(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@NonNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ActivityResultContract&lt;I, ?&gt; getContract() &#123;</span><br><span class="line">                <span class="keyword">return</span> contract;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">register</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> String key,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> &#123;</span><br><span class="line">        <span class="comment">// 和上面 register 类似</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">requestCode</span> <span class="operator">=</span> registerKey(key);</span><br><span class="line">        mKeyToCallback.put(key, <span class="keyword">new</span> <span class="title class_">CallbackAndContract</span>&lt;&gt;(callback, contract));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里开始产生差异，因为当前方法没有传入 LifecycleOwner ，所以没办法监测生命周期</span></span><br><span class="line">        <span class="comment">// 因此对于当前方法来说，只要注册就会尝试分发结果</span></span><br><span class="line">        <span class="comment">// 而且这种方式注册的，必须手动调用 unregister 方法。因为没有LifecycleOwner没办法做自动的</span></span><br><span class="line">        <span class="keyword">if</span> (mParsedPendingResults.containsKey(key)) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">O</span> <span class="variable">parsedPendingResult</span> <span class="operator">=</span> (O) mParsedPendingResults.get(key);</span><br><span class="line">            mParsedPendingResults.remove(key);</span><br><span class="line">            callback.onActivityResult(parsedPendingResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityResult</span> <span class="variable">pendingResult</span> <span class="operator">=</span> mPendingResults.getParcelable(key);</span><br><span class="line">        <span class="keyword">if</span> (pendingResult != <span class="literal">null</span>) &#123;</span><br><span class="line">            mPendingResults.remove(key);</span><br><span class="line">            callback.onActivityResult(contract.parseResult(</span><br><span class="line">                    pendingResult.getResultCode(),</span><br><span class="line">                    pendingResult.getData()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActivityResultLauncher</span>&lt;I&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(I input, <span class="meta">@Nullable</span> ActivityOptionsCompat options)</span> &#123;</span><br><span class="line">                mLaunchedKeys.add(key);</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">innerCode</span> <span class="operator">=</span> mKeyToRc.get(key);</span><br><span class="line">                onLaunch((innerCode != <span class="literal">null</span>) ? innerCode : requestCode, contract, input, options);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">()</span> &#123;</span><br><span class="line">                ActivityResultRegistry.<span class="built_in">this</span>.unregister(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@NonNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ActivityResultContract&lt;I, ?&gt; getContract() &#123;</span><br><span class="line">                <span class="keyword">return</span> contract;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册该key，返回该key对应的 requestCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">registerKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 先从 mKeyToRc 中查询该key是否已经注册过了，如果已经注册过了则直接返回之前的就行</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">existing</span> <span class="operator">=</span> mKeyToRc.get(key);</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> existing;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有注册过的话，则为其随机生成一个唯一不重复的 requestCode</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rc</span> <span class="operator">=</span> generateRandomNumber();</span><br><span class="line">        bindRcKey(rc, key);</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">generateRandomNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 mRandom 随机生成一个 requestCode ，如果生成的该code重复了则再重新生成一个直到不重复</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> mRandom.nextInt((Integer.MAX_VALUE - INITIAL_REQUEST_CODE_VALUE) + <span class="number">1</span>)</span><br><span class="line">                + INITIAL_REQUEST_CODE_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (mRcToKey.containsKey(number)) &#123;</span><br><span class="line">            number = mRandom.nextInt((Integer.MAX_VALUE - INITIAL_REQUEST_CODE_VALUE) + <span class="number">1</span>)</span><br><span class="line">                    + INITIAL_REQUEST_CODE_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 key 和 code 双向绑定起来，即分别存入到 mRcToKey 和 mKeyToRc 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindRcKey</span><span class="params">(<span class="type">int</span> rc, String key)</span> &#123;</span><br><span class="line">        mRcToKey.put(rc, key);</span><br><span class="line">        mKeyToRc.put(key, rc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中注释写的比较清楚了，但是额外还要补充几点：</p>
<p>1、首先需要明确几个重要方法的调用顺序。</p>
<p>onActivityResult() 方法是肯定在 onResume() 方法之前调用的。但是它和 onStart() 的顺序并没有规定，即可能在其前，也可以在其后。</p>
<p>2、ActivityResultApi 的使用是：先注册，再等待合适的时机调用其返回值 ActivityResultLauncher.launch()方法来完成真正的启动工作。</p>
<p>而对于第一步注册来说，当前库的要求是：必须要在 onStart()之前完成。而大多数场景一般就是在 onCreate() 中或者在成员方法定义时完成注册工作。这点在上面源码中也可以看出来，在其创建的LifecycleEventObserver中会统一在 onStart 时将 callback 等实例添加到mKeyToCallback 中。而如果你在 onStart 之后再注册的话，肯定会错过这个时间点。而关于为什么LifecycleEventObserver要在 onStart 中操作后面讲。</p>
<p>3、可以看到，注册之后其实并没有执行真正的跳转逻辑，只是其在内部分配变量，并存储起来而已，额外创建的 LifecycleEventObserver 用来监听并处理当前 LifecycleOwner 。</p>
<p>4、最后返回了一个 ActivityResultLauncher 实例，该实例中重写的 launch 方法中最终会将真正的跳转逻辑交给 onLaunch()去处理，而这个 onLaunch() 方法是抽象方法，一般是子类去实现的。</p>
<p>它的子类基本都是 ComponentActivity.mActivityResultRegistry 实例 ，该实例中实现了 onLaunch() 方法来完成真正的 startActivityForResult 动作。</p>
<p>所以说：注册是不会引起跳转的，只有 launch 方法调用才会触发真正的跳转逻辑。</p>
<p>5、创建的 LifecycleEventObserver 实例中，为什么要在 onStart 、onStop 、onDestroy 时处理数据呢？</p>
<p>首先我们知道 onActivityResult 方法肯定在 onResume 之前调用；但是可能会在 onStart 之前，也可能在 onStart 之后。而借助：mKeyToCallback 和 。mPendingResults 就可以解决该问题。</p>
<p>举个例子，比如目前有两个Activity，分别是A 和 B，目前在A中注册了ActivityResultApi的监听。</p>
<p>当前A 会按顺序执行 onStart ，最后处于 onResume ，当其执行 onStart 方法时，其内部对应的 LifecycleEventObserver 中会接受到 ON_START event ，此时会将当时注册时的key和对应 Callback 存储到 mKeyToCallback 中。</p>
<p>此时点击其中一个按钮后调用launch发生跳转，跳转到B。接着A页面会收到ON_STOP event，会将对应的Callback 从mKeyToCallback中移除掉。</p>
<p>最后等B页面返回退出后，那么A页面的 onActivityResult 和 onStart 会有一个先执行，另外一个后执行。</p>
<p>①假如先调用 A 的 onActivityResult ，后 onStart 。这种情况会先在 onActivityResult 中检查 mKeyToCallback 中是否存在对应key的Callback，此时肯定不存在，因为前面ON_STOP event时已经将对应Callback移除掉了。所以会将结果先暂存到 mPendingResults 中。接着往后执行到 A 页面的 ON_START event 中，此时再判断 mPendingResults 中有该key对应的值，那么将其解析并回调出去。</p>
<p>②假如先调用 A 的 onStart ，后onActivityResult 。那么会先在 ON_START event 中将对应key的Callback加入到mKeyToCallback 中，此时 mPendingResults 中应该是没有当前key对应的值的（先排除SaveInstance的异常情况）。接着执行 A 的 onActivityResult 方法，此时 mKeyToCallback中有了 Callback，那么就拿到 Callback 和 Contract 立马将结果回调出去</p>
<blockquote>
<p>注意这两种情况的差异：</p>
<p>第一种情况对于A来说，在使用ActivityResultApi之前，A应该是先收到 onActivityResult 后收到 onStart 的。但是在使用了 ActivityResultApi 之后，顺序变成了 先 onStart 执行，后 ActivityResultCallback.onActivityResult 了。(因为 Lifecycle 的 ON_START event 本来就是晚于Activity.onStart 的)</p>
<p>第二种情况对于A来说没啥变化。都还是先 onStart 执行，后 onActivityResult 。</p>
<p>因此说 ActivityResultApi 将这俩的顺序固定了。</p>
</blockquote>
<p>当然上面的分析还是不全，对于请求权限的场景时，比如在A页面使用ActivityResultApi来请求权限。其实A不会执行 ON_STOP ，而是只会执行 ON_PAUSE 。那么这种情况时，mKeyToCallback 中对应的Callback不会被移除，而是一直存在。等其授权结果完成后，到 onRequestPermissionsResult 方法中，在执行到 dispatchResult 中（和 onActivityResult 一样的），此时判断mKeyToCallback 中的Callback存在那么此时直接回调出去就行了。比上面启动 Activity 的情况简单些。</p>
<p>至此，写了这么多，其实也没有解答完当前的问题，可以说是只解答了ON_START 和 ON_STOP 中逻辑的一部分原因，因为我觉得还有另外一部分原因，即：当新的页面被启动之后，旧页面处于后台 onStop 状态，此时它可能会在系统内存不足的情况下被杀掉，这种情况时，在其刚进入后台那一刻的 onStop 方法中，将对应的 Callback 移除掉，可以用来避免内存泄露，因为它会持有外部Callback Contract 实例引用，如果其生命周期大于Activity 时就可能发生内存泄露。(猜测别人代码意图挺难的……)</p>
<p>而对于 ON_DESTROY 的话，则是将所有和当前key的相关的都移除或者解除注册.掉。</p>
<p>6、在 ActivityResultRegistry 中存在两个register() 方法，这俩有啥区别？</p>
<p>这俩方法入参区别是是否有 LifecycleOwner ，有的话则会自动做生命周期监测，等到页面生命周期变化时自动根据生命周期来在合适的时候回调结果。并且会在销毁时，自动解除注册。</p>
<p>而对于没有 LifecycleOwner的重载方法中，需要在不使用时，手动调 unregister 方法来解除注册。</p>
<p>而绝大多数使用场景下，都是使用有 LifecycleOwner 那个。</p>
<p>至此，就完成了 ActivityResultApi 注册的流程。</p>
<h4 id="请求执行"><a href="#请求执行" class="headerlink" title="请求执行"></a>请求执行</h4><p>注册完后，拿到返回的 ActivityResultLauncher 实例，就可以调用其 launch 方法来完成真正的启动工作了。</p>
<p>上面register() 方法中返回了一个内部的 ActivityResultLauncher 实例。下面简单贴一下相关代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.result.ActivityResultRegistry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ActivityResultRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">register</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> String key,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> LifecycleOwner lifecycleOwner,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个 ActivityResultLauncher 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActivityResultLauncher</span>&lt;I&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(I input, <span class="meta">@Nullable</span> ActivityOptionsCompat options)</span> &#123;</span><br><span class="line">                <span class="comment">// 实现其 launch 方法，在该方法中会首先将 key 保存到 mLaunchedKeys 中，</span></span><br><span class="line">                <span class="comment">// 表示该 key 对应的 ActivityResultLauncher 已经启动过了</span></span><br><span class="line">                mLaunchedKeys.add(key);</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">innerCode</span> <span class="operator">=</span> mKeyToRc.get(key);</span><br><span class="line">                <span class="comment">// 执行真正的 launch 逻辑。交给子类来实现，比如 ComponentActivity 中的实现类，绝大多数情况也是它。</span></span><br><span class="line">                onLaunch((innerCode != <span class="literal">null</span>) ? innerCode : requestCode, contract, input, options);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 解除注册。可以不用手动调用，上面 LifecycleEventObserver 中帮你做过了</span></span><br><span class="line">                ActivityResultRegistry.<span class="built_in">this</span>.unregister(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@NonNull</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ActivityResultContract&lt;I, ?&gt; getContract() &#123;</span><br><span class="line">                <span class="keyword">return</span> contract;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx.activity.ComponentActivity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentActivity</span> <span class="keyword">extends</span> <span class="title class_">androidx</span>.core.app.ComponentActivity <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ContextAware</span>,</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        HasDefaultViewModelProviderFactory,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner,</span><br><span class="line">        ActivityResultRegistryOwner,</span><br><span class="line">        ActivityResultCaller &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ActivityResultRegistry</span> <span class="variable">mActivityResultRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityResultRegistry</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;I, O&gt; <span class="keyword">void</span> <span class="title function_">onLaunch</span><span class="params">(</span></span><br><span class="line"><span class="params">                    <span class="keyword">final</span> <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">                    <span class="meta">@NonNull</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">                    I input,</span></span><br><span class="line"><span class="params">                    <span class="meta">@Nullable</span> ActivityOptionsCompat options)</span> &#123;</span><br><span class="line">                <span class="type">ComponentActivity</span> <span class="variable">activity</span> <span class="operator">=</span> ComponentActivity.<span class="built_in">this</span>;</span><br><span class="line">  </span><br><span class="line">                <span class="comment">// Immediate result path</span></span><br><span class="line">                <span class="comment">// 在正式发起跳转或者权限请求之前，先预先检查下是否已经有结果了</span></span><br><span class="line">                <span class="comment">// 如果已经有结果了的话，那么就直接回调出去，不执行后续操作了</span></span><br><span class="line">                <span class="comment">// 这种场景一般都是请求权限时会用到，即基本也就是权限相关的子类会实现 getSynchronousResult 方法</span></span><br><span class="line">                <span class="comment">// 其他正常跳转 activity 的基本该方法都是不实现，即返回null</span></span><br><span class="line">                <span class="keyword">final</span> ActivityResultContract.SynchronousResult&lt;O&gt; synchronousResult =</span><br><span class="line">                        contract.getSynchronousResult(activity, input);</span><br><span class="line">                <span class="keyword">if</span> (synchronousResult != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()).post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            dispatchResult(requestCode, synchronousResult.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">  </span><br><span class="line">                <span class="comment">// 接下来开始真正的页面启动工作</span></span><br><span class="line">                <span class="comment">// 先通过 ActivityResultContract.createIntent 方法来根据输入input创建对应的 Intent</span></span><br><span class="line">                <span class="comment">// Start activity path</span></span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> contract.createIntent(activity, input);</span><br><span class="line">                <span class="type">Bundle</span> <span class="variable">optionsBundle</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// If there are any extras, we should defensively set the classLoader</span></span><br><span class="line">                <span class="keyword">if</span> (intent.getExtras() != <span class="literal">null</span> &amp;&amp; intent.getExtras().getClassLoader() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    intent.setExtrasClassLoader(activity.getClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (intent.hasExtra(EXTRA_ACTIVITY_OPTIONS_BUNDLE)) &#123;</span><br><span class="line">                    optionsBundle = intent.getBundleExtra(EXTRA_ACTIVITY_OPTIONS_BUNDLE);</span><br><span class="line">                    intent.removeExtra(EXTRA_ACTIVITY_OPTIONS_BUNDLE);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options != <span class="literal">null</span>) &#123;</span><br><span class="line">                    optionsBundle = options.toBundle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是用来请求权限的，那么就执行 requestPermissions 方法</span></span><br><span class="line">                <span class="comment">// 这种最后接收结果回调是在当前 Activity 的 onRequestPermissionsResult 方法中的</span></span><br><span class="line">                <span class="keyword">if</span> (ACTION_REQUEST_PERMISSIONS.equals(intent.getAction())) &#123;</span><br><span class="line">  </span><br><span class="line">                    <span class="comment">// requestPermissions path</span></span><br><span class="line">                    String[] permissions = intent.getStringArrayExtra(EXTRA_PERMISSIONS);</span><br><span class="line">  </span><br><span class="line">                    <span class="keyword">if</span> (permissions == <span class="literal">null</span>) &#123;</span><br><span class="line">                        permissions = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">  </span><br><span class="line">                    ActivityCompat.requestPermissions(activity, permissions, requestCode);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_INTENT_SENDER_REQUEST.equals(intent.getAction())) &#123;</span><br><span class="line">                    <span class="type">IntentSenderRequest</span> <span class="variable">request</span> <span class="operator">=</span></span><br><span class="line">                            intent.getParcelableExtra(EXTRA_INTENT_SENDER_REQUEST);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// startIntentSenderForResult path</span></span><br><span class="line">                        ActivityCompat.startIntentSenderForResult(activity, request.getIntentSender(),</span><br><span class="line">                                requestCode, request.getFillInIntent(), request.getFlagsMask(),</span><br><span class="line">                                request.getFlagsValues(), <span class="number">0</span>, optionsBundle);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IntentSender.SendIntentException e) &#123;</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()).post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                dispatchResult(requestCode, RESULT_CANCELED,</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">Intent</span>().setAction(ACTION_INTENT_SENDER_REQUEST)</span><br><span class="line">                                                .putExtra(EXTRA_SEND_INTENT_EXCEPTION, e));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// startActivityForResult path</span></span><br><span class="line">                    <span class="comment">// 如果是用来启动Activity的，那么就执行 startActivityForResult 方法</span></span><br><span class="line">                    <span class="comment">// 这种最后接收结果回调是在当前 Activity 的 onActivityResult 方法中的</span></span><br><span class="line">                    ActivityCompat.startActivityForResult(activity, intent, requestCode, optionsBundle);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用注册返回的 ActivityResultLauncher.launch() 方法之后，首先会将当前 key 加到 mLaunchedKeys 中，表示当前key 已经调用过 launch 方法但还没有收到最终的结果。最后会在接收到结果之后将key从该列表中移除。</p>
<p>接着会调用到 onLaunch 方法中来完成真正的启动逻辑。</p>
<p>关于 onLaunch 方法中的逻辑，基本都在注释中体现了，这里不再做过多补充。</p>
<h4 id="结果处理"><a href="#结果处理" class="headerlink" title="结果处理"></a>结果处理</h4><p>调用 launch 方法完成真正的启动工作之后，会启动新的 Activity ，或者弹出权限弹框。对于这两种方式来说，接受到结果的方法不同，前者是：onActivityResult ,后者是 onRequestPermissionsResult 。而这俩方法里面的逻辑倒是差不多的，都是走到 ActivityResultRegistry#dispatchResult 方法（三个参数的重载版本）中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.ComponentActivity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentActivity</span> <span class="keyword">extends</span> <span class="title class_">androidx</span>.core.app.ComponentActivity <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ContextAware</span>,</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        HasDefaultViewModelProviderFactory,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner,</span><br><span class="line">        ActivityResultRegistryOwner,</span><br><span class="line">        ActivityResultCaller &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@CallSuper</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> &#123;</span><br><span class="line">            <span class="comment">// 先通知里面，能处理则处理，处理不了则交给super去处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mActivityResultRegistry.dispatchResult(requestCode, resultCode, data)) &#123;</span><br><span class="line">                <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">        <span class="meta">@CallSuper</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequestPermissionsResult</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> String[] permissions,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="type">int</span>[] grantResults)</span> &#123;</span><br><span class="line">            <span class="comment">// 先通知里面，能处理则处理，处理不了则交给super去处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mActivityResultRegistry.dispatchResult(requestCode, Activity.RESULT_OK, <span class="keyword">new</span> <span class="title class_">Intent</span>()</span><br><span class="line">                    .putExtra(EXTRA_PERMISSIONS, permissions)</span><br><span class="line">                    .putExtra(EXTRA_PERMISSION_GRANT_RESULTS, grantResults))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">                    <span class="built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx.activity.result.ActivityResultRegistry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ActivityResultRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">dispatchResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent data)</span> &#123;</span><br><span class="line">        <span class="comment">// 先从 mRcToKey 中取出对应的 key ，如果之前register过的话，则肯定存在 requestCode 和 key 的映射</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> mRcToKey.get(requestCode);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 mLaunchedKeys 中移除，表示该 key 现在拿到结果了</span></span><br><span class="line">        mLaunchedKeys.remove(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里需要从  mKeyToCallback 中取出对应的 Callback 和 Contract ，用来回调结果</span></span><br><span class="line">        doDispatch(key, resultCode, data, mKeyToCallback.get(key));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;O&gt; <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(String key, <span class="type">int</span> resultCode, <span class="meta">@Nullable</span> Intent data,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> CallbackAndContract&lt;O&gt; callbackAndContract)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果此时找到了对应的   Callback 和 Contract ，那么就此时回调出去</span></span><br><span class="line">        <span class="keyword">if</span> (callbackAndContract != <span class="literal">null</span> &amp;&amp; callbackAndContract.mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            ActivityResultCallback&lt;O&gt; callback = callbackAndContract.mCallback;</span><br><span class="line">            ActivityResultContract&lt;?, O&gt; contract = callbackAndContract.mContract;</span><br><span class="line">            callback.onActivityResult(contract.parseResult(resultCode, data));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则就先将结果暂存着，等后续再回调出去</span></span><br><span class="line">            <span class="comment">// Remove any parsed pending result</span></span><br><span class="line">            mParsedPendingResults.remove(key);</span><br><span class="line">            <span class="comment">// And add these pending results in their place</span></span><br><span class="line">            mPendingResults.putParcelable(key, <span class="keyword">new</span> <span class="title class_">ActivityResult</span>(resultCode, data));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，在结果回调拿到之后，会取出之前注册时保存的 Contract 和 Callback 并回调出去。</p>
<p>当然这里情况很多，更详细的流程分析在上面分析 register() 方法时已经提到过了，可以翻看上面的。</p>
<p>至此，就分析完了ActivityResultApi的注册启动以及接受到结果的整体代码了。</p>
<h4 id="数据保存和恢复"><a href="#数据保存和恢复" class="headerlink" title="数据保存和恢复"></a>数据保存和恢复</h4><p>在ActivityResultRegistry 中额外还处理了一些异常情况，比如异常时数据的保存和恢复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.activity.ComponentActivity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentActivity</span> <span class="keyword">extends</span> <span class="title class_">androidx</span>.core.app.ComponentActivity <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ContextAware</span>,</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        HasDefaultViewModelProviderFactory,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner,</span><br><span class="line">        ActivityResultRegistryOwner,</span><br><span class="line">        ActivityResultCaller &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ComponentActivity</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 注册 saveInstance 回调，用于在异常发生时，比如内存不足时的数据保存工作</span></span><br><span class="line">            getSavedStateRegistry().registerSavedStateProvider(ACTIVITY_RESULT_TAG,</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        <span class="type">Bundle</span> <span class="variable">outState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">                        <span class="comment">// 调用到 ActivityResultRegistry#onSaveInstanceState 方法中去保存其内部数据</span></span><br><span class="line">                        <span class="comment">// 因此可以将 ActivityResultRegistry#onSaveInstanceState 当做是 Activity#onSaveInstanceState 来理解</span></span><br><span class="line">                        mActivityResultRegistry.onSaveInstanceState(outState);</span><br><span class="line">                        <span class="keyword">return</span> outState;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在当前 Activity onCreate() 执行时，会回调到这里来。</span></span><br><span class="line">            addOnContextAvailableListener(context -&gt; &#123;</span><br><span class="line">                <span class="comment">// 拿到之前onSaveInstanceState时保存的 bundle </span></span><br><span class="line">                <span class="type">Bundle</span> <span class="variable">savedInstanceState</span> <span class="operator">=</span> getSavedStateRegistry()</span><br><span class="line">                        .consumeRestoredStateForKey(ACTIVITY_RESULT_TAG);</span><br><span class="line">                <span class="comment">// 将其传递到 ActivityResultRegistry#onRestoreInstanceState 方法中</span></span><br><span class="line">                <span class="comment">// 因此 ActivityResultRegistry#onRestoreInstanceState 方法被调用的时机是 onCreate 时，这个需要记住</span></span><br><span class="line">                <span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>) &#123;</span><br><span class="line">                    mActivityResultRegistry.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx.activity.result.ActivityResultRegistry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ActivityResultRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常时保存数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">onSaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Bundle outState)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存数据</span></span><br><span class="line">        outState.putIntegerArrayList(KEY_COMPONENT_ACTIVITY_REGISTERED_RCS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mKeyToRc.values()));</span><br><span class="line">        outState.putStringArrayList(KEY_COMPONENT_ACTIVITY_REGISTERED_KEYS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mKeyToRc.keySet()));</span><br><span class="line">        outState.putStringArrayList(KEY_COMPONENT_ACTIVITY_LAUNCHED_KEYS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mLaunchedKeys));</span><br><span class="line">        outState.putBundle(KEY_COMPONENT_ACTIVITY_PENDING_RESULTS,</span><br><span class="line">                (Bundle) mPendingResults.clone());</span><br><span class="line">        outState.putSerializable(KEY_COMPONENT_ACTIVITY_RANDOM_OBJECT, mRandom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">onRestoreInstanceState</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 挨个读取出之前保存的数据</span></span><br><span class="line">        ArrayList&lt;Integer&gt; rcs =</span><br><span class="line">                savedInstanceState.getIntegerArrayList(KEY_COMPONENT_ACTIVITY_REGISTERED_RCS);</span><br><span class="line">        ArrayList&lt;String&gt; keys =</span><br><span class="line">                savedInstanceState.getStringArrayList(KEY_COMPONENT_ACTIVITY_REGISTERED_KEYS);</span><br><span class="line">        <span class="keyword">if</span> (keys == <span class="literal">null</span> || rcs == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mLaunchedKeys =</span><br><span class="line">                savedInstanceState.getStringArrayList(KEY_COMPONENT_ACTIVITY_LAUNCHED_KEYS);</span><br><span class="line">        mRandom = (Random) savedInstanceState.getSerializable(KEY_COMPONENT_ACTIVITY_RANDOM_OBJECT);</span><br><span class="line">        mPendingResults.putAll(</span><br><span class="line">                savedInstanceState.getBundle(KEY_COMPONENT_ACTIVITY_PENDING_RESULTS));</span><br><span class="line">        <span class="comment">// keys 是读取出来之前保存的 mKeyToRc ，即 key 到 requestCode 的映射表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; keys.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keys.get(i);</span><br><span class="line">            <span class="comment">// Developers may have already registered with this same key by the time we restore</span></span><br><span class="line">            <span class="comment">// state, which caused us to generate a new requestCode that doesn&#x27;t match what we&#x27;re</span></span><br><span class="line">            <span class="comment">// about to restore. Clear out the new requestCode to ensure that we use the</span></span><br><span class="line">            <span class="comment">// previously saved requestCode.</span></span><br><span class="line">            <span class="comment">// 如果之前保存的和现在新注册的 key 有重复的，那么就清楚新的，保留旧的</span></span><br><span class="line">            <span class="keyword">if</span> (mKeyToRc.containsKey(key)) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">newRequestCode</span> <span class="operator">=</span> mKeyToRc.remove(key);</span><br><span class="line">                <span class="comment">// On the chance that developers have already called launch() with this new</span></span><br><span class="line">                <span class="comment">// requestCode, keep the mapping around temporarily to ensure the result is</span></span><br><span class="line">                <span class="comment">// properly delivered to both the new requestCode and the restored requestCode</span></span><br><span class="line">                <span class="keyword">if</span> (!mPendingResults.containsKey(key)) &#123;</span><br><span class="line">                    mRcToKey.remove(newRequestCode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将恢复出来可用的 key requestCode  绑定起来</span></span><br><span class="line">            bindRcKey(rcs.get(i), keys.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释中说的比较明白了，下面只是额外补充几点：</p>
<p>1、ActivityResultRegistry#onRestoreInstanceState 方法的调用时机是在 onCreate() 时，即在当前页面重建时的 onCreate 中。而 ActivityResultRegistry#onSaveInstanceState 方法则还是和 Activity 的调用时机一样。</p>
<p>onRestoreInstanceState 在onCreate 中调用的话，表示其恢复工作肯定是早于 onStart 的，因此前面说的逻辑照样可用，即在 接受到ON_START event 时，会处理 mPendingResults 中的结果，而这种情况下mPendingResults中存储的是恢复出来的结果，此时会将其在 onStart 时回调出去。</p>
<h3 id="相关源码分析-Fragment"><a href="#相关源码分析-Fragment" class="headerlink" title="相关源码分析 - Fragment"></a>相关源码分析 - Fragment</h3><p>对于 Fragment 来说，它也实现了 ActivityResultCaller 接口，说明后续支持直接在 Fragment 中调用 ActivityResultApi。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.fragment.app.Fragment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fragment</span> <span class="keyword">implements</span> <span class="title class_">ComponentCallbacks</span>, OnCreateContextMenuListener, LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner,</span><br><span class="line">        ActivityResultCaller &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@MainThread</span></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">registerForActivityResult</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> &#123;</span><br><span class="line">            <span class="comment">// 没有传入 ActivityResultRegistry ，这种方式是最常见的</span></span><br><span class="line">            <span class="keyword">return</span> prepareCallInternal(contract, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Void, ActivityResultRegistry&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> ActivityResultRegistry <span class="title function_">apply</span><span class="params">(Void input)</span> &#123;</span><br><span class="line">                    <span class="comment">// 没有传入 ActivityResultRegistry 的话，则指定 ActivityResultRegistry 为外部Activity 的</span></span><br><span class="line">                    <span class="comment">// 也就是使用 ComponentActivity 中的 ActivityResultRegistry 实例</span></span><br><span class="line">                    <span class="keyword">if</span> (mHost <span class="keyword">instanceof</span> ActivityResultRegistryOwner) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ((ActivityResultRegistryOwner) mHost).getActivityResultRegistry();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> requireActivity().getActivityResultRegistry();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, callback);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="meta">@MainThread</span></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">registerForActivityResult</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultRegistry registry,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> &#123;</span><br><span class="line">            <span class="comment">// 指定了 ActivityResultRegistry ，那么就使用它就行了，即在下面 apply 中返回入参 registry</span></span><br><span class="line">            <span class="keyword">return</span> prepareCallInternal(contract, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Void, ActivityResultRegistry&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> ActivityResultRegistry <span class="title function_">apply</span><span class="params">(Void input)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> registry;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, callback);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">private</span> &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; <span class="title function_">prepareCallInternal</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> Function&lt;Void, ActivityResultRegistry&gt; registryProvider,</span></span><br><span class="line"><span class="params">                <span class="meta">@NonNull</span> <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> &#123;</span><br><span class="line">            <span class="comment">// Throw if attempting to register after the Fragment is CREATED.</span></span><br><span class="line">            <span class="comment">// 跟 Activity 的一样，必须在 ON_START 之前完成注册，对于Fragment 来说就是要在其 onStart 方法之前定义</span></span><br><span class="line">            <span class="comment">// 你可以在 Fragment 的 onAttach onCreate  onCreateView  中定义</span></span><br><span class="line">            <span class="keyword">if</span> (mState &gt; CREATED) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Fragment &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; is attempting to &quot;</span></span><br><span class="line">                        + <span class="string">&quot;registerForActivityResult after being created. Fragments must call &quot;</span></span><br><span class="line">                        + <span class="string">&quot;registerForActivityResult() before they are created (i.e. initialization, &quot;</span></span><br><span class="line">                        + <span class="string">&quot;onAttach(), or onCreate()).&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用来存储 register 之后的 ActivityResultLauncher</span></span><br><span class="line">            <span class="keyword">final</span> AtomicReference&lt;ActivityResultLauncher&lt;I&gt;&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// We can&#x27;t call generateActivityResultKey during initialization of the Fragment</span></span><br><span class="line">            <span class="comment">// since we need to wait for the mWho to be restored from saved instance state</span></span><br><span class="line">            <span class="comment">// so we&#x27;ll wait until we have all the information needed to register  to actually</span></span><br><span class="line">            <span class="comment">// generate the key and register.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册回调，当执行当前 Fragment onAttach 时，会调用该回调</span></span><br><span class="line">            registerOnPreAttachListener(<span class="keyword">new</span> <span class="title class_">OnPreAttachedListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">void</span> <span class="title function_">onPreAttached</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 跟 Activity 一样，也是创建key，然后调用 ActivityResultRegistry 的 register 方法</span></span><br><span class="line">                    <span class="comment">// 将返回的  ActivityResultLauncher 保存到外部的变量  ref 中，等待后续 launch 时调用</span></span><br><span class="line">                    <span class="comment">// 一般情况下，onAttach 方法肯定比launch 方法先执行，所以等到后续调用launch方法时，ref 中肯定都有值</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> generateActivityResultKey();</span><br><span class="line">                    <span class="type">ActivityResultRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> registryProvider.apply(<span class="literal">null</span>);</span><br><span class="line">                    ref.set(registry.register(key, Fragment.<span class="built_in">this</span>, contract, callback));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里返回一个新的 ActivityResultLauncher 实例，内部使用 ref 来完成真正的逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActivityResultLauncher</span>&lt;I&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(I input, <span class="meta">@Nullable</span> ActivityOptionsCompat options)</span> &#123;</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    ActivityResultLauncher&lt;I&gt; delegate = ref.get();</span><br><span class="line">                    <span class="keyword">if</span> (delegate == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Operation cannot be started before fragment &quot;</span></span><br><span class="line">                                + <span class="string">&quot;is in created state&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    delegate.launch(input, options);</span><br><span class="line">                &#125;</span><br><span class="line">  </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">()</span> &#123;</span><br><span class="line">                    ActivityResultLauncher&lt;I&gt; delegate = ref.getAndSet(<span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (delegate != <span class="literal">null</span>) &#123;</span><br><span class="line">                        delegate.unregister();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">  </span><br><span class="line">                <span class="meta">@NonNull</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> ActivityResultContract&lt;I, ?&gt; getContract() &#123;</span><br><span class="line">                    <span class="keyword">return</span> contract;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerOnPreAttachListener</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> OnPreAttachedListener callback)</span> &#123;</span><br><span class="line">            <span class="comment">//If we are already attached, we can register immediately</span></span><br><span class="line">            <span class="keyword">if</span> (mState &gt;= ATTACHED) &#123;</span><br><span class="line">                callback.onPreAttached();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// else we need to wait until we are attached</span></span><br><span class="line">                mOnPreAttachedListeners.add(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        String <span class="title function_">generateActivityResultKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;fragment_&quot;</span> + mWho + <span class="string">&quot;_rq#&quot;</span> + mNextLocalRequestCode.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 Activity 的大同小异，具体的就不做分析了，看上面源代码中的注释应该就可以懂了。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="ActivityResultContracts"><a href="#ActivityResultContracts" class="headerlink" title="ActivityResultContracts"></a>ActivityResultContracts</h3><p>这个类中提供了常用的一些 ActivityResultContract 的实现，比如最常见的 StartActivityForResult ，它可以用于之前的 startActivityForResult ；以及RequestPermission用来替代传统的权限请求。</p>
<p>当然除了这俩还有很多封装好现成的类可以直接用。这里就不做展示了，可以自行搜索这个类来查找自己需要的。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Jetpack/">Jetpack</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/de9ff6b8.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">AOSP-RC-File</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/84ecfaa3.html">
        <span class="next-text nav-default">Jetpack- LiveData</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
