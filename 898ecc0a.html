<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="OkHttp 请求创建"/>




  <meta name="keywords" content="okhttp," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/898ecc0a.html"/>


<meta name="description" content="在Android应用层开发中，应该基本都听说过 Okhttp 的名号吧，他应该可以算得上是目前Android平台上使用最为广泛的开源网络库了吧。并且在 Android 6.0之后，也将其内部的 HttpUrlConnection 的默认实现替换成了 Okhttp。这种局面的造成，正是因为该库的优秀性，以致于后面出来的 Retrofit 库也是基于它来做的二次封装。 而相比其他开源库来说，OkHtt">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp 请求创建">
<meta property="og:url" content="https://youngkaaa.github.io/898ecc0a.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="在Android应用层开发中，应该基本都听说过 Okhttp 的名号吧，他应该可以算得上是目前Android平台上使用最为广泛的开源网络库了吧。并且在 Android 6.0之后，也将其内部的 HttpUrlConnection 的默认实现替换成了 Okhttp。这种局面的造成，正是因为该库的优秀性，以致于后面出来的 Retrofit 库也是基于它来做的二次封装。 而相比其他开源库来说，OkHtt">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-21T13:48:56.000Z">
<meta property="article:modified_time" content="2023-03-08T11:46:42.453Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="okhttp">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> OkHttp 请求创建 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          OkHttp 请求创建
        
      </h1>

      <time class="post-time">
          1月 21 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>在Android应用层开发中，应该基本都听说过 Okhttp 的名号吧，他应该可以算得上是目前Android平台上使用最为广泛的开源网络库了吧。并且在 Android 6.0之后，也将其内部的 HttpUrlConnection 的默认实现替换成了 Okhttp。这种局面的造成，正是因为该库的优秀性，以致于后面出来的 Retrofit 库也是基于它来做的二次封装。</p>
<p>而相比其他开源库来说，OkHttp中的源码，以及其项目结构都是很复杂的，而本文主要先介绍 OkHttp 中的 Call ，主要分析从一个请求发起到构建出Call 这个过程。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>从一个简单的例子开始，方便后续的分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetExample</span> &#123;</span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    		<span class="comment">// 构建请求</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line">				<span class="comment">// 发起请求</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute()) &#123;</span><br><span class="line">            <span class="keyword">return</span> response.body().string();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">GetExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetExample</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> example.run(<span class="string">&quot;https://raw.github.com/square/okhttp/master/README.md&quot;</span>);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是官方源码中提供的一个示例。可以看到，使用Okhttp很简单，首先创建一个 OkHttpClient 实例，接着创建 Request 实例，调用 OkhttpClient 的newCall() 方法构建一个 Call 对象实例，接着调用其 execute() 方法就可以拿到结果了。下面则先介绍这里出现的这些类。</p>
<h3 id="基础类介绍"><a href="#基础类介绍" class="headerlink" title="基础类介绍"></a>基础类介绍</h3><h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><p>先看其定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Call</span> <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Request <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isExecuted</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCanceled</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    Timeout <span class="title function_">timeout</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    okhttp3.Call <span class="title function_">clone</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">        okhttp3.Call <span class="title function_">newCall</span><span class="params">(Request request)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Call 是一个接口，它内部提供了enquene() 和 execute() 方法来发起请求，这俩的区别是前者是异步的，所以会接受callback入参返回void；而后者是同步的，所以他不需要入参并且返回请求结果 Response 实例。</p>
<p>额外的还提供了 cancel() 方法用于取消请求，以及其他方法这里不再介绍。</p>
<p>注意，其内部还定义了一个 Factory 接口，用于构建生成一个 Call 实例。</p>
<p>####OkHttpClient</p>
<p>先简单看下它的类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OkHttpClient</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, Call.Factory, WebSocket.Factory &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OkHttpClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">okhttp3</span>.OkHttpClient.Builder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OkHttpClient(okhttp3.OkHttpClient.Builder builder) &#123;</span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它实现了 Call.Factory 接口，所以其内部自然是要实现 newCall() 方法来返回一个 Call 接口实例的。</p>
<p>简单的熟悉完这俩类之后，后续就可以开始源码分析了。</p>
<h3 id="OkHttpClient-的创建"><a href="#OkHttpClient-的创建" class="headerlink" title="OkHttpClient 的创建"></a>OkHttpClient 的创建</h3><p>首先来看 OkHttpClient 实例的创建。在上面的示例中使用的是它的无参构造方法，这是最简便的一种方式，当然还有另外一种支持定制化的方式：使用Builder模式来创建。</p>
<p>在 OkHttpClient 中额外还定义了一个 Builder ，它内部定义了一系列的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    Dispatcher dispatcher;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Proxy proxy;</span><br><span class="line">    List&lt;Protocol&gt; protocols;</span><br><span class="line">    List&lt;ConnectionSpec&gt; connectionSpecs;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    EventListener.Factory eventListenerFactory;</span><br><span class="line">    ProxySelector proxySelector;</span><br><span class="line">    CookieJar cookieJar;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Cache cache;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    InternalCache internalCache;</span><br><span class="line">    SocketFactory socketFactory;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    SSLSocketFactory sslSocketFactory;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    CertificateChainCleaner certificateChainCleaner;</span><br><span class="line">    HostnameVerifier hostnameVerifier;</span><br><span class="line">    CertificatePinner certificatePinner;</span><br><span class="line">    Authenticator proxyAuthenticator;</span><br><span class="line">    Authenticator authenticator;</span><br><span class="line">    ConnectionPool connectionPool;</span><br><span class="line">    Dns dns;</span><br><span class="line">    <span class="type">boolean</span> followSslRedirects;</span><br><span class="line">    <span class="type">boolean</span> followRedirects;</span><br><span class="line">    <span class="type">boolean</span> retryOnConnectionFailure;</span><br><span class="line">    <span class="type">int</span> callTimeout;</span><br><span class="line">    <span class="type">int</span> connectTimeout;</span><br><span class="line">    <span class="type">int</span> readTimeout;</span><br><span class="line">    <span class="type">int</span> writeTimeout;</span><br><span class="line">    <span class="type">int</span> pingInterval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分发器，另有一个带线程池参数的构造器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dispatcher = <span class="keyword">new</span> <span class="title class_">Dispatcher</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 支持的协议，默认为HTTP_2、HTTP_1_1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 传输层版本、连接协议</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line"></span><br><span class="line">        eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line"></span><br><span class="line">        proxySelector = ProxySelector.getDefault();</span><br><span class="line">        <span class="keyword">if</span> (proxySelector == <span class="literal">null</span>) &#123;</span><br><span class="line">            proxySelector = <span class="keyword">new</span> <span class="title class_">NullProxySelector</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">        socketFactory = SocketFactory.getDefault();</span><br><span class="line">        hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">        certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">        proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">        authenticator = Authenticator.NONE;</span><br><span class="line">        connectionPool = <span class="keyword">new</span> <span class="title class_">ConnectionPool</span>();</span><br><span class="line">        dns = Dns.SYSTEM;</span><br><span class="line">        followSslRedirects = <span class="literal">true</span>;</span><br><span class="line">        followRedirects = <span class="literal">true</span>;</span><br><span class="line">        retryOnConnectionFailure = <span class="literal">true</span>;</span><br><span class="line">        callTimeout = <span class="number">0</span>;</span><br><span class="line">        connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">        readTimeout = <span class="number">10_000</span>;</span><br><span class="line">        writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">        pingInterval = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他设置属性的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里列出来的属性都是支持定制化的，即先通过创建 Builder 实例，再通过调用指定方法来定制化修改其中的属性，最后调用 Builder 实例的 build() 方法来创建并返回一个 OkHttpClient 实例。</p>
<p>Builder 的这种方式其实在实际项目开发中是使用最多的，因为基本都会有属性的定制化。</p>
<h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>在拿到 OkHttpClient 实例后，一般调用其 ： newCall() 方法，传入一个 Request 实例，返回一个 Call 接口的实现类，再使用该 Call 实例的 enqueue() 方法或者 execute() 方法来发起请求就行。</p>
<blockquote>
<p>对于 Request 实例来说，它的作用可以理解为是一个数据类，内部存储着一次请求所需要的数据，比如必不可少的请求地址url，以及请求方式 GET 还是 POST 等，或者说还有额外的 header 、body 等，这些都会被存储在 Request 中。</p>
</blockquote>
<p>接下来看 newCall() 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OkHttpClient.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RealCall.java</span></span><br><span class="line"><span class="keyword">static</span> RealCall <span class="title function_">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="type">boolean</span> forWebSocket)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里创建出来的 RealCall 对象只是保存了一下这些变量而已</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">RealCall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealCall</span>(client, originalRequest, forWebSocket);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 刚新建好 RealCall 之后就新建一个 Transmitter 对象实例</span></span><br><span class="line"><span class="comment">     * 所以说，每个 RealCall 对象中都会有一个属于它自己的 Transmitter 对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    call.transmitter = <span class="keyword">new</span> <span class="title class_">Transmitter</span>(client, call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="type">boolean</span> forWebSocket)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.client = client;</span><br><span class="line">    <span class="built_in">this</span>.originalRequest = originalRequest;</span><br><span class="line">    <span class="built_in">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实际返回的 Call接口实例是：RealCall ，它实现了 Call 接口中的方法，并且暴露了一个静态方法 newRealCall() 用来构建 RealCall 实例。创建实例时会将当前 OkHttpClient 实例，以及 Request 实例保存起来，额外还会为其创建一个 Transmitter 实例，关于他是什么，用处是什么等后面遇到了再说。</p>
<p>接下来调用这个 RealCall 的 execute() 方法或者 enqueue() 方法来发起请求。下面我们分情况来看这俩方法：</p>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//加锁执行</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// executed 是 RealCall 中的成员变量，使用它来标识当前 RealCall 是否被执行过</span></span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">        <span class="comment">// 置为true</span></span><br><span class="line">        executed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求超时开始计时</span></span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    <span class="comment">// 请求开始前的准备</span></span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前 call 对象加入到调度器中的 runningSyncCalls 队列中</span></span><br><span class="line">        client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 执行真正的请求逻辑</span></span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 执行完毕，将该 call 从调度器 runningSyncCalls 队列中移除</span></span><br><span class="line">        client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dispatcher.java</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">executed</span><span class="params">(RealCall call)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里只是将其加入到 runningSyncCalls 队列中等待后续调度执行</span></span><br><span class="line">    runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 execute() 方法中，首先会判断当前 RealCall 对象中的成员变量executed 的值，进而判断出当前 RealCall 实例是否已经被执行过了，如果已被执行过则抛出异常。所以说，一个 RealCall 只能被执行一次。</p>
<p>接着会调用 transmitter 的 timeoutEnter() 和 callStart() 方法完成请求前的准备工作，比如开始超时监测；在此之外还会调用 client.dispatcher() 方法拿到该 RealCall 所对应的 OkHttpClient 中的调度器实例：Dispatcher 。这个调度器可以在创建 OkHttpClient 时通过 Builder 自定义设置，一般都是默认的实现，它内部可以完成该 OkHttpClient 中的所有请求调度，包括最大请求数控制等。其内部会维护好几个队列用来存储不同状态的请求，下面简单看看它的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequests</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequestsPerHost</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span></span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span></span><br><span class="line">    ExecutorService executorService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall.AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall.AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dispatcher</span><span class="params">(ExecutorService executorService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorService = executorService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dispatcher</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它内部定义了三个队列：</p>
<p>① readyAsyncCalls：当前准备好了的异步请求，等待被执行。</p>
<p>② runningAsyncCalls ：当前正在运行处理中的请求，包括了那些被取消但是还没有取消成功的异步请求。</p>
<p>③ runningSyncCalls ： 正在运行中的同步方式的请求。</p>
<p>可以看到，这里三个队列中，前两个是给异步请求用的，它内部存储的是AsyncCall 类型的实例；另外一个队列存储的是同步方式的请求，它对应的类型是 RealCall 。调度器中剩余逻辑等到遇到时再说。</p>
<p>回到上面 execute() 方法中，在请求真正开始执行之前会调用：client.dispatcher().executed(this) 方法来将当前 RealCall 实例保存到 Dispatcher 中的 runningSyncCalls 队列中，表示该同步请求正在执行中了。</p>
<p>接着往下会执行  getResponseWithInterceptorChain() 方法来完成真正的请求工作，该方法暂时先放着后面再一起讲。</p>
<p>接着往下会在 finally 块中执行：client.dispatcher().finished(this) 方法，通知调度器当前 RealCall  同步请求执行完毕了。下面看看调度器中是怎么处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(RealCall call)</span> &#123;</span><br><span class="line">    <span class="comment">// 由于当前是同步请求 RealCall 执行完毕了，所以操作的队列应该是 runningSyncCalls</span></span><br><span class="line">    finished(runningSyncCalls, call);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> &#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先尝试从 runningSyncCalls 队列中删除该 Call ，删除失败时抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);</span><br><span class="line">        idleCallback = <span class="built_in">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试去调度异步请求，返回值表示当前是否还有请求在执行，包括同步和异步的请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> promoteAndExecute();</span><br><span class="line">    <span class="comment">// 如果当前没有请求执行即位于空闲状态，此时尝试去执行外部设置的idle事务</span></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">promoteAndExecute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line">    List&lt;RealCall.AsyncCall&gt; executableCalls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从 readyAsyncCalls 中开始遍历，拿到目前等待处理运行的 AsyncCall 放入到 executableCalls 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;RealCall.AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            RealCall.<span class="type">AsyncCall</span> <span class="variable">asyncCall</span> <span class="operator">=</span> i.next();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 同时运行的异步请求个数不能超过64个，超过的话则 readyAsyncCalls 中的异步请求就得等待着</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 请求数没有超限的话，就判断当前这个等待执行的异步请求的host 是否超限，</span></span><br><span class="line"><span class="comment">             * 即同一个host下有最多同时存在5个异步请求</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 上面那俩条件都不满足，此时该异步请求可以被执行了，将其加入到 executableCalls 和 runningAsyncCalls 中</span></span><br><span class="line">            i.remove();</span><br><span class="line">            asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">            executableCalls.add(asyncCall);</span><br><span class="line">            runningAsyncCalls.add(asyncCall);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 当前是否有请求正在运行中，包括同步请求和异步请求</span></span><br><span class="line">        isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历 executableCalls 中的 AsyncCall ，挨个提交到线程池中去处理</span></span><br><span class="line"><span class="comment">     * 最终执行的是 AsyncCall # execute</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">        RealCall.<span class="type">AsyncCall</span> <span class="variable">asyncCall</span> <span class="operator">=</span> executableCalls.get(i);</span><br><span class="line">        asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">runningCallsCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 包括同步请求和异步请求</span></span><br><span class="line">    <span class="keyword">return</span> runningAsyncCalls.size() + runningSyncCalls.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说在这里的同步请求执行完毕之后，会将其从之前保存的 runningSyncCalls 队列中移除掉它，表示其执行完毕了。</p>
<p>而这里在 finished() 方法中还会去执行 promoteAndExecute() 方法来完成异步请求的调度，调度规则是：1）同时运行的最大异步请求数不能超过 64 ；2）同一个host下的异步请求不能同时运行超过5个。</p>
<p>至此，就完成了对 execute() 方法的分析，除了其中核心的 getResponseWithInterceptorChain() 方法，而该方法等会儿再讲，下面先看另外一个方法 enqueue() 。</p>
<h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a>enqueue</h4><p>先看相关的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 还是先判断是否执行过</span></span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">        executed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始前的准备</span></span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="comment">// 新建一个 AsyncCall ，里面最终还是会调用到 getResponseWithInterceptorChain 中</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">RealCall</span>.AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 enqueue() 方法中，还是会先判断 executed 的值，避免当前Call被多次执行。</p>
<p>接着会将入参 Callback 包装成一个 AsyncCall 实例，再调用调度器的 enqueue() 方法来将其入队，等待调度处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(RealCall.AsyncCall call)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 将其加入到待执行的队列中，等待后续调度执行</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">        <span class="comment">// the same host.</span></span><br><span class="line">        <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">            RealCall.<span class="type">AsyncCall</span> <span class="variable">existingCall</span> <span class="operator">=</span> findExistingCallWithHost(call.host());</span><br><span class="line">            <span class="comment">// 如果找到了一个相同host 的异步请求，则这里复用其内部的 callsPerHost 计数的值</span></span><br><span class="line">            <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调度异步请求队列</span></span><br><span class="line">    promoteAndExecute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RealCall.AsyncCall <span class="title function_">findExistingCallWithHost</span><span class="params">(String host)</span> &#123;</span><br><span class="line">    <span class="comment">// 从正在运行的异步请求队列中找到一个和当前异步请求相同 host 的</span></span><br><span class="line">    <span class="keyword">for</span> (RealCall.AsyncCall existingCall : runningAsyncCalls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (existingCall.host().equals(host)) <span class="keyword">return</span> existingCall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从待执行的异步请求队列中找</span></span><br><span class="line">    <span class="keyword">for</span> (RealCall.AsyncCall existingCall : readyAsyncCalls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (existingCall.host().equals(host)) <span class="keyword">return</span> existingCall;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 dequeue() 方法中，首先会将当前准备执行的异步请求实例 AsyncCall 保存到  readyAsyncCalls 队列中等待调度。</p>
<p>接着还会寻找一个相同host的异步请求AsyncCall 实例，复用该实例中的 callsPerHost 属性，也就是将之前对于该 host 的计数继承了下来，后续基于它来自增。所以说，同一个host的所有异步请求AsyncCall 实例中的 callsPerHost 属性都指向同一个 AtomicInteger 实例。</p>
<p>最后调用 promoteAndExecute() 方法来重新调度一次 异步请求队列，该方法上面讲过了，最终如果被调度到了的话，会执行 AsyncCall 的 executeOn() 方法，下面顺便看看这个 AsyncCall 的庐山真面目 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span> <span class="keyword">extends</span> <span class="title class_">NamedRunnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line">    <span class="comment">// 用来为当前请求的 host 计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">callsPerHost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;OkHttp %s&quot;</span>, redactedUrl());</span><br><span class="line">        <span class="built_in">this</span>.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AtomicInteger <span class="title function_">callsPerHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> callsPerHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reuseCallsPerHostFrom</span><span class="params">(RealCall.AsyncCall other)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callsPerHost = other.callsPerHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">host</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Request <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RealCall <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.<span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调度器调度执行时会走该方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">executeOn</span><span class="params">(ExecutorService executorService)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 最终还是执行到下面的 execute 方法中</span></span><br><span class="line">            executorService.execute(<span class="built_in">this</span>);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            <span class="type">InterruptedIOException</span> <span class="variable">ioException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptedIOException</span>(<span class="string">&quot;executor rejected&quot;</span>);</span><br><span class="line">            ioException.initCause(e);</span><br><span class="line">            transmitter.noMoreExchanges(ioException);</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="built_in">this</span>, ioException);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                client.dispatcher().finished(<span class="built_in">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * run() 方法中实际执行的是本方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">signalledCallback</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        transmitter.timeoutEnter();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 拿到请求结果</span></span><br><span class="line">            <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">            signalledCallback = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 回调出去</span></span><br><span class="line">            responseCallback.onResponse(RealCall.<span class="built_in">this</span>, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">                Platform.get().log(INFO, <span class="string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            cancel();</span><br><span class="line">            <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">                <span class="type">IOException</span> <span class="variable">canceledException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;canceled due to &quot;</span> + t);</span><br><span class="line">                canceledException.addSuppressed(t);</span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="built_in">this</span>, canceledException);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 最后移除该 Call</span></span><br><span class="line">            client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AsyncCall 实际是实现了 NamedRunnable 接口，内部将 Runnable 的 run() 方法转而包装成了 execute() 方法，所以 AsyncCall 后续被线程池执行时，会调用到其内部的  execute() 方法中。</p>
<p>而从调度器 Dispatcher 中被调度执行时，会走到 AsyncTask 中的 executeOn() 方法内，进而被线程池调度处理，最后执行到 execute() 方法中。</p>
<p>在 AsyncCall 的 execute() 方法中，还是会执行 getResponseWithInterceptorChain() 方法拿到请求返回值，再通过回调 responseCallback 返回出去。</p>
<p>在最后的 finally 中还是会执行 client.dispatcher().finished(this) 方法来将当前 AsyncCall 移除掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(RealCall.AsyncCall call)</span> &#123;</span><br><span class="line">    <span class="comment">// 将该 host 的计数减一</span></span><br><span class="line">    call.callsPerHost().decrementAndGet();</span><br><span class="line">    finished(runningAsyncCalls, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，可以知道： RealCall 中的execute() 方法是同步请求的，它在调度器中对应的是 RealCall 自身；enqueue() 方法异步请求的，他在调度器中对应 AsyncCall 实例。</p>
<p>接着往后，就是请求的真正执行了，也就是前面 execute() 和 enqueue() 方法最终汇集到一起的 getResponseWithInterceptorChain() 方法。</p>
<h4 id="getResponseWithInterceptorChain"><a href="#getResponseWithInterceptorChain" class="headerlink" title="getResponseWithInterceptorChain"></a>getResponseWithInterceptorChain</h4><p>先看它的源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall.java</span></span><br><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  </span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 先将 OkHttpClient 中设置的 interceptors 保存起来</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">// 接下来按顺序保存这些内置拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">RetryAndFollowUpInterceptor</span>(client));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        <span class="comment">// 接下来再将 OkHttpClient 中设置的 networkInterceptors 保存起来</span></span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再接着加入 CallServerInterceptor</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 责任链模式，将这些保存好的拦截器设置进去，后续只需要调用 chain.proceed() 方法就可以按顺序执行这些拦截器了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>,</span><br><span class="line">            originalRequest, <span class="built_in">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">            client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">calledNoMoreExchanges</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 chain.proceed 开始执行拦截器</span></span><br><span class="line">        <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.proceed(originalRequest);</span><br><span class="line">        <span class="comment">// 当前已被取消，此时终止执行</span></span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">            closeQuietly(response);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        calledNoMoreExchanges = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            transmitter.noMoreExchanges(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法内部会构建一个拦截链，这个拦截链上会有多个拦截器，而拦截链的左右就是将这些拦截器串起来，挨个去执行。下面先看拦截器列表的构建：</p>
<p>① 首先是将 client.interceptors() 中返回的，之前外部开发者设置给 OkHttpClient 的那些拦截器保存进去。具体设置的方法是通过 OkHttpClient.Builder 的 addInterceptor() ，即在创建出 OkHttpClient 实例之前就需要确定好拦截器。</p>
<p>② 接着往拦截器列表中加入 RetryAndFollowUpInterceptor</p>
<p>③ 接着往拦截器列表中加入BridgeInterceptor</p>
<p>④ 接着往拦截器列表中加入CacheInterceptor</p>
<p>⑤ 接着往拦截器列表中加入ConnectInterceptor</p>
<p>⑥ 接着往拦截器列表中加入 client.networkInterceptors() 方法返回的列表，即之前通过 OkHttpClient.Builder 的addNetworkInterceptor() 方法指定的那些拦截器。</p>
<p>⑦ 最后往拦截器列表中加入 CallServerInterceptor 。</p>
<p>至此，拦截器列表就确定好了，接着就是使用它来创建一个拦截链 Interceptor.Chain 的实例 RealInterceptorChain ，最后调用其 proceed() 方法将初始的 Request 对象实例传入进去，开始执行拦截链。</p>
<p>接下来就先简单看看这里面的拦截器和拦截链的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interceptor.java</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    Response <span class="title function_">intercept</span><span class="params">(okhttp3.Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">        Request <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        Response <span class="title function_">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span> Connection <span class="title function_">connection</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        Call <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">connectTimeoutMillis</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        okhttp3.Interceptor.Chain <span class="title function_">withConnectTimeout</span><span class="params">(<span class="type">int</span> timeout, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">readTimeoutMillis</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        okhttp3.Interceptor.Chain <span class="title function_">withReadTimeout</span><span class="params">(<span class="type">int</span> timeout, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="title function_">writeTimeoutMillis</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        okhttp3.Interceptor.Chain <span class="title function_">withWriteTimeout</span><span class="params">(<span class="type">int</span> timeout, TimeUnit unit)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器的定义很简单，就是一个接口，内部只有一个 intercept() 方法，接收一个 Interceptor.Chain 参数，也就是接收拦截链实例。</p>
<p>而拦截链的定义也不复杂，最主要的就是其 proceed() 方法，用于执行该拦截链，使其往下接着去执行，接收一个 Request 参数，表示当前状态下的请求参数。因为对于拦截链中的拦截器来说，在执行时可能会在上一个拦截器中修改 Request 来给后续的拦截器来使用，所以这里说的是 当前状态下的请求参数 。</p>
<p>回到 getResponseWithInterceptorChain() 方法中来，接着往下看 ： RealInterceptorChain 的 proceed()方法是怎么执行的，在此之前，我们先看看这里创建这个 RealInterceptorChain 实例时设置的参数吧，除了将刚计算出来的拦截器列表保存了起来，额外还有一个 index &#x3D; 0，即将 RealInterceptorChain 中的 index 属性置为了0 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealInterceptorChain.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request, Transmitter transmitter, <span class="meta">@Nullable</span> Exchange exchange)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 判断当前拦截链的合法性，即当前 index 的索引值是否已经超限</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前状态合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.exchange != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.exchange.connection().supportsUrl(request.url())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">&quot; must retain the same host and port&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.exchange != <span class="literal">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">&quot; must call proceed() exactly once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 每次执行拦截链的 proceed() 方法，都会在其内部新建一个 RealInterceptorChain ，这个对象实例和当前对象实例的唯一区别就是 index</span></span><br><span class="line"><span class="comment">     * 即新创建的 RealInterceptorChain 中的 index 是当前 RealInterceptorChain 实例中index+1 之后的结果</span></span><br><span class="line"><span class="comment">     * 也就是这个新建的 RealInterceptorChain 开始执行时，是从下一个拦截器开始执行的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, transmitter, exchange,</span><br><span class="line">            index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 上面构建好后续的拦截链了，这里就开始处理当前拦截链中的拦截器了，也就是拦截器列表中的 index 位置的拦截器</span></span><br><span class="line">    <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line">    <span class="comment">// 执行该拦截器，拿到其返回的结果</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;network interceptor &quot;</span> + interceptor</span><br><span class="line">                + <span class="string">&quot; must call proceed() exactly once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;interceptor &quot;</span> + interceptor + <span class="string">&quot; returned null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;interceptor &quot;</span> + interceptor + <span class="string">&quot; returned a response with no body&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 proceed() 方法内部，会再次创建一个拦截链 RealInterceptorChain 实例，该实例中只有 index 值自增了1，其他都没变，那么等后续执行这个拦截链 RealInterceptorChain 的 proceed() 方法时，就会从当前 index+1 的位置所对应的拦截器开始往后执行。</p>
<p>回到当前 RealInterceptorChain 中的 proceed() 方法中来，它接着就是执行它所对应的 index 位置的拦截器了，找到那个拦截器，调用其 intercept () 方法，此时会将这个新的 拦截链 RealInterceptorChain 实例传入进去，用于在拦截器内部触发拦截链的剩余拦截逻辑。</p>
<p>假设外部开发者没有给 OkHttpClient 设置 Interceptors 和 NetworkInterceptors  ，那么此时拦截器列表中的第一个拦截器就是 RetryAndFollowUpInterceptor ，接着往后的拦截器依次是：BridgeInterceptor、CacheInterceptor、ConnectInterceptor、CallServerInterceptor 。所以下面基于这个顺序来举例：</p>
<p>① 第一次在 getResponseWithInterceptorChain() 方法中创建了 RealInterceptorChain 实例，此时其 index &#x3D; 0，接着执行其 proceed() 方法，其内部会再创建一个 RealInterceptorChain 实例，其 index &#x3D; 1。然后执行 RetryAndFollowUpInterceptor 中的 intercept 方法来将这个 index &#x3D; 1 的 RealInterceptorChain 实例传入进去。</p>
<p>② 到了 RetryAndFollowUpInterceptor 中的 intercept 方法中，处理完自己的逻辑之后，调用入参拦截链实例，也就是那个 index &#x3D; 1 的 RealInterceptorChain 实例的 proceed() 方法来接着执行拦截链剩余逻辑。此时进入到 RealInterceptorChain 的 proceed() 方法中，此时会再次新建一个 index &#x3D;2 的RealInterceptorChain实例，接着调用 BridgeInterceptor 的 intercept() 方法来将这个 index &#x3D;2 的RealInterceptorChain实例传入进去。</p>
<p>③ 到了BridgeInterceptor 中的 intercept 方法中，重复上面②中的逻辑….</p>
<p>④ 到了 CacheInterceptor 中的 intercept 方法中，重复上面②中的逻辑….</p>
<p>⑤ 到了 ConnectInterceptor 中的 intercept 方法中，重复上面②中的逻辑….</p>
<p>⑥ 到了 CallServerInterceptor 中的 intercept 方法中，重复上面②中的逻辑….</p>
<p>这样的话，这些拦截器都会挨个被执行，并且由于拦截链是传入给拦截器中的，所以拦截器可以控制拦截链的进行，即在某个拦截器中如果已经拿到自己想要的结果，觉得不需要再执行后续拦截器了，则可以直接返回结果而不去执行拦截链的 proceed() 方法，中断拦截器的后续传递。</p>
<blockquote>
<p>这种设计也叫做责任链模式</p>
</blockquote>
<p>所以说，执行完 getResponseWithInterceptorChain() 方法之后就可以拿到最终请求的结果了。所以后续的逻辑主要就是在这些拦截器中了，详细分析见下文：<a href="52da40ac.html">OkHttp 拦截器介绍</a></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/okhttp/">okhttp</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/52da40ac.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">OkHttp 拦截器介绍</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/d414997b.html">
        <span class="next-text nav-default">ARouter 原理分析</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
