<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Surface学习(一)--ComposerService"/>




  <meta name="keywords" content="AndroidFrameworks,Surface," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/99318d8c.html"/>


<meta name="description" content="SurfaceFlinger 是运行在单独的进程内的，而其他APP运行在各自的进程内，这些APP中有时候需要与SurfaceFlinger 进行一些通讯，比如APP中要监听来自SurfaceFlinger 的vsync 信号；或者APP中要在新页面启动时往 SurfaceFlinger 中添加 Layer 。这些操作都需要这些APP进程与SurfaceFlinger 进程通讯。 下面讲讲在Andr">
<meta property="og:type" content="article">
<meta property="og:title" content="Surface学习(一)--ComposerService">
<meta property="og:url" content="https://youngkaaa.github.io/99318d8c.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="SurfaceFlinger 是运行在单独的进程内的，而其他APP运行在各自的进程内，这些APP中有时候需要与SurfaceFlinger 进行一些通讯，比如APP中要监听来自SurfaceFlinger 的vsync 信号；或者APP中要在新页面启动时往 SurfaceFlinger 中添加 Layer 。这些操作都需要这些APP进程与SurfaceFlinger 进程通讯。 下面讲讲在Andr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/99318d8c/image1.png">
<meta property="article:published_time" content="2022-07-01T11:48:56.000Z">
<meta property="article:modified_time" content="2023-02-24T12:28:49.130Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="Surface">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/99318d8c/image1.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Surface学习(一)--ComposerService - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Surface学习(一)--ComposerService
        
      </h1>

      <time class="post-time">
          7月 01 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>SurfaceFlinger 是运行在单独的进程内的，而其他APP运行在各自的进程内，这些APP中有时候需要与SurfaceFlinger 进行一些通讯，比如APP中要监听来自SurfaceFlinger 的vsync 信号；或者APP中要在新页面启动时往 SurfaceFlinger 中添加 Layer 。这些操作都需要这些APP进程与SurfaceFlinger 进程通讯。</p>
<p>下面讲讲在Android 中怎么实现这些操作的。在正式阅读之前，建议先翻看下我的Binder系列文章，对Binder有个简单认识。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="ISurfaceComposer"><a href="#ISurfaceComposer" class="headerlink" title="ISurfaceComposer"></a>ISurfaceComposer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ISurfaceComposer.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISurfaceComposer</span>:</span> public IInterface &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 定义binder的方法</span></span><br><span class="line">    DECLARE_META_INTERFACE(SurfaceComposer)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Rotation</span> &#123;</span></span><br><span class="line">        eRotateNone = <span class="number">0</span>,</span><br><span class="line">        eRotate90   = <span class="number">1</span>,</span><br><span class="line">        eRotate180  = <span class="number">2</span>,</span><br><span class="line">        eRotate270  = <span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 vsync 监听时设置的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">VsyncSource</span> &#123;</span></span><br><span class="line">        eVsyncSourceApp = <span class="number">0</span>,</span><br><span class="line">        eVsyncSourceSurfaceFlinger = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;ISurfaceComposerClient&gt; <span class="title function_">createConnection</span><span class="params">()</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IDisplayEventConnection&gt; <span class="title function_">createDisplayEventConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">            VsyncSource vsyncSource = eVsyncSourceApp,</span></span><br><span class="line"><span class="params">            ConfigChanged configChanged = eConfigChangedSuppress)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual sp&lt;IBinder&gt; <span class="title function_">createDisplay</span><span class="params">(<span class="type">const</span> String8&amp; displayName,</span></span><br><span class="line"><span class="params">            <span class="type">bool</span> secure)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">destroyDisplay</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; display)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ISurfaceComposer 是一个接口，继承自 IInterface ，如果熟悉Binder的话就能知道它是一个Binder接口定义，对于他来说应该还有个Bn 和 Bp的实现，分别供Binder Server 和Binder Client 端来实现的。这里就不贴相关代码了。</p>
<h4 id="Binder-Server侧"><a href="#Binder-Server侧" class="headerlink" title="Binder Server侧"></a>Binder Server侧</h4><p>对于该接口，它的 Binder server侧的实现是交给 SurfaceFlinger 的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceFlinger</span> :</span> public BnSurfaceComposer,</span><br><span class="line">                       public PriorityDumper,</span><br><span class="line">                       public ClientCache::ErasedRecipient,</span><br><span class="line">                       private IBinder::DeathRecipient,</span><br><span class="line">                       private HWC2::ComposerCallback &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceFlinger 实现了 BnSurfaceComposer 接口。说明它就是 ISurfaceComposer 接口的Binder server 端实现。</p>
<p>接下来来看看SurfaceFlinger 中对于 ISurfaceComposer 接口中关键方法的实现。</p>
<h5 id="createConnection"><a href="#createConnection" class="headerlink" title="createConnection"></a>createConnection</h5><p>先看看其源码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposerClient&gt; <span class="title">SurfaceFlinger::createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1、创建了 Client 实例，然后将 SurfaceFlinger 实例this传入进去</span></span><br><span class="line"><span class="comment">   * 2、调用 initClient 方法来检查Client是否初始化成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">initClient</span>(<span class="keyword">new</span> <span class="built_in">Client</span>(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> sp&lt;ISurfaceComposerClient&gt; <span class="title">initClient</span><span class="params">(<span class="type">const</span> sp&lt;Client&gt; &amp;client)</span> </span>&#123;</span><br><span class="line">  <span class="type">status_t</span> err = client-&gt;<span class="built_in">initCheck</span>();</span><br><span class="line">  <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法返回一个 ISurfaceComposerClient 实例，而ISurfaceComposerClient 也是一个 Binder接口，Client 是其Binder Server端实现，更具体的分析下面会讲。</p>
<h5 id="createDisplayEventConnection"><a href="#createDisplayEventConnection" class="headerlink" title="createDisplayEventConnection"></a>createDisplayEventConnection</h5><p>先看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">SurfaceFlinger::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ISurfaceComposer::VsyncSource vsyncSource, ISurfaceComposer::ConfigChanged configChanged)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> resyncCallback = mScheduler-&gt;<span class="built_in">makeResyncCallback</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">    Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据传入的 vsyncSource 来确定外部需要注册的是 surfaceFlinger 的还是 app 的 vsync EventThreadConnection</span></span><br><span class="line"><span class="comment">   * 不过一般都是 app 的，因为其他进程的app需要监听vsync信号时，会从其 Choreographer 中通过 FrameDisplayEventReceiver </span></span><br><span class="line"><span class="comment">   * 再通过 DisplayEventReceiver构造方法调用到其对应native的 nativeInit() 方法中，进而调用到这里</span></span><br><span class="line"><span class="comment">   * 拿到这里返回的  EventThreadConnection （它是 IDisplayEventConnection 的Binder server侧实现）</span></span><br><span class="line"><span class="comment">   * 再通过 bitTube 也就是 socket 来监听 vsync 信号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> &amp;handle =</span><br><span class="line">      vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建 EventThreadConnection 并返回</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> mScheduler-&gt;<span class="built_in">createDisplayEventConnection</span>(handle, std::<span class="built_in">move</span>(resyncCallback),</span><br><span class="line">                                                  configChanged);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheduler.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">Scheduler::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;Scheduler::ConnectionHandle&gt; &amp;handle, ResyncCallback resyncCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">    ISurfaceComposer::ConfigChanged configChanged)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里通过 handle 拿到之前创建好的 EventThread</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">createConnectionInternal</span>(mConnections[handle-&gt;id]-&gt;thread.<span class="built_in">get</span>(),</span><br><span class="line">                                  std::<span class="built_in">move</span>(resyncCallback), configChanged);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">Scheduler::createConnectionInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    EventThread *eventThread, ResyncCallback &amp;&amp;resyncCallback, ISurfaceComposer::ConfigChanged configChanged)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 里面其实就是 new 一个 EventThreadConnection ，然后把入参都包装起来而已</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>(std::<span class="built_in">move</span>(resyncCallback), configChanged);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法主要是创建并返回一个 IDisplayEventConnection 接口实例，而该接口也是个 Binder 接口，实际返回的是其 Binder server侧实现：EventThreadConnection 。看到这个类是不是有点熟悉了，它是在前面 SurfaceFlinger::init() 初始化方法中讲到的。</p>
<p>当时只讲了：在SurfaceFlinger 初始化时会创建sf  EventThread 和 app EventThread ，以及会立马注册一个 sf 的Vsync 监听，但是没有注册app 的 vysnc 监听，而这里便是注册app的(主要是注册app的，还支持注册sf的)。更多的请翻看SurfaceFlinger 初始化的文章<a href="2fa835ad.html">SurfaceFlinger</a>。</p>
<p>其他的方法实现等后续遇到了再做补充吧。</p>
<h4 id="Binder-Client侧"><a href="#Binder-Client侧" class="headerlink" title="Binder Client侧"></a>Binder Client侧</h4><p>对于该接口，Binder client 侧主要是使用它。即使用 IServiceManager.getService() 方法来获取ISurfaceComposer 的 client 端实现类 BpSurfaceComposer 的实例。</p>
<p>而为了方便起见，源码中提供了一个 ComposerService 类来方便拿到该实例。</p>
<h5 id="ComposerService"><a href="#ComposerService" class="headerlink" title="ComposerService"></a>ComposerService</h5><p>先看下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComposerService.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 它是一个单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComposerService</span> : <span class="keyword">public</span> Singleton&lt;ComposerService&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取到的 ISurfaceComposer 的 BpSurfaceComposer 实例</span></span><br><span class="line"><span class="comment">     * binder client 使用它就可以发起对 binder server 的调用了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sp&lt;ISurfaceComposer&gt; mComposerService;</span><br><span class="line">    sp&lt;IBinder::DeathRecipient&gt; mDeathObserver;</span><br><span class="line">    Mutex mLock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ComposerService</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connectLocked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">composerServiceDied</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;ComposerService&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a connection to the Composer Service.  This will block until</span></span><br><span class="line">    <span class="comment">// a connection is established.</span></span><br><span class="line">    <span class="function"><span class="type">static</span> sp&lt;ISurfaceComposer&gt; <span class="title">getComposerService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从他的定义可以看出他是个单例类，内部的 mComposerService 属性存储了对应的 BpSurfaceComposer 实例。</p>
<p>接着看看它的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在其实例创建时就会尝试去获取 ISurfaceComposer 对应的binder服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ComposerService::<span class="built_in">ComposerService</span>()</span><br><span class="line">    : <span class="built_in">Singleton</span>&lt;ComposerService&gt;() &#123;</span><br><span class="line">  Mutex::Autolock _l(mLock);</span><br><span class="line">  <span class="built_in">connectLocked</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ComposerService::connectLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 按服务名查找 Service，ISurfaceComposer 对应的服务名是：SurfaceFlinger</span></span><br><span class="line">  <span class="function"><span class="type">const</span> String16 <span class="title">name</span><span class="params">(<span class="string">&quot;SurfaceFlinger&quot;</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 从 sm 中查找该服务，查找到之后将其封装为 BpSurfaceComposer 实例并赋值给 mComposerService</span></span><br><span class="line">  <span class="comment">// 因此这里的 mComposerService 对应的是 ISurfaceComposer 对应的client侧实现，使用它就可以发起对 server 的调用了</span></span><br><span class="line">  <span class="comment">// 如果没找到的话则等待一会儿再去查找</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">getService</span>(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">250000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(mComposerService != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 death 监听，当远端server 的服务死掉之后这边会收到回调从而去执行 composerServiceDied 方法</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">DeathObserver</span> : <span class="keyword">public</span> IBinder::DeathRecipient &#123;</span><br><span class="line">    ComposerService &amp;mComposerService;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">binderDied</span><span class="params">(<span class="type">const</span> wp&lt;IBinder&gt; &amp;who)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">ALOGW</span>(<span class="string">&quot;ComposerService remote (surfaceflinger) died [%p]&quot;</span>,</span><br><span class="line">            who.<span class="built_in">unsafe_get</span>());</span><br><span class="line">      mComposerService.<span class="built_in">composerServiceDied</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DeathObserver</span><span class="params">(ComposerService &amp;mgr)</span> : mComposerService(mgr) &#123;</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  mDeathObserver = <span class="keyword">new</span> <span class="built_in">DeathObserver</span>(*<span class="built_in">const_cast</span>&lt;ComposerService *&gt;(<span class="keyword">this</span>));</span><br><span class="line">  IInterface::<span class="built_in">asBinder</span>(mComposerService)-&gt;<span class="built_in">linkToDeath</span>(mDeathObserver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*static*/</span> <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">ComposerService::getComposerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ComposerService 是单例的</span></span><br><span class="line">  ComposerService &amp; instance = ComposerService::<span class="built_in">getInstance</span>();</span><br><span class="line">  Mutex::Autolock _l(instance.mLock);</span><br><span class="line">  <span class="comment">// 判断单例的 ComposerService 内部的 mComposerService 是否为null，为null则表示是第一次获取</span></span><br><span class="line">  <span class="keyword">if</span> (instance.mComposerService == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 为null则此时尝试去获取</span></span><br><span class="line">    ComposerService::<span class="built_in">getInstance</span>().<span class="built_in">connectLocked</span>();</span><br><span class="line">    <span class="built_in">assert</span>(instance.mComposerService != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;ComposerService reconnected&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance.mComposerService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IServiceManager.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">getService</span><span class="params">(<span class="type">const</span> String16&amp; name, sp&lt;INTERFACE&gt;* outService)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 首先拿到 sm 在当前进程的代理实例</span></span><br><span class="line">    <span class="type">const</span> sp&lt;IServiceManager&gt; sm = <span class="built_in">defaultServiceManager</span>();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再使用它来调用 getService 发起binder请求获取到该服务对应的handle等值</span></span><br><span class="line"><span class="comment">         * 最后调用 interface_cast 将其包装成 BpSurfaceComposer 实例返回并赋值给 outService</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *outService = <span class="built_in">interface_cast</span>&lt;INTERFACE&gt;(sm-&gt;<span class="built_in">getService</span>(name));</span><br><span class="line">        <span class="keyword">if</span> ((*outService) != <span class="literal">nullptr</span>) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NAME_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 ComposerService 类就相当于是一个工具类，方便获取 ISurfaceComposer 的binder client端实现。</p>
<p>后期如果想要对 SurfaceFlinger 发起请求，就可以调用 ComposerService::getComposerService() 方法来获取其对应的在当前进程的 ISurfaceComposer 实现。拿到它之后就可以调用其对应方法来跟 SurfaceFlinger 通讯了。</p>
<h3 id="ISurfaceComposerClient"><a href="#ISurfaceComposerClient" class="headerlink" title="ISurfaceComposerClient"></a>ISurfaceComposerClient</h3><p>前面讲的 ISurfaceComposer 是对应着 SurfaceFlinger 的，而 SurfaceFlinger 全局只有一个实例。而这里的 ISurfaceComposerClient 相当于是针对  ISurfaceComposer 又分叉开的子类。即一个 ISurfaceComposer 中可以对应有多个 ISurfaceComposerClient ，实际对应的 Binder server 端来说就是：一个SurfaceFlinger 可以对应有多个 Client 。</p>
<p>先看看其定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ISurfaceComposerClient.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ISurfaceComposerClient</span> : <span class="keyword">public</span> IInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DECLARE_META_INTERFACE</span>(SurfaceComposerClient)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// createSurface 时要用到的 flag</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; <span class="comment">// (keep in sync with Surface.java)</span></span><br><span class="line">        eHidden = <span class="number">0x00000004</span>,</span><br><span class="line">        eDestroyBackbuffer = <span class="number">0x00000020</span>,</span><br><span class="line">        eSecure = <span class="number">0x00000080</span>,</span><br><span class="line">        eNonPremultiplied = <span class="number">0x00000100</span>,</span><br><span class="line">        eOpaque = <span class="number">0x00000400</span>,</span><br><span class="line">        eProtectedByApp = <span class="number">0x00000800</span>,</span><br><span class="line">        eProtectedByDRM = <span class="number">0x00001000</span>,</span><br><span class="line">        eCursorWindow = <span class="number">0x00002000</span>,</span><br><span class="line"></span><br><span class="line">        eFXSurfaceBufferQueue = <span class="number">0x00000000</span>,</span><br><span class="line">        eFXSurfaceColor = <span class="number">0x00020000</span>,</span><br><span class="line">        eFXSurfaceBufferState = <span class="number">0x00040000</span>,</span><br><span class="line">        eFXSurfaceContainer = <span class="number">0x00080000</span>,</span><br><span class="line">        eFXSurfaceMask = <span class="number">0x000F0000</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Requires ACCESS_SURFACE_FLINGER permission</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Requires ACCESS_SURFACE_FLINGER permission</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">createWithSurfaceParent</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Requires ACCESS_SURFACE_FLINGER permission</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">clearLayerFrameStats</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Requires ACCESS_SURFACE_FLINGER permission</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">getLayerFrameStats</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle, FrameStats* outStats)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ISurfaceComposerClient 也是继承自 IInterface 的，所以它和上面 ISurfaceComposer 类似，也支持 Binder 调用，同样也存在Bp 和 Bn 的实现。</p>
<h4 id="Binder-Server侧-1"><a href="#Binder-Server侧-1" class="headerlink" title="Binder Server侧"></a>Binder Server侧</h4><p>先看其对应的实现类的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> : <span class="keyword">public</span> BnSurfaceComposerClient</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Client</span><span class="params">(<span class="type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span></span>;</span><br><span class="line">    ~<span class="built_in">Client</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">initCheck</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// protected by SurfaceFlinger::mStateLock</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attachLayer</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle, <span class="type">const</span> sp&lt;Layer&gt;&amp; layer)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detachLayer</span><span class="params">(<span class="type">const</span> Layer* layer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;Layer&gt; <span class="title">getLayerUser</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ISurfaceComposerClient interface</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt;&amp; parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   sp&lt;IGraphicBufferProducer&gt;* gbp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">createWithSurfaceParent</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             sp&lt;IGraphicBufferProducer&gt;* gbp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">clearLayerFrameStats</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">getLayerFrameStats</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle, FrameStats* outStats)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; mFlinger;</span><br><span class="line"></span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, wp&lt;Layer&gt; &gt; mLayers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> Mutex mLock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于 ISurfaceComposerClient 接口来说，其Binder server侧的实现类是：Client。该类的定义如上，其中额外还定义了一些字段，下面简单介绍下：</p>
<p>1、mFlinger：对应的 SurfaceFlinger 实例，因为该 Client 是由 SurfaceFlinger::createConnection方法创建出来的，在创建时会自动将该 SurfaceFlinger 实例保存到当前 Client 中，而SurfaceFlinger 中并没有保存自己创建了多少个 Client。</p>
<p>2、mLayers：使用当前 Client 创建过的 Layer 实例列表，比如当调用 ISurfaceComposerClient 的 createSurface 等方法时创建的 Layer ，这些Layer在创建之后，会被存放在对应 Client 的 mLayers 列表中。</p>
<p>而这里的 Client 实例被创建是在 SurfaceFlinger::createConnection 方法中的，具体详见上面模块的解释。</p>
<p>接着看该实现类的实现：</p>
<h5 id="createSurface"><a href="#createSurface" class="headerlink" title="createSurface"></a>createSurface</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Client::createSurface</span><span class="params">(<span class="type">const</span> String8 &amp;name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">uint32_t</span> flags, <span class="type">const</span> sp&lt;IBinder&gt; &amp;parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                               LayerMetadata metadata, sp&lt;IBinder&gt; *handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                               sp&lt;IGraphicBufferProducer&gt; *gbp)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用到 SurfaceFlinger 中的 createLayer 方法内去完成 Layer 的创建</span></span><br><span class="line">  <span class="comment">// 这里第二个参数传入的是 Client 当前实例，这样的话在 SurfaceFlinger 中就知道是哪个 Client 调用过来的</span></span><br><span class="line">  <span class="comment">// 最后会在创建完 Layer 之后调用其 attachLayer 来让他保存该 Layer</span></span><br><span class="line">  <span class="keyword">return</span> mFlinger-&gt;<span class="built_in">createLayer</span>(name, <span class="keyword">this</span>, w, h, format, flags, std::<span class="built_in">move</span>(metadata), handle, gbp,</span><br><span class="line">                               parentHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="type">const</span> String8 &amp;name, <span class="type">const</span> sp&lt;Client&gt; &amp;client, <span class="type">uint32_t</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     LayerMetadata metadata, sp&lt;IBinder&gt; *handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sp&lt;IGraphicBufferProducer&gt; *gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;IBinder&gt; &amp;parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;Layer&gt; &amp;parentLayer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查宽高数值是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">int32_t</span>(w | h) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;createLayer() failed, w or h is negative (w=%d, h=%d)&quot;</span>,</span><br><span class="line">          <span class="built_in">int</span>(w), <span class="built_in">int</span>(h));</span><br><span class="line">    <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查 parentLayer/parentHandle</span></span><br><span class="line">  <span class="built_in">ALOG_ASSERT</span>(parentLayer == <span class="literal">nullptr</span> || parentHandle == <span class="literal">nullptr</span>,</span><br><span class="line">              <span class="string">&quot;Expected only one of parentLayer or parentHandle to be non-null. &quot;</span></span><br><span class="line">              <span class="string">&quot;Programmer error?&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">status_t</span> result = NO_ERROR;</span><br><span class="line">  <span class="comment">// 创建一个layer</span></span><br><span class="line">  sp&lt;Layer&gt; layer;</span><br><span class="line">  <span class="comment">// 获取一个独一无二的Layer name，即不能有重名的Layer;</span></span><br><span class="line">  String8 uniqueName = <span class="built_in">getUniqueLayerName</span>(name);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> primaryDisplayOnly = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// window type is WINDOW_TYPE_DONT_SCREENSHOT from SurfaceControl.java</span></span><br><span class="line">  <span class="comment">// TODO b/64227542</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.<span class="built_in">has</span>(METADATA_WINDOW_TYPE)) &#123;</span><br><span class="line">    <span class="type">int32_t</span> windowType = metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (windowType == <span class="number">441731</span>) &#123;</span><br><span class="line">      metadata.<span class="built_in">setInt32</span>(METADATA_WINDOW_TYPE, InputWindowInfo::TYPE_NAVIGATION_BAR_PANEL);</span><br><span class="line">      primaryDisplayOnly = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据传入的 flag 来决定要创建哪种 Layer ，一般都是 BufferQueueLayer</span></span><br><span class="line">  <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">      result = <span class="built_in">createBufferQueueLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                      format, handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferState:</span><br><span class="line">      result = <span class="built_in">createBufferStateLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                      handle, &amp;layer);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:</span><br><span class="line">      <span class="keyword">if</span> (w &gt; <span class="number">0</span> || h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;createLayer() failed, w or h cannot be set for color layer (w=%d, h=%d)&quot;</span>,</span><br><span class="line">              <span class="built_in">int</span>(w), <span class="built_in">int</span>(h));</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="built_in">createColorLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata), handle,</span><br><span class="line">                                &amp;layer);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceContainer:</span><br><span class="line">      <span class="keyword">if</span> (w &gt; <span class="number">0</span> || h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;createLayer() failed, w or h cannot be set for container layer (w=%d, h=%d)&quot;</span>,</span><br><span class="line">              <span class="built_in">int</span>(w), <span class="built_in">int</span>(h));</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="built_in">createContainerLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                    handle, &amp;layer);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:result = BAD_VALUE;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面 createXXXLayer 失败了的话，直接返回吧</span></span><br><span class="line">  <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (primaryDisplayOnly) &#123;</span><br><span class="line">    layer-&gt;<span class="built_in">setPrimaryDisplayOnly</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否需要将 layer 加入到 mCurState 中</span></span><br><span class="line">  <span class="type">bool</span> addToCurrentState = <span class="built_in">callingThreadHasUnscopedSurfaceFlingerAccess</span>();</span><br><span class="line">  </span><br><span class="line">  result = <span class="built_in">addClientLayer</span>(client, *handle, *gbp, layer, parentHandle, parentLayer,</span><br><span class="line">                          addToCurrentState);</span><br><span class="line">  <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  mInterceptor-&gt;<span class="built_in">saveSurfaceCreation</span>(layer);</span><br><span class="line">  <span class="built_in">setTransactionFlags</span>(eTransactionNeeded);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::addClientLayer</span><span class="params">(<span class="type">const</span> sp&lt;Client&gt; &amp;client, <span class="type">const</span> sp&lt;IBinder&gt; &amp;handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;gbc, <span class="type">const</span> sp&lt;Layer&gt; &amp;lbc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IBinder&gt; &amp;parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;Layer&gt; &amp;parentLayer, <span class="type">bool</span> addToCurrentState)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; parent;</span><br><span class="line">    <span class="keyword">if</span> (parentHandle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      parent = <span class="built_in">fromHandle</span>(parentHandle);</span><br><span class="line">      <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NAME_NOT_FOUND;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent = parentLayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNumLayers &gt;= MAX_LAYERS) &#123;</span><br><span class="line">      <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLayersByLocalBinderToken.<span class="built_in">emplace</span>(handle-&gt;<span class="built_in">localBinder</span>(), lbc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该 Layer 加到 parent Layer 中去</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">nullptr</span> &amp;&amp; addToCurrentState) &#123;</span><br><span class="line">      mCurrentState.layersSortedByZ.<span class="built_in">add</span>(lbc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">isRemovedFromCurrentState</span>()) &#123;</span><br><span class="line">      parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">      lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该 Layer 对应的 Producer 保存起来</span></span><br><span class="line">    <span class="keyword">if</span> (gbc != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      mGraphicBufferProducerList.<span class="built_in">insert</span>(IInterface::<span class="built_in">asBinder</span>(gbc).<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    mLayersAdded = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将创建好的 Layer 保存到其对应的 Client 中</span></span><br><span class="line">  client-&gt;<span class="built_in">attachLayer</span>(handle, lbc);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 createSurface 方法的实现中，主要逻辑是交给了其内部的 SurfaceFlinger 实例去处理。</p>
<blockquote>
<p>注意，此时说的是Binder Server 侧，此时Client是执行在和SurfaceFlinger同一个进程中的，因此它内部才保存 SurfaceFlinger 实例。所以它可以直接调用 SurfaceFlinger 实例中的方法。而如果对于其他进程来说，需要调用 SurfaceFlinger 方法的话则必须走 Binder，即上面的 ISurfaceComposer 接口。</p>
</blockquote>
<p>而在调用 SurfaceFlinger::createLayer 方法时，额外将自身 this 传入了进去，这样的话SurfaceFlinger 内部才知道此次创建Layer 的请求是来源于哪个Client的，后期好把创建好的Layer保存给它。</p>
<p>在SurfaceFlinger内部创建 Layer 时，会根据传入的 flag 来确定到底创建哪种Layer，具体的Layer创建后续，这里只看Client相关的。在创建完Layer之后会调用SurfaceFlinger::addClientLayer() 方法来将该 Layer 保存到该 Client 中。</p>
<p>所以说，Client 的createSurface() 方法实际会创建一个Layer，并将其保存在自身的 mLayers集合中。</p>
<h5 id="createWithSurfaceParent"><a href="#createWithSurfaceParent" class="headerlink" title="createWithSurfaceParent"></a>createWithSurfaceParent</h5><p>类似于上面的  createSurface() 方法，只是额外多了个父Layer：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Client::createWithSurfaceParent</span><span class="params">(<span class="type">const</span> String8 &amp;name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         LayerMetadata metadata, sp&lt;IBinder&gt; *handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         sp&lt;IGraphicBufferProducer&gt; *gbp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mFlinger-&gt;<span class="built_in">authenticateSurfaceTexture</span>(parent) == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;failed to authenticate surface texture&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">static_cast</span>&lt;MonitoredProducer *&gt;(parent.<span class="built_in">get</span>()))-&gt;<span class="built_in">getLayer</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">ALOGE</span>(<span class="string">&quot;failed to find parent layer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出对应的 父Layer </span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> &amp;layer = (<span class="built_in">static_cast</span>&lt;MonitoredProducer *&gt;(parent.<span class="built_in">get</span>()))-&gt;<span class="built_in">getLayer</span>();</span><br><span class="line">  <span class="keyword">if</span> (layer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;failed to find parent layer&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用到 SurfaceFlinger 中，额外传入了 parentLayer</span></span><br><span class="line">  <span class="keyword">return</span> mFlinger-&gt;<span class="built_in">createLayer</span>(name, <span class="keyword">this</span>, w, h, format, flags, std::<span class="built_in">move</span>(metadata), handle, gbp,</span><br><span class="line">                               <span class="literal">nullptr</span>, layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程类似，关于 父Layer 的后面再讲吧，暂时可以忽略。</p>
<h4 id="Binder-Client侧-1"><a href="#Binder-Client侧-1" class="headerlink" title="Binder Client侧"></a>Binder Client侧</h4><p>和前面的 ISurfaceComposer 类似，对于 ISurfaceComposerClient 来说，它的Binder Client 侧也有一个对应的类来方便使用，这个类是：SurfaceComposerClient。</p>
<p>先看看这个类的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SurfaceComposerClient</span> : <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Composer</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">status_t</span> <span class="title">initCheck</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">sp&lt;IBinder&gt; <span class="title">connection</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dispose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">sp&lt;SurfaceControl&gt; <span class="title">createSurface</span><span class="params">(<span class="type">const</span> String8 &amp;name,              <span class="comment">// name of the surface</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">uint32_t</span> w,                       <span class="comment">// width in pixel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">uint32_t</span> h,                       <span class="comment">// height in pixel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   PixelFormat format,               <span class="comment">// pixel-format desired</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">uint32_t</span> flags = <span class="number">0</span>,               <span class="comment">// usage flags</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   SurfaceControl *parent = <span class="literal">nullptr</span>, <span class="comment">// parent</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                   LayerMetadata metadata = LayerMetadata() <span class="comment">// metadata</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">status_t</span> <span class="title">createSurfaceChecked</span><span class="params">(<span class="type">const</span> String8 &amp;name, <span class="comment">// name of the surface</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint32_t</span> w,          <span class="comment">// width in pixel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint32_t</span> h,          <span class="comment">// height in pixel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                PixelFormat format,  <span class="comment">// pixel-format desired</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                sp&lt;SurfaceControl&gt; *outSurface,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint32_t</span> flags = <span class="number">0</span>,                      <span class="comment">// usage flags</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                SurfaceControl *parent = <span class="literal">nullptr</span>,        <span class="comment">// parent</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                LayerMetadata metadata = LayerMetadata() <span class="comment">// metadata</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">sp&lt;SurfaceControl&gt; <span class="title">createWithSurfaceParent</span><span class="params">(<span class="type">const</span> String8 &amp;name,       <span class="comment">// name of the surface</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">uint32_t</span> w,                <span class="comment">// width in pixel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">uint32_t</span> h,                <span class="comment">// height in pixel</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                             PixelFormat format,        <span class="comment">// pixel-format desired</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">uint32_t</span> flags = <span class="number">0</span>,        <span class="comment">// usage flags</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                             Surface *parent = <span class="literal">nullptr</span>, <span class="comment">// parent</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                             LayerMetadata metadata = LayerMetadata() <span class="comment">// metadata</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> Mutex mLock;</span><br><span class="line">  <span class="type">status_t</span> mStatus;</span><br><span class="line">  sp&lt;ISurfaceComposerClient&gt; mClient;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该类实现了RefBase ，那么它的实例后期被第一次引用时会调用其 onFirstRef() 方法，另外它还增加了两个属性：mStatus 和 mClient 。</p>
<p>1、mStatus：表示当前类中的 mClient 是否被初始化，默认是 NO_INIT ，当它被初始化之后会置为 NO_ERROR ，后续通过当前类的 initCheck() 方法就可以判断出它是否被初始化成功。</p>
<p>2、mClient：它是一个 ISurfaceComposerClient 实例，实际对应的是 BpSurfaceComposerClient 实例，也就是 ISurfaceComposerClient 的 Binder client 侧代理，使用它可以调用到 ISurfaceComposerClient的远端Server侧，也就是前面讲到的 Client 中。</p>
<p>另外该类中还定义了一个 createSurface 方法，有点类似于 ISurfaceComposerClient 中的同名方法，但是不同的是这里返回的是一个 SurfaceControl 实例。</p>
<blockquote>
<p>这里是第一次遇到 SurfaceControl 这个类，该类后续会讲的，这里先不纠结，有个印象就行。</p>
</blockquote>
<p>接下来看其实现：</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::<span class="built_in">SurfaceComposerClient</span>()</span><br><span class="line">    : <span class="built_in">mStatus</span>(NO_INIT) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::<span class="built_in">SurfaceComposerClient</span>(<span class="type">const</span> sp&lt;ISurfaceComposerClient&gt; &amp;client)</span><br><span class="line">    : <span class="built_in">mStatus</span>(NO_ERROR), <span class="built_in">mClient</span>(client) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法很简单，没啥讲的。</p>
<h5 id="onFirstRef"><a href="#onFirstRef" class="headerlink" title="onFirstRef"></a>onFirstRef</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceComposerClient::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ComposerService::getComposerService ： 拿到对应的  ISurfaceComposer 在当前进程的代理对象</span></span><br><span class="line">  <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (sf != <span class="literal">nullptr</span> &amp;&amp; mStatus == NO_INIT) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn;</span><br><span class="line">    <span class="comment">// 调用到 sf 服务端去执行，也就是执行 SurfaceFlinger 类中的 createConnection 方法</span></span><br><span class="line">    <span class="comment">// 最终返回一个 ISurfaceComposerClient ，这个也是供该进程调用的，实际对应服务端的是 Client.cpp </span></span><br><span class="line">    conn = sf-&gt;<span class="built_in">createConnection</span>();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存起来，供后续调用</span></span><br><span class="line">      mClient = conn;</span><br><span class="line">      mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果理解了上面的 ISurfaceComposer 和 ComposerService 的话，就不难理解这里的逻辑。</p>
<p>这里会在当前进程创建一个 ISurfaceComposerClient 实例(实际是BpSurfaceComposerClient实例 )，同时在对应的SurfaceFlinger 进程中创建一个Client 实例。这两个不同进程的实例分别是 ISurfaceComposerClient 接口对应Binder传输的Client 端和 Server 端。后期这俩就可以进行互相通讯了。</p>
<h5 id="createSurface-1"><a href="#createSurface-1" class="headerlink" title="createSurface"></a>createSurface</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">SurfaceComposerClient::createSurface</span><span class="params">(<span class="type">const</span> String8 &amp;name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        SurfaceControl *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        LayerMetadata metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建了一个  SurfaceControl 对象实例，下面的方法会给 s 内部赋值填充</span></span><br><span class="line">  sp&lt;SurfaceControl&gt; s;</span><br><span class="line">  <span class="built_in">createSurfaceChecked</span>(name, w, h, format, &amp;s, flags, parent, std::<span class="built_in">move</span>(metadata));</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中调用了另外一个方法：createSurfaceChecked 来填充 SurfaceControl 。具体见下面 createSurfaceChecked 方法中的分析。</p>
<h5 id="createWithSurfaceParent-1"><a href="#createWithSurfaceParent-1" class="headerlink" title="createWithSurfaceParent"></a>createWithSurfaceParent</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">SurfaceComposerClient::createWithSurfaceParent</span><span class="params">(<span class="type">const</span> String8 &amp;name, <span class="type">uint32_t</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                  <span class="type">uint32_t</span> h, PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                  <span class="type">uint32_t</span> flags, Surface *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                  LayerMetadata metadata)</span> </span>&#123;</span><br><span class="line">  sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">  <span class="type">status_t</span> err = mStatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 SurfaceComposerClient 中的 mClient 已经被初始化过了</span></span><br><span class="line">  <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">    sp&lt;IBinder&gt; handle;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; parentGbp = parent-&gt;<span class="built_in">getIGraphicBufferProducer</span>();</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部去创建 Layer 那些，创建Layer 成功后，会给入参 handle、 gbp 赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = mClient-&gt;<span class="built_in">createWithSurfaceParent</span>(name, w, h, format, flags, parentGbp,</span><br><span class="line">                                           std::<span class="built_in">move</span>(metadata), &amp;handle, &amp;gbp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Layer 成功了，那么将其赋值的  handle、 gbp 以及当前 SurfaceComposerClient 整体包装到 SurfaceControl 中</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SurfaceControl</span>(<span class="keyword">this</span>, handle, gbp, <span class="literal">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中主要通过之前初始化好的 mClient 去调用到Binder Server侧的 Client 中创建 Layer ，创建完成之后，把对应的 handle 和 gbp 以及当前 SurfaceComposerClient 整体包装到 SurfaceControl 中返回出去。</p>
<p>这里我们对 SurfaceControl 有了初步的认识：它是对 Layer 或者说是 Surface 相关属性的封装类。</p>
<h5 id="createSurfaceChecked"><a href="#createSurfaceChecked" class="headerlink" title="createSurfaceChecked"></a>createSurfaceChecked</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceComposerClient::createSurfaceChecked</span><span class="params">(<span class="type">const</span> String8 &amp;name, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     sp&lt;SurfaceControl&gt; *outSurface, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     SurfaceControl *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     LayerMetadata metadata)</span> </span>&#123;</span><br><span class="line">  sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">  <span class="type">status_t</span> err = mStatus;</span><br><span class="line">  <span class="comment">// 当前 mClient 被初始化了才能使用它</span></span><br><span class="line">  <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">// SurfaceFlinger中创建的Layer的句柄或标识</span></span><br><span class="line">    sp&lt;IBinder&gt; handle;</span><br><span class="line">    sp&lt;IBinder&gt; parentHandle;</span><br><span class="line">    <span class="comment">// 指向内部创建的 Layer 中的 GraphicBufferProducer 实例</span></span><br><span class="line">    <span class="comment">// 比如内部会创建 BufferQueueLayer 实例，创建完成后会将其 mProducer 赋值给 gbp</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parent ： 上层设置的父级 SurfaceControl 的 mNativeObject 属性，没有设置的话就是0</span></span><br><span class="line">    <span class="comment">// 比如在 SurfaceView#updateSurface 中，设置的parent 就是 ViewRootImpl 的</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      parentHandle = parent-&gt;<span class="built_in">getHandle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * name : Surface 名</span></span><br><span class="line"><span class="comment">     * w、h、format、flag : 宽高格式和标识</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * handle ： 在内部一层层调用之后，最终在 SurfaceFlinger.cpp # createBufferStateLayer 中赋值</span></span><br><span class="line"><span class="comment">     *           其中持有 SurfaceFlinger 实例和新创建的 Layer 实例.(详见：Layer.cpp # Layer::getHandle)</span></span><br><span class="line"><span class="comment">     * gbp ： 指向内部创建的 Layer 中的 GraphicBufferProducer 实例 ,</span></span><br><span class="line"><span class="comment">     *        比如内部会创建 BufferQueueLayer 实例，创建完成后会将其 mProducer 赋值给 gbp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = mClient-&gt;<span class="built_in">createSurface</span>(name, w, h, format, flags, parentHandle, std::<span class="built_in">move</span>(metadata), &amp;handle, &amp;gbp);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">      <span class="comment">// 然后将返回的 handle 包装起来到 SurfaceControl 中，然后赋值给入参 outSurface</span></span><br><span class="line">      *outSurface = <span class="keyword">new</span> <span class="built_in">SurfaceControl</span>(<span class="keyword">this</span>, handle, gbp, <span class="literal">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前方法中，同样是通过 mClient 去通知 Client 创建 Layer ，并将创建好Layer 的相关信息保存到 SurfaceControl 。</p>
<p>至此就分析完了 ISurfaceComposerClient 的Binder Client 侧实现，其他进程想使用他的话可以直接创建一个SurfaceComposerClient 实例，然后调用其暴露的方法来创建 Layer，创建好的Layer 的相关信息可以通过返回值 SurfaceControl 来拿到。</p>
<p>最后附上一个图解：</p>
<p><img src="/99318d8c/image1.png" alt="image.png"></p>
<h3 id="SurfaceSession"><a href="#SurfaceSession" class="headerlink" title="SurfaceSession"></a>SurfaceSession</h3><p>前面讲到的 SurfaceComposerClient 是属于Native Framework 的，而它在Java Framework 中有一个对应的类： SurfaceSession 。</p>
<p>下面先看看它的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An instance of this class represents a connection to the surface</span></span><br><span class="line"><span class="comment"> * flinger, from which you can create one or more Surface instances that will</span></span><br><span class="line"><span class="comment"> * be composited to the screen.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SurfaceSession</span> &#123;</span><br><span class="line">    <span class="comment">// Note: This field is accessed by native code.</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mNativeClient; <span class="comment">// SurfaceComposerClient*</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeCreate</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeDestroy</span><span class="params">(<span class="type">long</span> ptr)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeKill</span><span class="params">(<span class="type">long</span> ptr)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Create a new connection with the surface flinger. */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SurfaceSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// android_view_SurfaceSession.cpp</span></span><br><span class="line">        <span class="comment">// nativeCreate 中会创建一个 SurfaceComposerClient 对象实例并且返回出来保存在 mNativeClient 中</span></span><br><span class="line">        mNativeClient = nativeCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no user serviceable parts here ... */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mNativeClient != <span class="number">0</span>) &#123;</span><br><span class="line">                nativeDestroy(mNativeClient);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forcibly detach native resources associated with this object.</span></span><br><span class="line"><span class="comment">     * Unlike destroy(), after this call any surfaces that were created</span></span><br><span class="line"><span class="comment">     * from the session will no longer work.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span> &#123;</span><br><span class="line">        nativeKill(mNativeClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看该类的注释也能看出来它的用途：它代表了一个到 SurfaceFlinger 的连接，使用这个连接你可以创建一个或者多个 Surface。</p>
<p>而该类的代码也比较简单，内部有一个 mNativeClient 属性来保存来自jni native的对象指针地址。</p>
<p>而关于 mNativeClient 属性的赋值是在 SurfaceSession 构造方法中，通过调用native的nativeCreate() 方法来完成对象的创建。</p>
<p>SurfaceSession 类对应的 jni 类是：android_view_SurfaceSession.cpp。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_SurfaceSession.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 SurfaceComposerClient 对象实例，增加其引用数，此时会调用其 onFirstRef</span></span><br><span class="line">    <span class="comment">// 然后返回给上层去</span></span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    client-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 nativeCreate() 方法中就创建了 SurfaceComposerClient 实例，然后触发其 onFirstRef() ，此时其内部会去 SurfaceFlinger 中创建一个Client。</p>
<p>最后将这个 SurfaceComposerClient 实例返回出去给上层 SurfaceSession 中的 mNativeClient 去保存着。</p>
<p>因此说：在Java Framework中，只要创建了一个 SurfaceSession 实例的话，那么底层会自动多一个SurfaceComposerClient 实例，对应的 SurfaceFlinger中多了个Client 。</p>
<p>因此在以后遇到 SurfaceSession 和 SurfaceComposerClient 时，你的脑袋里要能想到这俩的关系。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/Surface/">Surface</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/25fde216.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Surface学习(二)--Layer简介</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/8dd4bfe0.html">
        <span class="next-text nav-default">Jetpack- Lifecycle</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
