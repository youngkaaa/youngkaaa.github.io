<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Binder - Server数据处理"/>




  <meta name="keywords" content="Binder," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/1d5df811.html"/>


<meta name="description" content="前面讲了Client子进程中通过SM的BpBinder代理实例来发送数据给Server进程，经由Binder内核传输之后，到达Server服务对应的进程，而后续Server服务进程收到这些数据后是怎么操作的呢？本文便展开分析下。 主要分为两部分：service manager 进程处理的逻辑和普通BBinder 服务进程处理的逻辑。 Service Manager  处理分析而service ma">
<meta property="og:type" content="article">
<meta property="og:title" content="Binder - Server数据处理">
<meta property="og:url" content="https://youngkaaa.github.io/1d5df811.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="前面讲了Client子进程中通过SM的BpBinder代理实例来发送数据给Server进程，经由Binder内核传输之后，到达Server服务对应的进程，而后续Server服务进程收到这些数据后是怎么操作的呢？本文便展开分析下。 主要分为两部分：service manager 进程处理的逻辑和普通BBinder 服务进程处理的逻辑。 Service Manager  处理分析而service ma">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-09T02:48:56.000Z">
<meta property="article:modified_time" content="2022-12-27T13:16:27.648Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Binder">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Binder - Server数据处理 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Binder - Server数据处理
        
      </h1>

      <time class="post-time">
          6月 09 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>前面讲了Client子进程中通过SM的BpBinder代理实例来发送数据给Server进程，经由Binder内核传输之后，到达Server服务对应的进程，而后续Server服务进程收到这些数据后是怎么操作的呢？本文便展开分析下。</p>
<p>主要分为两部分：service manager 进程处理的逻辑和普通BBinder 服务进程处理的逻辑。</p>
<h3 id="Service-Manager-处理分析"><a href="#Service-Manager-处理分析" class="headerlink" title="Service Manager  处理分析"></a>Service Manager  处理分析</h3><p>而service manager 启动的主要逻辑是在 frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c 文件中的。而本文主要的内容也是围绕该类来展开的。</p>
<p>关于SM的启动，最开始应该是看frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;servicemanager.rc 文件，最后兜兜转转执行到 frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c 中的main() 方法内。下面就从此处开始往下分析。</p>
<h4 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service_manager.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">selinux_callback</span> <span class="title">cb</span>;</span></span><br><span class="line">    <span class="type">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打开 binder 驱动，并且执行 mmap ，返回 binder_state 实例，内部存储着上述操作的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VENDORSERVICEMANAGER</span></span><br><span class="line">        ALOGW(<span class="string">&quot;failed to open binder driver %s\n&quot;</span>, driver);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            sleep(UINT_MAX);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        ALOGE(<span class="string">&quot;failed to open binder driver %s\n&quot;</span>, driver);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成为上下文管理者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb.func_audit = audit_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VENDORSERVICEMANAGER</span></span><br><span class="line">    cb.func_log = selinux_vendor_log_callback;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cb.func_log = selinux_log_callback;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VENDORSERVICEMANAGER</span></span><br><span class="line">    sehandle = selinux_android_vendor_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    sehandle = selinux_android_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    selinux_status_open(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sehandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;SELinux: Failed to acquire sehandle. Aborting.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getcon(&amp;service_manager_context) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;SELinux: Failed to acquire service_manager context. Aborting.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进入无限循环，处理client端发来的请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动时，主要执行了三步：</p>
<ol>
<li>binder_open() ： 在 service manager 进程内打开binder驱动，并完成内存映射</li>
<li>binder_become_context_manager()：将当前进程作为SM 的对应实体进程</li>
<li>binder_loop()：循环一直从 binder 驱动中读取事务来处理</li>
</ol>
<h4 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open()"></a>binder_open()</h4><p>从 service_manager.c 中调用的该方法是位于：frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c 内的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="keyword">struct</span> binder_state *<span class="title function_">binder_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* driver, <span class="type">size_t</span> mapsize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_version</span> <span class="title">vers</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先为 binder_state 结构体分配内存，它要做为返回值返回出去，所以得在堆上分配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * open 方法经过系统调用，最终到 kernel/common/drivers/android/binder.c#binder_open 方法中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bs-&gt;fd = open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;binder: cannot open %s (%s)\n&quot;</span>,</span><br><span class="line">                driver, strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) == <span class="number">-1</span>) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">&quot;binder: kernel driver version (%d) differs from user space version (%d)\n&quot;</span>,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 mmap 操作，进行内存映射,实际是执行到 binder.c#binder_mmap 中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;binder: cannot map device (%s)\n&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * open driver 返回的文件描述符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mmap 之后被映射区的指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> *mapped;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 映射区大小，默认的话可以是 128*1024，也就是128k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">size_t</span> mapsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在该方法中，完成了对 binder 驱动的打开和内存映射操作。</p>
<p>这些操作在前面的 ProcessState 中基本都讲到过了。这些步骤对于每个要进行Binder通信的进程来说都是要走的。不同的是SM侧是单独实现的binder.c类来执行这些操作，而其他的进程则都是统一借助ProcessState来实现的。操作最后的结果保存在 binder_state 结构体实例内返回出去以供后续使用。</p>
<h4 id="binder-become-context-manager"><a href="#binder-become-context-manager" class="headerlink" title="binder_become_context_manager()"></a>binder_become_context_manager()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binder_become_context_manager</span><span class="params">(<span class="keyword">struct</span> binder_state *bs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> <span class="title">obj</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;obj, <span class="number">0</span>, <span class="keyword">sizeof</span>(obj));</span><br><span class="line">    obj.flags = FLAT_BINDER_FLAG_TXN_SECURITY_CTX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过ioctl，传递 BINDER_SET_CONTEXT_MGR_EXT 指令</span></span><br><span class="line"><span class="comment">     * 如果 BINDER_SET_CONTEXT_MGR_EXT 失败的话，则下面会尝试 BINDER_SET_CONTEXT_MGR</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> result = ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR_EXT, &amp;obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback to original method</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">&quot;121035042&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试 BINDER_SET_CONTEXT_MGR</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 对应的会调用到 kernel/common/drivers/android/binder.c#binder_ioctl 方法中去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        result = ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体是发送一条 cmd&#x3D;BINDER_SET_CONTEXT_MGR_EXT 的请求到binder内核中，用于将当前进程注册成SM的实体进程。这样的话后续其他Client进程对SM进程发起的请求事务，都会被发送到当前进程中来。</p>
<p>其实这里发送的BINDER_SET_CONTEXT_MGR_EXT 消息，到了Binder内核中之后，会调用 binder_new_node() 方法来将当前发起方进程封装成一个binder_node 实例，然后将其保存到全局属性 binder_context_mgr_node 中</p>
<p>后续别的进程向SM发送消息时，handle指定为0，然后传输到内核态Binder驱动中之后，会取出这个 binder_context_mgr_node 来作为 target_node 。这些在前文  binder_transaction() 方法中都有提到，可以翻看前文。</p>
<h4 id="binder-loop"><a href="#binder-loop" class="headerlink" title="binder_loop()"></a>binder_loop()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">binder_loop</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一位存储的就是其具体的 命令值 ，比如这里是 BC_ENTER_LOOPER</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 ioctl 将 BC_ENTER_LOOPER 命令发送给 binder 驱动，让 Service Manager 进入循环</span></span><br><span class="line"><span class="comment">     * 此时 bwr 只有 write_buffer 有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此时 read_size 不为空，而 write_size = 0 ，表示只是用来读取数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进入循环，不断地 binder 读写过程，其实 bwr 中 read_size 不为0</span></span><br><span class="line"><span class="comment">         * 此时bwr只有 read_buffer 有数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;binder_loop: ioctl failed (%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 binder 信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, (<span class="type">uintptr_t</span>) readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;binder_loop: unexpected reply?!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;binder_loop: io error %d %s\n&quot;</span>, res, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_loop() 方法是SM实体中最重要的部分了，它的内部实现了对Client侧发送来的数据事务的处理逻辑。</p>
<p>在开始读取Client发送的数据之前，会先调用 binder_write() 方法来先往Binder内核发送一个 cmd &#x3D; BC_ENTER_LOOPER 的请求，表示当前线程通知Binder内核：我已经准备好开始读取别人发送给我的数据了。</p>
<blockquote>
<p>当cmd &#x3D; BC_ENTER_LOOPER 时，最终会给当前线程binder_thread中的looper属性增加新的标识：</p>
<p>thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_ENTERED;</p>
<p>标志着该线程已经准备好了</p>
</blockquote>
<p>注意这里通过 binder_write() 方法发送新的请求时，发送的binder_write_read 结构体实例是在该方法内新创建的，read_size 、read_buffer 等都是置为0，而read_size 不为0，因此到了Binder内核中之后，只会执行 write 操作，而不会执行 read。即只往Binder驱动中发送数据，而不会读取数据。</p>
<p>接着往后进入到一个 for 死循环内，在循环体内会先给之前创建的 binder_write_read bwr 的read_XXX 系列的属性赋值，而write_XXX 系列的值则是默认值0。然后调用 ioctl() 方法来将这个 bwr 发送给Binder 内核。因此到了Binder内核之后只会执行 read 操作来读取当前线程 binder_thread 或者当前进程 binder_proc 中 todo 队列中的事务，然后将其封装成 binder_transaction_data_secctx 实例之后返回出来，并且其返回的 cmd &#x3D; BR_TRANSACTION 。</p>
<blockquote>
<p>cmd 可能是 BR_TRANSACTION_SEC_CTX ，也可能是 BR_TRANSACTION 。这俩的区别是对应的存储数据的结构体分别是 binder_transaction_data_secctx 或者 binder_transaction_data 。</p>
</blockquote>
<p>ioctl() 执行完毕之后，接着会执行 binder_parse() 方法来解析这些数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binder_parse</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">struct</span> binder_io *bio,</span></span><br><span class="line"><span class="params">                 <span class="type">uintptr_t</span> ptr, <span class="type">size_t</span> size, binder_handler func)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr 中数据的访问边界</span></span><br><span class="line">    <span class="type">uintptr_t</span> end = ptr + (<span class="type">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取</span></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="comment">// 先读取第一位，其作为 cmd ,然后 ptr 指针后移一位</span></span><br><span class="line">        <span class="type">uint32_t</span> cmd = *(<span class="type">uint32_t</span> *) ptr;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">        <span class="comment">// 开始处理读取出来的 cmd</span></span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_NOOP: <span class="comment">// 无操作，退出当前方法中的 while 循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_INCREFS:</span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE:</span><br><span class="line">        <span class="keyword">case</span> BR_RELEASE:</span><br><span class="line">        <span class="keyword">case</span> BR_DECREFS:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRACE</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;  %p, %p\n&quot;</span>, (<span class="type">void</span> *)ptr, (<span class="type">void</span> *)(ptr + <span class="keyword">sizeof</span>(<span class="type">void</span> *)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_ptr_cookie);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_SEC_CTX:</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data_secctx</span> <span class="title">txn</span>;</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果 cmd 是 BR_TRANSACTION_SEC_CTX 时，那么需要将 ptr 中的数据赋值到 txn 中</span></span><br><span class="line"><span class="comment">             * 赋值是从 ptr 当前位置开始，往后复制 sizeof(struct binder_transaction_data_secctx) 长度</span></span><br><span class="line"><span class="comment">             * 也就是从 ptr 中复制出来一个完整的 binder_transaction_data_secctx 结构体实例到 txn 中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (cmd == BR_TRANSACTION_SEC_CTX) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((end - ptr) &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_transaction_data_secctx)) &#123;</span><br><span class="line">                    ALOGE(<span class="string">&quot;parse: txn too small (binder_transaction_data_secctx)!\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;txn, (<span class="type">void</span>*) ptr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_transaction_data_secctx));</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 复制完成之后，将 ptr 指针往后挪动对应的长度，因为该长度内容已经被赋值消耗掉了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_transaction_data_secctx);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* BR_TRANSACTION */</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果 cmd 是 BR_TRANSACTION 时，那么从ptr 中复制出来一个完整的 binder_transaction_data 到 txn.transaction_data 中</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> ((end - ptr) &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_transaction_data)) &#123;</span><br><span class="line">                    ALOGE(<span class="string">&quot;parse: txn too small (binder_transaction_data)!\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;txn.transaction_data, (<span class="type">void</span>*) ptr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_transaction_data));</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 复制完成之后，将 ptr 指针往后挪动对应的长度，因为该长度内容已经被赋值消耗掉了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_transaction_data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 binder_transaction_data_secctx 结构体内另外一个字段置为 0</span></span><br><span class="line">                txn.secctx = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果入参 func 设置了的话，则调用它来具体处理</span></span><br><span class="line"><span class="comment">             * 如果从 service_manager.c#main.c 调用过来，func 指向的是 service_manager.c#svcmgr_handler()</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="type">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * bio_init ： 初始化 reply 中的属性，将其中对应的属性指向 rdata </span></span><br><span class="line"><span class="comment">                 * 也就是说 reply 中的 offs 和 offs0 就会指向 rdata 对应的内存区域</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * txn.transaction_data 是在上面从 ptr 中读取出来的数据</span></span><br><span class="line"><span class="comment">                 * 这里是将 txn.transaction_data 中的数据挨个赋值给 msg 中对应的属性</span></span><br><span class="line"><span class="comment">                 * 后续通过 msg 就可以访问 txn.transaction_data 中的那些数据了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                bio_init_from_txn(&amp;msg, &amp;txn.transaction_data);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果从 service_manager.c#main.c 调用过来，func 指向的是 service_manager.c#svcmgr_handler()</span></span><br><span class="line"><span class="comment">                 * 这里假设调用到了 service_manager.c#svcmgr_handler 方法中去了</span></span><br><span class="line"><span class="comment">                 * 在该方法中会读取  msg 也就是传递给 service manager 的消息，然后在 service manager 中执行对应的操作</span></span><br><span class="line"><span class="comment">                 * 然后将返回值写入到 reply 中</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                res = func(bs, &amp;txn, &amp;msg, &amp;reply);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * TF_ONE_WAY : 单向调用，异步，不需要返回值</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (txn.transaction_data.flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    binder_free_buffer(bs, txn.transaction_data.data.ptr.buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 需要返回值，则将返回值写入到 binder 中，返回给调用方</span></span><br><span class="line">                    binder_send_reply(bs, &amp;reply, txn.transaction_data.data.ptr.buffer, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> =</span> (<span class="keyword">struct</span> binder_transaction_data *) ptr;</span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) &lt; <span class="keyword">sizeof</span>(*txn)) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;parse: reply too small!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (bio) &#123;</span><br><span class="line">                bio_init_from_txn(bio, txn);</span><br><span class="line">                bio = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* todo FREE BUFFER */</span></span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_BINDER: &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * binder 死亡</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_death</span> *<span class="title">death</span> =</span> (<span class="keyword">struct</span> binder_death *)(<span class="type">uintptr_t</span>) *(<span class="type">binder_uintptr_t</span> *)ptr;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="type">binder_uintptr_t</span>);</span><br><span class="line">            death-&gt;func(bs, death-&gt;ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            r = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            r = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">&quot;parse: OOPS %d\n&quot;</span>, cmd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在解析数据时，是根据 cmd 类型来分类处理的。其中绝大多数类型都是BR_TRANSACTION 或者 BR_TRANSACTION_SEC_CTX 。可以详见上篇文章。</p>
<p>在处理这两种类型的cmd时，首先分别读取出对应的存储数据的结构体实例，这里假如读取出来的是 binder_transaction_data 实例。</p>
<p>然后将读取出来的 binder_transaction_data 实例通过调用 bio_init_from_txn() 方法来保存到 binder_io msg 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bio_init_from_txn</span><span class="params">(<span class="keyword">struct</span> binder_io *bio, <span class="keyword">struct</span> binder_transaction_data *txn)</span></span><br><span class="line">&#123;</span><br><span class="line">    bio-&gt;data = bio-&gt;data0 = (<span class="type">char</span> *)(<span class="type">intptr_t</span>)txn-&gt;data.ptr.buffer;</span><br><span class="line">    bio-&gt;offs = bio-&gt;offs0 = (<span class="type">binder_size_t</span> *)(<span class="type">intptr_t</span>)txn-&gt;data.ptr.offsets;</span><br><span class="line">    bio-&gt;data_avail = txn-&gt;data_size;</span><br><span class="line">    bio-&gt;offs_avail = txn-&gt;offsets_size / <span class="keyword">sizeof</span>(<span class="type">size_t</span>);</span><br><span class="line">    bio-&gt;flags = BIO_F_SHARED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到主要是将 binder_transaction_data 中的 buffer 内存地址和buffer长度等值挨个赋值给 binder_io msg实例中。与此同时还有一个 binder_io reply 也会被创建并初始化，这个是用来存储sm处理msg之后的返回值的。</p>
<p>接着调用 func() 来将这些值传入进去，而这个 func 实际对应的是 service_manager.c#svcmgr_handler()  方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service_manager.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">svcmgr_handler</span><span class="params">(<span class="keyword">struct</span> binder_state *bs,</span></span><br><span class="line"><span class="params">                   <span class="keyword">struct</span> binder_transaction_data_secctx *txn_secctx,</span></span><br><span class="line"><span class="params">                   <span class="keyword">struct</span> binder_io *msg,</span></span><br><span class="line"><span class="params">                   <span class="keyword">struct</span> binder_io *reply)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    <span class="type">uint16_t</span> *s;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="type">uint32_t</span> handle;</span><br><span class="line">    <span class="type">uint32_t</span> strict_policy;</span><br><span class="line">    <span class="type">int</span> allow_isolated;</span><br><span class="line">    <span class="type">uint32_t</span> dumpsys_priority;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> =</span> &amp;txn_secctx-&gt;transaction_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ALOGI(&quot;target=%p code=%d pid=%d uid=%d\n&quot;,</span></span><br><span class="line">    <span class="comment">//      (void*) txn-&gt;target.ptr, txn-&gt;code, txn-&gt;sender_pid, txn-&gt;sender_euid);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;target.ptr != BINDER_SERVICE_MANAGER)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;code == PING_TRANSACTION)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span></span><br><span class="line">    <span class="comment">// header with the strict mode policy mask and the interface name.</span></span><br><span class="line">    <span class="comment">// Note that we ignore the strict_policy and don&#x27;t propagate it</span></span><br><span class="line">    <span class="comment">// further (since we do no outbound RPCs anyway).</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 msg-&gt;data 中往后开始读取，这里是先读取出来一个 uint32_t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    strict_policy = bio_get_uint32(msg);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再往后读取，跳过一个 uint32_t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bio_get_uint32(msg);  <span class="comment">// Ignore worksource header.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再往后读取一个 string16 ，len 中保存着读取出来的string 的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s = bio_get_string16(msg, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取出来的 s ，和常量 svcmgr_id 作比较，如果不一样的话，则直接返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((len != (<span class="keyword">sizeof</span>(svcmgr_id) / <span class="number">2</span>)) ||</span><br><span class="line">        <span class="built_in">memcmp</span>(svcmgr_id, s, <span class="keyword">sizeof</span>(svcmgr_id))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;invalid id %s\n&quot;</span>, str8(s, len));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sehandle &amp;&amp; selinux_status_updated() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VENDORSERVICEMANAGER</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">selabel_handle</span> *<span class="title">tmp_sehandle</span> =</span> selinux_android_vendor_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">selabel_handle</span> *<span class="title">tmp_sehandle</span> =</span> selinux_android_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (tmp_sehandle) &#123;</span><br><span class="line">            selabel_close(sehandle);</span><br><span class="line">            sehandle = tmp_sehandle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始处理具体的命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再从 msg-&gt;data 中往后读取 string </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 读取出来的这个 string 应该就是 service name 了</span></span><br><span class="line"><span class="comment">         * 开始调用  do_find_service 方法来查找该 service ，返回值 handle 是查找到对应的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid,</span><br><span class="line">                                 (<span class="type">const</span> <span class="type">char</span>*) txn_secctx-&gt;secctx);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * handle 如果是 0 的话，表示没有找到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!handle)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将返回数据写入到 reply 中去 ，注意返回的是其 handle 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再从 msg-&gt;data 中往后读取 string ，此时读取出来的 s 应该就是要add 的 service name了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在接着从 msg-&gt;data 中往后读取一个 flat_binder_object ，然后返回其 handle</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        handle = bio_get_ref(msg);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在接着从 msg-&gt;data 中往后读取一个 uint32_t ，然后返回读取到的值</span></span><br><span class="line"><span class="comment">         * 看变量名可以知道此时读取出来的是 allow_isolated</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        allow_isolated = bio_get_uint32(msg) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 接着再读取一个 uint32_t 出来</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dumpsys_priority = bio_get_uint32(msg);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开始执行 addService 方法，将读取到的要添加的 service 的信息传入进去</span></span><br><span class="line"><span class="comment">         * 内部会执行 addService 操作，主要就是将其封装并且存储在全局链表中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,</span><br><span class="line">                           txn-&gt;sender_pid, (<span class="type">const</span> <span class="type">char</span>*) txn_secctx-&gt;secctx))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_LIST_SERVICES: &#123;</span><br><span class="line">        <span class="type">uint32_t</span> n = bio_get_uint32(msg);</span><br><span class="line">        <span class="type">uint32_t</span> req_dumpsys_priority = bio_get_uint32(msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!svc_can_list(txn-&gt;sender_pid, (<span class="type">const</span> <span class="type">char</span>*) txn_secctx-&gt;secctx, txn-&gt;sender_euid)) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;list_service() uid=%d - PERMISSION DENIED\n&quot;</span>,</span><br><span class="line">                    txn-&gt;sender_euid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si = svclist;</span><br><span class="line">        <span class="comment">// walk through the list of services n times skipping services that</span></span><br><span class="line">        <span class="comment">// do not support the requested priority</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历全局 svclist 链表，将其中所有注册过的 service name 放入到 reply 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (si) &#123;</span><br><span class="line">            <span class="keyword">if</span> (si-&gt;dumpsys_priority &amp; req_dumpsys_priority) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            si = si-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si) &#123;</span><br><span class="line">            bio_put_string16(reply, si-&gt;name);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ALOGE(<span class="string">&quot;unknown code %d\n&quot;</span>, txn-&gt;code);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在最后，往 reply 中写入一个 0，作为结束吧</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入该方法之后，会通过判断 binder_transaction_data  txn 的code值来执行不同的逻辑分支，正如之前所说的code和cmd的区别：code是client端和server端之间使用的，binder驱动只是原封不动转发而已。更明确来说是用来标识server端的不同方法。这里便是个印证了。</p>
<p>比如我们之前调用的是 BpServiceManager 的 addService() 方法，那么放置的code &#x3D; ADD_SERVICE_TRANSACTION 。而到这里就对应着 SVC_MGR_ADD_SERVICE。</p>
<blockquote>
<p>为啥这俩不一样呢？其实ADD_SERVICE_TRANSACTION 或者 SVC_MGR_ADD_SERVICE这些都是枚举，不是字符串之类的。所以尽管名称不一样，但是其对应的具体枚举数值都是一样的。</p>
</blockquote>
<p>这里则将常用的这几种都分别分析下。</p>
<h5 id="SVC-MGR-GET-SERVICE-amp-SVC-MGR-CHECK-SERVICE"><a href="#SVC-MGR-GET-SERVICE-amp-SVC-MGR-CHECK-SERVICE" class="headerlink" title="SVC_MGR_GET_SERVICE &amp; SVC_MGR_CHECK_SERVICE"></a>SVC_MGR_GET_SERVICE &amp; SVC_MGR_CHECK_SERVICE</h5><p>这两者对应的意思其实是一样的，即：根据service name 来获取对应的service 信息。</p>
<p>对应的client 端 BpServiceManager 来说的话，就是 getService 和 checkService方法。</p>
<blockquote>
<p>这俩方法其实都是走的 CHECK_SERVICE_TRANSACTION ，因为在 getService 方法中调用的是 checkService 的。而getService 额外多了个重试机制而已。</p>
</blockquote>
<p>所以这里首先是取出 service name，即这里的属性 s。接着调用 do_find_service() 方法来将这个 service name 传入进去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service_manager.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">do_find_service</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *s, <span class="type">size_t</span> len, <span class="type">uid_t</span> uid, <span class="type">pid_t</span> spid, <span class="type">const</span> <span class="type">char</span>* sid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 查找该 service name</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span> =</span> find_svc(s, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没找到的话</span></span><br><span class="line">    <span class="keyword">if</span> (!si || !si-&gt;handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果该 service 不允许被 isolated 进程所访问，那么判断该进程是否是 isolated 的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;allow_isolated) &#123;</span><br><span class="line">        <span class="comment">// If this service doesn&#x27;t allow access from isolated processes,</span></span><br><span class="line">        <span class="comment">// then check the uid to see if it is isolated.</span></span><br><span class="line">        <span class="type">uid_t</span> appid = uid % AID_USER;</span><br><span class="line">        <span class="keyword">if</span> (appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!svc_can_find(s, len, spid, sid, uid)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> si-&gt;handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前已经注册过的 service 链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">svclist</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> svcinfo *<span class="title function_">find_svc</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *s16, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从全局变量  svclist 中查找和入参 s16 名称一样的 service</span></span><br><span class="line"><span class="comment">     * 找到后就返回其 svcinfo 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (si = svclist; si; si = si-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((len == si-&gt;len) &amp;&amp;</span><br><span class="line">            !<span class="built_in">memcmp</span>(s16, si-&gt;name, len * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的下一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唯一id， ServiceManager 的 handle = 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> handle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对应的该 service death 时回调的方法那些</span></span><br><span class="line"><span class="comment">     * 在 do_add_service 方法中赋值，其内部的 func 指向 svcinfo_death 方法</span></span><br><span class="line"><span class="comment">     * 其内部的 ptr 指向当前 svcinfo 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_death</span> <span class="title">death</span>;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该 service 是否允许被 isolated processes 所访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> allow_isolated;</span><br><span class="line">    <span class="type">uint32_t</span> dumpsys_priority;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面 name 的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * service name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint16_t</span> name[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，在查找service 时，实际是从全局的svcinfo链表中查找name相同的实例，如果找到了的话则返回该 svcinfo 实例中的handle值，如果没找到则do_find_service() 返回0。</p>
<p>最后如果找到的话则通过 bio_put_ref() 方法将找到的 handle 写入到 reply 中作为返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service_manager.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bio_put_ref</span><span class="params">(<span class="keyword">struct</span> binder_io *bio, <span class="type">uint32_t</span> handle)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">obj</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle)</span><br><span class="line">        obj = bio_alloc_obj(bio);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        obj = bio_alloc(bio, <span class="keyword">sizeof</span>(*obj));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    obj-&gt;flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    obj-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">    obj-&gt;handle = handle;</span><br><span class="line">    obj-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在返回的时候，会在 reply 对应的内存中新创建一个 flat_binder_object 实例，然后将其类型置为： BINDER_TYPE_HANDLE ，并且同时将其handle 值保存起来，也就是查找到的service 在 SM 进程中所对应的 handle 值。关于SM 中的handle值，在后面addService 时统一再讲。</p>
<p>这样的话，就完成了service 查找工作，将查找到的 service 的 handle 值保存到 reply 中的一个 flat_binder_object 实例中。</p>
<h5 id="SVC-MGR-ADD-SERVICE"><a href="#SVC-MGR-ADD-SERVICE" class="headerlink" title="SVC_MGR_ADD_SERVICE"></a>SVC_MGR_ADD_SERVICE</h5><p>在添加 Service 时，其按顺序读的是：</p>
<p>1、service name ：服务名</p>
<p>2、flat_binder_object 中的 handle值：要添加的service binder实体中存储的handle 值。</p>
<p>2.1  首先在server端通过调用Parcel::writeStrongBinder 来保存一个BBinder 实例时，会将其保存成一个 flat_binder_object实例，并在该实例中保存该BBinder 实例的地址到cookie等属性，其type设置为 BINDER_TYPE_BINDER。</p>
<p>2.2 其次到内核态的Binder驱动中，执行到 binder_transaction() 方法中，会处理该 flat_binder_object实例。即调用 binder_translate_binder() 方法来将该flat_binder_object 实例封装成 binder_node 实例保存到【发起方进程】binder_proc中，同时在【接收方进程】binder_proc中新建一个binder_ref，为其分配handle值，同时该binder_ref.node指向该binder_node 实例。</p>
<p>额外的还会修改该 flat_binder_object 实例的属性，即将其type 从 BINDER_TYPE_BINDER 修改为 BINDER_TYPE_HANDLER，然后将其cookie和binder内存地址置为0，并将其handle值设置为上面为binder_ref 所分配的handle值。</p>
<p>下面举例说明：</p>
<p>比如在mediaserver进程中，会调用 SM.addService 来注册自身服务MediaPlayerService，此时会将其自身BBinder实例(也就是MediaPlayerService对象实例)发送到内核态，其中Binder驱动会为其创建一个binder_node 来保存该BBinder的内存地址，并将该binder_node 保存到media server进程内核态所对应的binder_proc 实例中；同时对于接收方进程 service manager进程来说，会同时创建一个 binder_ref 实例，存储在service manager进程内核态所对应的binder_proc 实例中。而在创建该binder_ref 实例时，同时会为其分配handle值(从1开始每个数字挨个分配，用过的不能重复用)，同时其node指向上面的 binder_node 实例。</p>
<p>最后会将该 flat_binder_object 实例的属性 type 从 BINDER_TYPE_BINDER 修改为 BINDER_TYPE_HANDLER，然后将其cookie和binder内存地址置为0，并将其handle值设置为上面为binder_ref 所分配的handle值。</p>
<p>至此，media server进程在内核态所对应的binder_proc中多了个binder_node 保存该MediaPlayerService,也就是BBinder实例的地址；service manager 进程在内核态所对应的binder_proc中多了个binder_ref 实例，其node属性指向上面的binder_node 实例，并且拥有为其分配的在service manager进程binder_proc中唯一的handle值。该handle 值也会被保存到flat_binder_object 实例中。</p>
<p>后续接收方进程 service manager 进程中获取到该addService 的 binder_work 时，也就是会一步步执行到当前方法位置来，再获取其flat_binder_object 实例，取出其 handle 值保存起来。</p>
<p>至此你应该明白这里的 flat_binder_object 以及其 handle值表示的意思了吧。</p>
<p>3、allow_isolated ： 这个是addService 时指定的属性。详见 BpServiceManager::addService</p>
<p>接着就是调用 do_add_service() 来完成service 的实际添加工作了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service_manager.c</span></span><br><span class="line"></span><br><span class="line">nt <span class="title function_">do_add_service</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, <span class="type">const</span> <span class="type">uint16_t</span> *s, <span class="type">size_t</span> len, <span class="type">uint32_t</span> handle,</span></span><br><span class="line"><span class="params">                   <span class="type">uid_t</span> uid, <span class="type">int</span> allow_isolated, <span class="type">uint32_t</span> dumpsys_priority, <span class="type">pid_t</span> spid, <span class="type">const</span> <span class="type">char</span>* sid)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ALOGI(&quot;add_service(&#x27;%s&#x27;,%x,%s) uid=%d\n&quot;, str8(s, len), handle,</span></span><br><span class="line">    <span class="comment">//        allow_isolated ? &quot;allow_isolated&quot; : &quot;!allow_isolated&quot;, uid);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做一些容错 合法性处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!handle || (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!svc_can_register(s, len, spid, sid, uid)) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;add_service(&#x27;%s&#x27;,%x) uid=%d - PERMISSION DENIED\n&quot;</span>,</span><br><span class="line">             str8(s, len), handle, uid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先查找当前该 service 是否已经被注册过了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确实被注册过了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="comment">// 那么首先将之前注册的 death 掉，也就是新的会覆盖旧的</span></span><br><span class="line">        <span class="keyword">if</span> (si-&gt;handle) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;add_service(&#x27;%s&#x27;,%x) uid=%d - ALREADY REGISTERED, OVERRIDE\n&quot;</span>,</span><br><span class="line">                 str8(s, len), handle, uid);</span><br><span class="line">            svcinfo_death(bs, si);</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  (len + 1) * sizeof(uint16_t) 应该是为 service name 分配空间，最后一位是 &#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (!si) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;add_service(&#x27;%s&#x27;,%x) uid=%d - OUT OF MEMORY\n&quot;</span>,</span><br><span class="line">                 str8(s, len), handle, uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 然后挨个将入参赋值给新创建出来的 svcinfo</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        <span class="comment">// 给 service name 末尾拼接 &#x27;\0&#x27; 表示字符串结束</span></span><br><span class="line">        si-&gt;name[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="type">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;dumpsys_priority = dumpsys_priority;</span><br><span class="line">        <span class="comment">// 新add 的作为链表头部，然后它的 next 指向之前旧的链表头，头插法</span></span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往 binder 驱动中发送一条 BC_ACQUIRE 消息，传入了当前 svcinfo 的句柄 handle 作为参数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往 binder 驱动中发送一条 BC_REQUEST_DEATH_NOTIFICATION 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在添加service 时，主要是将其handle、servicename等值保存到 svcinfo 实例中，存储在全局 svclist 链表中。后续查找时也是从 svclist 链表开始往后查找。</p>
<h5 id="SVC-MGR-LIST-SERVICES"><a href="#SVC-MGR-LIST-SERVICES" class="headerlink" title="SVC_MGR_LIST_SERVICES"></a>SVC_MGR_LIST_SERVICES</h5><p>理解了前面的话这个很简单就不解释了，很少用。</p>
<p>到这里的话，svcmgr_handler 方法就执行完毕了。</p>
<p>此时 reply 中就存储着返回数据了，此时还回到 binder.c#binder_parse() 方法中来接着往后执行 binder_send_reply() 方法：</p>
<blockquote>
<p>注意如果是异步binder请求的话，则不需要返回值，即只需要执行binder_free_buffer() 即可，即发送一条 BC_FREE_BUFFER 的请求；而Binder请求常用的都是同步方式，所以这里就直接分析binder_send_reply() 方法了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">binder_send_reply</span><span class="params">(<span class="keyword">struct</span> binder_state *bs,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> binder_io *reply,</span></span><br><span class="line"><span class="params">                       <span class="type">binder_uintptr_t</span> buffer_to_free,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> status)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一次性发送 free 和 reply 两条消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> cmd_free;</span><br><span class="line">        <span class="type">binder_uintptr_t</span> buffer;</span><br><span class="line">        <span class="type">uint32_t</span> cmd_reply;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) data;</span><br><span class="line"></span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER;</span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY;</span><br><span class="line">    <span class="comment">// 这里都是赋值为 0</span></span><br><span class="line">    data.txn.target.ptr = <span class="number">0</span>;</span><br><span class="line">    data.txn.cookie = <span class="number">0</span>;</span><br><span class="line">    data.txn.code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        data.txn.flags = TF_STATUS_CODE;</span><br><span class="line">        data.txn.data_size = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        data.txn.offsets_size = <span class="number">0</span>;</span><br><span class="line">        data.txn.data.ptr.buffer = (<span class="type">uintptr_t</span>)&amp;status;</span><br><span class="line">        data.txn.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data.txn.flags = <span class="number">0</span>;</span><br><span class="line">        data.txn.data_size = reply-&gt;data - reply-&gt;data0;</span><br><span class="line">        data.txn.offsets_size = ((<span class="type">char</span>*) reply-&gt;offs) - ((<span class="type">char</span>*) reply-&gt;offs0);</span><br><span class="line">        data.txn.data.ptr.buffer = (<span class="type">uintptr_t</span>)reply-&gt;data0;</span><br><span class="line">        data.txn.data.ptr.offsets = (<span class="type">uintptr_t</span>)reply-&gt;offs0;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_write(bs, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中会一次性发送两条消息：BC_FREE_BUFFER 和 BC_REPLY 。</p>
<blockquote>
<p>通过这里也可以看出，发送的数据格式是 cmd+data +cmd+data +… 的，所以内部Binder驱动处理时是while。而不是只处理一条。</p>
</blockquote>
<p>而这里给 BC_REPLY 类型的 data  ：binder_transaction_data 赋值时是使用的 reply 中的数据，即返回数据。</p>
<p>最后调用  binder_write() 方法来将数据发送给 binder 驱动。</p>
<h3 id="普通-BBinder-处理分析"><a href="#普通-BBinder-处理分析" class="headerlink" title="普通 BBinder 处理分析"></a>普通 BBinder 处理分析</h3><p>这里说的普通BBinder，表示所有继承自BBinder 的类，或者更准确说是继承自 BnInterface 的。比如前面举例的  MediaPlayerService ，或者对于Android开发者更常见的AIDL，它要求开发者继承自AIDL自动生成的 XXX.Stub类，实现onTransact()方法(它的底层也是间接的和 BBinder有关的，后面会讲)。</p>
<blockquote>
<p>对于native层来说，MediaPlayerService是运行在对应的 media server 进程的，来为其他进程提供媒体服务；</p>
<p>当然更常见的是平时开发中开发者自行编写的Service 继承自AIDL自动生成的 XXX.Stub 类。比如常见的一个APP会有多个进程存在。</p>
</blockquote>
<p>因为上层的Binder.java 也是和BBinder有关的。所以下面还是以 MediaPlayerService 为例解释下这些BBinder 实体类在其所在进程中是怎么处理来自client进程的Binder请求的。</p>
<p>MediaPlayerService的初始化添加是在 main_mediaserver.c 文件中的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main_mediaserver.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建当前进程的 ProcessState 单例对象</span></span><br><span class="line"><span class="comment">     * 其内部在常见 ProcessState 时，会先打开 binder 驱动，然后对打开的binder驱动执行 mmap 操作，然后保存 mmap 映射在当前进程的地址 mVMStart</span></span><br><span class="line"><span class="comment">     * 而 ProcessState 是单例，则保证了一个进程只会打开一次 binder 驱动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sp&lt;ProcessState&gt; <span class="title function_">proc</span><span class="params">(ProcessState::self())</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前进程的 servierManger 实例，实际是获取到了 BpServiceManager 对象实例</span></span><br><span class="line"><span class="comment">     * 其内部包装了了一个 handle=0 的 BpBinder 对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sp&lt;IServiceManager&gt; <span class="title function_">sm</span><span class="params">(defaultServiceManager())</span>;</span><br><span class="line">    ALOGI(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.get());</span><br><span class="line">    AIcu_initializeIcuOrDie();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始注册 多媒体 服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 binder 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前线程加入到线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，先调用了 <code>MediaPlayerService::instantiate()</code> 方法来将当前 MediaPlayerService 添加到了 SM 中。接着最后调用了 startThreadPool() 方法来在当前media server 进程开启线程池，用来从Binder 中读取要处理的事务，即binder_work。</p>
<blockquote>
<p>这个类似于上面service manager进程中的 binder_loop() ，也是用来循环一直读取Binder内核，也就是其他Client进程发来的Binder请求。</p>
</blockquote>
<p>接着往下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String8 <span class="title">ProcessState::makeBinderThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> s = <span class="built_in">android_atomic_add</span>(<span class="number">1</span>, &amp;mThreadPoolSeq);</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">    String8 name;</span><br><span class="line">    name.<span class="built_in">appendFormat</span>(<span class="string">&quot;Binder:%d_%X&quot;</span>, pid, s);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;<span class="comment">// ProcessState.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessState::startThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="comment">// mThreadPoolStarted 保证一个进程只能开启一次线程池</span></span><br><span class="line">    <span class="keyword">if</span> (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 参数传入的是 true ，表示是创建主线程</span></span><br><span class="line">        <span class="built_in">spawnPooledThread</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessState::spawnPooledThread</span><span class="params">(<span class="type">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        <span class="comment">// 创建 binder 线程名</span></span><br><span class="line">        String8 name = <span class="built_in">makeBinderThreadName</span>();</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Spawning new pooled thread, name=%s\n&quot;</span>, name.<span class="built_in">string</span>());</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> <span class="built_in">PoolThread</span>(isMain);</span><br><span class="line">        t-&gt;<span class="built_in">run</span>(name.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">String8 <span class="title">ProcessState::makeBinderThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> s = <span class="built_in">android_atomic_add</span>(<span class="number">1</span>, &amp;mThreadPoolSeq);</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">getpid</span>();</span><br><span class="line">    String8 name;</span><br><span class="line">    name.<span class="built_in">appendFormat</span>(<span class="string">&quot;Binder:%d_%X&quot;</span>, pid, s);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoolThread</span> : <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PoolThread</span><span class="params">(<span class="type">bool</span> isMain)</span></span></span><br><span class="line"><span class="function">        : mIsMain(isMain)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 最终还是调用了 joinThreadPool 方法</span></span><br><span class="line">        IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>(mIsMain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到一步步的最终是创建了一个 PoolThread，也就是一个 Thread 线程。所以最终会执行到其 threadLoop 方法内，最终还是调用到了 joinThreadPool() 方法中，注意此时路径下 isMain&#x3D;true；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessState.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IPCThreadState::joinThreadPool</span><span class="params">(<span class="type">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_THREADPOOL</span>(<span class="string">&quot;**** THREAD %p (PID %d) IS JOINING THE THREAD POOL\n&quot;</span>, (<span class="type">void</span>*)<span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程则是 BC_ENTER_LOOPER ， 其他线程都是 BC_REGISTER_LOOPER</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    <span class="type">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">processPendingDerefs</span>();</span><br><span class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 跟binder驱动通信，获取别的进程发送来的事务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        result = <span class="built_in">getAndExecuteCommand</span>();</span><br><span class="line">        <span class="comment">// 出错了</span></span><br><span class="line">        <span class="keyword">if</span> (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting&quot;</span>,</span><br><span class="line">                  mProcess-&gt;mDriverFD, result);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let this thread exit the thread pool if it is no longer</span></span><br><span class="line">        <span class="comment">// needed and it is not the main process thread.</span></span><br><span class="line">        <span class="comment">// 非主线程的 binder 线程，遇到超时时直接终止循环，也就是线程执行完毕</span></span><br><span class="line">        <span class="keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_THREADPOOL</span>(<span class="string">&quot;**** THREAD %p (PID %d) IS LEAVING THE THREAD POOL err=%d\n&quot;</span>,</span><br><span class="line">        (<span class="type">void</span>*)<span class="built_in">pthread_self</span>(), <span class="built_in">getpid</span>(), result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到这里时，那么线程肯定就是终止了的，此时需要通知到 binder driver 中去  </span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(BC_EXIT_LOOPER);</span><br><span class="line">    <span class="built_in">talkWithDriver</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> result;</span><br><span class="line">    <span class="type">int32_t</span> cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跟 binder driver 进程数据传输</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    result = <span class="built_in">talkWithDriver</span>();</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="type">size_t</span> IN = mIn.<span class="built_in">dataAvail</span>();</span><br><span class="line">        <span class="keyword">if</span> (IN &lt; <span class="built_in">sizeof</span>(<span class="type">int32_t</span>)) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在上面 talkWithDriver 方法中，会从内核空间的 binder_thread_read 方法中读取数据，并且填充到 mIn 中</span></span><br><span class="line"><span class="comment">         * 其中会先赋值 cmd ，然后再复制一份 binder_transaction_data_secctx tr 结构体实例到当前用户空间来</span></span><br><span class="line"><span class="comment">         * 也就是 mIn 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cmd = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Processing top-level Command: &quot;</span></span><br><span class="line">                 &lt;&lt; <span class="built_in">getReturnString</span>(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount++;</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mExecutingThreadsCount &gt;= mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs == <span class="number">0</span>) &#123;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = <span class="built_in">uptimeMillis</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到这里表示读取的数据没有问题，那么就开始处理请求</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        result = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">        mProcess-&gt;mExecutingThreadsCount--;</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mExecutingThreadsCount &lt; mProcess-&gt;mMaxThreads &amp;&amp;</span><br><span class="line">                mProcess-&gt;mStarvationStartTimeMs != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int64_t</span> starvationTimeMs = <span class="built_in">uptimeMillis</span>() - mProcess-&gt;mStarvationStartTimeMs;</span><br><span class="line">            <span class="keyword">if</span> (starvationTimeMs &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;binder thread pool (%zu threads) starved for %&quot;</span> PRId64 <span class="string">&quot; ms&quot;</span>,</span><br><span class="line">                      mProcess-&gt;mMaxThreads, starvationTimeMs);</span><br><span class="line">            &#125;</span><br><span class="line">            mProcess-&gt;mStarvationStartTimeMs = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_cond_broadcast</span>(&amp;mProcess-&gt;mThreadCountDecrement);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="type">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="type">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始根据 cmd 具体类型来进行处理</span></span><br><span class="line"><span class="comment">     * 主要可以看 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">switch</span> ((<span class="type">uint32_t</span>)cmd) &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION_SEC_CTX:</span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data_secctx tr_secctx;</span><br><span class="line">            binder_transaction_data&amp; tr = tr_secctx.transaction_data;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * BR_TRANSACTION_SEC_CTX 时，binder 驱动复制过来的是 binder_transaction_data_secctx 结构体实例</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (cmd == (<span class="type">int</span>) BR_TRANSACTION_SEC_CTX) &#123;</span><br><span class="line">                result = mIn.<span class="built_in">read</span>(&amp;tr_secctx, <span class="built_in">sizeof</span>(tr_secctx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则就是 binder_transaction_data 实例</span></span><br><span class="line">                result = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">                tr_secctx.secctx = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ALOG_ASSERT</span>(result == NO_ERROR,</span><br><span class="line">                <span class="string">&quot;Not enough command data for brTRANSACTION&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Record the fact that we&#x27;re in a binder call.</span></span><br><span class="line">            mIPCThreadStateBase-&gt;<span class="built_in">pushCurrentState</span>(</span><br><span class="line">                IPCThreadStateBase::CallState::BINDER);</span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">pid_t</span> origPid = mCallingPid;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* origSid = mCallingSid;</span><br><span class="line">            <span class="type">const</span> <span class="type">uid_t</span> origUid = mCallingUid;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> origStrictModePolicy = mStrictModePolicy;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> origTransactionBinderFlags = mLastTransactionBinderFlags;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> origWorkSource = mWorkSource;</span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> origPropagateWorkSet = mPropagateWorkSource;</span><br><span class="line">            <span class="comment">// Calling work source will be set by Parcel#enforceInterface. Parcel#enforceInterface</span></span><br><span class="line">            <span class="comment">// is only guaranteed to be called for AIDL-generated stubs so we reset the work source</span></span><br><span class="line">            <span class="comment">// here to never propagate it.</span></span><br><span class="line">            <span class="built_in">clearCallingWorkSource</span>();</span><br><span class="line">            <span class="built_in">clearPropagateWorkSource</span>();</span><br><span class="line"></span><br><span class="line">            mCallingPid = tr.sender_pid;</span><br><span class="line">            mCallingSid = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(tr_secctx.secctx);</span><br><span class="line">            mCallingUid = tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags = tr.flags;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ALOGI(&quot;&gt;&gt;&gt;&gt; TRANSACT from pid %d sid %s uid %d\n&quot;, mCallingPid,</span></span><br><span class="line">            <span class="comment">//    (mCallingSid ? mCallingSid : &quot;&lt;N/A&gt;&quot;), mCallingUid);</span></span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            <span class="type">status_t</span> error;</span><br><span class="line">            <span class="built_in">IF_LOG_TRANSACTIONS</span>() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; <span class="string">&quot;BR_TRANSACTION thr &quot;</span> &lt;&lt; (<span class="type">void</span>*)<span class="built_in">pthread_self</span>()</span><br><span class="line">                    &lt;&lt; <span class="string">&quot; / obj &quot;</span> &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">&quot; / code &quot;</span></span><br><span class="line">                    &lt;&lt; <span class="built_in">TypeCode</span>(tr.code) &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; indent &lt;&lt; buffer</span><br><span class="line">                    &lt;&lt; dedent &lt;&lt; endl</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;Data addr = &quot;</span></span><br><span class="line">                    &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer)</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;, offsets addr=&quot;</span></span><br><span class="line">                    &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">size_t</span>*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 指向的是对应在该进程 node 的地址</span></span><br><span class="line"><span class="comment">             * 如果不为空则调用其 transact 方法</span></span><br><span class="line"><span class="comment">             * 也就是调用到对应的 BBbinder 的实现类中，比如 ServiceManager 中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">                <span class="comment">// We only have a weak reference on the target object, so we must first try to</span></span><br><span class="line">                <span class="comment">// safely acquire a strong reference before doing anything else with it.</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;<span class="built_in">attemptIncStrong</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    error = <span class="built_in">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;<span class="built_in">transact</span>(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    <span class="built_in">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;<span class="built_in">decStrong</span>(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    error = UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                error = the_context_object-&gt;<span class="built_in">transact</span>(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mIPCThreadStateBase-&gt;<span class="built_in">popCurrentState</span>();</span><br><span class="line">            <span class="comment">//ALOGI(&quot;&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d sid %s uid %d\n&quot;,</span></span><br><span class="line">            <span class="comment">//     mCallingPid, origPid, (origSid ? origSid : &quot;&lt;N/A&gt;&quot;), origUid);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果是同步 binder 请求的话，则需要发送最终的结果</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">LOG_ONEWAY</span>(<span class="string">&quot;Sending reply to %d!&quot;</span>, mCallingPid);</span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.<span class="built_in">setError</span>(error);</span><br><span class="line">                <span class="built_in">sendReply</span>(reply, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 异步的不需要结果返回</span></span><br><span class="line">                <span class="built_in">LOG_ONEWAY</span>(<span class="string">&quot;NOT sending reply to %d!&quot;</span>, mCallingPid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCallingPid = origPid;</span><br><span class="line">            mCallingSid = origSid;</span><br><span class="line">            mCallingUid = origUid;</span><br><span class="line">            mStrictModePolicy = origStrictModePolicy;</span><br><span class="line">            mLastTransactionBinderFlags = origTransactionBinderFlags;</span><br><span class="line">            mWorkSource = origWorkSource;</span><br><span class="line">            mPropagateWorkSource = origPropagateWorkSet;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">IF_LOG_TRANSACTIONS</span>() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; <span class="string">&quot;BC_REPLY thr &quot;</span> &lt;&lt; (<span class="type">void</span>*)<span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; / obj &quot;</span></span><br><span class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即先是在 joinThreadPool 方法内的 do while 循环内一直调用 getAndExecuteCommand() 方法来从 Binder获取要处理的数据并且处理；</p>
<p>而获取要处理的数据也是通过之前讲过的 talkWithDriver() 方法，拿到待处理的数据之后就调用 executeCommand() 方法来处理数据。</p>
<p>处理数据是根据传递来的cmd 来分类执行的，主要的cmd是 BR_TRANSACTION</p>
<blockquote>
<p>还记得前面 service manager 中的 binder_parse() 中的逻辑嘛，也是判断的 BR_TRANSACTION 和 BR_TRANSACTION_SEC_CTX 。这里和他是一样的，不同的是两个不同的地方来处理：前者是专门针对service manager的处理；而这里是针对普通其他的BBinder实体的处理。</p>
</blockquote>
<p>接着就是读取出数据到 binder_transaction_data tr中，在通过 reinterpret_cast 来将 tr.cookie 强转成 BBinder 实例来使用，调用其 transact() 方法。这样的话就到了 BBinder 实现类的 onTransact() 中了。</p>
<blockquote>
<p>这里的 tr.cookie 是之前保存的 BBinder 实体的地址，这里就会用到了。</p>
</blockquote>
<h3 id="补充BC-REPLY-分析"><a href="#补充BC-REPLY-分析" class="headerlink" title="补充BC_REPLY 分析"></a>补充BC_REPLY 分析</h3><p>对于上面最后通过 binder_write() 方法来将发送的返回数据包装成 binder_write_read 实例，其调用 ioctl 时cmd &#x3D; BINDER_WRITE_READ 来将其发送给 Binder 驱动。</p>
<p>正如前面文章分析的流程一样，最终会执行到 ：kernel&#x2F;common&#x2F;drivers&#x2F;android&#x2F;binder.c 中的 binder_transaction() 方法内，而该方法在前面介绍过了，这里接着只介绍关于 BC_REPLY 的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/common/drivers/android/binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> binder_transaction_data *tr, <span class="type">int</span> reply,</span></span><br><span class="line"><span class="params"><span class="type">binder_size_t</span> extra_buffers_size)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果对应的 cmd 是 BC_REPLY 时，reply 才会是 true ，才会执行到内部去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (reply) &#123;</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 假设之前是 A 线程发送事务 t 到B线程，此时 thread =B，</span></span><br><span class="line"><span class="comment">	 * transaction_stack 之前保存了该 thread 当前在处理的事务</span></span><br><span class="line"><span class="comment">	 * 所以此时 A-&gt;transaction_stack = t</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">	<span class="keyword">if</span> (in_reply_to == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		binder_user_error(<span class="string">&quot;%d:%d got reply transaction with no transaction stack\n&quot;</span>,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EPROTO;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_empty_call_stack;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 假设之前是 A线程发送事务 t 到B线程，那么 t-&gt;to_thread = B </span></span><br><span class="line"><span class="comment">	 * 而此时是 B返回数据给A，此时 thread =B，</span></span><br><span class="line"><span class="comment">	 * 所以这里的判断就是保证必须是 B 返回的数据给 A 才行。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) &#123;</span><br><span class="line">		spin_lock(&amp;in_reply_to-&gt;lock);</span><br><span class="line">		binder_user_error(<span class="string">&quot;%d:%d got reply transaction with bad transaction stack, transaction %d has target %d:%d\n&quot;</span>,</span><br><span class="line">			proc-&gt;pid, thread-&gt;pid, in_reply_to-&gt;debug_id,</span><br><span class="line">			in_reply_to-&gt;to_proc ?</span><br><span class="line">			in_reply_to-&gt;to_proc-&gt;pid : <span class="number">0</span>,</span><br><span class="line">			in_reply_to-&gt;to_thread ?</span><br><span class="line">			in_reply_to-&gt;to_thread-&gt;pid : <span class="number">0</span>);</span><br><span class="line">		spin_unlock(&amp;in_reply_to-&gt;lock);</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EPROTO;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		in_reply_to = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_bad_call_stack;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 此时 thread = B，</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">	target_thread = binder_get_txn_from_and_acq_inner(in_reply_to);</span><br><span class="line">	<span class="keyword">if</span> (target_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return_error = BR_DEAD_REPLY;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) &#123;</span><br><span class="line">		binder_user_error(<span class="string">&quot;%d:%d got reply transaction with bad target transaction stack %d, expected %d\n&quot;</span>,</span><br><span class="line">			proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">			target_thread-&gt;transaction_stack ?</span><br><span class="line">			target_thread-&gt;transaction_stack-&gt;debug_id : <span class="number">0</span>,</span><br><span class="line">			in_reply_to-&gt;debug_id);</span><br><span class="line">		binder_inner_proc_unlock(target_thread-&gt;proc);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EPROTO;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		in_reply_to = <span class="literal">NULL</span>;</span><br><span class="line">		target_thread = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">	&#125;</span><br><span class="line">	target_proc = target_thread-&gt;proc;</span><br><span class="line">	target_proc-&gt;tmp_ref++;</span><br><span class="line">	binder_inner_proc_unlock(target_thread-&gt;proc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略创建 binder_transaction 部分的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reply) &#123;</span><br><span class="line">	binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">	binder_inner_proc_lock(target_proc);</span><br><span class="line">	<span class="keyword">if</span> (target_thread-&gt;is_dead) &#123;</span><br><span class="line">		binder_inner_proc_unlock(target_proc);</span><br><span class="line">		<span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">	&#125;</span><br><span class="line">	BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">	binder_pop_transaction_ilocked(target_thread, in_reply_to);</span><br><span class="line">	binder_enqueue_thread_work_ilocked(target_thread, &amp;t-&gt;work);</span><br><span class="line">	binder_inner_proc_unlock(target_proc);</span><br><span class="line">	wake_up_interruptible_sync(&amp;target_thread-&gt;wait);</span><br><span class="line">	binder_restore_priority(current, in_reply_to-&gt;saved_priority);</span><br><span class="line">	binder_free_transaction(in_reply_to);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意此时 thread 就是返回方线程信息了，比如之前是 A 向 B 发起Binder请求，此时B回应了A，那么此时thread就是B，而计算出来的 target_thread 这些就是当时的A。</p>
<p>也就是跟之前是相反的。之前A作为client向B server 发起请求，而此时当B响应它时B就作为client，A就是server端了。</p>
<p>接着会创建 binder_transaction 来存储这些数据，最后将其放入到 target_thread.todo 队列中。这样的话后续在A线程中就可以读取到这个结果了。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Binder/">Binder</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2af50710.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Binder - Java Framework</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/9a74aa64.html">
        <span class="next-text nav-default">Binder - Binder驱动数据处理</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2022
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
