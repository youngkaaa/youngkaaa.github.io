<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Surface学习(二)--Layer简介"/>




  <meta name="keywords" content="AndroidFrameworks,Surface," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/25fde216.html"/>


<meta name="description" content="前面 Surface学习(一)–ComposerService 讲到了其他进程怎么与SurfaceFlinger 进程进行通讯，介绍了一些基础的类和概念。下面再接着它往后讲讲。 前面在 Native Framework 中遇到了 SurfaceControl 类，但是在讲 SurfaceControl 之前，需要先看下 Layer 的创建相关逻辑。 LayerLayer 我的理解是类似于图层的概念">
<meta property="og:type" content="article">
<meta property="og:title" content="Surface学习(二)--Layer简介">
<meta property="og:url" content="https://youngkaaa.github.io/25fde216.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="前面 Surface学习(一)–ComposerService 讲到了其他进程怎么与SurfaceFlinger 进程进行通讯，介绍了一些基础的类和概念。下面再接着它往后讲讲。 前面在 Native Framework 中遇到了 SurfaceControl 类，但是在讲 SurfaceControl 之前，需要先看下 Layer 的创建相关逻辑。 LayerLayer 我的理解是类似于图层的概念">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-01T12:48:56.000Z">
<meta property="article:modified_time" content="2023-02-24T12:29:06.835Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="Surface">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Surface学习(二)--Layer简介 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Surface学习(二)--Layer简介
        
      </h1>

      <time class="post-time">
          7月 01 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>前面 <a href="99318d8c.html">Surface学习(一)–ComposerService</a> 讲到了其他进程怎么与SurfaceFlinger 进程进行通讯，介绍了一些基础的类和概念。下面再接着它往后讲讲。</p>
<p>前面在 Native Framework 中遇到了 SurfaceControl 类，但是在讲 SurfaceControl 之前，需要先看下 Layer 的创建相关逻辑。</p>
<h3 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h3><p>Layer 我的理解是类似于图层的概念，它有显示区域大小的属性，也有显示数据属性，以及层级关系。</p>
<p>简单看下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layer.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> compositionengine::LayerFE &#123;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">int32_t</span>&gt; sSequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// regions below are in window-manager space</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line">    Region coveredRegion;</span><br><span class="line">    Region visibleNonTransparentRegion;</span><br><span class="line">    Region surfaceDamageRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer serial number.  This gives layers an explicit ordering, so we</span></span><br><span class="line">    <span class="comment">// have a stable sort order when their layer stack and Z-order are</span></span><br><span class="line">    <span class="comment">// the same.</span></span><br><span class="line">    <span class="type">int32_t</span> sequence&#123;sSequence++&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Layer</span><span class="params">(<span class="type">const</span> LayerCreationArgs&amp; args)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Layer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setPerFrameData</span><span class="params">(<span class="type">const</span> sp&lt;<span class="type">const</span> DisplayDevice&gt;&amp; display,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> ui::Transform&amp; transform, <span class="type">const</span> Rect&amp; viewport,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">int32_t</span> supportedPerFrameMetadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> ui::Dataspace targetDataspace)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">shouldPresentNow</span><span class="params">(<span class="type">nsecs_t</span> <span class="comment">/*expectedPresentTime*/</span>)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">onPreComposition</span><span class="params">(<span class="type">nsecs_t</span> refreshStartTime)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">onPostComposition</span><span class="params">(<span class="type">const</span> std::optional&lt;DisplayId&gt;&amp; <span class="comment">/*displayId*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> std::shared_ptr&lt;FenceTime&gt;&amp; <span class="comment">/*glDoneFence*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> std::shared_ptr&lt;FenceTime&gt;&amp; <span class="comment">/*presentFence*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> CompositorTiming&amp; <span class="comment">/*compositorTiming*/</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">latchBuffer</span><span class="params">(<span class="type">bool</span>&amp; <span class="comment">/*recomputeVisibleRegions*/</span>, <span class="type">nsecs_t</span> <span class="comment">/*latchTime*/</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasReadyFrame</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int32_t</span> <span class="title">getQueuedFrameCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// constant</span></span><br><span class="line">    <span class="comment">// 对应的 SurfaceFlinger 实例</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; mFlinger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承自 BBinder ，可以通过 Binder IPC机制传递给客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Handle</span> : <span class="keyword">public</span> BBinder, <span class="keyword">public</span> LayerCleaner &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Handle</span>(<span class="type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger, <span class="type">const</span> sp&lt;Layer&gt;&amp; layer)</span><br><span class="line">              : <span class="built_in">LayerCleaner</span>(flinger, layer), <span class="built_in">owner</span>(layer) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        wp&lt;Layer&gt; owner;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;IBinder&gt; <span class="title">getHandle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> wp&lt;Client&gt; mClientRef;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; mActiveBuffer;</span><br><span class="line">    sp&lt;Fence&gt; mActiveBufferFence;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Layer 中的代码很多，这里省略了绝大部分只展示其中关键的（其实是我认识的哈哈哈），下面介绍下下相关属性：</p>
<p>1、visibleRegion ：</p>
<p>当前Layer的可见区域。基本上就是当前 Layer 所占用的区域面积减去上层的<strong>不透明</strong>区域。注意当被上层透明区域所覆盖的区域也认为是可见的。</p>
<p>2、coveredRegion ：</p>
<p>当前 Layer 被上层 Layer 覆盖的区域，被上层透明区域所覆盖的区域也算被覆盖区域。</p>
<p>3、visibleNonTransparentRegion ：</p>
<p>当前Layer非透明的可见区域，其实就是从可见区域内剔除掉全透明的区域，这样的话在后期渲染时就可以跳过这些透明区域了。</p>
<p>4、surfaceDamageRegion ：</p>
<p>待补充</p>
<p>5、sequence：当前layer的序列值，每创建一个layer都会自增一个序列值给它。当Layer 的Z值一样时，就可以使用sequence来进行layer的排序了。</p>
<p>6、mFlinger ： 对应的 SurfaceFlinger 实例。</p>
<p>7、mActiveBuffer ：当前Layer目前要显示的的帧数据。该GraphicBuffer缓存区内存储的就是对应要显示的数据。一般是充当消费者从消费者队列中acquire一个BufferItem，然后将其 mGraphicBuffer 和 slot 保存起来准备等待真正的绘制显示，而其中这里的mActiveBuffer 此时就指向对应的缓存区。</p>
<p>8、mActiveBufferFence：和上面 mActiveBuffer 对应的同步 fence ，用来处理同步的，暂时先忽略。</p>
<p>9、mClientRef ：当前 Layer 创建时所对应的 Client 。前面在讲 Client 时提到了，它里面有个 mLayers 集合用来存储它所创建过的Layer，而对于Layer来说，它也指向Client，表示是哪个Client创建了它。</p>
<p>接下来看看关于它的一些关键方法实现：</p>
<h4 id="构造-amp-析构方法"><a href="#构造-amp-析构方法" class="headerlink" title="构造&amp;析构方法"></a>构造&amp;析构方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layer.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是通过传入的 LayerCreationArgs 来给 mFlinger mClientRef 等属性赋值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Layer::<span class="built_in">Layer</span>(<span class="type">const</span> LayerCreationArgs &amp;args)</span><br><span class="line">    : <span class="built_in">mFlinger</span>(args.flinger),</span><br><span class="line">      <span class="built_in">mName</span>(args.name),</span><br><span class="line">      <span class="built_in">mClientRef</span>(args.client),</span><br><span class="line">      <span class="built_in">mWindowType</span>(args.metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>)) &#123;</span><br><span class="line">  mCurrentCrop.<span class="built_in">makeInvalid</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下都是些初始化工作，先忽略</span></span><br><span class="line">  <span class="type">uint32_t</span> layerFlags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eHidden) layerFlags |= <span class="type">layer_state_t</span>::eLayerHidden;</span><br><span class="line">  <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eOpaque) layerFlags |= <span class="type">layer_state_t</span>::eLayerOpaque;</span><br><span class="line">  <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eSecure) layerFlags |= <span class="type">layer_state_t</span>::eLayerSecure;</span><br><span class="line"></span><br><span class="line">  mTransactionName = <span class="built_in">String8</span>(<span class="string">&quot;TX - &quot;</span>) + mName;</span><br><span class="line"></span><br><span class="line">  mCurrentState.active_legacy.w = args.w;</span><br><span class="line">  mCurrentState.active_legacy.h = args.h;</span><br><span class="line">  mCurrentState.flags = layerFlags;</span><br><span class="line">  mCurrentState.active_legacy.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  mCurrentState.crop_legacy.<span class="built_in">makeInvalid</span>();</span><br><span class="line">  mCurrentState.requestedCrop_legacy = mCurrentState.crop_legacy;</span><br><span class="line">  mCurrentState.z = <span class="number">0</span>;</span><br><span class="line">  mCurrentState.color.a = <span class="number">1.0f</span>;</span><br><span class="line">  mCurrentState.layerStack = <span class="number">0</span>;</span><br><span class="line">  mCurrentState.sequence = <span class="number">0</span>;</span><br><span class="line">  mCurrentState.requested_legacy = mCurrentState.active_legacy;</span><br><span class="line">  mCurrentState.active.w = UINT32_MAX;</span><br><span class="line">  mCurrentState.active.h = UINT32_MAX;</span><br><span class="line">  mCurrentState.active.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  mCurrentState.transform = <span class="number">0</span>;</span><br><span class="line">  mCurrentState.transformToDisplayInverse = <span class="literal">false</span>;</span><br><span class="line">  mCurrentState.crop.<span class="built_in">makeInvalid</span>();</span><br><span class="line">  mCurrentState.acquireFence = <span class="keyword">new</span> <span class="built_in">Fence</span>(<span class="number">-1</span>);</span><br><span class="line">  mCurrentState.dataspace = ui::Dataspace::UNKNOWN;</span><br><span class="line">  mCurrentState.hdrMetadata.validTypes = <span class="number">0</span>;</span><br><span class="line">  mCurrentState.surfaceDamageRegion.<span class="built_in">clear</span>();</span><br><span class="line">  mCurrentState.cornerRadius = <span class="number">0.0f</span>;</span><br><span class="line">  mCurrentState.api = <span class="number">-1</span>;</span><br><span class="line">  mCurrentState.hasColorTransform = <span class="literal">false</span>;</span><br><span class="line">  mCurrentState.colorSpaceAgnostic = <span class="literal">false</span>;</span><br><span class="line">  mCurrentState.metadata = args.metadata;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// drawing state &amp; current state are identical</span></span><br><span class="line">  mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">  CompositorTiming compositorTiming;</span><br><span class="line">  args.flinger-&gt;<span class="built_in">getCompositorTiming</span>(&amp;compositorTiming);</span><br><span class="line">  mFrameEventHistory.<span class="built_in">initializeCompositorTiming</span>(compositorTiming);</span><br><span class="line">  mFrameTracker.<span class="built_in">setDisplayRefreshPeriod</span>(compositorTiming.interval);</span><br><span class="line"></span><br><span class="line">  mSchedulerLayerHandle = mFlinger-&gt;mScheduler-&gt;<span class="built_in">registerLayer</span>(mName.<span class="built_in">c_str</span>(), mWindowType);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知到 SurfaceFlinger 当前有 Layer 新创建出来了，SurfaceFlinger 中会有个全局 Layer 的计数</span></span><br><span class="line">  mFlinger-&gt;<span class="built_in">onLayerCreated</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Layer::~<span class="built_in">Layer</span>() &#123;</span><br><span class="line">  <span class="comment">// 取出其对应的 Client ，然后将其从 Client 的 mLayers 中移除掉</span></span><br><span class="line">  <span class="function">sp&lt;Client&gt; <span class="title">c</span><span class="params">(mClientRef.promote())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">    c-&gt;<span class="built_in">detachLayer</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mFrameTracker.<span class="built_in">logAndResetStats</span>(mName);</span><br><span class="line">  <span class="comment">// 和前面构造方法中的  mFlinger-&gt;onLayerCreated() 类似，匹配调用</span></span><br><span class="line">  mFlinger-&gt;<span class="built_in">onLayerDestroyed</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Layer.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实就是将一些创建 Layer 时的属性封装在一起</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LayerCreationArgs</span> &#123;</span><br><span class="line">  <span class="built_in">LayerCreationArgs</span>(SurfaceFlinger* flinger, <span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">const</span> String8&amp; name,</span><br><span class="line">                    <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, <span class="type">uint32_t</span> flags, LayerMetadata metadata)</span><br><span class="line">        : <span class="built_in">flinger</span>(flinger), <span class="built_in">client</span>(client), <span class="built_in">name</span>(name), <span class="built_in">w</span>(w), <span class="built_in">h</span>(h), <span class="built_in">flags</span>(flags),</span><br><span class="line">          <span class="built_in">metadata</span>(std::<span class="built_in">move</span>(metadata)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  SurfaceFlinger* flinger;</span><br><span class="line">  <span class="type">const</span> sp&lt;Client&gt;&amp; client;</span><br><span class="line">  <span class="type">const</span> String8&amp; name;</span><br><span class="line">  <span class="type">uint32_t</span> w;</span><br><span class="line">  <span class="type">uint32_t</span> h;</span><br><span class="line">  <span class="type">uint32_t</span> flags;</span><br><span class="line">  LayerMetadata metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Layer创建时，是通过LayerCreationArgs来将创建所需的参数传入进来的，比如对应的 SurfaceFlinger 实例、创建该Layer时对应的 Client 实例、以及该Layer 的名称、宽高尺寸等。</p>
<p>在构造方法中首先根据入参来将传入的值保存起来，然后会进行一系列的初始化操作。最后会调用</p>
<p>SurfaceFlinger 的 onLayerCreated 方法来通知它当前有Layer新建成功了。而对于析构方法类似的，先调用当前 Layer 对应的 Client 的 detachLayer 方法来将当前 Layer 从该 Client 的 mLayers 集合中移除掉，最后同样的调用 SurfaceFlinger 的 onLayerDestroyed 方法来通知他当前有Layer被销毁了。</p>
<p>额外的 LayerCreationArgs 结构体只是将一些参数封装了起来而已，不难理解。</p>
<h4 id="getHandle"><a href="#getHandle" class="headerlink" title="getHandle"></a>getHandle</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layer.cpp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">Layer::getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Mutex::Autolock _l(mLock);</span><br><span class="line">  <span class="keyword">if</span> (mGetHandleCalled) &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;Get handle called twice&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mGetHandleCalled = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 这个 Handle 类的定义在 Layer.h 中</span></span><br><span class="line">  <span class="comment">// 持有 SurfaceFlinger 对象实例，以及 Layer</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Handle</span>(mFlinger, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Layer.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handle</span> : <span class="keyword">public</span> BBinder, <span class="keyword">public</span> LayerCleaner &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Handle</span>(<span class="type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger, <span class="type">const</span> sp&lt;Layer&gt;&amp; layer)</span><br><span class="line">              : <span class="built_in">LayerCleaner</span>(flinger, layer), <span class="built_in">owner</span>(layer) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        wp&lt;Layer&gt; owner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LayerCleaner</span> &#123;</span><br><span class="line">    sp&lt;SurfaceFlinger&gt; mFlinger;</span><br><span class="line">    sp&lt;Layer&gt; mLayer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">      ~<span class="built_in">LayerCleaner</span>() &#123;</span><br><span class="line">          <span class="comment">// destroy client resources</span></span><br><span class="line">          mFlinger-&gt;<span class="built_in">onHandleDestroyed</span>(mLayer);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">LayerCleaner</span>(<span class="type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger, <span class="type">const</span> sp&lt;Layer&gt;&amp; layer)</span><br><span class="line">            : <span class="built_in">mFlinger</span>(flinger), <span class="built_in">mLayer</span>(layer) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当前方法会返回一个Handle实例，那先解释下Handle 和 LayerCleaner 。</p>
<p>Handle类是继承自 BBinder 和 LayerCleaner 的，在Handle 内中存储了 Layer ，在 LayerCleaner 中存储了 SurfaceFlinger 。</p>
<p>这里继承自 BBinder 的目的是使得当前 Handle 支持 Binder 传输，在Client端可以与其建立映射关系。而该BBinder没有往ServiceManager中注册，因此它是个匿名Binder。</p>
<p>将这个 Binder 返回给 Binder Client 端的目的是：在Client端可以拥有一个Layer的唯一标识。</p>
<p>举个栗子：</p>
<p>比如前面在其他Binder Client进程中调用SurfaceComposerClient 中的 createSurface 方法时，会通知到 SurfaceFlinger 中去创建一个对应的 Layer，创建出来的 Layer 并没有返回给 Binder Client进程，而是返回了一个类型是 IBinder 的 handle ，然后将其存储在 SurfaceControl 中，后期就会在该Client进程中使用该 handle 作为该 Layer 的唯一标识。比如SurfaceControl 的  isSameSurface() 方法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceControl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceControl::isSameSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;SurfaceControl&gt;&amp; lhs, <span class="type">const</span> sp&lt;SurfaceControl&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs == <span class="literal">nullptr</span> || rhs == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> lhs-&gt;mHandle == rhs-&gt;mHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就是判断 handle 值是否相等，相等的话就表示 Surface 是一样的，也就是Layer是一样的。</p>
<p>因此说此处的 handle 就是该 Layer 在Binder Client进程中的一个标识，它对应着SurfaceFlinger进程中刚创建的那个Layer。</p>
<p>而该方法的实现中也是比较简单的，就是将当前 Layer 包装成该 Binder 对象，然后将其返回给 Binder Client进程去作为该 Layer的唯一标识。</p>
<blockquote>
<p>注意当前方法创建的 Handle 在 Binder Server进程侧并没有做保存，而且每次调用都是创建一个新的 Handle，所以多次调用时，可能存在：多个不同地址的 Handle 对应着同一个Layer 的情况。所以该方法要求最好只调用一次，在第二次调用时会直接返回 null。</p>
</blockquote>
<p>而对于 LayerCleaner 来说，它存在的目的是为了在当该 Handle 被销毁时，能够回调通知到 SurfaceFlinger 中去。</p>
<p>目前只分析这些方法，后期等遇到了其他方法时再做补充吧。</p>
<h3 id="BufferLayer"><a href="#BufferLayer" class="headerlink" title="BufferLayer"></a>BufferLayer</h3><p>先看其定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayer.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferLayer</span> : <span class="keyword">public</span> Layer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BufferLayer</span><span class="params">(<span class="type">const</span> LayerCreationArgs&amp; args)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">BufferLayer</span>() <span class="keyword">override</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">latchBuffer</span><span class="params">(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBufferLatched</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> mRefreshPending; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasReadyFrame</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// from GLES</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> mTextureName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 BufferLayer::latchBuffer 方法中，如果获取新的Buffer 成功后，会将其置为true</span></span><br><span class="line">    <span class="type">bool</span> mRefreshPending&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// main thread.</span></span><br><span class="line">    <span class="type">bool</span> mBufferLatched&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;compositionengine::Layer&gt; mCompositionLayer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BufferLayer 是继承自 Layer 的，它在Layer 的基础上扩充了一些字段和方法。</p>
<p>1、mTextureName：该属性在后面 OpenGLES 中会用到，这里暂时忽略。</p>
<p>2、mCompositionLayer ： 该属性在最后Layer合成时会用到，这里暂时忽略。</p>
<p>接下来看看它的实现：</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayer.cpp</span></span><br><span class="line"></span><br><span class="line">BufferLayer::<span class="built_in">BufferLayer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">      : <span class="built_in">Layer</span>(args),   </span><br><span class="line">        <span class="built_in">mTextureName</span>(args.flinger-&gt;<span class="built_in">getNewTexture</span>()),</span><br><span class="line">        mCompositionLayer&#123;mFlinger-&gt;<span class="built_in">getCompositionEngine</span>().<span class="built_in">createLayer</span>(</span><br><span class="line">                compositionengine::LayerCreationArgs&#123;<span class="keyword">this</span>&#125;)&#125; &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating Layer %s&quot;</span>, args.name.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的 flag 来初始化其他属性</span></span><br><span class="line">    mPremultipliedAlpha = !(args.flags &amp; ISurfaceComposerClient::eNonPremultiplied);</span><br><span class="line"></span><br><span class="line">    mPotentialCursor = args.flags &amp; ISurfaceComposerClient::eCursorWindow;</span><br><span class="line">    mProtectedByApp = args.flags &amp; ISurfaceComposerClient::eProtectedByApp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在BufferLayer的构造方法中，会先去调用 Layer 的构造方法初始化 Layer ，然后再去初始化 mTextureName 和 mCompositionLayer 。</p>
<p>在初始化 mCompositionLayer 时，是借助 SurfaceFlinger 中的 CompositionEngine 的 createLayer 方法来实现的。传入了一个封装了当前BufferLayer实例this的 compositionengine::LayerCreationArgs 对象。我们简单看下创建流程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CompositionEngine.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;compositionengine::Layer&gt; <span class="title">CompositionEngine::createLayer</span><span class="params">(LayerCreationArgs&amp;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compositionengine::impl::<span class="built_in">createLayer</span>(*<span class="keyword">this</span>, std::<span class="built_in">move</span>(args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compositionengine::Layer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;compositionengine::Layer&gt; <span class="title">createLayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> compositionengine::CompositionEngine&amp; compositionEngine,</span></span></span><br><span class="line"><span class="params"><span class="function">        compositionengine::LayerCreationArgs&amp;&amp; args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Layer&gt;(compositionEngine, std::<span class="built_in">move</span>(args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Layer::<span class="built_in">Layer</span>(<span class="type">const</span> CompositionEngine&amp; compositionEngine, LayerCreationArgs&amp;&amp; args)</span><br><span class="line">      : <span class="built_in">mCompositionEngine</span>(compositionEngine), <span class="built_in">mLayerFE</span>(args.layerFE) &#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">void</span>&gt;(mCompositionEngine); <span class="comment">// Temporary use to prevent an unused warning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的 CompositionEngine 对象实例是从 SurfaceFlinger 中获取到的，而它的创建是在 SurfaceFlinger的 init() 方法中完成的。</p>
<p>这里调用到 CompositionEngine 内，创建了一个compositionengine::Layer 对象。然后使用传入进去的 compositionengine::LayerCreationArgs 来初始化它。实际就是：</p>
<p>①让新创建出来的 compositionengine::Layer 中的  mCompositionEngine 指向 SurfaceFlinger 中的 mCompositionEngine；</p>
<p>②让新创建出来的 compositionengine::Layer 中的  mLayerFE 指向这里的 BufferLayer 。</p>
<blockquote>
<p>注意这里的 LayerCreationArgs 中实际接收的是一个 compositionengine::LayerFE 实例。由于 Layer 是继承自它的，所以这里可以把 BufferLayer 的this 传入进去。</p>
</blockquote>
<p>上面创建之后的 compositionengine::Layer 实例最终会赋值给 BufferLayer 的 mCompositionLayer 属性。那么此时可以知道： BufferLayer 和 compositionengine::Layer 之间是互相引用的。知道其中一个也就知道了另外一个。这俩的区别等后面再说。</p>
<p>对于BufferLayer 中的方法实现，想分析的一些关键方法都和其子类有关，分析起来别扭，因此等后续介绍其子类时再补充吧。</p>
<p>而对于 BufferLayer 的子类，着重要分析的是BufferQueueLayer，但为了后面能更好的讲它，我们需要在讲他之前做一些基础知识铺垫，所谓：磨刀不误砍柴工。</p>
<blockquote>
<p>下面会有一些 BufferQueue 相关的知识，建议先去熟悉下再往下看：<a href="98c274c6.html">BufferQueue1</a> 和 <a href="dff29dd0.html">BufferQueue2</a></p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="ConsumerBase"><a href="#ConsumerBase" class="headerlink" title="ConsumerBase"></a>ConsumerBase</h3><p>ConsumerBase 相当于是 BufferQueueConsumer 的一个包装类，它内部包装了 BufferQueueConsumer 并在其基础上扩充出来一些新的功能。</p>
<p>先看看其定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerBase.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsumerBase</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase,</span><br><span class="line">        <span class="keyword">protected</span> ConsumerListener &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FrameAvailableListener</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">        <span class="comment">// See IConsumerListener::onFrame&#123;Available,Replaced&#125;</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onFrameAvailable</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onFrameReplaced</span><span class="params">(<span class="type">const</span> BufferItem&amp; <span class="comment">/* item */</span>)</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ConsumerBase</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">abandon</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAbandoned</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> String8&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFrameAvailableListener</span><span class="params">(<span class="type">const</span> wp&lt;FrameAvailableListener&gt;&amp; listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">detachBuffer</span><span class="params">(<span class="type">int</span> slot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">setDefaultBufferSize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">discardFreeBuffers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">ConsumerBase</span>(<span class="type">const</span> ConsumerBase&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onFrameAvailable</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onFrameReplaced</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onBuffersReleased</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeBufferLocked</span><span class="params">(<span class="type">int</span> slotIndex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">abandonLocked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">acquireBufferLocked</span><span class="params">(BufferItem *item, <span class="type">nsecs_t</span> presentWhen,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">releaseBufferLocked</span><span class="params">(<span class="type">int</span> slot,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> sp&lt;GraphicBuffer&gt; graphicBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">            EGLDisplay display = EGL_NO_DISPLAY, EGLSyncKHR eglFence = EGL_NO_SYNC_KHR)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Slot</span> &#123;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line"></span><br><span class="line">        sp&lt;Fence&gt; mFence;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint64_t</span> mFrameNumber;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Slot mSlots[BufferQueueDefs::NUM_BUFFER_SLOTS];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mAbandoned;</span><br><span class="line"></span><br><span class="line">    String8 mName;</span><br><span class="line"></span><br><span class="line">    wp&lt;FrameAvailableListener&gt; mFrameAvailableListener;</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt; mConsumer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ConsumerBase 继承自 RefBase 和 ConsumerListener 。</p>
<p>它内部还额外定义了两个结构体，这里先介绍下</p>
<h4 id="FrameAvailableListener"><a href="#FrameAvailableListener" class="headerlink" title="FrameAvailableListener"></a>FrameAvailableListener</h4><p>可以认为是一个回调接口，外部可以通过当前类的 setFrameAvailableListener 方法来注册一个监听，用来监听当前类内部的 BufferQueueComsumer 中的BufferItem可用，或者被替换。这个接口类似于之前在 BufferQueue中给 BufferQueueComsumer 设置的 ConsumerListener 。</p>
<p>这个接口其实就是 ConsumerListener的精简版本。</p>
<h4 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h4><p>这个结构体是对 BufferItem 中关键字段的封装，比如代表缓冲区的 mGraphicBuffer ，代表同步的 mFence ，以及代表当前是第几帧的 mFrameNumber ，这些字段在 BufferItem 中都有，甚至说是在 BufferSlot 中都有这些字段，它相当于是那俩的子集。</p>
<p>关于Slot 的其他分析在后续分析当前类中 mSlots 时再说吧。</p>
<p>分析完这俩之后，接着就可以分析当前类中的属性了：</p>
<p>1、mSlots ： 它是一个长度为BufferQueueDefs::NUM_BUFFER_SLOTS 的 Slot 数组。而这个长度也是跟 BufferQueueCore 中 mSlots 的长度一致。</p>
<p>这个数组的作用是：把 从 BufferQueueComsumer 中取出的待消费 BufferItem 的信息暂存起来。以供后续使用。</p>
<p>2、mAbandoned ： 当前 ConsumerBase 是否已被抛弃。类似于 BufferQueueCore 一样，不使用了就可以将其抛弃掉，此时内部的资源会被销毁回收。</p>
<p>3、mFrameAvailableListener ： 外部通过当前类的 setFrameAvailableListener 方法来注册的监听，它的回调时刻等后面分析实现时，再讲吧。</p>
<p>4、mConsumer ： 这才是主角，它对应着一个 IGraphicBufferConsumer 接口的实现类，当然一般就是 BufferQueueConsumer 实例。后续默认将其当做是 BufferQueueConsumer 来分析。</p>
<p>前面讲到了当前 ConsumerBase 实际是一个包装类，而它包装的就是当前  BufferQueueConsumer 。</p>
<p>看完定义之后，接着看它的实现：</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerBase.cpp</span></span><br><span class="line"></span><br><span class="line">ConsumerBase::<span class="built_in">ConsumerBase</span>(<span class="type">const</span> sp&lt;IGraphicBufferConsumer&gt;&amp; bufferQueue, <span class="type">bool</span> controlledByApp) :</span><br><span class="line">        <span class="built_in">mAbandoned</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mConsumer</span>(bufferQueue),</span><br><span class="line">        <span class="built_in">mPrevFinalReleaseFence</span>(Fence::NO_FENCE) &#123;</span><br><span class="line"></span><br><span class="line">    mName = String8::format(<span class="string">&quot;unnamed-%d-%d&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">createProcessUniqueId</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前类转为 ConsumerListener 来使用</span></span><br><span class="line">    wp&lt;ConsumerListener&gt; listener = <span class="built_in">static_cast</span>&lt;ConsumerListener*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将其封装到 ProxyConsumerListener 中去</span></span><br><span class="line">    sp&lt;IConsumerListener&gt; proxy = <span class="keyword">new</span> BufferQueue::<span class="built_in">ProxyConsumerListener</span>(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将创建好的 Listener 设置到 GraphicBufferConsumer 中去</span></span><br><span class="line">    <span class="comment">// 当 BufferQueue 所对应的 BufferQueueProducer queueBuffer 之后，会回调这里的 Listener</span></span><br><span class="line">    <span class="comment">// 比如会回调 onFrameAvailable 或者 onFrameReplaced</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前 消费者mConsumer 与 BufferQueue 之间建立连接，主要的就是将 ConsumerListener 监听设置进去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">status_t</span> err = mConsumer-&gt;<span class="built_in">consumerConnect</span>(proxy, controlledByApp);</span><br><span class="line">    <span class="comment">// 设置失败</span></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">CB_LOGE</span>(<span class="string">&quot;ConsumerBase: error connecting to BufferQueue: %s (%d)&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mConsumer-&gt;<span class="built_in">setConsumerName</span>(mName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BufferQueue.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyConsumerListener</span> : <span class="keyword">public</span> BnConsumerListener &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ProxyConsumerListener</span><span class="params">(<span class="type">const</span> wp&lt;ConsumerListener&gt;&amp; consumerListener)</span></span>;</span><br><span class="line">        ~<span class="built_in">ProxyConsumerListener</span>() <span class="keyword">override</span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">onDisconnect</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">onFrameAvailable</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">onFrameReplaced</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">onBuffersReleased</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">onSidebandStreamChanged</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addAndGetFrameTimestamps</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> NewFrameEventsEntry* newTimestamps,</span></span></span><br><span class="line"><span class="params"><span class="function">                FrameEventHistoryDelta* outDelta)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        wp&lt;ConsumerListener&gt; mConsumerListener;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在其构造方法中会给 mConsumer 赋值，一般赋值的就是一个 BufferQueueConsumer 。</p>
<p>然后在方法内，会首先将当前 ConsumerBase 当做是 ConsumerListener 然后包装到 ProxyConsumerListener 中，然后调用 mConsumer 的 consumerConnect 方法来将该 BufferQueueComsumer 接入到 BufferQueue 中，实际就是保存了 ConsumerListener 回调。</p>
<blockquote>
<p>使用 ProxyConsumerListener 包一层是因为当前 ConsumerBase 的子类可能是在其他进程中初始化的，那么就会牵扯到进程间调用，所以这里使用 ProxyConsumerListener ，它是继承自 BnXXXX ，支持Binder通信的。</p>
</blockquote>
<p>当 ConsumerListener 设置进去之后，等到后续生产者生产完成数据，并调用 queueBuffer 入队到BufferQueueCore . mQueue 时，这里的 ConsumerListener 就会被回调，也就是当前 ConsumerBase 中的 onFrameAvailable() 之类的方法就会被回调。</p>
<h4 id="onFrameAvailable"><a href="#onFrameAvailable" class="headerlink" title="onFrameAvailable"></a>onFrameAvailable</h4><p>正如前面所言，该方法被回调时，是对应的生产者往BufferQueue队列中放入了生产好待消费的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsumerBase::onFrameAvailable</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    sp&lt;FrameAvailableListener&gt; listener;</span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameAvailableMutex)</span></span>;</span><br><span class="line">        listener = mFrameAvailableListener.<span class="built_in">promote</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">CB_LOGV</span>(<span class="string">&quot;actually calling onFrameAvailable&quot;</span>);</span><br><span class="line">        listener-&gt;<span class="built_in">onFrameAvailable</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>luoji逻辑很简单，就是回调 FrameAvailableListener 的 onFrameAvailable 方法就行了。此时外部设置进来的监听器就会被触发。因此我们可以把 FrameAvailableListener 当做  ConsumerListener 来理解，他俩被回调的时机是一样的。</p>
<h4 id="onFrameReplaced"><a href="#onFrameReplaced" class="headerlink" title="onFrameReplaced"></a>onFrameReplaced</h4><p>同上 onFrameAvailable 。</p>
<h4 id="abandon"><a href="#abandon" class="headerlink" title="abandon"></a>abandon</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsumerBase::abandon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mAbandoned) &#123;</span><br><span class="line">        <span class="built_in">abandonLocked</span>();</span><br><span class="line">        mAbandoned = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsumerBase::abandonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 避免重复调用</span></span><br><span class="line">    <span class="keyword">if</span> (mAbandoned) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试把所有的Slot都清除掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i &lt; BufferQueue::NUM_BUFFER_SLOTS; i++) &#123;</span><br><span class="line">        <span class="built_in">freeBufferLocked</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// disconnect from the BufferQueue</span></span><br><span class="line">    mConsumer-&gt;<span class="built_in">consumerDisconnect</span>();</span><br><span class="line">    mConsumer.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsumerBase::freeBufferLocked</span><span class="params">(<span class="type">int</span> slotIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将其属性清理掉</span></span><br><span class="line">    mSlots[slotIndex].mGraphicBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">    mSlots[slotIndex].mFence = Fence::NO_FENCE;</span><br><span class="line">    mSlots[slotIndex].mFrameNumber = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>丢弃掉当前 ConsumerBase ，此时会清理掉内部所有的 Slot ，并且把  mAbandoned 置为true。</p>
<h4 id="acquireBufferLocked"><a href="#acquireBufferLocked" class="headerlink" title="acquireBufferLocked"></a>acquireBufferLocked</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">ConsumerBase::acquireBufferLocked</span><span class="params">(BufferItem *item,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span> presentWhen, <span class="type">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当前对象已经被 abandon 掉了</span></span><br><span class="line">    <span class="keyword">if</span> (mAbandoned) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过内部封装的 GraphicBufferConsumer 来获取一个可以消费的 BufferItem </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">status_t</span> err = mConsumer-&gt;<span class="built_in">acquireBuffer</span>(item, presentWhen, maxFrameNumber);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果新获取到的 BufferItem 的 mGraphicBuffer 不为空(一般都不为空)，则将该 mGraphicBuffer 保存到指定位置的 mSlots 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;mGraphicBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果原先该位置的 Slot 中对应的 mGraphicBuffer 有值，那么就把之前的值先清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (mSlots[item-&gt;mSlot].mGraphicBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">freeBufferLocked</span>(item-&gt;mSlot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清理掉之后再保存新的值</span></span><br><span class="line">        mSlots[item-&gt;mSlot].mGraphicBuffer = item-&gt;mGraphicBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样是保存新的值</span></span><br><span class="line">    mSlots[item-&gt;mSlot].mFrameNumber = item-&gt;mFrameNumber;</span><br><span class="line">    mSlots[item-&gt;mSlot].mFence = item-&gt;mFence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法相当于是对其内部的 BufferQueueConsumer 的 acquireBuffer 的封装。</p>
<blockquote>
<p>ConsumerBase 中好多方法的具体实现都是 交由 BufferQueueConsumer 来处理的。</p>
</blockquote>
<p>但是在该方法中，额外的会将从内部 BufferQueueConsumer 中取出的待消费的 BufferItem 转存到当前 ConsumerBase 中的 mSlots 数组中，以供后续使用。</p>
<h4 id="releaseBufferLocked"><a href="#releaseBufferLocked" class="headerlink" title="releaseBufferLocked"></a>releaseBufferLocked</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerBase.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">ConsumerBase::releaseBufferLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> slot, <span class="type">const</span> sp&lt;GraphicBuffer&gt; graphicBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        EGLDisplay display, EGLSyncKHR eglFence)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 合法性检查</span></span><br><span class="line">    <span class="keyword">if</span> (mAbandoned) &#123;</span><br><span class="line">        <span class="built_in">CB_LOGE</span>(<span class="string">&quot;releaseBufferLocked: ConsumerBase is abandoned!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">stillTracking</span>(slot, graphicBuffer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要是调用 releaseBuffer 方法来将对应的 Buffer 置为 Free 状态，方便后续复用</span></span><br><span class="line">    <span class="type">status_t</span> err = mConsumer-&gt;<span class="built_in">releaseBuffer</span>(slot, mSlots[slot].mFrameNumber,</span><br><span class="line">            display, eglFence, mSlots[slot].mFence);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回 STALE_BUFFER_SLOT 的话，表示对应的缓存区无效了，此时外部需要将之前存储的清除掉</span></span><br><span class="line">    <span class="keyword">if</span> (err == IGraphicBufferConsumer::STALE_BUFFER_SLOT) &#123;</span><br><span class="line">        <span class="built_in">freeBufferLocked</span>(slot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrevFinalReleaseFence = mSlots[slot].mFence;</span><br><span class="line">    mSlots[slot].mFence = Fence::NO_FENCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上面的方法类似，该方法是对其内部的 BufferQueueConsumer 的 releaseBuffer 的封装。</p>
<p>而这里方法的入参中，只传入了比较关键的 slot，通过 slot 值可以从 mSlots 中查找到其之前 acquire 取出时的 mFrameNumber 等属性。更加方便了之后的操作。</p>
<p>至此，我们对于 ConsumerBase 的理解又加深了一点，它相当于就是 BufferQueueConsumer 的封装类。外部使用它就跟使用 BufferQueueConsumer 一样，BufferQueueConsumer 中的一些方法当前类中也都有暴露，可以理解是一个静态代理类吧。</p>
<h3 id="BufferLayerConsumer"><a href="#BufferLayerConsumer" class="headerlink" title="BufferLayerConsumer"></a>BufferLayerConsumer</h3><p>先看其定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayerConsumer.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferLayerConsumer</span> : <span class="keyword">public</span> ConsumerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ContentsChangedListener</span> : <span class="keyword">public</span> FrameAvailableListener &#123;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onSidebandStreamChanged</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BufferLayerConsumer</span>(<span class="type">const</span> sp&lt;IGraphicBufferConsumer&gt;&amp; bq, renderengine::RenderEngine&amp; engine,</span><br><span class="line">                        <span class="type">uint32_t</span> tex, Layer* layer);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setContentsChangedListener</span><span class="params">(<span class="type">const</span> wp&lt;ContentsChangedListener&gt;&amp; listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">updateTexImage</span><span class="params">(BufferRejecter* rejecter, <span class="type">nsecs_t</span> expectedPresentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">bool</span>* autoRefresh, <span class="type">bool</span>* queuedBuffer, <span class="type">uint64_t</span> maxFrameNumber)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">bindTextureImage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">releasePendingBuffer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getTransformMatrix</span><span class="params">(<span class="type">float</span> mtx[<span class="number">16</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">getTimestamp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ui::Dataspace <span class="title">getCurrentDataSpace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> HdrMetadata&amp; <span class="title">getCurrentHdrMetadata</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">getFrameNumber</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Region&amp; <span class="title">getSurfaceDamage</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCurrentApi</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">setDefaultBufferSize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">getCurrentBuffer</span><span class="params">(<span class="type">int</span>* outSlot = <span class="literal">nullptr</span>, sp&lt;Fence&gt;* outFence = <span class="literal">nullptr</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Rect <span class="title">getCurrentCrop</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getCurrentTransform</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getCurrentScalingMode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onBufferAvailable</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> <span class="title">EXCLUDES</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">abandonLocked</span><span class="params">()</span> <span class="title">EXCLUDES</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">acquireBufferLocked</span><span class="params">(BufferItem* item, <span class="type">nsecs_t</span> presentWhen,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">            <span class="title">EXCLUDES</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PendingRelease</span> &#123;</span><br><span class="line">        <span class="built_in">PendingRelease</span>() : <span class="built_in">isPending</span>(<span class="literal">false</span>), <span class="built_in">currentTexture</span>(<span class="number">-1</span>), <span class="built_in">graphicBuffer</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> isPending;</span><br><span class="line">        <span class="type">int</span> currentTexture;</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">updateAndReleaseLocked</span><span class="params">(<span class="type">const</span> BufferItem&amp; item,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    PendingRelease* pendingRelease = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">            <span class="title">EXCLUDES</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">bindTextureImageLocked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其实就是将 GraphicBuffer 和 RenderEngine 保存起来了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Image</span>(<span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; graphicBuffer, renderengine::RenderEngine&amp; engine);</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Image</span>();</span><br><span class="line">        <span class="function"><span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">graphicBuffer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mGraphicBuffer; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// mGraphicBuffer is the buffer that was used to create this image.</span></span><br><span class="line">        sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line">        <span class="comment">// Back-reference into renderengine to initiate cleanup.</span></span><br><span class="line">        renderengine::RenderEngine&amp; mRE;</span><br><span class="line">        <span class="built_in">DISALLOW_COPY_AND_ASSIGN</span>(Image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">freeBufferLocked</span><span class="params">(<span class="type">int</span> slotIndex)</span> <span class="title">EXCLUDES</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onDisconnect</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;Image&gt; mCurrentTextureBuffer;</span><br><span class="line"></span><br><span class="line">    Rect mCurrentCrop;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> mCurrentTransform;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> mCurrentScalingMode;</span><br><span class="line"></span><br><span class="line">    sp&lt;Fence&gt; mCurrentFence;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;FenceTime&gt; mCurrentFenceTime&#123;FenceTime::NO_FENCE&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> mCurrentTransformMatrix[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> mCurrentTimestamp;</span><br><span class="line"></span><br><span class="line">    ui::Dataspace mCurrentDataSpace;</span><br><span class="line"></span><br><span class="line">    HdrMetadata mCurrentHdrMetadata;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> mCurrentFrameNumber;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mCurrentTransformToDisplayInverse;</span><br><span class="line"></span><br><span class="line">    Region mCurrentSurfaceDamage;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mCurrentApi;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> mDefaultWidth, mDefaultHeight;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mFilteringEnabled;</span><br><span class="line"></span><br><span class="line">    renderengine::RenderEngine&amp; mRE;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> mTexName;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> wp&lt;Layer&gt; mLayer;</span><br><span class="line"></span><br><span class="line">    wp&lt;ContentsChangedListener&gt; mContentsChangedListener;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mCurrentTexture;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;Image&gt; mImages[BufferQueueDefs::NUM_BUFFER_SLOTS] <span class="built_in">GUARDED_BY</span>(mImagesMutex);</span><br><span class="line"></span><br><span class="line">    PendingRelease mPendingRelease;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该类中的定义较多，一步步来分析。首先该类继承自 ConsumerBase，因此它内部也是有一个 BufferQueueConsumer 的。</p>
<p>其次它内部定义了几个新类型：</p>
<h4 id="ContentsChangedListener"><a href="#ContentsChangedListener" class="headerlink" title="ContentsChangedListener"></a>ContentsChangedListener</h4><p>该结构体继承自 FrameAvailableListener ,在其基础上扩充了一个新的方法。后续可以把该结构体当做是 FrameAvailableListener 来理解。</p>
<h4 id="PendingRelease"><a href="#PendingRelease" class="headerlink" title="PendingRelease"></a>PendingRelease</h4><p>该结构体其实是： isPending 、currentTexture、graphicBuffer 的一个封装体，其中 isPending 默认是false ，当其内部有合法值时将其置为true，只有isPending&#x3D;true时才能去使用PendingRelease实例中的其他俩属性。</p>
<p>currentTexture 其实它的值就是之前讲的 slot 索引值。暂时可以将其当做是 slot 索引值来理解。</p>
<p>而 PendingRelease 类实例代表的是：即将要被回收release 掉的BufferItem信息。currentTexture代表了其 slot索引值。</p>
<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>Image 这个名称就可以看出来其和最终的帧渲染展示有关。</p>
<p>而该类内部封装了 GraphicBuffer 和 renderengine::RenderEngine 。其中前者代表待显示的图形数据；后者代表渲染展示用的引擎，实际对应的是 SurfaceFlinger 中创建的 mRenderEngine 。</p>
<p>接下来看当前类中的属性定义：</p>
<p>1、mImages：一个长度为BufferQueueDefs::NUM_BUFFER_SLOTS 的 Image 数组。</p>
<p>该数组的作用跟前面 ConsumerBase 中 mSlots 数组有点类似。</p>
<p>前面的 ConsumerBase 中，是将从其内部 BufferQueueConsumer 中 acquire 出来的BufferItem 的信息封装成 Slot 放入到 mSlots 数组对应位置去。</p>
<p>而这里是将其封装成 Image ，存入到 mImages 数组的对应位置去。在封装成 Image 时，只是将 BufferItem 的 GraphicBuffer 和SurfaceFlinger中的 mRenderEngine 这两个保存了起来。</p>
<p>2、mLayer：当前 BufferLayerConsumer 所对应的 Layer 。因为对于当前 BufferLayerConsumer 来说，它的创建和实例化都是在 BufferQueueLayer(BufferLayer的子类，后续会讲的) 中完成的。当前BufferLayerConsumer其实就是为BufferQueueLayer服务的，所以它里面需要保存对应它所服务的Layer实例。</p>
<p>该属性在 BufferLayerConsumer 的构造方法中被赋值。</p>
<p>3、mRE：它对应的是 SurfaceFlinger 中的 mRenderEngine 实例，使用它可以用来后期的渲染。</p>
<p>它的赋值也是在 BufferLayerConsumer 的构造方法中。后期它会被保存到每个 Image 中去。</p>
<p>4、mCurrentTexture：实际对应的是当前从消费者队列中通过 acquire 方法取出的 BufferItem 的 slot 索引值。</p>
<p>5、mPendingRelease：待release的数据，当内部有需要延迟release 的数据时，会将其slot等值存入到PendingRelease中，然后保存给当前属性 mPendingRelease，后期就可以使用它来release相关数据了。</p>
<p>6、mContentsChangedListener ： 外部通过 setContentsChangedListener 方法设置进来的监听，可以将其当做 前面讲过的 FrameAvailableListener 来理解。</p>
<p>7、mCurrentTextureBuffer ：和前面讲的 mCurrentTexture 属性类似，不同的是 mCurrentTexture 表示的是对应 slot 索引值，而这里的 mCurrentTextureBuffer表示的是对应该 slot 位置的Image实例。</p>
<p>8、其他 mCurrentXXXX 属性：有点类似前面的 mCurrentTexture 和 mCurrentTextureBuffer ，因为这俩属性只保存了对应的BufferItem 中的 slot 和 graphicBuffer ，而BufferItem 中剩余的属性保存在哪儿呢？正是这些 mCurrentXXX 属性中。</p>
<p>接下来看当前类具体的实现：</p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayerConsumer.cpp</span></span><br><span class="line"></span><br><span class="line">BufferLayerConsumer::<span class="built_in">BufferLayerConsumer</span>(<span class="type">const</span> sp&lt;IGraphicBufferConsumer&gt;&amp; bq,</span><br><span class="line">                                         renderengine::RenderEngine&amp; engine, <span class="type">uint32_t</span> tex,</span><br><span class="line">                                         Layer* layer)</span><br><span class="line">      : <span class="built_in">ConsumerBase</span>(bq, <span class="literal">false</span>),   <span class="comment">// 先进行父类的初始化</span></span><br><span class="line">        <span class="built_in">mCurrentCrop</span>(Rect::EMPTY_RECT),</span><br><span class="line">        <span class="built_in">mCurrentTransform</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">mCurrentScalingMode</span>(NATIVE_WINDOW_SCALING_MODE_FREEZE),</span><br><span class="line">        <span class="built_in">mCurrentFence</span>(Fence::NO_FENCE),</span><br><span class="line">        <span class="built_in">mCurrentTimestamp</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">mCurrentDataSpace</span>(ui::Dataspace::UNKNOWN),</span><br><span class="line">        <span class="built_in">mCurrentFrameNumber</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">mCurrentTransformToDisplayInverse</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mCurrentSurfaceDamage</span>(),</span><br><span class="line">        <span class="built_in">mCurrentApi</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">mDefaultWidth</span>(<span class="number">1</span>),</span><br><span class="line">        <span class="built_in">mDefaultHeight</span>(<span class="number">1</span>),</span><br><span class="line">        <span class="built_in">mFilteringEnabled</span>(<span class="literal">true</span>),</span><br><span class="line">        <span class="built_in">mRE</span>(engine),</span><br><span class="line">        <span class="built_in">mTexName</span>(tex),</span><br><span class="line">        <span class="built_in">mLayer</span>(layer),</span><br><span class="line">        <span class="built_in">mCurrentTexture</span>(BufferQueue::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(mCurrentTransformMatrix, mtxIdentity.<span class="built_in">asArray</span>(), <span class="built_in">sizeof</span>(mCurrentTransformMatrix));</span><br><span class="line"></span><br><span class="line">    mConsumer-&gt;<span class="built_in">setConsumerUsageBits</span>(DEFAULT_USAGE_FLAGS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其构造方法中，传入了 bq ，实际是 BufferQueueConsumer 实例，以及 engine ，实际是 SurfaceFlinger 中的 mRenderEngine。</p>
<p>在构造方法中首先将其传入到父类 ConsumerBase 中去初始化，然后再将当前类中的属性初始化。</p>
<h4 id="setContentsChangedListener"><a href="#setContentsChangedListener" class="headerlink" title="setContentsChangedListener"></a>setContentsChangedListener</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayerConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferLayerConsumer::setContentsChangedListener</span><span class="params">(<span class="type">const</span> wp&lt;ContentsChangedListener&gt;&amp; listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先调用父类的注册方法来注册监听</span></span><br><span class="line">    <span class="built_in">setFrameAvailableListener</span>(listener);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="comment">// 再将其保存到当前类中</span></span><br><span class="line">    mContentsChangedListener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是外部注册监听给 BufferLayerConsumer 的，在注册进来之后，首先会调用父类的 setFrameAvailableListener 方法来注册FrameAvailableListener 监听，然后再将其保存到当前类属性中。</p>
<h4 id="updateTexImage"><a href="#updateTexImage" class="headerlink" title="updateTexImage"></a>updateTexImage</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayerConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferLayerConsumer::updateTexImage</span><span class="params">(BufferRejecter* rejecter, <span class="type">nsecs_t</span> expectedPresentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">bool</span>* autoRefresh, <span class="type">bool</span>* queuedBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查合法性</span></span><br><span class="line">    <span class="keyword">if</span> (mAbandoned) &#123;</span><br><span class="line">        <span class="built_in">BLC_LOGE</span>(<span class="string">&quot;updateTexImage: BufferLayerConsumer is abandoned!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BufferItem item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过父类从内部BufferQueue 中出队一个待消费的 BufferItem ，并将其更新的 mImages 中对应位置上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">acquireBufferLocked</span>(&amp;item, expectedPresentTime, maxFrameNumber);</span><br><span class="line">    <span class="comment">// 出队有点问题</span></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err == BufferQueue::NO_BUFFER_AVAILABLE) &#123;</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == BufferQueue::PRESENT_LATER) &#123;</span><br><span class="line">            <span class="comment">// return the error, without logging</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">BLC_LOGE</span>(<span class="string">&quot;updateTexImage: acquire failed: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将出队的 BufferItem 中的属性保存，用于返回给外部</span></span><br><span class="line">    <span class="keyword">if</span> (autoRefresh) &#123;</span><br><span class="line">        *autoRefresh = item.mAutoRefresh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// acquire 到的该 BufferItem 是否处于消费队列中，非共享模式下肯定是 true</span></span><br><span class="line">    <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">        *queuedBuffer = item.mQueuedBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> slot = item.mSlot;</span><br><span class="line">    <span class="comment">// 是否拒绝该BufferItem，比如尺寸不一样之类的，内部会有一套拒绝策略</span></span><br><span class="line">    <span class="keyword">if</span> (rejecter &amp;&amp; rejecter-&gt;<span class="built_in">reject</span>(mSlots[slot].mGraphicBuffer, item)) &#123;</span><br><span class="line">        <span class="built_in">releaseBufferLocked</span>(slot, mSlots[slot].mGraphicBuffer);</span><br><span class="line">        <span class="keyword">return</span> BUFFER_REJECTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Release the previous buffer.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里将获取到的 item 保存到当前实例的 mCurrentTexture 等全局变量中</span></span><br><span class="line"><span class="comment">     * 在将新的 item 相关信息保存在 mCurrentTexture 中之前，会先将之前的值保存在 mPendingRelease 中</span></span><br><span class="line"><span class="comment">     * 注意此时是将新获取到的待消费的 BufferItem 的信息保存在了全局 mCurrentTexture 等变量中，等后续调用 getCurrentBuffer 时可以获取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = <span class="built_in">updateAndReleaseLocked</span>(item, &amp;mPendingRelease);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mRE.<span class="built_in">useNativeFenceSync</span>()) &#123;</span><br><span class="line">        err = <span class="built_in">bindTextureImageLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferLayerConsumer::acquireBufferLocked</span><span class="params">(BufferItem* item, <span class="type">nsecs_t</span> presentWhen,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用到父类 ConsumerBase 中，去从 BufferQueue 中出队一个待消费的BufferItem</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">status_t</span> err = ConsumerBase::<span class="built_in">acquireBufferLocked</span>(item, presentWhen, maxFrameNumber);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队的 BufferItem 的 mGraphicBuffer 一般不为空</span></span><br><span class="line"><span class="comment">     * 这里会判断 mImages 数组中对应位置存储的 GraphicBuffer 是否和新出队的一致，</span></span><br><span class="line"><span class="comment">     * 不一致的话则使用新的来更新旧的，始终保持 mImages 中存储的数据是最新的</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;mGraphicBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mImages[item-&gt;mSlot] == <span class="literal">nullptr</span> || mImages[item-&gt;mSlot]-&gt;<span class="built_in">graphicBuffer</span>() == <span class="literal">nullptr</span> ||</span><br><span class="line">            mImages[item-&gt;mSlot]-&gt;<span class="built_in">graphicBuffer</span>()-&gt;<span class="built_in">getId</span>() != item-&gt;mGraphicBuffer-&gt;<span class="built_in">getId</span>()) &#123;</span><br><span class="line">            mImages[item-&gt;mSlot] = std::<span class="built_in">make_shared</span>&lt;Image&gt;(item-&gt;mGraphicBuffer, mRE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferLayerConsumer::updateAndReleaseLocked</span><span class="params">(<span class="type">const</span> BufferItem&amp; item,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     PendingRelease* pendingRelease)</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> slot = item.mSlot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出 mImages 中对应位置的 Image 。因为在前面调用 acquireBufferLocked 方法时会将新取出的待消费BufferItem 存储到 mImages中</span></span><br><span class="line"><span class="comment">     * 因此此时取出的就是之前保存的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::shared_ptr&lt;Image&gt; nextTextureBuffer;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line">        nextTextureBuffer = mImages[slot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mCurrentTexture 中存储的是上次调用 updateAndReleaseLocked 方法时传入的BufferItem 的 slot</span></span><br><span class="line"><span class="comment">     * 而本次调用 updateAndReleaseLocked 时需要更新 mCurrentTexture 的值，在更新之前需要将其之前对应的数据释放掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">        <span class="comment">// 如果入参 pendingRelease 为空则这里直接释放，否则扔给 pendingRelease 让他去外部释放</span></span><br><span class="line">        <span class="comment">// 这里的 pendingRelease 是外部传入的 mPendingRelease </span></span><br><span class="line">        <span class="keyword">if</span> (pendingRelease == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 该方法内部会调用 BufferQueue 的 releaseBuffer 方法来释放掉对应的 Buffer，即将其置为 FREE 状态，方便后续复用</span></span><br><span class="line">            <span class="type">status_t</span> status =</span><br><span class="line">                    <span class="built_in">releaseBufferLocked</span>(mCurrentTexture, mCurrentTextureBuffer-&gt;<span class="built_in">graphicBuffer</span>());</span><br><span class="line">            <span class="keyword">if</span> (status &lt; NO_ERROR) &#123;</span><br><span class="line">                err = status;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pendingRelease-&gt;currentTexture = mCurrentTexture;</span><br><span class="line">            pendingRelease-&gt;graphicBuffer = mCurrentTextureBuffer-&gt;<span class="built_in">graphicBuffer</span>();</span><br><span class="line">            pendingRelease-&gt;isPending = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用本次新的 BufferItem 来更新 mCurrentTexture、mCurrentTextureBuffer等这些属性</span></span><br><span class="line"><span class="comment">     * 这里保存其新的 BufferItem 中的值，后续就可以通过这些值直接获取对应的数据了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mCurrentTexture = slot;</span><br><span class="line">    mCurrentTextureBuffer = nextTextureBuffer;</span><br><span class="line">    mCurrentCrop = item.mCrop;</span><br><span class="line">    mCurrentTransform = item.mTransform;</span><br><span class="line">    mCurrentScalingMode = item.mScalingMode;</span><br><span class="line">    mCurrentTimestamp = item.mTimestamp;</span><br><span class="line">    mCurrentDataSpace = <span class="built_in">static_cast</span>&lt;ui::Dataspace&gt;(item.mDataSpace);</span><br><span class="line">    mCurrentHdrMetadata = item.mHdrMetadata;</span><br><span class="line">    mCurrentFence = item.mFence;</span><br><span class="line">    mCurrentFenceTime = item.mFenceTime;</span><br><span class="line">    mCurrentFrameNumber = item.mFrameNumber;</span><br><span class="line">    mCurrentTransformToDisplayInverse = item.mTransformToDisplayInverse;</span><br><span class="line">    mCurrentSurfaceDamage = item.mSurfaceDamage;</span><br><span class="line">    mCurrentApi = item.mApi;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">computeCurrentTransformMatrixLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是用来从 BufferQueue 中获取待消费的BufferItem，并将其属性保存到当前 BufferLayerConsumer 实例中的对应属性中。</p>
<p>该方法中在实现上述的逻辑时，主要分为两步：</p>
<p>1、调用 acquireBufferLocked() 方法，来通过父类从内部BufferQueue 中出队一个待消费的 BufferItem ，并将其更新的 mImages 中对应位置上</p>
<p>2、调用 updateAndReleaseLocked() 方法将取出的 BufferItem 的数据保存到当前 BufferLayerConsumer 中的对应属性中。这样的话后续就可以通过这些属性拿到上次出队的BufferItem中的信息。</p>
<h4 id="releasePendingBuffer"><a href="#releasePendingBuffer" class="headerlink" title="releasePendingBuffer"></a>releasePendingBuffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayerConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayerConsumer::releasePendingBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该PendingRelease 中的数据不合法，不使用它</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingRelease.isPending) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 mPendingRelease 中的slot的值来将对应的数据release掉</span></span><br><span class="line">    <span class="type">status_t</span> result =</span><br><span class="line">            <span class="built_in">releaseBufferLocked</span>(mPendingRelease.currentTexture, mPendingRelease.graphicBuffer);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">BLC_LOGE</span>(<span class="string">&quot;releasePendingBuffer failed: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-result), result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mPendingRelease 使用完了就将其重置掉。新创建的 PendingRelease 中的 isPending 默认是 false</span></span><br><span class="line">    mPendingRelease = <span class="built_in">PendingRelease</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清理释放掉之前在 mPendingRelease 中保存的数据。</p>
<h4 id="getCurrentBuffer"><a href="#getCurrentBuffer" class="headerlink" title="getCurrentBuffer"></a>getCurrentBuffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayerConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;GraphicBuffer&gt; <span class="title">BufferLayerConsumer::getCurrentBuffer</span><span class="params">(<span class="type">int</span>* outSlot, sp&lt;Fence&gt;* outFence)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将前面保存的 slot 值设置给入参，返回给外部</span></span><br><span class="line">    <span class="keyword">if</span> (outSlot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *outSlot = mCurrentTexture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outFence != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *outFence = mCurrentFence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对应mCurrentTextureBuffer 中保存的 GraphicBuffer</span></span><br><span class="line">    <span class="keyword">return</span> mCurrentTextureBuffer == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : mCurrentTextureBuffer-&gt;<span class="built_in">graphicBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>s如果理解了前面的 mCurrentTexture 、mCurrentTextureBuffer 的含义，以及其赋值时机，那么对于该方法就不难理解了。注意这里返回的是 GraphicBuffer。</p>
<h4 id="onBufferAvailable"><a href="#onBufferAvailable" class="headerlink" title="onBufferAvailable"></a>onBufferAvailable</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayerConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferLayerConsumer::onBufferAvailable</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查该 BufferItem 是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (item.mGraphicBuffer != <span class="literal">nullptr</span> &amp;&amp; item.mSlot != BufferQueue::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mImagesMutex)</span></span>;</span><br><span class="line">        <span class="type">const</span> std::shared_ptr&lt;Image&gt;&amp; oldImage = mImages[item.mSlot];</span><br><span class="line">        <span class="comment">// 判断该 BufferItem 和 mImages 中存储的是否有差异，有的话则使用 BufferItem 来更新它</span></span><br><span class="line">        <span class="keyword">if</span> (oldImage == <span class="literal">nullptr</span> || oldImage-&gt;<span class="built_in">graphicBuffer</span>() == <span class="literal">nullptr</span> ||</span><br><span class="line">            oldImage-&gt;<span class="built_in">graphicBuffer</span>()-&gt;<span class="built_in">getId</span>() != item.mGraphicBuffer-&gt;<span class="built_in">getId</span>()) &#123;</span><br><span class="line">            mImages[item.mSlot] = std::<span class="built_in">make_shared</span>&lt;Image&gt;(item.mGraphicBuffer, mRE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会被 BufferQueueLayer 调用，时机就是 BufferQueue 的 ConsumerListener 的 onBufferAvailable 回调。</p>
<p>这里是当生产者将生产好的数据放入到 BufferQueue 中之后，BufferQueueLayer 会收到通知，然后调用到这里来，这里面会使用这个新放入的 BufferItem 来更新 mImages 中的属性。</p>
<p>至此就基本算是将 BufferLayerConsumer 分析完了，这个类主要是将 Layer 和 BufferQueueConsumer 连接了起来。</p>
<p>理解了上面的 ConsumerBase 和 BufferLayerConsumer 之后，就可以接着看 Layer 相关的分析了，接下来看 BufferLayer 的一个子类 BufferQueueLayer。</p>
<h3 id="BufferQueueLayer"><a href="#BufferQueueLayer" class="headerlink" title="BufferQueueLayer"></a>BufferQueueLayer</h3><p>先看其定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueLayer.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferQueueLayer</span> : <span class="keyword">public</span> BufferLayer, <span class="keyword">public</span> BufferLayerConsumer::ContentsChangedListener &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BufferQueueLayer</span><span class="params">(<span class="type">const</span> LayerCreationArgs&amp;)</span></span>;</span><br><span class="line">    ~<span class="built_in">BufferQueueLayer</span>() <span class="keyword">override</span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">shouldPresentNow</span><span class="params">(<span class="type">nsecs_t</span> expectedPresentTime)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">nsecs_t</span> <span class="title">getDesiredPresentTime</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">getFrameNumber</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasFrameUpdate</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">bindTextureImage</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">updateTexImage</span><span class="params">(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">updateActiveBuffer</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">status_t</span> <span class="title">updateFrameNumber</span><span class="params">(<span class="type">nsecs_t</span> latchTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHwcLayerBuffer</span><span class="params">(<span class="type">const</span> sp&lt;<span class="type">const</span> DisplayDevice&gt;&amp; displayDevice)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onFrameAvailable</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onFrameReplaced</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onSidebandStreamChanged</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">getProducer</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onFirstRef</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">    sp&lt;BufferLayerConsumer&gt; mConsumer;</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; mProducer;</span><br><span class="line"></span><br><span class="line">    PixelFormat mFormat&#123;PIXEL_FORMAT_NONE&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> mPreviousFrameNumber&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="type">bool</span> mUpdateTexImageFailed&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Vector&lt;BufferItem&gt; mQueueItems;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mAutoRefresh&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mActiveBufferSlot&#123;BufferQueue::INVALID_BUFFER_SLOT&#125;;</span><br><span class="line"></span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; mQueuedFrames&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该 BufferLayerQueue 是继承自 BufferLayer 的，</p>
<p>并且额外实现了 BufferLayerConsumer::ContentsChangedListener 。</p>
<p>接着看看它内部的属性值：</p>
<p>1、mConsumer：一个BufferLayerConsumer 实例，在当前类的 onFirstRef 中被初始化赋值。后续使用它可以从消费队列中取出数据来处理。</p>
<p>2、mProducer：MonitoredProducer 实例，这个类其实就是 BufferQueueProducer 的代理类，后续可以把它当做是BufferQueueProducer 来理解。</p>
<blockquote>
<p>MonitoredProducer 类继承自 BnGraphicBufferProducer ，支持Binder跨进程调用。另外其中扩充了清理功能，在其析构方法执行时会通知到 SurfaceFlinger中去执行清理工作。</p>
</blockquote>
<p>3、mQueueItems ：他是一个存放 BufferItem 的集合。</p>
<p>它的作用基本和 BufferQueueCore 中的 mQueue 类似</p>
<p>相同点：都是存放着生产者生产好的并且通过 queueBuffer 方法入队了的待消费的 BufferItem ，</p>
<p>不同点：它所处的类不同而已，BufferQueueCore 中的 mQueue是给对应的消费者和生产者使用的；而这里的mQueueItems 是给当前 BufferQueueLayer 来使用的，而这两个可能不是同一个进程，所以这边的mQueueItems 相当于是 mQueue 的一个副本。</p>
<p>4、mActiveBufferSlot：存储着内部 BufferLayerConsumer 中刚出队的 BufferItem 的索引。后续分析实现时再细讲。</p>
<p>5、mQueuedFrames：当前已经入队到 mQueueItems 中的数量。其实就等价于 mQueueItems 的大小。</p>
<p>下面来看其具体实现：</p>
<h4 id="onFirstRef"><a href="#onFirstRef" class="headerlink" title="onFirstRef"></a>onFirstRef</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferQueueLayer::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BufferLayer::<span class="built_in">onFirstRef</span>();</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建  BufferQueueProducer 、 BufferQueueConsumer 实例</span></span><br><span class="line"><span class="comment">     * 该方法执行完毕后，入参 outProducer、outConsumer 分别指向创建的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BufferQueue::<span class="built_in">createBufferQueue</span>(&amp;producer, &amp;consumer, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MonitoredProducer 其实就是封装了下 producer ，然后内部方法都是使用 producer 来实现的</span></span><br><span class="line">    <span class="comment">// 后续可以将 MonitoredProducer 当做 BufferQueueProducer 来使用就行</span></span><br><span class="line">    mProducer = <span class="keyword">new</span> <span class="built_in">MonitoredProducer</span>(producer, mFlinger, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFlinger-&gt;mStateLock)</span></span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * consumer 是 BufferQueueConsumer 对象实例</span></span><br><span class="line"><span class="comment">         * 注意这里创建时传入的参数，consumer 是BufferQueueConsumer ，第二个是 SurfaceFlinger 中的 mRenderEngine</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mConsumer = <span class="keyword">new</span> <span class="built_in">BufferLayerConsumer</span>(consumer, mFlinger-&gt;<span class="built_in">getRenderEngine</span>(), mTextureName, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mConsumer-&gt;<span class="built_in">setConsumerUsageBits</span>(<span class="built_in">getEffectiveUsage</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册回调，后续会收到 onFrameAvailable 等方法回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mConsumer-&gt;<span class="built_in">setContentsChangedListener</span>(<span class="keyword">this</span>);</span><br><span class="line">    mConsumer-&gt;<span class="built_in">setName</span>(mName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mFlinger-&gt;<span class="built_in">isLayerTripleBufferingDisabled</span>()) &#123;</span><br><span class="line">        mProducer-&gt;<span class="built_in">setMaxDequeuedBufferCount</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> display = mFlinger-&gt;<span class="built_in">getDefaultDisplayDevice</span>()) &#123;</span><br><span class="line">        <span class="built_in">updateTransformHint</span>(display);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BufferQueueLayer 到头是继承自 RefBase 的，所以其实例后期被第一次引用时会调用其 onFirstRef 方法，在该方法中本类会完成初始化。</p>
<p>①通过 BufferQueue::createBufferQueue() 方法来创建一对 BufferQueueProducer 和 BufferQueueConsumer 实例。这俩实例是对应同一个 BufferQueueCore 的，也就是说这俩是一个生产消费队列的两端。</p>
<p>②将创建的这俩实例分别再次封装一下再赋值保存起来。即：将BufferQueueProducer 包装成 MonitoredProducer 然后再赋值给 mProducer ；将 BufferQueueConsumer 封装成 BufferLayerConsumer 实例并赋值给 mConsumer。</p>
<p>③ 通过 setContentsChangedListener  方法来给 BufferLayerConsumer 设置监听，这样的话后续 mProducer 那边生产好数据，入队之后，这边的 onFrameAvailable 方法会收到通知。</p>
<h4 id="onFrameAvailable-1"><a href="#onFrameAvailable-1" class="headerlink" title="onFrameAvailable"></a>onFrameAvailable</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferQueueLayer::onFrameAvailable</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFlinger-&gt;mUseSmart90ForVideo) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">nsecs_t</span> presentTime = item.mIsAutoTimestamp ? <span class="number">0</span> : item.mTimestamp;</span><br><span class="line">            mFlinger-&gt;mScheduler-&gt;<span class="built_in">addLayerPresentTimeAndHDR</span>(mSchedulerLayerHandle, presentTime,</span><br><span class="line">                                                            item.mHdrMetadata.validTypes != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (item.mFrameNumber == <span class="number">1</span>) &#123;</span><br><span class="line">            mLastFrameNumberReceived = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (item.mFrameNumber != mLastFrameNumberReceived + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">status_t</span> result = mQueueItemCondition.<span class="built_in">waitRelative</span>(mQueueItemLock, <span class="built_in">ms2ns</span>(<span class="number">500</span>));</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;[%s] Timed out waiting on callback&quot;</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 将生产者放入生产队列的BufferItem 放入到当前类的 mQueueItems 中</span></span><br><span class="line">        mQueueItems.<span class="built_in">push_back</span>(item);</span><br><span class="line">        <span class="comment">// mQueueItems 中有数据进来了，就自增计数器</span></span><br><span class="line">        mQueuedFrames++;</span><br><span class="line"></span><br><span class="line">        mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">        mQueueItemCondition.<span class="built_in">broadcast</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;mInterceptor-&gt;<span class="built_in">saveBufferUpdate</span>(<span class="keyword">this</span>, item.mGraphicBuffer-&gt;<span class="built_in">getWidth</span>(),</span><br><span class="line">                                             item.mGraphicBuffer-&gt;<span class="built_in">getHeight</span>(), item.mFrameNumber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isRemovedFromCurrentState</span>()) &#123;</span><br><span class="line">        <span class="built_in">fakeVsync</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFlinger-&gt;<span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知到 BufferLayerConsumer 中去，内部会更新 mImage</span></span><br><span class="line">    mConsumer-&gt;<span class="built_in">onBufferAvailable</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为前面注册了监听，因此后续 mProducer 那边生产好数据，入队之后，这边的 onFrameAvailable 方法会收到通知。</p>
<p>这边在收到通知之后，会将其入队到 mQueueItems集合中，并且会将 mQueuedFrames 计数器自增1，表示入队的 BufferItem 数增加了。</p>
<p>最后会调用到 BufferLayerConsumer 的 onFrameAvailable 方法内去通知它更新内部的 mImages 集合。</p>
<h4 id="shouldPresentNow"><a href="#shouldPresentNow" class="headerlink" title="shouldPresentNow"></a>shouldPresentNow</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::shouldPresentNow</span><span class="params">(<span class="type">nsecs_t</span> expectedPresentTime)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getSidebandStreamChanged</span>() || <span class="built_in">getAutoRefresh</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时内部如果还没有待消费的数据那么就直接返回吧</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasFrameUpdate</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 mQueueItems 列表中的第一项，也就是生产者已经生产数据中的第一项</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> addedTime = mQueueItems[<span class="number">0</span>].mTimestamp;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isPlausible = addedTime &lt; (expectedPresentTime + <span class="built_in">s2ns</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isDue = addedTime &lt; expectedPresentTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * addedTime : 已生产的待消费的数据中，第一帧数据的展示时间戳</span></span><br><span class="line"><span class="comment">     * expectedPresentTime : 外部期望的时间戳</span></span><br><span class="line"><span class="comment">     * isDue = true 时：第一帧数据的展示时间小于期望的时间戳，表示其早已到了该展示的时间了</span></span><br><span class="line"><span class="comment">     * isPlausible = false 时：即第一帧的展示时间大于期望期望时间+1s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> isDue || !isPlausible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::hasFrameUpdate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在 onFrameAvailable 中会将 mQueuedFrames 自增1</span></span><br><span class="line">    <span class="comment">// 因此它如果大于0 表示有生产好的数据了</span></span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断当前Layer，在期望时刻时是否应该显示出来。是否应该显示出来的判断标准是：该 Layer 中是否有“合适”的 BufferItem 等待消费。</p>
<p>这里说的“合适”对应到代码中有两个条件：</p>
<p>① mQueueItems中第一帧数据的展示时间小于期望的时间戳，表示其早已到了该展示的时间了</p>
<p>②mQueueItems中第一帧数据的展示时间大于等于期望的时间戳，表示其数据可能是不可信的，也就是不合理的帧，那么此时将它刷新掉。</p>
<blockquote>
<p>总感觉第②点怪怪的…..</p>
</blockquote>
<h4 id="updateTexImage-1"><a href="#updateTexImage-1" class="headerlink" title="updateTexImage"></a>updateTexImage</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueLayer::updateTexImage</span><span class="params">(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> queuedBuffer = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> layerID = <span class="built_in">getSequence</span>();</span><br><span class="line">    <span class="function">LayerRejecter <span class="title">r</span><span class="params">(mDrawingState, getCurrentState(), recomputeVisibleRegions,</span></span></span><br><span class="line"><span class="params"><span class="function">                    getProducerStickyTransform() != <span class="number">0</span>, mName.string(), mOverrideScalingMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                    getTransformToDisplayInverse(), mFreezeGeometryUpdates)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> expectedPresentTime = mFlinger-&gt;<span class="built_in">getExpectedPresentTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 Layer 已被移除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isRemovedFromCurrentState</span>()) &#123;</span><br><span class="line">        expectedPresentTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> lastSignaledFrameNumber = mLastFrameNumberReceived;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mQueueItems.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">bool</span> fenceSignaled =</span><br><span class="line">                    mQueueItems[i].mFenceTime-&gt;<span class="built_in">getSignalTime</span>() != Fence::SIGNAL_TIME_PENDING;</span><br><span class="line">            <span class="keyword">if</span> (!fenceSignaled) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lastSignaledFrameNumber = mQueueItems[i].mFrameNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> maxFrameNumberToAcquire =</span><br><span class="line">            std::<span class="built_in">min</span>(mLastFrameNumberReceived.<span class="built_in">load</span>(), lastSignaledFrameNumber);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行到 BufferLayerConsumer 中，其中会从 BufferQueue 中取出一个待消费的 BufferItem</span></span><br><span class="line"><span class="comment">     * 然后将该 BufferItem 的相关信息保存到 BufferLayerConsumer 中的 mCurrentXXX 系列的值中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * queuedBuffer ： 表示该 BufferItem 是否是处于 BufferQueue 中的，因为如果是共享模式时，它可能不是在队列中取出的 BufferItem</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">status_t</span> updateResult = mConsumer-&gt;<span class="built_in">updateTexImage</span>(&amp;r, expectedPresentTime, &amp;mAutoRefresh,</span><br><span class="line">                                                      &amp;queuedBuffer, maxFrameNumberToAcquire);</span><br><span class="line">    <span class="comment">// 根据消费返回的状态做处理  </span></span><br><span class="line">    <span class="comment">// 如果需要延迟显示则表示现在没有帧需要显示，则通知外部等待下一次刷新                                </span></span><br><span class="line">    <span class="keyword">if</span> (updateResult == BufferQueue::PRESENT_LATER) &#123;</span><br><span class="line">        mFlinger-&gt;<span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResult == BufferLayerConsumer::BUFFER_REJECTED) &#123;</span><br><span class="line">        <span class="comment">// 如果发现需要拒绝显示这个帧，并且该Buffer 是在消费队列中的，则将会丢弃mQueueItem中对应的图元参数和索引</span></span><br><span class="line">        <span class="comment">// 这里相当于就是将内外部的 BufferItem 列表保持同步</span></span><br><span class="line">        <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">            Mutex::Autolock <span class="built_in">lock</span>(mQueueItemLock);</span><br><span class="line">            mConsumer-&gt;<span class="built_in">mergeSurfaceDamage</span>(mQueueItems[<span class="number">0</span>].mSurfaceDamage);</span><br><span class="line">            mFlinger-&gt;mTimeStats-&gt;<span class="built_in">removeTimeRecord</span>(layerID, mQueueItems[<span class="number">0</span>].mFrameNumber);</span><br><span class="line">            mQueueItems.<span class="built_in">removeAt</span>(<span class="number">0</span>);</span><br><span class="line">            mQueuedFrames--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResult != NO_ERROR || mUpdateTexImageFailed) &#123;</span><br><span class="line">        <span class="comment">// 如果消费失败了，则会处理清除 mQueueItem 中所有等待消费的图元。最后返回空脏区</span></span><br><span class="line">        <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">            Mutex::Autolock <span class="built_in">lock</span>(mQueueItemLock);</span><br><span class="line">            mQueueItems.<span class="built_in">clear</span>();</span><br><span class="line">            mQueuedFrames = <span class="number">0</span>;</span><br><span class="line">            mFlinger-&gt;mTimeStats-&gt;<span class="built_in">onDestroy</span>(layerID);</span><br><span class="line">        &#125;</span><br><span class="line">        mUpdateTexImageFailed = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果成功获取到要展示的 Buffer ，并且它是位于 消费者队列中的，(通常都是位于消费队列中的，除非是共享模式)</span></span><br><span class="line">    <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">        <span class="keyword">auto</span> currentFrameNumber = mConsumer-&gt;<span class="built_in">getFrameNumber</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 因为上面 mConsumer-&gt;updateTexImage 中会有丢帧操作，所以这里同步下，避免出现里面把这帧丢掉了，而外面还有的情况</span></span><br><span class="line"><span class="comment">         * 由于在 BufferQueue 中的每个 Item，其 mFrameNumber 应该是从头到尾顺序递增的 ，比如内部的消费队列是 1,2,3,4,5.。。</span></span><br><span class="line"><span class="comment">         * 内部丢弃了1，2，getFrameNumber() 返回了 3 ，所以从 mQueueItems 头部开始往后遍历，把 1、2  删掉，因为内部丢帧丢掉了它</span></span><br><span class="line"><span class="comment">         * 遇到3 时终止 while 循环 ，也就是暂停移除， 此时内外部同步了 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (mQueueItems[<span class="number">0</span>].mFrameNumber != currentFrameNumber) &#123;</span><br><span class="line">            mConsumer-&gt;<span class="built_in">mergeSurfaceDamage</span>(mQueueItems[<span class="number">0</span>].mSurfaceDamage);</span><br><span class="line">            mFlinger-&gt;mTimeStats-&gt;<span class="built_in">removeTimeRecord</span>(layerID, mQueueItems[<span class="number">0</span>].mFrameNumber);</span><br><span class="line">            mQueueItems.<span class="built_in">removeAt</span>(<span class="number">0</span>);</span><br><span class="line">            mQueuedFrames--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFlinger-&gt;mTimeStats-&gt;<span class="built_in">setAcquireFence</span>(layerID, currentFrameNumber,</span><br><span class="line">                                              mQueueItems[<span class="number">0</span>].mFenceTime);</span><br><span class="line">        mFlinger-&gt;mTimeStats-&gt;<span class="built_in">setLatchTime</span>(layerID, currentFrameNumber, latchTime);</span><br><span class="line">        <span class="comment">// 当前 mQueueItems[0] 就是要即将要消费的那个，所以这里先移除掉</span></span><br><span class="line">        mQueueItems.<span class="built_in">removeAt</span>(<span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 queuedBuffer = true 时才会移除 mQueueItems ，也就是 mQueuedFrames 才会减少</span></span><br><span class="line">    <span class="comment">// 而上面  mQueueItems.removeAt(0) 之后，在这里就要将 mQueuedFrames 减一，保持同步</span></span><br><span class="line">    <span class="keyword">if</span> ((queuedBuffer &amp;&amp; mQueuedFrames.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) &gt; <span class="number">1</span>) || mAutoRefresh) &#123;</span><br><span class="line">        mFlinger-&gt;<span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是：更新当前待消费的数据，何为更新呢？其实就是从消费者队列中取出一个新的待消费的BufferItem 等待消费使用。</p>
<p>因此这里先调用了其内部的 BufferLayerConsumer中的updateTexImage 方法，该方法前面讲过了，主要是从队列中出队一个 BufferItem，然后将该BufferItem的一些属性保存到 BufferLayerConsumer 中的一系列 mCurrentXXX 属性中。</p>
<p>而回到本方法，执行完updateTexImage 之后会进行内外部BufferItem 队列的同步。因为你从内部BufferQueueCore的mQueue中出队了一个BufferItem，那么外部BufferQueueLayer中的 mQueueItems 中也得移除掉它，保持内外部的同步。当然内部acquireBuffer出队时不一定只会从 mQueue 中移除一个，由于内部可能会触发丢帧操作，因此可能会移除掉多个，所以这里外部需要谨慎的保持内外部一致。</p>
<h4 id="updateActiveBuffer"><a href="#updateActiveBuffer" class="headerlink" title="updateActiveBuffer"></a>updateActiveBuffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueLayer::updateActiveBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 BufferQueueConsumer 中取出上次出队保存的 BufferItem 中的 GraphicBuffer</span></span><br><span class="line">    mActiveBuffer = mConsumer-&gt;<span class="built_in">getCurrentBuffer</span>(&amp;mActiveBufferSlot, &amp;mActiveBufferFence);</span><br><span class="line">    <span class="comment">// 然后将这些保存到 getCompositionLayer()-&gt;editState().frontEnd 中去</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; layerCompositionState = <span class="built_in">getCompositionLayer</span>()-&gt;<span class="built_in">editState</span>().frontEnd;</span><br><span class="line">    layerCompositionState.buffer = mActiveBuffer;</span><br><span class="line">    layerCompositionState.bufferSlot = mActiveBufferSlot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActiveBuffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// this can only happen if the very first buffer was rejected.</span></span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// compositionengine::Layer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">LayerCompositionState&amp; <span class="title">Layer::editState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前方法用于将： BufferLayerConsumer 中上次出队的BufferItem 中的 GraphicBuffer 保存到 另外一个 Layer 中。</p>
<p>①如果之前调用过 BufferLayerConsumer::updateTexImage 方法的话，其内部会出队一个 BufferItem 并将其信息保存起来，然后此时再调用当前方法就能拿到保存的信息了，比如保存的 GraphicBuffer ，其中存储着生产者生产的数据。</p>
<p>②这里取出该 GraphicBuffer 之后，将其保存到了 当前 BufferQueueLayer 中的 mCompositionLayer 属性中。</p>
<p>通过前面我们可以知道，mCompositionLayer 是在当前 BufferQueueLayer 的父类：BufferLayer 中定义并初始化的。（详见上面 BufferLayer 中关于其构造方法的分析）。当时创建 mCompositionLayer 时，只给其 mCompositionEngine 和 mLayerFE 赋值了，并没有给其中的 mState 赋值，而此处就是给 mState 中的frontEnd属性赋值。这里暂时先到此打住，等后续分析到对应的模块时再补充。</p>
<p>因此简单来说：当前方法调用完毕之后，会将待处理的BufferItem中的数据转存到当前Layer中 mCompositionLayer.mState 内。</p>
<h4 id="updateFrameNumber"><a href="#updateFrameNumber" class="headerlink" title="updateFrameNumber"></a>updateFrameNumber</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BufferQueueLayer::updateFrameNumber</span><span class="params">(<span class="type">nsecs_t</span> latchTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录上一帧序列</span></span><br><span class="line">    mPreviousFrameNumber = mCurrentFrameNumber;</span><br><span class="line">    <span class="comment">// 记录当前这一帧的序列</span></span><br><span class="line">    mCurrentFrameNumber = mConsumer-&gt;<span class="built_in">getFrameNumber</span>();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">        <span class="comment">// 记录上锁时间</span></span><br><span class="line">        mFrameEventHistory.<span class="built_in">addLatch</span>(mCurrentFrameNumber, latchTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// BufferLayerConsumer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">BufferLayerConsumer::getFrameNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">BLC_LOGV</span>(<span class="string">&quot;getFrameNumber&quot;</span>);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> mCurrentFrameNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>da当前方法就是保持内外 frameNumber 的同步。因为如果你调用了BufferLayerConsumer::updateTexImage 方法的话，其内部的 mCurrentXXX 会发生变化，而外部BufferQueueLayer 中也有 mCurrentFrameNumber 值，因此需要使用内部的最新值来更新外部的值，使得内外部值保持一致。</p>
<p>至此就把 BufferQueueLayer 中的关键实现分析完了，接下来我们补充下之前在 BufferLayer 中没有分析的一个关键方法：latchBuffer() ，当时没分析是因为该方法跟子类实现有关，现在分析完其子类之后，就可以看看它了。</p>
<h3 id="BufferLayer-latchBuffer"><a href="#BufferLayer-latchBuffer" class="headerlink" title="BufferLayer::latchBuffer"></a>BufferLayer::latchBuffer</h3><p>当前方法是属于 BufferLayer 的，应该放在BufferLayer 模块下的，但是为了理解上的通畅，将其延后到这里。</p>
<p>先看其实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::latchBuffer</span><span class="params">(<span class="type">bool</span>&amp; recomputeVisibleRegions, <span class="type">nsecs_t</span> latchTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> refreshRequired = <span class="built_in">latchSidebandStream</span>(recomputeVisibleRegions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refreshRequired) &#123;</span><br><span class="line">        <span class="keyword">return</span> refreshRequired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前还没有生产者入队数据，那么消费者也没得东西来消费，此时直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasReadyFrame</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mRefreshPending = true 表示上次调用过当前方法并且将待处理的数据保存好等待刷新显示了</span></span><br><span class="line">    <span class="comment">// 那么此时有调用当前方法，那么直接返回，等上次的数据刷新消费之后才行</span></span><br><span class="line">    <span class="keyword">if</span> (mRefreshPending) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the head buffer&#x27;s acquire fence hasn&#x27;t signaled yet, return and</span></span><br><span class="line">    <span class="comment">// try again later</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">fenceHasSignaled</span>()) &#123;</span><br><span class="line">        <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;!fenceHasSignaled()&quot;</span>);</span><br><span class="line">        mFlinger-&gt;<span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到当前 Layer 当前已显示的状态数据</span></span><br><span class="line">    <span class="function"><span class="type">const</span> State&amp; <span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> oldOpacity = <span class="built_in">isOpaque</span>(s);</span><br><span class="line">    <span class="comment">// 拿到上一帧对应的 GraphicBuffer ，也就是当前正在显示的那个</span></span><br><span class="line">    sp&lt;GraphicBuffer&gt; oldBuffer = mActiveBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">allTransactionsSignaled</span>()) &#123;</span><br><span class="line">        mFlinger-&gt;<span class="built_in">setTransactionFlags</span>(eTraversalNeeded);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从消息队列中找到一个待消费的 BufferItem ，然后将其信息存储起来(比如对于 BufferQueueLayer 来说是存储在其内部 mConsumer 中的 mCurrentXXX 属性中)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">status_t</span> err = <span class="built_in">updateTexImage</span>(recomputeVisibleRegions, latchTime);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将上面 updateTexImage 中获取到的即将消费的 buffer 保存到两个地方：</span></span><br><span class="line">    <span class="comment">// 1. mActiveBuffer 中</span></span><br><span class="line">    <span class="comment">// 2. getCompositionLayer()-&gt;editState().frontEnd 中</span></span><br><span class="line">    err = <span class="built_in">updateActiveBuffer</span>();</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当成功获取 Buffer 之后，并且更新到了全局 mActiveBuffer 中了，此时将 mBufferLatched 置为 true </span></span><br><span class="line">    mBufferLatched = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 frameNumber</span></span><br><span class="line">    err = <span class="built_in">updateFrameNumber</span>(latchTime);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将 mRefreshPending 置为 true ，表示此时有新数据需要展示，也就是返回给外部当前需要刷新了</span></span><br><span class="line">    mRefreshPending = <span class="literal">true</span>;</span><br><span class="line">    mFrameLatencyNeeded = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldBuffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录DataSpace</span></span><br><span class="line">    ui::Dataspace dataSpace = <span class="built_in">getDrawingDataSpace</span>();</span><br><span class="line">    <span class="comment">// translate legacy dataspaces to modern dataspaces</span></span><br><span class="line">    <span class="keyword">switch</span> (dataSpace) &#123;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::SRGB:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_SRGB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::SRGB_LINEAR:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_SRGB_LINEAR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::JFIF:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_JFIF;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::BT601_625:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_BT601_625;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::BT601_525:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_BT601_525;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ui::Dataspace::BT709:</span><br><span class="line">            dataSpace = ui::Dataspace::V0_BT709;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentDataSpace = dataSpace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 mCurrentCrop 等值</span></span><br><span class="line">    <span class="function">Rect <span class="title">crop</span><span class="params">(getDrawingCrop())</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">uint32_t</span> <span class="title">transform</span><span class="params">(getDrawingTransform())</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">uint32_t</span> <span class="title">scalingMode</span><span class="params">(getDrawingScalingMode())</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">bool</span> <span class="title">transformToDisplayInverse</span><span class="params">(getTransformToDisplayInverse())</span></span>;</span><br><span class="line">    <span class="comment">// 如果 crop 或者 transform scale 等发生变化了，则将对应变量更新到全局保存</span></span><br><span class="line">    <span class="keyword">if</span> ((crop != mCurrentCrop) || (transform != mCurrentTransform) ||</span><br><span class="line">        (scalingMode != mCurrentScalingMode) ||</span><br><span class="line">        (transformToDisplayInverse != mTransformToDisplayInverse)) &#123;</span><br><span class="line">        mCurrentCrop = crop;</span><br><span class="line">        mCurrentTransform = transform;</span><br><span class="line">        mCurrentScalingMode = scalingMode;</span><br><span class="line">        mTransformToDisplayInverse = transformToDisplayInverse;</span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 mActiveBuffer 是马上要展示的帧数据，oldBuffer 是当前正在展示的，一般叫做上一帧</span></span><br><span class="line">    <span class="comment">// 如果两帧的宽高发生变化，则将 recomputeVisibleRegions 置为 true ，表示需要重新计算Layer区域面积</span></span><br><span class="line">    <span class="keyword">if</span> (oldBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> bufWidth = mActiveBuffer-&gt;<span class="built_in">getWidth</span>();</span><br><span class="line">        <span class="type">uint32_t</span> bufHeight = mActiveBuffer-&gt;<span class="built_in">getHeight</span>();</span><br><span class="line">        <span class="keyword">if</span> (bufWidth != <span class="built_in">uint32_t</span>(oldBuffer-&gt;width) || bufHeight != <span class="built_in">uint32_t</span>(oldBuffer-&gt;height)) &#123;</span><br><span class="line">            recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可见度发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (oldOpacity != <span class="built_in">isOpaque</span>(s)) &#123;</span><br><span class="line">        recomputeVisibleRegions = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mLocalSyncPointMutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> point = mLocalSyncPoints.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (point != mLocalSyncPoints.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(*point)-&gt;<span class="built_in">frameIsAvailable</span>() || !(*point)-&gt;<span class="built_in">transactionIsApplied</span>()) &#123;</span><br><span class="line">                <span class="comment">// This sync point must have been added since we started</span></span><br><span class="line">                <span class="comment">// latching. Don&#x27;t drop it yet.</span></span><br><span class="line">                ++point;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((*point)-&gt;<span class="built_in">getFrameNumber</span>() &lt;= mCurrentFrameNumber) &#123;</span><br><span class="line">                std::stringstream ss;</span><br><span class="line">                ss &lt;&lt; <span class="string">&quot;Dropping sync point &quot;</span> &lt;&lt; (*point)-&gt;<span class="built_in">getFrameNumber</span>();</span><br><span class="line">                <span class="built_in">ATRACE_NAME</span>(ss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">                point = mLocalSyncPoints.<span class="built_in">erase</span>(point);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前方法是属于 BufferLayer 的，其中有多个方法是需要子类实现的，我们这里把它的子类默认先当做是 BufferQueueLayer 。</p>
<p>该方法中做了如下几步：</p>
<p>①合法性判断，比如判断当前是否存在待消费的数据，以及上次的数据是否已被消费了，没被消费的话不能再获取新的去消费。</p>
<p>②调用子类的 updateTexImage 方法去出队一个新的待消费的BufferItem，并将其数据保存起来。</p>
<p>比如对于 BufferQueueLayer 来说是存储在其内部 mConsumer 中的 mCurrentXXX 属性中</p>
<p>③调用子类的 updateActiveBuffer 来将新出队的 BufferItem 的 GraphicBuffer 保存到 mActiveBuffer 和 mCompositionLayer.mState.frontEnd中。再调用子类的 updateFrameNumber 方法来同步 frameNumber，因为有新的BufferItem出队了。</p>
<p>④ 根据新出队的GraphicBuffer 和出队之前旧的 GraphicBuffer 做对比，如果尺寸呀，或者缩放变换等发生了变化，会按需将入参 recomputeVisibleRegions置为 true 表示通知外部当前Layer需要重新计算显示区域。如果新的BufferItem成功出队了，那么会将返回值 mRefreshPending 置为true ，表示通知外部：当前Layer内部有新的数据等待处理。</p>
<p>Layer 中的 mActiveBuffer 表示的是该Layer此时需要显示处理的数据，每当需要其内部刷新数据显示下一帧时，就可以调用其 latchBuffer 方法，该方法如果正常执行的话，会从消费队列中出队一个待消费的数据，然后更新 mActiveBuffer 的值，那么等下次该 Layer刷新显示时就是新的一帧数据了。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/Surface/">Surface</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/91da79fe.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Surface学习(三)--Layer简介</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/99318d8c.html">
        <span class="next-text nav-default">Surface学习(一)--ComposerService</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
