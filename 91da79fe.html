<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Surface学习(三)--Layer简介"/>




  <meta name="keywords" content="AndroidFrameworks,Surface," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/91da79fe.html"/>


<meta name="description" content="前面 Surface学习(一)–ComposerService 讲到了其他进程怎么与SurfaceFlinger 进程进行通讯， Surface学习(二)–Layer简介 中讲了一些关于 Layer 的只是。下面再接着它往后讲讲。 前面在 Native Framework 中遇到了 SurfaceControl 类，但是在讲 SurfaceControl 之前，需要先看下其他相关类。 Surfac">
<meta property="og:type" content="article">
<meta property="og:title" content="Surface学习(三)--Layer简介">
<meta property="og:url" content="https://youngkaaa.github.io/91da79fe.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="前面 Surface学习(一)–ComposerService 讲到了其他进程怎么与SurfaceFlinger 进程进行通讯， Surface学习(二)–Layer简介 中讲了一些关于 Layer 的只是。下面再接着它往后讲讲。 前面在 Native Framework 中遇到了 SurfaceControl 类，但是在讲 SurfaceControl 之前，需要先看下其他相关类。 Surfac">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-01T13:48:56.000Z">
<meta property="article:modified_time" content="2023-02-24T12:29:10.539Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="Surface">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Surface学习(三)--Layer简介 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Surface学习(三)--Layer简介
        
      </h1>

      <time class="post-time">
          7月 01 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>前面 <a href="99318d8c.html">Surface学习(一)–ComposerService</a> 讲到了其他进程怎么与SurfaceFlinger 进程进行通讯， <a href="25fde216.html">Surface学习(二)–Layer简介</a> 中讲了一些关于 Layer 的只是。下面再接着它往后讲讲。</p>
<p>前面在 Native Framework 中遇到了 SurfaceControl 类，但是在讲 SurfaceControl 之前，需要先看下其他相关类。</p>
<h3 id="SurfaceSession"><a href="#SurfaceSession" class="headerlink" title="SurfaceSession"></a>SurfaceSession</h3><p>对于SurfaceSession来说，在 Java Framework层有对应的类，Native Framework层也有，下面从上到下开始分析。</p>
<p>先看它的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.view.SurfaceSession.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SurfaceSession</span> &#123;</span><br><span class="line">    <span class="comment">// 存储着native层的 SurfaceComposerClient 实例地址</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mNativeClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeCreate</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeDestroy</span><span class="params">(<span class="type">long</span> ptr)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeKill</span><span class="params">(<span class="type">long</span> ptr)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SurfaceSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造方法时就会去创建对应的native层SurfaceComposerClient实例</span></span><br><span class="line">        mNativeClient = nativeCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mNativeClient != <span class="number">0</span>) &#123;</span><br><span class="line">                nativeDestroy(mNativeClient);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span> &#123;</span><br><span class="line">        nativeKill(mNativeClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层的SurfaceSession类很简单，内部就持有了一个 mNativeClient 属性，该属性存储的是一个Native层对应的 SurfaceComposerClient 实例地址。</p>
<p>在 SurfaceSession 构造方法中会调用 Native 层的nativeCreate 方法来执行创建工作。该方法是位于：android_view_SurfaceSession.cpp 中的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_SurfaceSession.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 SurfaceComposerClient 对象实例</span></span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    <span class="comment">// 触发其 onFirstRef 方法让其内部进行初始化</span></span><br><span class="line">    client-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到该方法中就只是创建了 SurfaceComposerClient 实例，并触发其内部的 onFirstRef 去让其进行初始化，这样的话其内部就会建立跟 SurfaceFlinger 的Binder连接，后期可以与其进行通讯。</p>
<p>最后将创建的 SurfaceComposerClient 返回上去，保存到 SurfaceSession.java 中的 mNativeClient 中，以供后续使用。</p>
<p>不像是 Surface 和 SurfaceControl 这些，SurfaceSession 只有Java层有同名的类，在Native层没有，而Native层的SurfaceComposerClient可能更适合对应它。</p>
<h3 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a>SurfaceControl</h3><p>我们同样从上往下开始看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.view.SurfaceControl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SurfaceControl</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 一系列 native 方法，对应的实现是在 android_view_SurfaceControl.cpp 中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeCreate</span><span class="params">(SurfaceSession session, String name,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> format, <span class="type">int</span> flags, <span class="type">long</span> parentObject, Parcel metadata)</span></span><br><span class="line">            <span class="keyword">throws</span> OutOfResourcesException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他 native 方法定义</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在当前类的构造方法中会赋值,指向的是返回的 native SurfaceControl 对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> mNativeObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他常量定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">assignNativeObject</span><span class="params">(<span class="type">long</span> nativeObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            release();</span><br><span class="line">        &#125;</span><br><span class="line">        mNativeObject = nativeObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFrom</span><span class="params">(SurfaceControl other)</span> &#123;</span><br><span class="line">        mName = other.mName;</span><br><span class="line">        mWidth = other.mWidth;</span><br><span class="line">        mHeight = other.mHeight;</span><br><span class="line">        assignNativeObject(nativeCopyFromSurfaceControl(other.mNativeObject));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> SurfaceSession mSession;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mFlags</span> <span class="operator">=</span> HIDDEN;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> mWidth;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> mHeight;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mFormat</span> <span class="operator">=</span> PixelFormat.OPAQUE;</span><br><span class="line">        <span class="keyword">private</span> String mName;</span><br><span class="line">        <span class="keyword">private</span> SurfaceControl mParent;</span><br><span class="line">        <span class="keyword">private</span> SparseIntArray mMetadata;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(SurfaceSession session)</span> &#123;</span><br><span class="line">            mSession = session;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">public</span> SurfaceControl <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWidth &lt; <span class="number">0</span> || mHeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;width and height must be positive or unset&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((mWidth &gt; <span class="number">0</span> || mHeight &gt; <span class="number">0</span>) &amp;&amp; (isColorLayerSet() || isContainerLayerSet())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;Only buffer layers can set a valid buffer size.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SurfaceControl</span>(</span><br><span class="line">                    mSession, mName, mWidth, mHeight, mFormat, mFlags, mParent, mMetadata);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(<span class="meta">@NonNull</span> String name)</span> &#123;</span><br><span class="line">            mName = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setBufferSize</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> <span class="type">int</span> width,</span></span><br><span class="line"><span class="params">                <span class="meta">@IntRange(from = 0)</span> <span class="type">int</span> height)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (width &lt; <span class="number">0</span> || height &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;width and height must be positive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mWidth = width;</span><br><span class="line">            mHeight = height;</span><br><span class="line">            <span class="keyword">return</span> setFlags(FX_SURFACE_NORMAL, FX_SURFACE_MASK);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setFormat</span><span class="params">(<span class="meta">@PixelFormat</span>.Format <span class="type">int</span> format)</span> &#123;</span><br><span class="line">            mFormat = format;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SurfaceControl</span><span class="params">(SurfaceSession session, String name, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> format, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            SurfaceControl parent, SparseIntArray metadata)</span></span><br><span class="line">                    <span class="keyword">throws</span> OutOfResourcesException, IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;name must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; SurfaceControl.HIDDEN) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Surfaces should always be created with the HIDDEN flag set &quot;</span></span><br><span class="line">                    + <span class="string">&quot;to ensure that they are not made visible prematurely before &quot;</span></span><br><span class="line">                    + <span class="string">&quot;all of the surface&#x27;s properties have been configured.  &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Set the other properties and make the surface visible within &quot;</span></span><br><span class="line">                    + <span class="string">&quot;a transaction.  New surface name: &quot;</span> + name,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Throwable</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mName = name;</span><br><span class="line">        mWidth = w;</span><br><span class="line">        mHeight = h;</span><br><span class="line">        <span class="type">Parcel</span> <span class="variable">metaParcel</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (metadata != <span class="literal">null</span> &amp;&amp; metadata.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                metaParcel.writeInt(metadata.size());</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; metadata.size(); ++i) &#123;</span><br><span class="line">                    metaParcel.writeInt(metadata.keyAt(i));</span><br><span class="line">                    metaParcel.writeByteArray(</span><br><span class="line">                            ByteBuffer.allocate(<span class="number">4</span>).order(ByteOrder.nativeOrder())</span><br><span class="line">                                    .putInt(metadata.valueAt(i)).array());</span><br><span class="line">                &#125;</span><br><span class="line">                metaParcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mNativeObject = nativeCreate(session, name, w, h, format, flags,</span><br><span class="line">                    parent != <span class="literal">null</span> ? parent.mNativeObject : <span class="number">0</span>, metaParcel);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            metaParcel.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfResourcesException</span>(</span><br><span class="line">                    <span class="string">&quot;Couldn&#x27;t allocate SurfaceControl native object&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCloseGuard.open(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SurfaceControl</span><span class="params">(SurfaceControl other)</span> &#123;</span><br><span class="line">        mName = other.mName;</span><br><span class="line">        mWidth = other.mWidth;</span><br><span class="line">        mHeight = other.mHeight;</span><br><span class="line">        mNativeObject = other.mNativeObject;</span><br><span class="line">        other.mCloseGuard.close();</span><br><span class="line">        other.mNativeObject = <span class="number">0</span>;</span><br><span class="line">        mCloseGuard.open(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SurfaceControl</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        readFromParcel(in);</span><br><span class="line">        mCloseGuard.open(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SurfaceControl</span><span class="params">()</span> &#123;</span><br><span class="line">        mCloseGuard.open(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">            mNativeObject = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCloseGuard.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeDisconnect(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到对于SurfaceControl.java 来说，它内部同样还是有一个  mNativeObject 属性来将其跟Native层对象进行关联。</p>
<p>而关于 SurfaceControl 的创建是交给其 Builder 的，也就是 Builder 模式。</p>
<p>在 Builder 中存储了若干个和 SurfaceControl 的创建有关的属性。</p>
<p>1、mSession：就是前面刚讲到的 SurfaceSession 实例。有了该实例，就相当于有了一个 Native 层的 SurfaceComposerClient 实例，后期就可以使用它来跟SurfaceFlinger 侧进行通讯了。</p>
<p>一般这个值都是有的，而如果没有设置的话后面会使用一个默认的单例：DefaultComposerClient 。</p>
<p>2、mFlags：用于在：该 SurfaceControl 对应的 Surface (Layer )创建时的状态控制。</p>
<p>它是一个int，它的每一位都代表了对应着不同的控制，比如对于Layer创建时用到的：</p>
<p>① SECURE &#x3D; 0x00000080 ：在创建 Layer 时会用到，表示该 Layer 中存在需要保护的信息，此时该Layer内容不允许截屏等操作。</p>
<p>② FX_SURFACE_NORMAL  &#x3D; 0x00000000 ：在创建 Layer 时会用到，表示此时需要创建一个默认的 Layer ,也就是 BufferQueueLayer，大多数都是当前这种默认情况。</p>
<p>③ FX_SURFACE_DIM &#x3D; 0x00020000 ：在创建 Layer 时会用到，表示此时需要创建一个Layer，该 Layer 会显示一层灰蒙蒙的蒙层，用以和底下其他图层区分来。实际在Native层对应的是 ColorLayer 实例。</p>
<p>④ FX_SURFACE_CONTAINER &#x3D; 0x00080000 ：在创建 Layer 时会用到，表示此时需要创建一个Layer，该 Layer 只是用来存放其他 Layer，有点像View体系中的ViewGroup。实际在Native层对应的是 ContainerLayer 实例。</p>
<p>⑤：SURFACE_HIDDEN &#x3D; 0x01 ：在创建 Layer 时会用到，表示该Layer在创建后需要隐藏掉。</p>
<p>当然还有其他的常量值这里就不再分析了。可以看到这些常量值都对应着不同的位，统一都合并到 mFlags 中，这样的话使用一个Int就可以传递多种信息，这种设计模式在源码中有很多，比如View中的 mViewFlags 。</p>
<p>3、mWidth、mHeight：创建 Layer 时指定给Layer的宽高尺寸信息</p>
<p>4、mFormat：图像像素位格式，比如之前常见的 RGBA8888 。</p>
<p>5、mName：对应需要创建的 Layer 名，内部会基于它，再做一些修改以保证其唯一性。</p>
<p>6、mParent ： 父 SurfaceControl 对象。作用等后面遇到了再说。</p>
<p>因此通过 Builder 设置好其中的一些属性之后，可以调用其 build() 方法来创建 SurfaceControl() 实例。</p>
<p>在 SurfaceControl 构造方法中，首先会将入参的值比如 name 保存起来，然后调用 nativeCreate() 方法来完成 Native 层的初始化创建工作。</p>
<p>接下来主要看该方法的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_SurfaceControl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject metadataParcel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由上层传递下来的 name</span></span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果指定了 SurfaceSession 对象，则对应的 SurfaceComposerClient 实例从该 SurfaceSession 中取</span></span><br><span class="line"><span class="comment">     * 否则使用默认的单例 DefaultComposerClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (sessionObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        client = <span class="built_in">android_view_SurfaceSession_getClient</span>(env, sessionObj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        client = SurfaceComposerClient::<span class="built_in">getDefault</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parentObject ：  上层设置的父级 SurfaceControl 的 mNativeObject 属性，没有设置的话就是0</span></span><br><span class="line">    SurfaceControl *parent = <span class="built_in">reinterpret_cast</span>&lt;SurfaceControl*&gt;(parentObject);</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface;</span><br><span class="line">    LayerMetadata metadata;</span><br><span class="line">    Parcel *parcel = <span class="built_in">parcelForJavaObject</span>(env, metadataParcel);</span><br><span class="line">    <span class="keyword">if</span> (parcel &amp;&amp; !parcel-&gt;<span class="built_in">objectsCount</span>()) &#123;</span><br><span class="line">        <span class="type">status_t</span> err = metadata.<span class="built_in">readFromParcel</span>(parcel);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalArgumentException&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;Metadata parcel has wrong format&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 上面拿到的 SurfaceComposerClient 实例就可以用来和 SurfaceFlinger 通讯，比如使用它来创建 Layer</span></span><br><span class="line"><span class="comment">   * 创建出来的 Layer(在当前进程的唯一句柄handle) 以及其对应的 BufferQueueProducer 会被封封装到 surface 中</span></span><br><span class="line"><span class="comment">   * 注意这里的 surface 变量是 SurfaceControl 类型的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">status_t</span> err = client-&gt;<span class="built_in">createSurfaceChecked</span>(</span><br><span class="line">      <span class="built_in">String8</span>(name.<span class="built_in">c_str</span>()), w, h, format, &amp;surface, flags, parent, std::<span class="built_in">move</span>(metadata));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NAME_NOT_FOUND) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalArgumentException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, OutOfResourcesException, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    surface-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span> *)nativeCreate);</span><br><span class="line">    <span class="comment">// 将这个 SurfaceControl 返回出去，上层会将其保存到 SurfaceControl.java 中的 mNativeObject 属性中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(surface.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，在Native层最主要的逻辑是去SurfaceFlinger 中创建Layer，但是怎么去通知它创建Layer呢？当然是通过SurfaceComposerClient 了。即在当前进程创建了 SurfaceSession，其内部会创建好一个 SurfaceComposerClient ，然后再去创建 SurfaceControl ，此时SurfaceSession 来给 SurfaceControl 提供 SurfaceComposerClient 实例，供其去调用到 SurfaceFlinger 中去创建 Layer，最后将创建好的 Layer （在当前进程对应的 handle），以及该 Layer 对应的 BufferLayerProducer 这些一起封装到一个新的 SurfaceControl.cpp 实例中返回给上层。此时上层 SurfaceControl.java 中的 mNativeObject 会保存着该 SurfaceControl.cpp 实例，供以后使用。</p>
<p>如果这段听起来有点费力，可以翻看下前面关于  <a href="99318d8c.html">SurfaceComposerClient</a> 的文章。</p>
<p>接下来还是再看看 SurfaceFlinger 那边是怎么创建 Layer 的。上面方法最终调用到 SurfaceFlinger 中对应的是 createLayer 方法（不明白的话请翻看前面文章）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="type">const</span> String8 &amp;name, <span class="type">const</span> sp&lt;Client&gt; &amp;client, <span class="type">uint32_t</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     LayerMetadata metadata, sp&lt;IBinder&gt; *handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sp&lt;IGraphicBufferProducer&gt; *gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;IBinder&gt; &amp;parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;Layer&gt; &amp;parentLayer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 检查宽高数值是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">int32_t</span>(w | h) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">status_t</span> result = NO_ERROR;</span><br><span class="line">  <span class="comment">// 创建一个layer 用来存储最终创建出来的 Layer实例</span></span><br><span class="line">  sp&lt;Layer&gt; layer;</span><br><span class="line">  <span class="comment">// 获取一个独一无二的Layer name，即不能有重名的Layer;</span></span><br><span class="line">  String8 uniqueName = <span class="built_in">getUniqueLayerName</span>(name);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> primaryDisplayOnly = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metadata.<span class="built_in">has</span>(METADATA_WINDOW_TYPE)) &#123;</span><br><span class="line">    <span class="type">int32_t</span> windowType = metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (windowType == <span class="number">441731</span>) &#123;</span><br><span class="line">      metadata.<span class="built_in">setInt32</span>(METADATA_WINDOW_TYPE, InputWindowInfo::TYPE_NAVIGATION_BAR_PANEL);</span><br><span class="line">      primaryDisplayOnly = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 主要看这里</span></span><br><span class="line"><span class="comment">   * 这里根据上层传下来的 flag 来决定此时要创建何种 Layer </span></span><br><span class="line"><span class="comment">   * 详见：SurfaceControl.java 中的常量定义</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;  <span class="comment">// eFXSurfaceMask : 0x000F0000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:  <span class="comment">// 0x00000000</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 创建一个 BufferQueueLayer ，这也是最常见的 Layer</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      result = <span class="built_in">createBufferQueueLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                      format, handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferState:  <span class="comment">// 0x00040000</span></span><br><span class="line">      <span class="comment">// 创建一个 BufferStateLayer 实例</span></span><br><span class="line">      result = <span class="built_in">createBufferStateLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                      handle, &amp;layer);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceColor:  <span class="comment">// 0x00020000</span></span><br><span class="line">      <span class="keyword">if</span> (w &gt; <span class="number">0</span> || h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 纯色或阴影的显示效果的Surface</span></span><br><span class="line">      result = <span class="built_in">createColorLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata), handle,</span><br><span class="line">                                &amp;layer);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceContainer:  <span class="comment">// 0x00080000</span></span><br><span class="line">      <span class="keyword">if</span> (w &gt; <span class="number">0</span> || h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建surface容器</span></span><br><span class="line">      result = <span class="built_in">createContainerLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                    handle, &amp;layer);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:result = BAD_VALUE;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面 createXXXLayer 失败了</span></span><br><span class="line">  <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (primaryDisplayOnly) &#123;</span><br><span class="line">    layer-&gt;<span class="built_in">setPrimaryDisplayOnly</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> addToCurrentState = <span class="built_in">callingThreadHasUnscopedSurfaceFlingerAccess</span>();</span><br><span class="line">  <span class="comment">// 将创建出来的 Layer</span></span><br><span class="line">  result = <span class="built_in">addClientLayer</span>(client, *handle, *gbp, layer, parentHandle, parentLayer,</span><br><span class="line">                          addToCurrentState);</span><br><span class="line">  <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  mInterceptor-&gt;<span class="built_in">saveSurfaceCreation</span>(layer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 告诉SurfaceFlinger，新增加了Layer，有新的显示，有很多显示数据需要去更新。</span></span><br><span class="line">  <span class="comment">// 而 SurfaceFlinger根据flag，决定是否需要换醒服务。</span></span><br><span class="line">  <span class="built_in">setTransactionFlags</span>(eTransactionNeeded);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::addClientLayer</span><span class="params">(<span class="type">const</span> sp&lt;Client&gt; &amp;client, <span class="type">const</span> sp&lt;IBinder&gt; &amp;handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;gbc, <span class="type">const</span> sp&lt;Layer&gt; &amp;lbc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IBinder&gt; &amp;parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;Layer&gt; &amp;parentLayer, <span class="type">bool</span> addToCurrentState)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从传入的 parentHandle 或者 parentLayer 中来确定当前Layer的 父Layer</span></span><br><span class="line">    sp&lt;Layer&gt; parent;</span><br><span class="line">    <span class="keyword">if</span> (parentHandle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      parent = <span class="built_in">fromHandle</span>(parentHandle);</span><br><span class="line">      <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NAME_NOT_FOUND;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent = parentLayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNumLayers &gt;= MAX_LAYERS) &#123;</span><br><span class="line">      <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 handle 和 Layer 保存起来</span></span><br><span class="line">    mLayersByLocalBinderToken.<span class="built_in">emplace</span>(handle-&gt;<span class="built_in">localBinder</span>(), lbc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果父Layer为空，此时将其加入到mCurrentState.layersSortedByZ 中</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">nullptr</span> &amp;&amp; addToCurrentState) &#123;</span><br><span class="line">      mCurrentState.layersSortedByZ.<span class="built_in">add</span>(lbc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">isRemovedFromCurrentState</span>()) &#123; <span class="comment">// 将其加入到 父Layer 中</span></span><br><span class="line">      parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">      lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 将其加入到 父Layer 中</span></span><br><span class="line">      parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该 Layer 对应的 Producer 保存起来</span></span><br><span class="line">    <span class="keyword">if</span> (gbc != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      mGraphicBufferProducerList.<span class="built_in">insert</span>(IInterface::<span class="built_in">asBinder</span>(gbc).<span class="built_in">get</span>());</span><br><span class="line">      <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mGraphicBufferProducerList.<span class="built_in">size</span>() &gt;</span><br><span class="line">                              mMaxGraphicBufferProducerListSize,</span><br><span class="line">                          <span class="string">&quot;Suspected IGBP leak: %zu IGBPs (%zu max), %zu Layers&quot;</span>,</span><br><span class="line">                          mGraphicBufferProducerList.<span class="built_in">size</span>(),</span><br><span class="line">                          mMaxGraphicBufferProducerListSize, mNumLayers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示有 Layer创建成功了，将该标识置为true</span></span><br><span class="line">    mLayersAdded = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其实这个方法在前面的文章中已经讲过了，此处为了逻辑的通畅还是再贴一下分析的代码。</p>
<p>这里在实际创建 Layer 实例时，是根据上层传入的 flag 来决定的，该flag中的位常量在前面有分析过。因此说上层通过 flag 就可以控制Native层Layer的创建。</p>
<p>实际在创建时最常见的就是 BuffeQueueLayer ，因此这里主要也只讲它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::createBufferQueueLayer</span><span class="params">(<span class="type">const</span> sp&lt;Client&gt; &amp;client, <span class="type">const</span> String8 &amp;name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                LayerMetadata metadata, PixelFormat &amp;format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                sp&lt;IBinder&gt; *handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                sp&lt;IGraphicBufferProducer&gt; *gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                sp&lt;Layer&gt; *outLayer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 统一格式</span></span><br><span class="line">  <span class="keyword">switch</span> (format) &#123;</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">      format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">      format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将参数包装到 LayerCreationArgs 实例中，然后去创建 BufferQueueLayer 对象实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  sp&lt;BufferQueueLayer&gt; layer = <span class="built_in">getFactory</span>().<span class="built_in">createBufferQueueLayer</span>(</span><br><span class="line">      <span class="built_in">LayerCreationArgs</span>(<span class="keyword">this</span>, client, name, w, h, flags, std::<span class="built_in">move</span>(metadata)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 到这里时， BufferQueueLayer 就已经被创建完毕了，包括其内部  Producer 和 Consumer 也都初始化好了</span></span><br><span class="line">  <span class="type">status_t</span> err = layer-&gt;<span class="built_in">setDefaultBufferProperties</span>(w, h, format);</span><br><span class="line">  <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建完 Layer 之后，就会调用其 getHandle 方法来给入参 handle 赋值，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *handle = layer-&gt;<span class="built_in">getHandle</span>();</span><br><span class="line">    <span class="comment">// 拿到内部的 IGraphicBufferProducer 实例</span></span><br><span class="line">    *gbp = layer-&gt;<span class="built_in">getProducer</span>();</span><br><span class="line">    *outLayer = layer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlingerFactory.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;BufferQueueLayer&gt; <span class="title">createBufferQueueLayer</span><span class="params">(<span class="type">const</span> LayerCreationArgs &amp;args)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BufferQueueLayer</span>(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建BufferQueueLayer时，会先将指定的Layer信息封装到 LayerCreationArgs 实例中，接着去创建 BufferQueueLayer ，创建好之后会拿到其对应的 Handle 和 BufferQueueProducer 实例，并将其赋值给入参。这样的话当方法执行完毕之后最外面调用者就能拿到这俩实例了，然后将其封装到 SurfaceControl 中。关于这俩方法的分析详见之前关于 BufferQueue 分析的文章。</p>
<p>至此完成了对 SurfaceControl 的分析，分析完之后我们知道：SurfaceControl.java 中存储了一个Native层的 SurfaceControl.cpp 实例，而该 SurfaceControl.cpp 实例中存储了对应的 Layer 句柄，对应Layer的生产者实例。</p>
<p>讲了这么久，该主角Surface出场了。但是在讲 Surface之前得先插入一些其他铺垫。</p>
<h3 id="ANativeWindow"><a href="#ANativeWindow" class="headerlink" title="ANativeWindow"></a>ANativeWindow</h3><p>先看其定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// window.h</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ANativeWindow</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    <span class="built_in">ANativeWindow</span>()</span><br><span class="line">        : <span class="built_in">flags</span>(<span class="number">0</span>), <span class="built_in">minSwapInterval</span>(<span class="number">0</span>), <span class="built_in">maxSwapInterval</span>(<span class="number">0</span>), <span class="built_in">xdpi</span>(<span class="number">0</span>), <span class="built_in">ydpi</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化其内部的 common</span></span><br><span class="line">        common.magic = ANDROID_NATIVE_WINDOW_MAGIC;</span><br><span class="line">        common.version = <span class="built_in">sizeof</span>(ANativeWindow);</span><br><span class="line">        <span class="built_in">memset</span>(common.reserved, <span class="number">0</span>, <span class="built_in">sizeof</span>(common.reserved));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incStrong</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* <span class="comment">/*id*/</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        common.<span class="built_in">incRef</span>(<span class="built_in">const_cast</span>&lt;<span class="type">android_native_base_t</span>*&gt;(&amp;common));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decStrong</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* <span class="comment">/*id*/</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        common.<span class="built_in">decRef</span>(<span class="built_in">const_cast</span>&lt;<span class="type">android_native_base_t</span>*&gt;(&amp;common));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部第一个属性，因此相当于当前 ANativeWindow 继承自 android_native_base_t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">android_native_base_t</span> common;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>   minSwapInterval;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>   maxSwapInterval;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> xdpi;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> ydpi;</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span>    oem[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*setSwapInterval)(<span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="type">int</span> interval);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*dequeueBuffer_DEPRECATED)(<span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="keyword">struct</span> ANativeWindowBuffer** buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*lockBuffer_DEPRECATED)(<span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*queueBuffer_DEPRECATED)(<span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*query)(<span class="type">const</span> <span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="type">int</span> what, <span class="type">int</span>* value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*perform)(<span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="type">int</span> operation, ... );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*cancelBuffer_DEPRECATED)(<span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="keyword">struct</span> ANativeWindowBuffer* buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*dequeueBuffer)(<span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="keyword">struct</span> ANativeWindowBuffer** buffer, <span class="type">int</span>* fenceFd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*queueBuffer)(<span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="keyword">struct</span> ANativeWindowBuffer* buffer, <span class="type">int</span> fenceFd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>     (*cancelBuffer)(<span class="keyword">struct</span> ANativeWindow* window,</span><br><span class="line">                <span class="keyword">struct</span> ANativeWindowBuffer* buffer, <span class="type">int</span> fenceFd);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// nativebase.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">android_native_base_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* reserved[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (*incRef)(<span class="keyword">struct</span> <span class="type">android_native_base_t</span>* base);</span><br><span class="line">    <span class="built_in">void</span> (*decRef)(<span class="keyword">struct</span> <span class="type">android_native_base_t</span>* base);</span><br><span class="line">&#125; <span class="type">android_native_base_t</span>;</span><br></pre></td></tr></table></figure>

<p>首先看它定义的属性，其中最重要的就是:common 属性。</p>
<p>common属性是一个 android_native_base_t 类型，它的定义位于当前 ANativeWindow 中的第一个，因此可以理解为：ANativeWindow 继承自 android_native_base_t ，后续可以使用android_native_base_t 类型来指向 ANativeWindow 实例。</p>
<blockquote>
<p>可以了解下 c 的结构体”继承”。</p>
</blockquote>
<p>在 android_native_base_t  结构体中，定义了几个属性。</p>
<p>1、magic ： 魔数值，用来区分当前 android_native_base_t 的子类是啥。比如 ANDROID_NATIVE_WINDOW_MAGIC 就对应着 ANativeWindow 子类。而这种魔数值是较为常见的做法，一般是存储在文件开头，用来区分文件的类型。</p>
<p>2、version：版本，一般是子类的 sizeof 。比如对于ANativeWindow 来说就是 sizeof(ANativeWindow)。</p>
<p>而这个 common 的初始化是放在了 ANativeWindow 的构造方法中了。主要是初始化 common.magic 为 ：ANDROID_NATIVE_WINDOW_MAGIC 。后期就可以使用 magic 来区分了。</p>
<p>接下来，在ANativeWindow 中定义了一系列的函数指针，用于子类实现时给设置具体的实现。</p>
<p>大概看一下这些函数指针的定义，就可以发现，其中主要都是和消费生产队列的生产者有关的。比如出队相关的 dequeueBuffer ，入队的 queueBuffer。但是这里出入队传入的参数不是之前的 slot，GraphicBuffer 那些了，而是：ANativeWindowBuffer 了。</p>
<h3 id="ANativeWindowBuffer"><a href="#ANativeWindowBuffer" class="headerlink" title="ANativeWindowBuffer"></a>ANativeWindowBuffer</h3><p>这里简单介绍下 ANativeWindowBuffer ，对他有个简单的认识，后面还会再讲到它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nativebase.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ANativeWindowBuffer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">    <span class="built_in">ANativeWindowBuffer</span>() &#123;</span><br><span class="line">        common.magic = ANDROID_NATIVE_BUFFER_MAGIC;</span><br><span class="line">        common.version = <span class="built_in">sizeof</span>(ANativeWindowBuffer);</span><br><span class="line">        <span class="built_in">memset</span>(common.reserved, <span class="number">0</span>, <span class="built_in">sizeof</span>(common.reserved));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implement the methods that sp&lt;ANativeWindowBuffer&gt; expects so that it</span></span><br><span class="line">    <span class="comment">// can be used to automatically refcount ANativeWindowBuffer&#x27;s.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">incStrong</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* <span class="comment">/*id*/</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        common.<span class="built_in">incRef</span>(<span class="built_in">const_cast</span>&lt;<span class="type">android_native_base_t</span>*&gt;(&amp;common));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decStrong</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* <span class="comment">/*id*/</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        common.<span class="built_in">decRef</span>(<span class="built_in">const_cast</span>&lt;<span class="type">android_native_base_t</span>*&gt;(&amp;common));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">android_native_base_t</span> common;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图形Buffer的宽度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图形Buffer的高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图形Buffer的步长，为了处理对齐问题，与height可能不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> stride;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图形Buffer的像素格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> format;</span><br><span class="line">    <span class="type">int</span> usage_deprecated;</span><br><span class="line">    <span class="type">uintptr_t</span> layerCount;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* reserved[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向一块图形Buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">native_handle_t</span>* handle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图形Buffer的使用规则（gralloc会分配不同属性的图形Buffer）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint64_t</span> usage;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* reserved_proc[<span class="number">8</span> - (<span class="built_in">sizeof</span>(<span class="type">uint64_t</span>) / <span class="built_in">sizeof</span>(<span class="type">void</span>*))];</span><br><span class="line">&#125; ANativeWindowBuffer_t;</span><br></pre></td></tr></table></figure>

<p>可以看到，它跟 ANativeWindow 比较类似，比如第一个属性也是 android_native_base_t common ，那么它也就相当于是 android_native_base_t 的子类。</p>
<p>在其构造方法中，会给 common 赋值，比如将其 magic 赋值为：ANDROID_NATIVE_BUFFER_MAGIC 。</p>
<p>另外其内部还定义了一些关于图形帧数据的属性，比如宽高格式等。以及指向图形数据的 handle ，关于handle 后面再讲，这里可以暂且简单将其看做是指向的图形数据，也就是 GraphicBuffer 对应的缓存区。</p>
<p>而它跟 GraphicBuffer 具体的关系是啥呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GraphicBuffer.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicBuffer</span></span><br><span class="line">    : <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindowBuffer, GraphicBuffer, RefBase&gt;,</span><br><span class="line">      <span class="keyword">public</span> Flattenable&lt;GraphicBuffer&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即 GraphicBuffer 是 ANativeWindowBuffer 的子类。更具体的就先不在这里分析了，后续可能会在讲 GraphicBuffer 分配的逻辑时再分析。</p>
<p>至此，我们可以简单的认为： ANativeWindow 就相当于之前生产消费队列的 BufferQueueProducer ，它的一个代表是 Surface；</p>
<p>ANativeWindowBuffer 就相当于是之前的 slot、GraphicBuffer。</p>
<p>接下来可以分析 Surface 了。延续上面的步伐，我们从 Surface.cpp 往上看到 Surface.java 。</p>
<h3 id="Surface-cpp"><a href="#Surface-cpp" class="headerlink" title="Surface.cpp"></a>Surface.cpp</h3><p>先看其相关定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Surface</span></span><br><span class="line">    : <span class="keyword">public</span> ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 以下会省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Surface</span><span class="params">(<span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">bool</span> controlledByApp = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">getIGraphicBufferProducer</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> sp&lt;Surface&gt; &amp;surface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> surface != <span class="literal">nullptr</span> &amp;&amp; surface-&gt;<span class="built_in">getIGraphicBufferProducer</span>() != <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">allocateBuffers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Surface</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  Surface &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Surface &amp;rhs);</span><br><span class="line">  <span class="built_in">Surface</span>(<span class="type">const</span> Surface &amp;rhs);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hook_cancelBuffer</span><span class="params">(ANativeWindow *window,</span></span></span><br><span class="line"><span class="params"><span class="function">                               ANativeWindowBuffer *buffer, <span class="type">int</span> fenceFd)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hook_dequeueBuffer</span><span class="params">(ANativeWindow *window,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ANativeWindowBuffer **buffer, <span class="type">int</span> *fenceFd)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hook_perform</span><span class="params">(ANativeWindow *window, <span class="type">int</span> operation, ...)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hook_query</span><span class="params">(<span class="type">const</span> ANativeWindow *window, <span class="type">int</span> what, <span class="type">int</span> *value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hook_queueBuffer</span><span class="params">(ANativeWindow *window,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ANativeWindowBuffer *buffer, <span class="type">int</span> fenceFd)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hook_setSwapInterval</span><span class="params">(ANativeWindow *window, <span class="type">int</span> interval)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dispatchConnect</span><span class="params">(va_list args)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dispatchDisconnect</span><span class="params">(va_list args)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dispatchSetBufferCount</span><span class="params">(va_list args)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">dequeueBuffer</span><span class="params">(ANativeWindowBuffer **buffer, <span class="type">int</span> *fenceFd)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">cancelBuffer</span><span class="params">(ANativeWindowBuffer *buffer, <span class="type">int</span> fenceFd)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">queueBuffer</span><span class="params">(ANativeWindowBuffer *buffer, <span class="type">int</span> fenceFd)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">perform</span><span class="params">(<span class="type">int</span> operation, va_list args)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> api)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">setBufferCount</span><span class="params">(<span class="type">int</span> bufferCount)</span></span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">disconnect</span><span class="params">(<span class="type">int</span> api,</span></span></span><br><span class="line"><span class="params"><span class="function">                         IGraphicBufferProducer::DisconnectMode mode =</span></span></span><br><span class="line"><span class="params"><span class="function">                         IGraphicBufferProducer::DisconnectMode::Api)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">lock</span><span class="params">(ANativeWindow_Buffer *outBuffer, ARect *inOutDirtyBounds)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">unlockAndPost</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> what, <span class="type">int</span> *value)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt; &amp;listener)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt; &amp;listener,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> reportBufferRemoval)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// BufferQueue 中 mSlots 数组的大小。当dequeue等操作之后会拿到对应的slot index，该index肯定小于这个值</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; NUM_BUFFER_SLOTS = BufferQueueDefs::NUM_BUFFER_SLOTS &#125;;</span><br><span class="line">  <span class="keyword">enum</span> &#123; DEFAULT_FORMAT = PIXEL_FORMAT_RGBA_8888 &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BufferSlot</span> &#123;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">    Region dirtyRegion;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  sp&lt;IGraphicBufferProducer&gt; mGraphicBufferProducer;</span><br><span class="line"></span><br><span class="line">  BufferSlot mSlots[NUM_BUzFFER_SLOTS];</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> mReqWidth;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> mReqHeight;</span><br><span class="line"></span><br><span class="line">  PixelFormat mReqFormat;</span><br><span class="line"></span><br><span class="line">  <span class="type">int64_t</span> mTimestamp;</span><br><span class="line"></span><br><span class="line">  sp&lt;GraphicBuffer&gt; mLockedBuffer;</span><br><span class="line"></span><br><span class="line">  sp&lt;GraphicBuffer&gt; mPostedBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> mConnectedToCpu;</span><br><span class="line"></span><br><span class="line">  Region mDirtyRegion;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> mBufferAge;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> mGenerationNumber;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> mSharedBufferMode;</span><br><span class="line">  <span class="type">bool</span> mAutoRefresh;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> mSharedBufferSlot;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> mSharedBufferHasBeenQueued;</span><br><span class="line"></span><br><span class="line">  <span class="type">nsecs_t</span> mLastDequeueDuration = <span class="number">0</span>;</span><br><span class="line">  <span class="type">nsecs_t</span> mLastQueueDuration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">nsecs_t</span> mLastDequeueStartTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> mNextFrameNumber = <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint64_t</span> mLastFrameNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;sp&lt;GraphicBuffer&gt;&gt; mRemovedBuffers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ANativeObjectBase.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NATIVE_TYPE, <span class="keyword">typename</span> TYPE, <span class="keyword">typename</span> REF,</span><br><span class="line">        <span class="keyword">typename</span> NATIVE_BASE = <span class="type">android_native_base_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> ANativeObjectBase : <span class="keyword">public</span> NATIVE_TYPE, <span class="keyword">public</span> REF</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">incStrong</span>(<span class="type">const</span> <span class="type">void</span>* id) <span class="type">const</span> &#123;</span><br><span class="line">        REF::<span class="built_in">incStrong</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decStrong</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* id)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        REF::<span class="built_in">decStrong</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> ANativeObjectBase&lt;NATIVE_TYPE, TYPE, REF, NATIVE_BASE&gt; BASE;</span><br><span class="line">    <span class="built_in">ANativeObjectBase</span>() : <span class="built_in">NATIVE_TYPE</span>(), <span class="built_in">REF</span>() &#123;</span><br><span class="line">        NATIVE_TYPE::common.incRef = incRef;</span><br><span class="line">        NATIVE_TYPE::common.decRef = decRef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供了一系列 getSelf 方法来将入参转换为 Surface</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> TYPE* <span class="title">getSelf</span><span class="params">(NATIVE_TYPE* self)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;TYPE*&gt;(self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> TYPE <span class="type">const</span>* <span class="title">getSelf</span><span class="params">(NATIVE_TYPE <span class="type">const</span>* self)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;TYPE <span class="type">const</span> *&gt;(self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> TYPE* <span class="title">getSelf</span><span class="params">(NATIVE_BASE* base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSelf</span>(<span class="built_in">reinterpret_cast</span>&lt;NATIVE_TYPE*&gt;(base));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> TYPE <span class="type">const</span> * <span class="title">getSelf</span><span class="params">(NATIVE_BASE <span class="type">const</span>* base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSelf</span>(<span class="built_in">reinterpret_cast</span>&lt;NATIVE_TYPE <span class="type">const</span>*&gt;(base));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">incRef</span><span class="params">(NATIVE_BASE* base)</span> </span>&#123;</span><br><span class="line">        ANativeObjectBase* self = <span class="built_in">getSelf</span>(base);</span><br><span class="line">        self-&gt;<span class="built_in">incStrong</span>(self);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">decRef</span><span class="params">(NATIVE_BASE* base)</span> </span>&#123;</span><br><span class="line">        ANativeObjectBase* self = <span class="built_in">getSelf</span>(base);</span><br><span class="line">        self-&gt;<span class="built_in">decStrong</span>(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到 Surface 是继承自 ANativeObjectBase 的，而ANativeObjectBase 是一个模板类，此时为其指定了模板类的类型：</p>
<p>①NATIVE_TYPE &#x3D; ANativeWindow</p>
<p>②TYPE &#x3D; Surface</p>
<p>③REF &#x3D; RefBase</p>
<p>因此 Surface 类其实是继承自 ANativeWindow 和 RefBase 的。并且提供了一系列的 getSelf 方法用于将 ANativeWindow 或者 RefBase 转换为 Surface 类型实例。</p>
<p>接着看 Surface 中的属性定义：</p>
<p>1、mGraphicBufferProducer：可以将其认为是一个 BufferQueueProducer 实例。它一般对应着一个 BufferQueueLayer 中的 BufferQueueConsumer。</p>
<p>2、mSlots：它是一个长度为BufferQueueDefs::NUM_BUFFER_SLOTS 的 BufferSlot 数组。而这里的 BufferSlot 是新定义的类，其内部封装了 GraphicBuffer 和其对应的脏区域dirtyRegion。</p>
<p>而这个 mSlots 数组中会存储Surface中后续从其内部 mGraphicBufferProducer 中出队的 slot 、GraphicBuffer 的信息。</p>
<blockquote>
<p>这种实现方式在前面讲到过了，比如 ConsumerBase 中的 mSlots ，以及 BufferLayerConsumer 中的 mImages 。不同的是这俩是对应的 消费者 端，而当前的 Surface 对应的是 生产者端。</p>
</blockquote>
<p>3、mLockedBuffer：调用 lock 方法新出队的 GraphicBuffer，也就是指向上次(通过lock方法)出队的 GraphicBuffer 。</p>
<p>4、mPostedBuffer：调用 unlockAndPost 方法将 mLockedBuffer 数据提交入队之后，mPostedBuffer会指向它，也就是指向上次(通过 unlockAndPost 方法)入队的 GraphicBuffer 。</p>
<p>接下来看看其关键方法的实现：</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.cpp</span></span><br><span class="line"></span><br><span class="line">Surface::<span class="built_in">Surface</span>(<span class="type">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer, <span class="type">bool</span> controlledByApp)</span><br><span class="line">    : <span class="built_in">mGraphicBufferProducer</span>(bufferProducer),</span><br><span class="line">      <span class="built_in">mCrop</span>(Rect::EMPTY_RECT),</span><br><span class="line">      <span class="built_in">mBufferAge</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mGenerationNumber</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mSharedBufferMode</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mAutoRefresh</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mSharedBufferSlot</span>(BufferItem::INVALID_BUFFER_SLOT),</span><br><span class="line">      <span class="built_in">mSharedBufferHasBeenQueued</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mQueriedSupportedTimestamps</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mFrameTimestampsSupportsPresent</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mEnableFrameTimestamps</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mFrameEventHistory</span>(std::<span class="built_in">make_unique</span>&lt;ProducerFrameEventHistory&gt;()) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化父类 ANativeWindow 中的函数指针，相当于子类对它的实现</span></span><br><span class="line">  ANativeWindow::setSwapInterval = hook_setSwapInterval;</span><br><span class="line">  <span class="comment">// 设置 dequeueBuffer hook</span></span><br><span class="line">  ANativeWindow::dequeueBuffer = hook_dequeueBuffer;</span><br><span class="line">  ANativeWindow::cancelBuffer = hook_cancelBuffer;</span><br><span class="line">  ANativeWindow::queueBuffer = hook_queueBuffer;</span><br><span class="line">  <span class="comment">// ANativeWindow 中的 query 方法</span></span><br><span class="line">  ANativeWindow::query = hook_query;</span><br><span class="line">  ANativeWindow::perform = hook_perform;</span><br><span class="line"></span><br><span class="line">  ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;</span><br><span class="line">  ANativeWindow::cancelBuffer_DEPRECATED = hook_cancelBuffer_DEPRECATED;</span><br><span class="line">  ANativeWindow::lockBuffer_DEPRECATED = hook_lockBuffer_DEPRECATED;</span><br><span class="line">  ANativeWindow::queueBuffer_DEPRECATED = hook_queueBuffer_DEPRECATED;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(ANativeWindow::minSwapInterval) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(ANativeWindow::maxSwapInterval) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化赋值</span></span><br><span class="line">  mReqWidth = <span class="number">0</span>;</span><br><span class="line">  mReqHeight = <span class="number">0</span>;</span><br><span class="line">  mReqFormat = <span class="number">0</span>;</span><br><span class="line">  mReqUsage = <span class="number">0</span>;</span><br><span class="line">  mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;</span><br><span class="line">  mDataSpace = Dataspace::UNKNOWN;</span><br><span class="line">  mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;</span><br><span class="line">  mTransform = <span class="number">0</span>;</span><br><span class="line">  mStickyTransform = <span class="number">0</span>;</span><br><span class="line">  mDefaultWidth = <span class="number">0</span>;</span><br><span class="line">  mDefaultHeight = <span class="number">0</span>;</span><br><span class="line">  mUserWidth = <span class="number">0</span>;</span><br><span class="line">  mUserHeight = <span class="number">0</span>;</span><br><span class="line">  mTransformHint = <span class="number">0</span>;</span><br><span class="line">  mConsumerRunningBehind = <span class="literal">false</span>;</span><br><span class="line">  mConnectedToCpu = <span class="literal">false</span>;</span><br><span class="line">  mProducerControlledByApp = controlledByApp;</span><br><span class="line">  mSwapIntervalZero = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其构造方法中，首先会将传入的 BufferQueueProducer 实现类保存起来，后期出队入队的操作都由它来完成。</p>
<blockquote>
<p>回想之前的 BufferQueueLayer ，它内部封装的是 BufferQueueConsumer ，而这里封装的是 BufferQueueProducer ，因此可以把他俩分别当做是生产消费者的具体实现。</p>
</blockquote>
<p>进入到构造方法体内后，会给其父类 ANativeWindow 中的函数指针赋值，为其指定实现。</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::connect</span><span class="params">(<span class="type">int</span> api)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> sp&lt;IProducerListener&gt; listener = <span class="keyword">new</span> <span class="built_in">DummyProducerListener</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">connect</span>(api, listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::connect</span><span class="params">(<span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt; &amp;listener)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">connect</span>(api, listener, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> api, <span class="type">const</span> sp&lt;IProducerListener&gt; &amp;listener, <span class="type">bool</span> reportBufferRemoval)</span> </span>&#123;</span><br><span class="line">  <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">  <span class="comment">// 用来接收 connect 结果</span></span><br><span class="line">  IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">  mReportRemovedBuffers = reportBufferRemoval;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将生产者 BufferQueueProducer 接入到队列中去，后续就可以使用该生产者去生产数据了</span></span><br><span class="line">  <span class="type">int</span> err = mGraphicBufferProducer-&gt;<span class="built_in">connect</span>(listener, api, mProducerControlledByApp, &amp;output);</span><br><span class="line">  <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">// 获取到内部的返回值，比如默认宽高格式信息等</span></span><br><span class="line">    mDefaultWidth = output.width;</span><br><span class="line">    mDefaultHeight = output.height;</span><br><span class="line">    mNextFrameNumber = output.nextFrameNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStickyTransform == <span class="number">0</span> &amp;&amp; !<span class="built_in">transformToDisplayInverse</span>()) &#123;</span><br><span class="line">      mTransformHint = output.transformHint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mConsumerRunningBehind = (output.numPendingBuffers &gt;= <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// connect 成功</span></span><br><span class="line">  <span class="keyword">if</span> (!err &amp;&amp; api == NATIVE_WINDOW_API_CPU) &#123;</span><br><span class="line">    mConnectedToCpu = <span class="literal">true</span>;</span><br><span class="line">    mDirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    mDirtyRegion = Region::INVALID_REGION;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是一开始就要调用的，相当于是将该 BufferQueueProducer 接入到 BufferQueue 中，这样的话后续就可以使用该 BufferQueueProducer 来从 BufferQueue 中出队，入队数据了。</p>
<h4 id="dequeueBuffer"><a href="#dequeueBuffer" class="headerlink" title="dequeueBuffer"></a>dequeueBuffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::hook_dequeueBuffer</span><span class="params">(ANativeWindow *window,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ANativeWindowBuffer **buffer, <span class="type">int</span> *fenceFd)</span> </span>&#123;</span><br><span class="line">  Surface *c = <span class="built_in">getSelf</span>(window);</span><br><span class="line">  <span class="keyword">return</span> c-&gt;<span class="built_in">dequeueBuffer</span>(buffer, fenceFd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span> **buffer, <span class="type">int</span> *fenceFd)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> reqWidth;</span><br><span class="line">  <span class="type">uint32_t</span> reqHeight;</span><br><span class="line">  PixelFormat reqFormat;</span><br><span class="line">  <span class="type">uint64_t</span> reqUsage;</span><br><span class="line">  <span class="type">bool</span> enableFrameTimestamps;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最终需要的宽高格式等信息</span></span><br><span class="line">    reqWidth = mReqWidth ? mReqWidth : mUserWidth;</span><br><span class="line">    reqHeight = mReqHeight ? mReqHeight : mUserHeight;</span><br><span class="line"></span><br><span class="line">    reqFormat = mReqFormat;</span><br><span class="line">    reqUsage = mReqUsage;</span><br><span class="line"></span><br><span class="line">    enableFrameTimestamps    = mEnableFrameTimestamps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享模式不考虑</span></span><br><span class="line">    <span class="keyword">if</span> (mSharedBufferMode &amp;&amp; mAutoRefresh &amp;&amp; mSharedBufferSlot !=</span><br><span class="line">        BufferItem::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">      <span class="function">sp&lt;GraphicBuffer&gt; &amp;<span class="title">gbuf</span><span class="params">(mSlots[mSharedBufferSlot].buffer)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (gbuf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *buffer = gbuf.<span class="built_in">get</span>();</span><br><span class="line">        *fenceFd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> buf = <span class="number">-1</span>;</span><br><span class="line">  sp&lt;Fence&gt; fence;</span><br><span class="line">  <span class="type">nsecs_t</span> startTime = <span class="built_in">systemTime</span>();</span><br><span class="line"></span><br><span class="line">  FrameEventHistoryDelta frameTimestamps;</span><br><span class="line">  <span class="comment">// 通过 BufferQueueProducer 来出队一个 slot 来给消费者使用</span></span><br><span class="line">  <span class="type">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, reqWidth, reqHeight,</span><br><span class="line">                                                          reqFormat, reqUsage, &amp;mBufferAge,</span><br><span class="line">                                                          enableFrameTimestamps ? &amp;frameTimestamps</span><br><span class="line">                                                                                : <span class="literal">nullptr</span>);</span><br><span class="line">  mLastDequeueDuration = <span class="built_in">systemTime</span>() - startTime;</span><br><span class="line">  <span class="comment">// 出队失败了</span></span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断返回的 slot 索引是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (buf &lt; <span class="number">0</span> || buf &gt;= NUM_BUFFER_SLOTS) &#123;</span><br><span class="line">    <span class="built_in">android_errorWriteLog</span>(<span class="number">0x534e4554</span>, <span class="string">&quot;36991414&quot;</span>); <span class="comment">// SafetyNet logging</span></span><br><span class="line">    <span class="keyword">return</span> FAILED_TRANSACTION;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">  mLastDequeueStartTime = startTime;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每个 slot 位置第一次从 mSlots 中取 buffer 时，都是null的</span></span><br><span class="line">  <span class="function">sp&lt;GraphicBuffer&gt; &amp;<span class="title">gbuf</span><span class="params">(mSlots[buf].buffer)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(<span class="built_in">atrace_is_tag_enabled</span>(ATRACE_TAG_GRAPHICS))) &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> FenceMonitor <span class="title">hwcReleaseThread</span><span class="params">(<span class="string">&quot;HWC release&quot;</span>)</span></span>;</span><br><span class="line">    hwcReleaseThread.<span class="built_in">queueFence</span>(fence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result &amp; IGraphicBufferProducer::RELEASE_ALL_BUFFERS) &#123;</span><br><span class="line">    <span class="built_in">freeAllBuffers</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableFrameTimestamps) &#123;</span><br><span class="line">    mFrameEventHistory-&gt;<span class="built_in">applyDelta</span>(frameTimestamps);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 出队返回的 slot 位置的 GraphicBuffer 需要重新初始化，</span></span><br><span class="line"><span class="comment">   * 或者从 mSlots中取出之前的 GraphicBuffer 就是null，</span></span><br><span class="line"><span class="comment">   * 那么此时需要调用 requestBuffer 方法来拿到其 GraphicBuffer 实例</span></span><br><span class="line"><span class="comment">   * 此时会自动将获取到的 GraphicBuffer 实例赋值给 gbuf ，也就是 mSlots[buf] 位置的 buffer 属性，后续获取该位置时就不是null了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mReportRemovedBuffers &amp;&amp; (gbuf != <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      mRemovedBuffers.<span class="built_in">push_back</span>(gbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用生产者的 requestBuffer 方法来拿到 buf index 位置的 mGraphicBuffer 属性</span></span><br><span class="line">    <span class="comment">// 第一个参数是前面 dequeueBuffer 时返回的BufferQueue中对应 BufferSlot 的索引</span></span><br><span class="line">    <span class="comment">// 第二个参数是最终结果，即内部会将 gbuf 指向对应 BufferSlot 中的mGraphicBuffer，然后后续对gbuf操作就可以了</span></span><br><span class="line">    result = mGraphicBufferProducer-&gt;<span class="built_in">requestBuffer</span>(buf, &amp;gbuf);</span><br><span class="line">    <span class="comment">// requestBuffer 失败了</span></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">      <span class="built_in">ALOGE</span>(<span class="string">&quot;dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d&quot;</span>, result);</span><br><span class="line">      mGraphicBufferProducer-&gt;<span class="built_in">cancelBuffer</span>(buf, fence);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fence-&gt;<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">    *fenceFd = fence-&gt;<span class="built_in">dup</span>();</span><br><span class="line">    <span class="keyword">if</span> (*fenceFd == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">ALOGE</span>(<span class="string">&quot;dequeueBuffer: error duping fence: %d&quot;</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *fenceFd = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将对应的 GraphicBuffer 返回给外面</span></span><br><span class="line">  *buffer = gbuf.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新共享模式时的属性，一般不是共享模式，这里不用考虑</span></span><br><span class="line">  <span class="keyword">if</span> (mSharedBufferMode &amp;&amp; mAutoRefresh) &#123;</span><br><span class="line">    mSharedBufferSlot = buf;</span><br><span class="line">    mSharedBufferHasBeenQueued = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSharedBufferSlot == buf) &#123;</span><br><span class="line">    mSharedBufferSlot = BufferItem::INVALID_BUFFER_SLOT;</span><br><span class="line">    mSharedBufferHasBeenQueued = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前方法中首先会调用内部 BufferQueueProducer 中的 dequeueBuffer 方法来从生产消费队列中出队一个 GraphicBuffer 给消费者侧来使用。然后会将该 slot 位置的 GraphicBuffer 保存到 mSlots 中。这样的话后续就可以很方便的使用它了。</p>
<h4 id="queueBuffer"><a href="#queueBuffer" class="headerlink" title="queueBuffer"></a>queueBuffer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="type">android_native_buffer_t</span> *buffer, <span class="type">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">  <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">  <span class="type">int64_t</span> timestamp;</span><br><span class="line">  <span class="type">bool</span> isAutoTimestamp = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mTimestamp 默认是 NATIVE_WINDOW_TIMESTAMP_AUTO，</span></span><br><span class="line">  <span class="comment">// 这里是确定出后续 dequeueBuffer 时的时间戳</span></span><br><span class="line">  <span class="keyword">if</span> (mTimestamp == NATIVE_WINDOW_TIMESTAMP_AUTO) &#123;</span><br><span class="line">    timestamp = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    isAutoTimestamp = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timestamp = mTimestamp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 mSlots 中找到该 Buffer 对应的 slot 索引</span></span><br><span class="line">  <span class="comment">// 如果没有找到表示之前该 buffer 并没有保存到这里。则不能进行下一步计算</span></span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">getSlotFromBufferLocked</span>(buffer);</span><br><span class="line">  <span class="comment">// 返回的 slot 不合法，表示没找到</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fenceFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">close</span>(fenceFd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 共享模式不考虑</span></span><br><span class="line">  <span class="keyword">if</span> (mSharedBufferSlot == i &amp;&amp; mSharedBufferHasBeenQueued) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fenceFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">close</span>(fenceFd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">Rect <span class="title">crop</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">  mCrop.<span class="built_in">intersect</span>(<span class="built_in">Rect</span>(buffer-&gt;width, buffer-&gt;height), &amp;crop);</span><br><span class="line">  <span class="function">sp&lt;Fence&gt; <span class="title">fence</span><span class="params">(fenceFd &gt;= <span class="number">0</span> ? <span class="keyword">new</span> Fence(fenceFd) : Fence::NO_FENCE)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 QueueBufferOutput 和 QueueBufferInput 实例</span></span><br><span class="line">  <span class="comment">// 其中前者是用来接受 BufferQueue::queueBuffer 的结果的，后者是用来将 queueBuffer 相关信息封装起来的</span></span><br><span class="line">  IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">  <span class="function">IGraphicBufferProducer::QueueBufferInput <span class="title">input</span><span class="params">(timestamp, isAutoTimestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="keyword">static_cast</span>&lt;android_dataspace&gt;(mDataSpace), crop, mScalingMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 mTransform ^ mStickyTransform, fence, mStickyTransform,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 mEnableFrameTimestamps)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we should send HDR metadata as needed if this becomes a bottleneck</span></span><br><span class="line">  input.<span class="built_in">setHdrMetadata</span>(mHdrMetadata);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mConnectedToCpu || mDirtyRegion.<span class="built_in">bounds</span>() == Rect::INVALID_RECT) &#123;</span><br><span class="line">    input.<span class="built_in">setSurfaceDamage</span>(Region::INVALID_REGION);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> width = buffer-&gt;width;</span><br><span class="line">    <span class="type">int</span> height = buffer-&gt;height;</span><br><span class="line">    <span class="type">bool</span> rotated90 = (mTransform ^ mStickyTransform) &amp;</span><br><span class="line">        NATIVE_WINDOW_TRANSFORM_ROT_90;</span><br><span class="line">    <span class="keyword">if</span> (rotated90) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Region flippedRegion;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> rect: mDirtyRegion) &#123;</span><br><span class="line">      <span class="type">int</span> left = rect.left;</span><br><span class="line">      <span class="type">int</span> right = rect.right;</span><br><span class="line">      <span class="type">int</span> top = height - rect.bottom; <span class="comment">// Flip from OpenGL convention</span></span><br><span class="line">      <span class="type">int</span> bottom = height - rect.top; <span class="comment">// Flip from OpenGL convention</span></span><br><span class="line">      <span class="keyword">switch</span> (mTransform ^ mStickyTransform) &#123;</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_TRANSFORM_ROT_90: &#123;</span><br><span class="line">          <span class="comment">// Rotate 270 degrees</span></span><br><span class="line">          Rect flippedRect&#123;top, width - right, bottom, width - left&#125;;</span><br><span class="line">          flippedRegion.<span class="built_in">orSelf</span>(flippedRect);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_TRANSFORM_ROT_180: &#123;</span><br><span class="line">          <span class="comment">// Rotate 180 degrees</span></span><br><span class="line">          Rect flippedRect&#123;width - right, height - bottom,</span><br><span class="line">                           width - left, height - top&#125;;</span><br><span class="line">          flippedRegion.<span class="built_in">orSelf</span>(flippedRect);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> NATIVE_WINDOW_TRANSFORM_ROT_270: &#123;</span><br><span class="line">          <span class="comment">// Rotate 90 degrees</span></span><br><span class="line">          Rect flippedRect&#123;height - bottom, left,</span><br><span class="line">                           height - top, right&#125;;</span><br><span class="line">          flippedRegion.<span class="built_in">orSelf</span>(flippedRect);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          Rect flippedRect&#123;left, top, right, bottom&#125;;</span><br><span class="line">          flippedRegion.<span class="built_in">orSelf</span>(flippedRect);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input.<span class="built_in">setSurfaceDamage</span>(flippedRegion);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>();</span><br><span class="line">  <span class="comment">// 上面设置完 input 的属性字段之后，现在开始将入参 buffer queue 到 BufferQueue 中去</span></span><br><span class="line">  <span class="comment">// 这里的 i 就是入参 buffer 对应的 slot </span></span><br><span class="line">  <span class="type">status_t</span> err = mGraphicBufferProducer-&gt;<span class="built_in">queueBuffer</span>(i, input, &amp;output);</span><br><span class="line">  mLastQueueDuration = <span class="built_in">systemTime</span>() - now;</span><br><span class="line">  <span class="comment">// 处理 queueBuffer</span></span><br><span class="line">  <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;queueBuffer: error queuing buffer to SurfaceTexture, %d&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mEnableFrameTimestamps) &#123;</span><br><span class="line">    mFrameEventHistory-&gt;<span class="built_in">applyDelta</span>(output.frameTimestamps);</span><br><span class="line">    mFrameEventHistory-&gt;<span class="built_in">updateAcquireFence</span>(mNextFrameNumber,</span><br><span class="line">                                           std::<span class="built_in">make_shared</span>&lt;FenceTime&gt;(fence));</span><br><span class="line"></span><br><span class="line">    mFrameEventHistory-&gt;<span class="built_in">updateSignalTimes</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成功入队了一帧数据，此时更新对应的属性值</span></span><br><span class="line">  mLastFrameNumber = mNextFrameNumber;</span><br><span class="line"></span><br><span class="line">  mDefaultWidth = output.width;</span><br><span class="line">  mDefaultHeight = output.height;</span><br><span class="line">  mNextFrameNumber = output.nextFrameNumber;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mStickyTransform == <span class="number">0</span> &amp;&amp; !<span class="built_in">transformToDisplayInverse</span>()) &#123;</span><br><span class="line">    mTransformHint = output.transformHint;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mConsumerRunningBehind = (output.numPendingBuffers &gt;= <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!mConnectedToCpu) &#123;</span><br><span class="line">    mDirtyRegion = Region::INVALID_REGION;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mSharedBufferMode &amp;&amp; mAutoRefresh &amp;&amp; mSharedBufferSlot == i) &#123;</span><br><span class="line">    mSharedBufferHasBeenQueued = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mQueueBufferCondition.<span class="built_in">broadcast</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(<span class="built_in">atrace_is_tag_enabled</span>(ATRACE_TAG_GRAPHICS))) &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> FenceMonitor <span class="title">gpuCompletionThread</span><span class="params">(<span class="string">&quot;GPU completion&quot;</span>)</span></span>;</span><br><span class="line">    gpuCompletionThread.<span class="built_in">queueFence</span>(fence);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::getSlotFromBufferLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">android_native_buffer_t</span> *buffer)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 遍历 mSlots ，挨个比对其是否是要找的 buffer ，是的话则返回该 slot 索引</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_BUFFER_SLOTS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mSlots[i].buffer != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        mSlots[i].buffer-&gt;handle == buffer-&gt;handle) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将对应的数据通过内部的 BufferQueueProducer 入队到 BufferQueue 中。这样的话就相当于生产者生产了数据并且扔到队伍中等待消费者处理了。</p>
<p>而入队时，入参不再是 GraphicBuffer 或者 slot 值了，而是 android_native_buffer_t ，它其实也就是对应的 GraphicBuffer 。而BufferQueueProducer入队时，接收的是对应的 slot 值，所以之前 mSlots 中保存的值此时就排上了用场。</p>
<h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Surface::lock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ANativeWindow_Buffer *outBuffer, ARect *inOutDirtyBounds)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 已经 lock 过了，不能重复lock</span></span><br><span class="line">  <span class="keyword">if</span> (mLockedBuffer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 connect 中可能会将 mConnectedToCpu 置为 true。这里再次尝试下connect</span></span><br><span class="line">  <span class="keyword">if</span> (!mConnectedToCpu) &#123;</span><br><span class="line">    <span class="type">int</span> err = Surface::<span class="built_in">connect</span>(NATIVE_WINDOW_API_CPU);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setUsage</span>(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ANativeWindowBuffer *out;</span><br><span class="line">  <span class="type">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 先调用 dequeueBuffer 方法来从生产消费队列中出队一个 GraphicBuffer</span></span><br><span class="line"><span class="comment">   * 这个 GraphicBuffer 同时会保存到 mSlots 中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">status_t</span> err = <span class="built_in">dequeueBuffer</span>(&amp;out, &amp;fenceFd);</span><br><span class="line">  <span class="comment">// dequeueBuffer 成功了</span></span><br><span class="line">  <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">// out 其实就是一个 sp&lt;GraphicBuffer&gt;</span></span><br><span class="line">    <span class="comment">// 所以这里 backBuffer 其实就指向了刚出队的 out </span></span><br><span class="line">    <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">backBuffer</span><span class="params">(GraphicBuffer::getSelf(out))</span></span>;</span><br><span class="line">    <span class="comment">// 新出队 GraphicBuffer 的宽高信息</span></span><br><span class="line">    <span class="function"><span class="type">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</span><br><span class="line"></span><br><span class="line">    Region newDirtyRegion;</span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">      newDirtyRegion.<span class="built_in">set</span>(<span class="built_in">static_cast</span>&lt;Rect <span class="type">const</span> &amp;&gt;(*inOutDirtyBounds));</span><br><span class="line">      newDirtyRegion.<span class="built_in">andSelf</span>(bounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次调用当前 lock 方法时，mPostedBuffer 应该是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">const</span> sp&lt;GraphicBuffer&gt; &amp;<span class="title">frontBuffer</span><span class="params">(mPostedBuffer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * frontBuffer 不为空的话，则判断它的 宽高格式 是否和和刚出队的 backBuffer 的宽高格式是一样的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> canCopyBack = (frontBuffer != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        backBuffer-&gt;width == frontBuffer-&gt;width &amp;&amp;</span><br><span class="line">        backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</span><br><span class="line">        backBuffer-&gt;format == frontBuffer-&gt;format);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 frontBuffer 和刚出队的 backBuffer 的宽高格式是一样的，那么就可以进行像素复制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (canCopyBack) &#123;</span><br><span class="line">      <span class="function"><span class="type">const</span> Region <span class="title">copyback</span><span class="params">(mDirtyRegion.subtract(newDirtyRegion))</span></span>;</span><br><span class="line">      <span class="comment">// 将 frontBuffer 内容复制到 backBuffer 中</span></span><br><span class="line">      <span class="keyword">if</span> (!copyback.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="built_in">copyBlt</span>(backBuffer, frontBuffer, copyback, &amp;fenceFd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果前后两帧的宽高格式不一样不能直接赋值，那么此时将 脏区扩大，表示整个帧都是脏区，</span></span><br><span class="line">      <span class="comment">// 也就是整个帧的区域内都需要刷新，刷新整个帧</span></span><br><span class="line">      newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">      mDirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">      <span class="comment">// 清除所有的脏区</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; NUM_BUFFER_SLOTS; i++) &#123;</span><br><span class="line">        mSlots[i].dirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">      <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到当前 Surface 中 mSlots 中 backBuffer 位置的索引</span></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">backBufferSlot</span><span class="params">(getSlotFromBufferLocked(backBuffer.get()))</span></span>;</span><br><span class="line">      <span class="comment">// 如果在 mSlots 中找到了 backBuffer ，则更新其对应的脏区信息</span></span><br><span class="line">      <span class="keyword">if</span> (backBufferSlot &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">Region &amp;<span class="title">dirtyRegion</span><span class="params">(mSlots[backBufferSlot].dirtyRegion)</span></span>;</span><br><span class="line">        mDirtyRegion.<span class="built_in">subtract</span>(dirtyRegion);</span><br><span class="line">        dirtyRegion = newDirtyRegion;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDirtyRegion.<span class="built_in">orSelf</span>(newDirtyRegion);</span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">      *inOutDirtyBounds = newDirtyRegion.<span class="built_in">getBounds</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *vaddr;</span><br><span class="line">    <span class="comment">// 将 backBuffer 也就是后缓冲 lock 起来，这也正是当前 Surface::lock 方法的作用</span></span><br><span class="line">    <span class="comment">// 而这个 backBuffer 从上面可以知道它就是刚 dequeue 的那个</span></span><br><span class="line">    <span class="type">status_t</span> res = backBuffer-&gt;<span class="built_in">lockAsync</span>(</span><br><span class="line">        GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">        newDirtyRegion.<span class="built_in">bounds</span>(), &amp;vaddr, fenceFd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// backBuffer  lock 失败了</span></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">      err = INVALID_OPERATION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// lock 成功了，那么将 mLockedBuffer 赋值为  backBuffer</span></span><br><span class="line">      mLockedBuffer = backBuffer;</span><br><span class="line">      <span class="comment">// 将对外的返回值 ANativeWindow_Buffer 中赋值</span></span><br><span class="line">      outBuffer-&gt;width = backBuffer-&gt;width;</span><br><span class="line">      outBuffer-&gt;height = backBuffer-&gt;height;</span><br><span class="line">      outBuffer-&gt;stride = backBuffer-&gt;stride;</span><br><span class="line">      outBuffer-&gt;format = backBuffer-&gt;format;</span><br><span class="line">      outBuffer-&gt;bits = vaddr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">status_t</span> <span class="title">copyBlt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;GraphicBuffer&gt; &amp;dst,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;GraphicBuffer&gt; &amp;src,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Region &amp;reg,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> *dstFenceFd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dst-&gt;<span class="built_in">getId</span>() == src-&gt;<span class="built_in">getId</span>())</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">  <span class="type">status_t</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始复制之前，先对 src 和 dst 加锁</span></span><br><span class="line">  <span class="type">uint8_t</span> *src_bits = <span class="literal">nullptr</span>;</span><br><span class="line">  err = src-&gt;<span class="built_in">lock</span>(GRALLOC_USAGE_SW_READ_OFTEN, reg.<span class="built_in">bounds</span>(),</span><br><span class="line">                  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> **&gt;(&amp;src_bits));</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span> *dst_bits = <span class="literal">nullptr</span>;</span><br><span class="line">  err = dst-&gt;<span class="built_in">lockAsync</span>(GRALLOC_USAGE_SW_WRITE_OFTEN, reg.<span class="built_in">bounds</span>(),</span><br><span class="line">                       <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> **&gt;(&amp;dst_bits), *dstFenceFd);</span><br><span class="line">  *dstFenceFd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Region::const_iterator <span class="title">head</span><span class="params">(reg.begin())</span></span>;</span><br><span class="line">  <span class="function">Region::const_iterator <span class="title">tail</span><span class="params">(reg.end())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在开始复制</span></span><br><span class="line">  <span class="keyword">if</span> (head != tail &amp;&amp; src_bits &amp;&amp; dst_bits) &#123;</span><br><span class="line">    <span class="comment">// 该种 format 格式下，一个像素点对应几个字节呢？通过 bytesPerPixel 方法来计算</span></span><br><span class="line">    <span class="comment">// 比如 PIXEL_FORMAT_RGBA_8888 是一个像素对应4个字节</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> bpp = <span class="built_in">bytesPerPixel</span>(src-&gt;format);</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> dbpr = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(dst-&gt;stride) * bpp;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> sbpr = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(src-&gt;stride) * bpp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">      <span class="function"><span class="type">const</span> Rect &amp;<span class="title">r</span><span class="params">(*head++)</span></span>;</span><br><span class="line">      <span class="type">int32_t</span> h = r.<span class="built_in">height</span>();</span><br><span class="line">      <span class="keyword">if</span> (h &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="type">size_t</span> size = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(r.<span class="built_in">width</span>()) * bpp;</span><br><span class="line">      <span class="type">uint8_t</span> <span class="type">const</span> *s = src_bits +</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(r.left + src-&gt;stride * r.top) * bpp;</span><br><span class="line">      <span class="type">uint8_t</span> *d = dst_bits +</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(r.left + dst-&gt;stride * r.top) * bpp;</span><br><span class="line">      <span class="keyword">if</span> (dbpr == sbpr &amp;&amp; size == sbpr) &#123;</span><br><span class="line">        size *= <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(h);</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(d, s, size);</span><br><span class="line">        d += dbpr;</span><br><span class="line">        s += sbpr;</span><br><span class="line">      &#125; <span class="keyword">while</span> (--h &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (src_bits)</span><br><span class="line">    src-&gt;<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dst_bits)</span><br><span class="line">    dst-&gt;<span class="built_in">unlockAsync</span>(dstFenceFd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lock方法算是 Surface 中很重要的方法了。</p>
<p>在该方法中主要执行了如下几个操作：</p>
<p>①调用 dequeueBuffer 从 BufferQueue 中出队一个 GraphicBuffer 。该方法执行时，会同时将出队的 GraphicBuffer 等信息存储到 mSlots 数组中。</p>
<p>注意这里调用 dequeueBuffer 方法时，传入的是ANativeWindowBuffer ，而该方法定义的入参是：android_native_buffer_t 类型的，但是该方法内部实际给入参赋值的是 GraphicBuffer 实例。这三者的关系：</p>
<p>android_native_buffer_t 是 ANativeWindowBuffer 的一个别名，这俩基本算是等价的。而另外的 GraphicBuffer 是ANativeWindowBuffer 的子类。因此代码中的： GraphicBuffer::getSelf(out) 就不难理解了。</p>
<blockquote>
<p>额外补充下：GraphicBuffer 是通过继承ANativeObjectBase 模板类来同时继承 ANativeWindowBuffer 的，而 getSelf 方法正是来自于ANativeObjectBase 的。</p>
</blockquote>
<p>②将新出队的 GraphicBuffer 作为 backBuffer ，将 mPostedBuffer 作为 frontBuffer 。这俩命名就可以看出是俩一前一后的Buffer。</p>
<blockquote>
<p>对于 mPostedBuffer 来说，一开始它就是 null ，只有在调用 lock 方法之后再调用 unlockAndPost 方法它才会被赋值，具体是赋值为 mLockedBuffer 。</p>
</blockquote>
<p>然后判断这俩 backBuffer 和 frontBuffer 的宽、高、格式信息，如果都一样的话，则会尝试将 fontBuffer 的像素信息复制到 backBuffer 中；否则会将 newDirtyRegion 的区域更新为 bounds，也就是 backBuffer 的整个区域。</p>
<p>这里复制像素的原因是因为可能backBuffer 和 frontBuffer 之间的差异，或者说是 backBuffer 的变化区域可能只有一小块，而不是整个区域，所以发生变化的区域之外的像素就需要沿用上一帧的，也就是 frontBuffer 中的像素信息。</p>
<blockquote>
<p>这里说的发生变化的区域就可以理解为是：脏区。脏区内的数据是需要刷新的。</p>
</blockquote>
<p>而如果宽高格式不一致的话则不能直接复制，所以此时会更新脏区为 backBuffer 的整个区域，也就是整个帧区域都需要刷新。</p>
<p>同时会将最终的脏区更新到 mSlots 数组中指定位置上去。</p>
<p>③调用 backBuffer 的 lockAsync 方法来将其对应的缓冲区域锁定起来，表示被占用，后续生产者才能往该区域内去写入生产好的数据。</p>
<p>最后在返回之前，将刚出队的 backBuffer 赋值给 mLockerBuffer 。表示调用过 lock 方法了。</p>
<blockquote>
<p>关于 lockAsync 方法本篇文章不做分析，后续会专门有文章来分析它的。</p>
</blockquote>
<h4 id="unlockAndPost"><a href="#unlockAndPost" class="headerlink" title="unlockAndPost"></a>unlockAndPost</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Surface::unlockAndPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 之前没有调用过 lock 方法，那么不能调用 unlockAndPost</span></span><br><span class="line">  <span class="keyword">if</span> (mLockedBuffer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 将 mLockedBuffer 解除锁定，因为在上面 Surface::lock 方法中会对其进行lock</span></span><br><span class="line">  <span class="type">status_t</span> err = mLockedBuffer-&gt;<span class="built_in">unlockAsync</span>(&amp;fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将其入队到 BufferQueue 中去</span></span><br><span class="line">  err = <span class="built_in">queueBuffer</span>(mLockedBuffer.<span class="built_in">get</span>(), fd);</span><br><span class="line">  <span class="built_in">ALOGE_IF</span>(err, <span class="string">&quot;queueBuffer (handle=%p) failed (%s)&quot;</span>,</span><br><span class="line">           mLockedBuffer-&gt;handle, <span class="built_in">strerror</span>(-err));</span><br><span class="line"></span><br><span class="line">  mPostedBuffer = mLockedBuffer;</span><br><span class="line">  mLockedBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面调用过 lock 方法之后，会先将新出队的 GraphicBuffer 调用 lockAsync() 来锁定住供消费者去使用，填充生产数据，然后将其保存到 mLockedBuffer 中。</p>
<p>而等其填充好数据之后，可以调用当前方法来提交数据。</p>
<p>在提交数据到BufferQueue中之前，得先调用 GraphicBuffer 的 unlockAsync 方法来解除其锁定状态，接着调用 enqueueBuffer 方法来将其入队到 BufferQueue 中去等待消费者侧消费。</p>
<p>这里需要额外注意的是 ：mPostedBuffer会保存成mLockedBuffer，而mLockedBuffer会被置为 null。</p>
<p>到这里应该可以明白这俩值的作用了吧。其实在 Surface 中，它作为一个生产者，拥有：双缓冲，即前缓冲和后缓冲。当然这属于是软件绘制中的双缓冲。</p>
<p>双缓冲简单来说就是一个缓冲区存储的数据用来前台展示，另外一个缓冲区用于在后台生产数据。等到Vsync信号来临时，交换两个缓冲区。这样可以避免帧撕裂，以及是的交互显示更加流畅。Android后续还出了一个三缓冲。</p>
<h4 id="disconnnect"><a href="#disconnnect" class="headerlink" title="disconnnect"></a>disconnnect</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Surface::disconnect</span><span class="params">(<span class="type">int</span> api, IGraphicBufferProducer::DisconnectMode mode)</span> </span>&#123;</span><br><span class="line">  <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">  mRemovedBuffers.<span class="built_in">clear</span>();</span><br><span class="line">  mSharedBufferSlot = BufferItem::INVALID_BUFFER_SLOT;</span><br><span class="line">  mSharedBufferHasBeenQueued = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 将内部数据都清除</span></span><br><span class="line">  <span class="built_in">freeAllBuffers</span>();</span><br><span class="line">  <span class="comment">// 通知BufferQueue，将该生产者从 BufferQueue 中断开</span></span><br><span class="line">  <span class="type">int</span> err = mGraphicBufferProducer-&gt;<span class="built_in">disconnect</span>(api, mode);</span><br><span class="line">  <span class="comment">// 清除其他数据</span></span><br><span class="line">  <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    mReqFormat = <span class="number">0</span>;</span><br><span class="line">    mReqWidth = <span class="number">0</span>;</span><br><span class="line">    mReqHeight = <span class="number">0</span>;</span><br><span class="line">    mReqUsage = <span class="number">0</span>;</span><br><span class="line">    mCrop.<span class="built_in">clear</span>();</span><br><span class="line">    mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;</span><br><span class="line">    mTransform = <span class="number">0</span>;</span><br><span class="line">    mStickyTransform = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (api == NATIVE_WINDOW_API_CPU) &#123;</span><br><span class="line">      mConnectedToCpu = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和前面的 connect 方法相对应。不再细述。</p>
<h3 id="Surface-java"><a href="#Surface-java" class="headerlink" title="Surface.java"></a>Surface.java</h3><p>代码比较长，这里就不贴上来了，还是按照之前的流程，先看看其内部定义的属性：</p>
<p>① mNativeObject ： 看到这个命名是不是觉得很熟悉，前面的 SurfaceSession 、SurfaceControl 中都有类似的。而这里它的用处类似，同样是用来存储着当前 Surface.java 所对应的Native层对象实例，实际是 Surface.cpp 实例。</p>
<p>② mLockedObject：调用 Surface.java 的 lockCanvas方法时，会在Native层完成相关操作，最后返回一个 Surface.cpp 实例，而这个Surface.cpp 实例其实就是上面的 mNativeObject 中的 Surface.cpp 实例，具体详见后续分析。</p>
<p>③mGenerationId：当前Surface.java 中mNativeObject的版本号，每次 mNativeObject 的值发生变化时，都会将其自增1。</p>
<p>④mCanvas：Canvas.java 对象实例，在一开始就就会为当前 mCanvas 赋值并且后期不会变，变得只是其Native层。</p>
<p>接下来看其关键方法的实现：</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.view.Surface.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用  SurfaceControl 来初始化 Surface</span></span><br><span class="line"><span class="comment"> * 重点分析该方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Surface</span><span class="params">(<span class="meta">@NonNull</span> SurfaceControl from)</span> &#123;</span><br><span class="line">    copyFrom(from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用  SurfaceTexture 来初始化 Surface</span></span><br><span class="line"><span class="comment"> * 可以先不考虑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Surface</span><span class="params">(SurfaceTexture surfaceTexture)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (surfaceTexture == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;surfaceTexture must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mIsSingleBuffered = surfaceTexture.isSingleBuffered();</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mName = surfaceTexture.toString();</span><br><span class="line">        setNativeObjectLocked(nativeCreateFromSurfaceTexture(surfaceTexture));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Surface</span><span class="params">(<span class="type">long</span> nativeObject)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        setNativeObjectLocked(nativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFrom</span><span class="params">(SurfaceControl other)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;other must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到 surfaceControl 中的 native SurfaceControl 对象实例</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">surfaceControlPtr</span> <span class="operator">=</span> other.mNativeObject;</span><br><span class="line">    <span class="keyword">if</span> (surfaceControlPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(</span><br><span class="line">                <span class="string">&quot;null SurfaceControl native object. Are you using a released SurfaceControl?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用到 android_view_Surface.cpp # nativeGetFromSurfaceControl 方法中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">newNativeObject</span> <span class="operator">=</span> nativeGetFromSurfaceControl(mNativeObject, surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的 NativeObject 和旧的作比较，如果发生变化则需要将旧的释放掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newNativeObject == mNativeObject) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将从 SurfaceControl 中读取出来的 native Surface 实例赋值给 mNativeObject</span></span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>z在 Surface.java 中有三个构造方法，分别使用： SurfaceControl 、SurfaceTexture以及直接使用一个 nativeObject 来初始化Surface。当然这三个的原理都是一样的，就是取到 Surface.cpp 实例。这里只分析 SurfaceControl 的情况。</p>
<p>使用 SurfaceControl.java 来初始化 Surface.java 实例时，主要逻辑都在：copyFrom() 中。</p>
<p>在 copyFrom() 方法中，首先会检查入参 SurfaceControl.java 的合法性，然后调用 Native 的 nativeGetFromSurfaceControl() 方法来创建一个 Surface.cpp 实例。在调用该方法是，传入的是 SurfaceControl中的 mNativeObject 属性值，该属性值在前面讲过了，对应的是一个 SurfaceControl.cpp 实例。</p>
<p>该Native方法位于：android_view_Surface.cpp 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeGetFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong nativeObject,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入下来的 nativeObject 对应的是 Surface.mNativeObject</span></span><br><span class="line">    <span class="function">Surface* <span class="title">self</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line">    <span class="comment">// surfaceControlNativeObj 对应的是 SurfaceControl.mNativeObject</span></span><br><span class="line">    <span class="function">sp&lt;SurfaceControl&gt; <span class="title">ctrl</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Surface 和 SurfaceControl 中的生产者是同一个，那么就不需要再创建新的 Surface 了，直接返回原来的 nativeObject 即可</span></span><br><span class="line">    <span class="keyword">if</span> (self != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">            IInterface::<span class="built_in">asBinder</span>(self-&gt;<span class="built_in">getIGraphicBufferProducer</span>()) ==</span><br><span class="line">            IInterface::<span class="built_in">asBinder</span>(ctrl-&gt;<span class="built_in">getIGraphicBufferProducer</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> nativeObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 SurfaceControl 来创建 Surface 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(ctrl-&gt;getSurface())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        surface-&gt;<span class="built_in">incStrong</span>(&amp;sRefBaseOwner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新创建的 Surface 实例返回出去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(surface.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceControl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">SurfaceControl::getSurface</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">// 第一次的时候，会调用  SurfaceControl::generateSurfaceLocked</span></span><br><span class="line">    <span class="keyword">if</span> (mSurfaceData == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generateSurfaceLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;Surface&gt; <span class="title">SurfaceControl::generateSurfaceLocked</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用 mGraphicBufferProducer 来创建 Surface 对象实例</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> <span class="built_in">Surface</span>(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，首先会将Java 层传递下来的属性转换为Native层的对象来使用，比如：</p>
<p>①传入的 nativeObject ，它对应的是 Surface.mNativeObject 的值，在Native层对应的是 Surface.cpp 实例，当然第一次它是空的。</p>
<p>②传入的 surfaceControlNativeObj ，它对应的是 SurfaceControl.mNativeObject 的值，在Native层对应的是SurfaceControl.cpp 实例，它一般此时是不为空的。</p>
<p>然后会判断下两者内部的生产者实例是否是同一个，是的话则表示他俩对应的是同一个生产消费者队列，此时不需要额外再操作直接返回原nativeObject即可。</p>
<p>当然如果这俩生产者不一致，那么此时会调用 SurfaceControl.cpp 的 getSurface() 方法来创建一个新的 Surface。在创建该新 Surface 时，实际只是用到了该 SurfaceControl 中的 生产者Producer 实例。</p>
<p>最后将这个新创建出来的 Surface 返回出去。</p>
<p>接下来回到上层，会判断返回的这个值是否和 Surface.java 中的 mNativeObject 是一样的，是一样的话则不做其他操作，否则会将旧的 mNativeObject 释放掉，并将新的值赋值给它。</p>
<p>至此我们可以知道，Surface.java 实例会对应着一个 Native 层的 Surface.cpp 实例，而这个 Surface.cpp 实例中最主要的是封装了一个 生产者实例，比如 BufferQueueProducer 。因此只要有生产者实例，比如 BufferQueueProducer ，就可以完成Surface.cpp 甚至于 Surface.java 的创建。因此对于Surface.java 来说，它的那些构造方法传入的不同类型的实例，都是用来提供这个生产者实例的。</p>
<h4 id="lockCanvas"><a href="#lockCanvas" class="headerlink" title="lockCanvas"></a>lockCanvas</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.view.Surface.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Canvas <span class="title function_">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span><br><span class="line">            <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        checkNotReleasedLocked();</span><br><span class="line">        <span class="comment">// 不能重复调用当前方法</span></span><br><span class="line">        <span class="keyword">if</span> (mLockedObject != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Surface was already locked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * mNativeObject : 当前 Surface 对应的 native 层 Surface 对象指针地址</span></span><br><span class="line"><span class="comment">         * mCanvas       : Surface 实例创建时，会自动创建一个 Canvas</span></span><br><span class="line"><span class="comment">         * inOutDirty    : 重绘区域，可能会为 null ，表示整个Surface都需要被刷新重绘</span></span><br><span class="line"><span class="comment">         * 返回值实际是入参 mNativeObject， 但是 native 层会将其转存一下的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">        <span class="keyword">return</span> mCanvas;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法类似于前面讲到的 Surface.cpp 中的 lock() 方法。</p>
<p>比如一开始会检查 mLockedObject 的值，如果它不为空表示刚刚调用过当前方法了，不能再次重复调用。</p>
<p>接着将最主要的逻辑扔到 Native 层去完成了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 将上层 Surface 对象中的 mNativeObject  转换为 native 层的 Surface 对象实例</span></span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line">    <span class="comment">// 判断入参 Surface 对象是否是可用的。主要判断其内部是否存在 GraphicBufferProducer</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isSurfaceValid</span>(surface)) &#123;</span><br><span class="line">        <span class="built_in">doThrowIAE</span>(env);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ANativeWindow_getFormat 最终会调用到 Surface#query 中去，去查找 NATIVE_WINDOW_FORMAT 对应的值</span></span><br><span class="line">    <span class="comment">// 然后通过 convertPixelFormat 方法来将 PixelFormat 转换映射为 SkColorType</span></span><br><span class="line">    <span class="comment">// 如果设置的 format 不对，或者没有设置，则这里会设置为 PIXEL_FORMAT_RGBA_8888</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">convertPixelFormat</span>(<span class="built_in">ANativeWindow_getFormat</span>(surface.<span class="built_in">get</span>())) == kUnknown_SkColorType) &#123;</span><br><span class="line">        <span class="built_in">native_window_set_buffers_format</span>(surface.<span class="built_in">get</span>(), PIXEL_FORMAT_RGBA_8888);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">    Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上层传入的 Rect dirty 不为空，则这里拿到其对应的坐标并且保存到 dirtyRectPtr 中</span></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        dirtyRect.left   = env-&gt;<span class="built_in">GetIntField</span>(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">        dirtyRect.top    = env-&gt;<span class="built_in">GetIntField</span>(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">        dirtyRect.right  = env-&gt;<span class="built_in">GetIntField</span>(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">        dirtyRect.bottom = env-&gt;<span class="built_in">GetIntField</span>(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">        dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    <span class="comment">// 通过 Surface lock 来申请 dequeue 一个 GraphicBuffer ，将其内部像素值等锁起来，将其相关值赋值给入参 outBuffer</span></span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">lock</span>(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">    <span class="comment">// lock 失败了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> exception = (err == NO_MEMORY) ?</span><br><span class="line">                OutOfResourcesException :</span><br><span class="line">                <span class="string">&quot;java/lang/IllegalArgumentException&quot;</span>;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, exception, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用返回值 outBuffer 中的属性来创建 SkImageInfo</span></span><br><span class="line">    SkImageInfo info = SkImageInfo::<span class="built_in">Make</span>(outBuffer.width, outBuffer.height,</span><br><span class="line">                                         <span class="built_in">convertPixelFormat</span>(outBuffer.format),</span><br><span class="line">                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888</span><br><span class="line">                                                 ? kOpaque_SkAlphaType : kPremul_SkAlphaType);</span><br><span class="line"></span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    <span class="type">ssize_t</span> bpr = outBuffer.stride * <span class="built_in">bytesPerPixel</span>(outBuffer.format);</span><br><span class="line">    bitmap.<span class="built_in">setInfo</span>(info, bpr);</span><br><span class="line">    <span class="comment">// 如果 outBuffer 的宽高是合法的，那么将其赋值给 bitmap</span></span><br><span class="line">    <span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bitmap.<span class="built_in">setPixels</span>(outBuffer.bits);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">        bitmap.<span class="built_in">setPixels</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到 Java层传下来的 Canvas 对象中所对应的 native 层的 Canvas 对象实例</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::<span class="built_in">getNativeCanvas</span>(env, canvasObj);</span><br><span class="line">    <span class="comment">// 将该 canvas 和 bitmap 绑定起来</span></span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">setBitmap</span>(bitmap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirtyRectPtr 中存储的是上层传下来的 Rect dirty 中的坐标信息，如果上层传null下来的话则 dirtyRectPtr 也是null</span></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">        nativeCanvas-&gt;<span class="built_in">clipRect</span>(dirtyRect.left, dirtyRect.top,</span><br><span class="line">                dirtyRect.right, dirtyRect.bottom, SkClipOp::kIntersect);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">        env-&gt;<span class="built_in">SetIntField</span>(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是该 Surface ，但是使用另外一个属性中转一下，方式和外部的 mNativeObject 一样了</span></span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">lockedSurface</span><span class="params">(surface)</span></span>;</span><br><span class="line">    lockedSurface-&gt;<span class="built_in">incStrong</span>(&amp;sRefBaseOwner);</span><br><span class="line">    <span class="keyword">return</span> (jlong) lockedSurface.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isSurfaceValid</span><span class="params">(<span class="type">const</span> sp&lt;Surface&gt;&amp; sur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Surface::<span class="built_in">isValid</span>(sur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Surface.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">const</span> sp&lt;Surface&gt; &amp;surface)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主要是 Surface 内部的生产者要是不为空，那么就表示该 Surface 合法可用</span></span><br><span class="line">    <span class="keyword">return</span> surface != <span class="literal">nullptr</span> &amp;&amp; surface-&gt;<span class="built_in">getIGraphicBufferProducer</span>() != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前方法中，会首先将上层传下来的 mNativeObject 转为 Surface.cpp 来使用，接着会调用其 lock() 方法来出队一个 GraphicBuffer ，并将其 lockAsync 住，也就是方式该 GraphicBuffer 被其他生产者使用。</p>
<p>接着使用该 GraphicBuffer 的宽高格式来构建一个  SkBitmap ，将该 Bitmap 设置给上层传入下来的 Canvas 。后续使用该 Canvas 绘制的内容就都会存储在该 Bitmap 中，也就是该 GraphicBuffer 中。</p>
<blockquote>
<p>Canvas 像是一个画笔，Bitmap相当于是画布，用来存储画笔绘制的内容。</p>
</blockquote>
<p>最后将该 Surface 转存到新的属性中返回出去。</p>
<p>外部拿到该返回值，会将其保存到 mLockedObject 属性中。最后将当前 mCanvas 返回出去。外部拿到这个 Canvas 就可以绘制内容了。</p>
<p>那么后续你再调用当前 lockCanvas 方法时就会抛出异常，因此下一步你应该调用的是：unlockCanvasAndPost 方法。</p>
<h4 id="unlockCanvasAndPost"><a href="#unlockCanvasAndPost" class="headerlink" title="unlockCanvasAndPost"></a>unlockCanvasAndPost</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.view.Surface.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mHwuiContext 是 lockHardwareCanvas 方法调用时才会初始化</span></span><br><span class="line">        <span class="comment">// 这里先不考虑</span></span><br><span class="line">        <span class="keyword">if</span> (mHwuiContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 如果之前是调用的 lockCanvas 的话，则会执行到这里</span></span><br><span class="line">            unlockSwCanvasAndPost(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlockSwCanvasAndPost</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果提交的 canvas 不是当前 Surface lockCanvas 返回出去的那个</span></span><br><span class="line">    <span class="keyword">if</span> (canvas != mCanvas) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;canvas object must be the same instance that &quot;</span></span><br><span class="line">                + <span class="string">&quot;was previously returned by lockCanvas&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前 mNativeObject 和上次 lockCanvas 时返回的是不一样的，一般是一样的</span></span><br><span class="line">    <span class="keyword">if</span> (mNativeObject != mLockedObject) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;WARNING: Surface&#x27;s mNativeObject (0x&quot;</span> +</span><br><span class="line">                Long.toHexString(mNativeObject) + <span class="string">&quot;) != mLockedObject (0x&quot;</span> +</span><br><span class="line">                Long.toHexString(mLockedObject) +<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有调用过 lockCanvas 方法</span></span><br><span class="line">    <span class="keyword">if</span> (mLockedObject == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Surface was not locked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用到 native 层来提交当前已经绘制了的内容</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 将 mLockedObject 释放掉，其实就是将其引用减少1</span></span><br><span class="line">        nativeRelease(mLockedObject);</span><br><span class="line">        mLockedObject = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面调用的是 lockCanvas() 方法来申请并锁定了一块儿区域给 mCanvas 来使用，外部调用者拿到 lockCanvas 方法返回的 Canvas 来进行后续的绘制工作，绘制完成之后调用当前方法来将该 Canvas 绘制的东西提交进生产消费队列中等待消费者去消费。</p>
<p>因此在该方法一开始就是校验参数是否合法，比如入参 canvas等。最后回调用 Native 层的 nativeUnlockCanvasAndPost 方法来完成真正的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_Surface.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line">    <span class="comment">// 该 surface 是否还可用</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isSurfaceValid</span>(surface)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到上层 Canvas 所对应的 native 层 Canvas 对象实例</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::<span class="built_in">getNativeCanvas</span>(env, canvasObj);</span><br><span class="line">    <span class="comment">// 将其内部对应的 Bitmap 重置掉</span></span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">setBitmap</span>(<span class="built_in">SkBitmap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 surface 提交上次 buffer 内容</span></span><br><span class="line">    <span class="type">status_t</span> err = surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">doThrowIAE</span>(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，首先会将 Canvas 中的 Bitmap 给重置掉，后续使用该 Canvas 再去绘制内容就不会存到之前的 GraphicBuffer 中了。</p>
<p>接着调用 Surface.cpp 的 unlockAndPost 方法来将其内部的 mLockedBuffer 提交到 BufferQueue 中，等待消费者去消费。而这个 mLockedBuffer 中存储的数据就是上层生产者使用Canvasl刚绘制好的数据内容。</p>
<p>最后回到Java层，会将 mLockedObject 释放并重置掉。</p>
<p>小结：Surface 是一个生产者，它内部有对应的生产者实例，上层可以通过他来获取一个 Canvas 实例，再使用该 Canvas 去绘制内容，也就是生产待消费的数据。完事之后会将其提交到该生产者实例所对应的生产消费队列中去，等待消费者去消费。而具体的消费者是哪个呢？怎么指定呢？</p>
<p>想要看消费者，可以从生产者下手，因为生产者和消费者是成对出现的。比如当通过 SurfaceControl 来创建 Surface 时，其内部的生产者所对应的消费者一般就是 BufferQueueLayer 中的消费者。如果这俩产生关联的话，后续通过 Surface 生产的数据就会到 BufferQueueLayer 中去消费。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/Surface/">Surface</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/6d1e424c.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Jetpack- ViewModel</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/25fde216.html">
        <span class="next-text nav-default">Surface学习(二)--Layer简介</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
