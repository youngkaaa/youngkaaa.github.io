<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Jetpack- Lifecycle"/>




  <meta name="keywords" content="Jetpack," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/8dd4bfe0.html"/>


<meta name="description" content="生命周期，顾名思义就是其从生到死的一个周期过程。 在代码世界中也同样存在这样的概念，比如前端 React component中的生命周期；后端Servlet 的生命周期，或者更广泛些吧，在JVM中存在的类Class 也都存在自己对应的生命周期。 而在Android中的许多类也都有它自己的生命周期，比如常见的Activity，它主要负责Android中 Window View 的展示处理，它可以简单">
<meta property="og:type" content="article">
<meta property="og:title" content="Jetpack- Lifecycle">
<meta property="og:url" content="https://youngkaaa.github.io/8dd4bfe0.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="生命周期，顾名思义就是其从生到死的一个周期过程。 在代码世界中也同样存在这样的概念，比如前端 React component中的生命周期；后端Servlet 的生命周期，或者更广泛些吧，在JVM中存在的类Class 也都存在自己对应的生命周期。 而在Android中的许多类也都有它自己的生命周期，比如常见的Activity，它主要负责Android中 Window View 的展示处理，它可以简单">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-01T02:48:56.000Z">
<meta property="article:modified_time" content="2023-01-06T13:10:52.780Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Jetpack">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Jetpack- Lifecycle - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Jetpack- Lifecycle
        
      </h1>

      <time class="post-time">
          7月 01 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>生命周期，顾名思义就是其从生到死的一个周期过程。</p>
<p>在代码世界中也同样存在这样的概念，比如前端 React component中的生命周期；后端Servlet 的生命周期，或者更广泛些吧，在JVM中存在的类Class 也都存在自己对应的生命周期。</p>
<p>而在Android中的许多类也都有它自己的生命周期，比如常见的Activity，它主要负责Android中 Window View 的展示处理，它可以简单理解为：是官方封装好的用于展示页面的类，借助它可以很方便的展示页面。</p>
<p>关于Activity 的生命周期有哪些，怎么用，Android开发人员基本都清楚，这里不再赘述。本文主要讲解Jetpack Lifecycle库的原理。对它的更多解释和使用方法详见官方：<a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/architecture/lifecycle">https://developer.android.com/topic/libraries/architecture/lifecycle</a></p>
<h3 id="基础类"><a href="#基础类" class="headerlink" title="基础类"></a>基础类</h3><h4 id="androidx-lifecycle-LifecycleOwner"><a href="#androidx-lifecycle-LifecycleOwner" class="headerlink" title="androidx.lifecycle.LifecycleOwner"></a>androidx.lifecycle.LifecycleOwner</h4><p>这是一个接口，用于提供 Lifecycle 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.lifecycle.LifecycleOwner</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LifecycleOwner</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the Lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The lifecycle of the provider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    Lifecycle <span class="title function_">getLifecycle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当某个类，或者说是某种类型支持生命周期这种概念时，便可以实现该接口并返回一个 Lifecycle 实例，调用方拿到这个 Lifecycle 实例之后，就可以监控其生命周期的变化了。</p>
<p>比如Activity，它自身具有生命周期，那么就可以让它来实现该接口，然后返回一个 Lifecycle 实例，开发者就拿到其实例之后就可以观察其生命周期变化了。</p>
<p>而本文讲的Jetpack Lifecycle 库便是Google 官方对Activity的一种实现。</p>
<h4 id="androidx-lifecycle-Lifecycle"><a href="#androidx-lifecycle-Lifecycle" class="headerlink" title="androidx.lifecycle.Lifecycle"></a>androidx.lifecycle.Lifecycle</h4><p>用于处理生命周期的抽象类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.lifecycle.Lifecycle</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lifecycle coroutines extensions stashes the CoroutineScope into this field.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    AtomicReference&lt;Object&gt; mInternalScopeRef = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds a LifecycleObserver that will be notified when the LifecycleOwner changes</span></span><br><span class="line"><span class="comment">     * state.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The given observer will be brought to the current state of the LifecycleOwner.</span></span><br><span class="line"><span class="comment">     * For example, if the LifecycleOwner is in &#123;<span class="doctag">@link</span> State#STARTED&#125; state, the given observer</span></span><br><span class="line"><span class="comment">     * will receive &#123;<span class="doctag">@link</span> Event#ON_CREATE&#125;, &#123;<span class="doctag">@link</span> Event#ON_START&#125; events.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer The observer to notify.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the given observer from the observers list.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If this method is called while a state change is being dispatched,</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;If the given observer has not yet received that event, it will not receive it.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;If the given observer has more than 1 method that observes the currently dispatched</span></span><br><span class="line"><span class="comment">     * event and at least one of them received the event, all of them will receive the event and</span></span><br><span class="line"><span class="comment">     * the removal will happen afterwards.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer The observer to be removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current state of the Lifecycle.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The current state of the Lifecycle.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title function_">getCurrentState</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lifecycle states. You can consider the states as the nodes in a graph and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Event&#125;s as the edges between these nodes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lifecycle 抽象类中主要有如下几点需要关注：</p>
<p>1、AtomicReference<Object> mInternalScopeRef ：用来存储 LifecycleCoroutineScope 实例的，即为 lifecycleScope 协程域服务的。关于 lifecycleScope 协程域相关的可以看看 [TODO] 协程相关的文章。</p>
<p>2、addObserver ：该方法为该Lifecycle注册观察者，这样的话后续其生命周期变化时，观察者就可以收到通知了。</p>
<p>3、removeObserver ：该方法从该Lifecycle中移除之前注册的观察者。</p>
<p>4、getCurrentState ：获取当前Lifecycle 所处的生命周期状态。返回类型是 State。</p>
<p>而该 Lifecycle 抽象类的具体实现主要是：androidx.lifecycle.LifecycleRegistry 。而一个 Activity 中只有一个 LifecycleRegistry 实例(原因后面会讲)，所以说一个Activity 中只有一个 Lifecycle 实例。这个 Lifecycle 实例就代表了这个 Activity 的生命周期，Activity 生命周期变化了，那么 Lifecycle 中的State状态就同步发生变化，并且通知给所有的观察者，这样就完成了生命周期的监测和通知。</p>
<h4 id="androidx-lifecycle-Lifecycle-State-amp-androidx-lifecycle-Lifecycle-Event"><a href="#androidx-lifecycle-Lifecycle-State-amp-androidx-lifecycle-Lifecycle-Event" class="headerlink" title="androidx.lifecycle.Lifecycle.State&amp;androidx.lifecycle.Lifecycle.Event"></a>androidx.lifecycle.Lifecycle.State&amp;androidx.lifecycle.Lifecycle.Event</h4><p>这俩类都是枚举，由于比较简单就放在一起了。</p>
<p>Event 代表的是Activity中每个生命周期值，比如 onCreate() 时对应的是Event.ON_CREATE ，其他类似。</p>
<p>State 代表的是该 Lifecycle 实例所对应的Activity 当前所处的生命周期状态，即：</p>
<p>State.DESTROYED：表示该 Lifecycle对应的对象即将要销毁、结束了。比如对于Activity 来说的话就是其 onDestroy() 方法即将调用时，其对应 Lifecycle 状态会被置为 DESTROYED。这个状态是该Lifecycle的最后一个状态了，该状态之后就不会再给观察者分发其他状态了，因为这个对象生命周期已经终止了。</p>
<p>State.INITIALIZED：表示该 Lifecycle对应的对象目前处于刚实例化但未初始化状态。比如对于Activity 来说的话就是其 onCreate() 方法都还没调用时，其状态就是INITIALIZED。</p>
<p>State.CREATED：表示该 Lifecycle对应的对象目前处于已初始化状态。比如对于Activity 来说的话就是其 onCreate() 方法调用之后，或者其 onStop() 方法调用之前，其状态就是CREATED。</p>
<p>State.STARTED：表示该 Lifecycle对应的对象目前处于已开始状态。比如对于Activity 来说的话就是其 onStart() 方法调用之后，或者其 onPause() 方法调用之前，其状态就是STARTED。</p>
<p>State.RESUMED：表示该 Lifecycle对应的对象目前处于使用中状态。比如对于Activity 来说的话就是其 onResume() 方法调用之后，其状态就是STARTED。</p>
<p>上面解释的CREATED、STARTED 状态不太好理解。比如对于STARTED 来说，什么叫：onStart() 方法调用之后，或者其 onPause() 方法调用之前。其实如果把Activity 的生命周期看做是从头到尾的一整个过程的话，Activity 要不从一开始的 onCreate 一直到 onResume 展示出来，这种方向是往后。或者从后往前，比如Activity销毁，从onResume 一直到 onDestroy。</p>
<p>那么当从前往后时，刚开始 Activity 处于刚被反射创建出来的实例，此时其内部的 LifecycleRegistry 成员变量实例也被创建出来，同时会给其内部的 mState 赋初始值 INITIALIZED ，接着 Activity 被 AMS 调度执行 onCreate() 方法，此时其内部的状态变成了CREATED，接着Activity 执行 obStart() 方法，此时其内部的状态变成了 STARTED；接着Activity 执行 onResume() 方法，此时其内部的状态变成了RESUMED,这个过程便是从前往后的过程。</p>
<p>等到Activity要退出时，也就是从后往前时，此时Activity 处于之前的RESUMED状态。往后会执行其 onPause() 方法，此时其内部的状态变成了STARTED；接着会执行其 onStop() 方法，此时其内部的状态变成了CREATED；最后会执行其 onDestroy() 方法，此时其内部的状态变成了DESTROYED。</p>
<p>Event 和 State 的关系如上，懂了这个关系之后，Lifecycle.Event中的 downFrom() 、downTo() 等方法，以及LifecycleRegistry中的 getStateAfter() 、downEvent() 等方法就很好理解了吧。</p>
<p>这里将 State 分为这几个状态之后，后续的其他逻辑就会方便些，比如判断Adtivity当前是否处于活跃态，那么只需要判断其 State 是否大于 STARTED ，因为 State 这些是枚举，所以可以直接比较大小，很方便。</p>
<p>另外额外需要补充的两点：</p>
<p>1、Event.ON_CREATE 、Event.ON_START 以及 Event.ON_RESUME 事件是发生在对应Activity 生命周期方法【之后】的。比如对于Event.ON_START 来说，它发生在 Activity.onStart() 方法之后。</p>
<p>2、Event.ON_PAUSE 、Event.ON_STOP 以及 Event.ON_DESTROY 事件是发生在对应Activity 生命周期方法【之前】的。比如对于Event.ON_STOP 来说，它发生在 Activity.onStop() 方法之前。</p>
<h4 id="androidx-lifecycle-LifecycleObserver"><a href="#androidx-lifecycle-LifecycleObserver" class="headerlink" title="androidx.lifecycle.LifecycleObserver"></a>androidx.lifecycle.LifecycleObserver</h4><p>它只是一个空接口。而对于它的用法有两种，</p>
<p>1、使用其子类接口，比如 FullLifecycleObserver或者 LifecycleEventObserver等。当然还有其他的，这里只列举这俩。</p>
<p>2、直接实现 LifecycleObserver 接口，此时它起到标记的作用，然后内部使用注解 OnLifecycleEvent 来标记对应的方法。当然这种方式官方不推荐，推荐使用第一种。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>这得从 androidx.activity.ComponentActivity 开始了。它向上继承自 androidx.core.app.ComponentActivity ，进而继承自 Activity。而下的子类是androidx.fragment.app.FragmentActivity ,再往下就是常见的androidx.appcompat.app.AppCompatActivity 了。所以说，我们日常写的Activity 实例基本上都 是androidx.activity.ComponentActivity的子类</p>
<blockquote>
<p>这里有两个 ComponentActivity ：androidx.activity.ComponentActivity 和 androidx.core.app.ComponentActivity 。前者是androidx Activity 的，也就是我们常用的androidx 项目。后者是一个使用@hide修饰的隐藏的类，它的作用是为了为兼容以前的老版本的，可以不用考虑。</p>
<p>后面讲的ComponentActivity 表示的都是前者。</p>
</blockquote>
<p>在 ComponentActivity 中实现了 LifecycleOwner 接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComponentActivity</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">LifecycleRegistry</span> <span class="variable">mLifecycleRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LifecycleRegistry</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Lifecycle <span class="title function_">getLifecycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其 getLifecycle() 方法实现中直接返回了其成员属性实例mLifecycleRegistry，它是一个 LifecycleRegistry 实例，而该类是 Lifecycle 抽象类的主要实现者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LifecycleRegistry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifecycleRegistry</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOG_TAG</span> <span class="operator">=</span> <span class="string">&quot;LifecycleRegistry&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Custom list that keeps observers and can handle removals / additions during traversal.</span></span><br><span class="line"><span class="comment">     * Invariant: at any moment of time for observer1 &amp; observer2:</span></span><br><span class="line"><span class="comment">     * if addition_order(observer1) &lt; addition_order(observer2), then</span></span><br><span class="line"><span class="comment">     * state(observer1) &gt;= state(observer2),</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = <span class="keyword">new</span> <span class="title class_">FastSafeIterableMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Current state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> State mState;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The provider that owns this Lifecycle.</span></span><br><span class="line"><span class="comment">     * Only WeakReference on LifecycleOwner is kept, so if somebody leaks Lifecycle, they won&#x27;t leak</span></span><br><span class="line"><span class="comment">     * the whole Fragment / Activity. However, to leak Lifecycle object isn&#x27;t great idea neither,</span></span><br><span class="line"><span class="comment">     * because it keeps strong references on all other listeners, so you&#x27;ll leak all of them as</span></span><br><span class="line"><span class="comment">     * well.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">     <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new LifecycleRegistry for the given provider.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * You should usually create this inside your LifecycleOwner class&#x27;s constructor and hold</span></span><br><span class="line"><span class="comment">     * onto the same instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> provider The owner LifecycleOwner</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifecycleRegistry</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner provider)</span> &#123;</span><br><span class="line">        mLifecycleOwner = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(provider);</span><br><span class="line">        mState = INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其内部有如下属性：</p>
<p>1、mObserverMap ：用来存储通过 addObserver()添加注册的那些观察者们，等待后面生命周期发生变化时，会从中找到他们并开始遍历回调通知他们。</p>
<p>2、mState ：该 Lifecycle 当前所处的状态，即该 Lifecycycle 所对应 Activity 当前所处的状态</p>
<p>3、mLifecycleOwner ： 该 Lifecycle 所对应的 LifecycleOwner实例，其实就是对应的 Activity 实例。</p>
<p>另外它的构造方法外部在 ComponentActivity 中传入的是this，也就是 ComponentActivity自身，在 LifecycleRegistry 构造方法中会对其进行保存，以及 mState 的初始化。</p>
<p>接着回到 ComponentActivity  中，当执行到它的 onCreate() 方法时，会调用：ReportFragment.injectIfNeededIn(this); 来完成其生命周期的监听注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReportFragment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReportFragment</span> <span class="keyword">extends</span> <span class="title class_">android</span>.app.Fragment &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REPORT_FRAGMENT_TAG</span> <span class="operator">=</span> <span class="string">&quot;androidx.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 ComponentActivity # onCreate 方法中调用，用来add一个 ReportFragment 到 ComponentActivity中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">injectIfNeededIn</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">        <span class="comment">// API&gt;29时，注册 ActivityLifecycleCallbacks，该方法是29新增的</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="comment">// On API 29+, we can register for the correct Lifecycle callbacks directly</span></span><br><span class="line">            LifecycleCallbacks.registerIn(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Prior to API 29 and to maintain compatibility with older versions of</span></span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and</span></span><br><span class="line">        <span class="comment">// need to support activities that don&#x27;t extend from FragmentActivity from support lib),</span></span><br><span class="line">        <span class="comment">// use a framework fragment to get the correct timing of Lifecycle events</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 所有的API版本都增加 ReportFragment ，为了兼容性，因为可能有些业务用到了 ReportFragment ，不同API版本要保持一致</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        android.app.<span class="type">FragmentManager</span> <span class="variable">manager</span> <span class="operator">=</span> activity.getFragmentManager();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 避免重复添加 fragment</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="literal">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> <span class="title class_">ReportFragment</span>(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LifecycleCallbacks</span> <span class="keyword">implements</span> <span class="title class_">Application</span>.ActivityLifecycleCallbacks &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerIn</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">            activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> <span class="title class_">LifecycleCallbacks</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@Nullable</span> Bundle bundle)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 表示在API29及其之后，是在onCreate()方法之后回调的 ON_CREATE 事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">            dispatch(activity, Lifecycle.Event.ON_CREATE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 表示在API29及其之后，是在 onStart()方法之后回调的 ON_START 事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">            dispatch(activity, Lifecycle.Event.ON_START);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 表示在API29及其之后，是在 onResume()方法之后回调的 ON_RESUME 事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">            dispatch(activity, Lifecycle.Event.ON_RESUME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 表示在API29及其之后，是在 onPause()方法之前回调的 ON_PAUSE 事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPrePaused</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">            dispatch(activity, Lifecycle.Event.ON_PAUSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPaused</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 表示在API29及其之后，是在 onStop()方法之前回调的 ON_STOP 事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPreStopped</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">            dispatch(activity, Lifecycle.Event.ON_STOP);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityStopped</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivitySaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Bundle bundle)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 表示在API29及其之后，是在 onDestroy()方法之前回调的 ON_DESTROY 事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPreDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">            dispatch(activity, Lifecycle.Event.ON_DESTROY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 ReportFragment 是继承自 Fragment 的，在其  injectIfNeededIn() 方法中会根据当前Android版本来执行不同的操作：</p>
<p>1、所有的Android版本都会自动往其 FragmentManager 中注入一个 ReportFragment 空白 Fragment 实例，用来监听当前 ComponentActivity的生命周期</p>
<p>2、针对 API29及其之后的版本则会调用 activity.registerActivityLifecycleCallbacks() 方法来对当前 ComponentActivity 进行生命周期的监听；而</p>
<blockquote>
<p>这种注入空白 Fragment 的方式其实之前就有了，比如在Glide中就存在这种方式来实现对 Activity生命周期监听的策略。</p>
</blockquote>
<p>这里对于所有API 版本都注入ReportFragment ，是为了保证兼容性。但对于 API29及其之后的版本而言，其Activity 回调是从 registerActivityLifecycleCallbacks 中拿到的，而不是 ReportFragment ；之前的版本则只能从 ReportFragment 中获取了。</p>
<p>所以这里处理完成之后，就完成了 Lifecycle 初始准备工作，后续的就等 ReportFragment 或者 registerActivityLifecycleCallbacks 回调了。</p>
<h4 id="ReportFragment-生命周期回调"><a href="#ReportFragment-生命周期回调" class="headerlink" title="ReportFragment 生命周期回调"></a>ReportFragment 生命周期回调</h4><p>下面主要看 ReportFragment 逻辑，在 ReportFragment 类中，重写了 Fragment 中的生命周期方法，比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReportFragment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReportFragment</span> <span class="keyword">extends</span> <span class="title class_">android</span>.app.Fragment &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个可以忽略，目前没有用到 LifecycleRegistryOwner 的地方</span></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Activity 一般都是实现了 LifecycleOwner，比如 ComponentActivity</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            <span class="type">Lifecycle</span> <span class="variable">lifecycle</span> <span class="operator">=</span> ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调到LifecycleRegistry 中的 handleLifecycleEvent方法</span></span><br><span class="line"><span class="comment">             * LifecycleRegistry # handleLifecycleEvent</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReportFragment <span class="title function_">get</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ReportFragment) activity.getFragmentManager().findFragmentByTag(REPORT_FRAGMENT_TAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityInitializationListener mProcessListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchCreate</span><span class="params">(ActivityInitializationListener listener)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchStart</span><span class="params">(ActivityInitializationListener listener)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchResume</span><span class="params">(ActivityInitializationListener listener)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onResume();</span><br><span class="line">        dispatchResume(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onStop();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">        <span class="comment">// just want to be sure that we won&#x27;t leak reference to an activity</span></span><br><span class="line">        mProcessListener = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里过滤掉29及其以上的版本调用，因为29及其已上版本用的是 ActivityLifecycleCallbacks</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="comment">// Only dispatch events from ReportFragment on API levels prior</span></span><br><span class="line">            <span class="comment">// to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks</span></span><br><span class="line">            <span class="comment">// added in ReportFragment.injectIfNeededIn</span></span><br><span class="line">            dispatch(getActivity(), event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setProcessListener</span><span class="params">(ActivityInitializationListener processListener)</span> &#123;</span><br><span class="line">        mProcessListener = processListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">ActivityInitializationListener</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 Fragment 对应的生命周期方法中，会调用 dispatch() 方法来进行对应 Event 的分发，比如在其 onActivityCreated() 方法中会调用 dispatch(Event.ON_CREATE) ；在其 onStop() 方法中会调用 dispatch(Event.ON_STOP) 等</p>
<p>而到了 dispatch() 方法时，会过滤掉 API &gt;&#x3D;29 的调用，因为 API&gt;&#x3D;29 的情况是归 ActivityLifecycleCallbacks 来处理的。最终调用到两个参数的 dispatch(Activity , Lifecycle.Event) 方法中，完成真正的分发工作。</p>
<p>上面代码中的注释比较清晰了，在其内部分发时，首先通过传入的 Activity 拿到其 Lifecycle 实例，再将其强转成 LifecycleRegistry 再调用它的 handleLifecycleEvent() 方法中去。所以现在是将Event事件从 Fragment 中兜兜转转的传入到了 LifecycleRegistry中去。</p>
<h4 id="ActivityLifecycleCallbacks-生命周期回调"><a href="#ActivityLifecycleCallbacks-生命周期回调" class="headerlink" title="ActivityLifecycleCallbacks 生命周期回调"></a>ActivityLifecycleCallbacks 生命周期回调</h4><p>这种方式是API&gt;&#x3D;29时才会使用的，因为它是要借助 Activity.registerActivityLifecycleCallbacks() 方法，而该方法是 API29开始才有的。</p>
<p>下面具体看下其Callback实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LifecycleRegistry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LifecycleCallbacks</span> <span class="keyword">implements</span> <span class="title class_">Application</span>.ActivityLifecycleCallbacks &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerIn</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">        activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> <span class="title class_">LifecycleCallbacks</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@Nullable</span> Bundle bundle)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示在API29及其之后，是在onCreate()方法之后回调的 ON_CREATE 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示在API29及其之后，是在 onStart()方法之后回调的 ON_START 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示在API29及其之后，是在 onResume()方法之后回调的 ON_RESUME 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示在API29及其之后，是在 onPause()方法之前回调的 ON_PAUSE 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPrePaused</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPaused</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示在API29及其之后，是在 onStop()方法之前回调的 ON_STOP 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPreStopped</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityStopped</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivitySaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Bundle bundle)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示在API29及其之后，是在 onDestroy()方法之前回调的 ON_DESTROY 事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPreDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在Callback 方法中最终也是调用到两个参数的 dispatch(Activity , Lifecycle.Event) 方法中，完成真正的分发工作。</p>
<blockquote>
<p>额外需要关注的是 ON_CREATE 、ON_START 、ON_RESUME 这三个是在对应生命周期方法执行之后再执行的，从其被回调的系列方法 onActivityPostXXXX() 中就能看出。</p>
<p>另外其他几个状态是在其对应生命周期方法之前执行的，不再赘述。</p>
</blockquote>
<p>最终也还是调用到了 LifecycleRegistry 的 handleLifecycleEvent 方法中。</p>
<p>所以说，不管是ReportFragment 方式还是ActivityLifecycleCallbacks 方式，最终都是汇集到同一个方法去执行生命周期分发工作。</p>
<h4 id="LifecycleRegistry"><a href="#LifecycleRegistry" class="headerlink" title="LifecycleRegistry"></a>LifecycleRegistry</h4><p>前面的生命周期变化，最终都会通知到 LifecycleRegistry.handleLifecycleEvent() 方法中，在该方法中会完成生命周期的同步，即将新的生命周期同步给所有的观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LifecycleRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLifecycleEvent</span><span class="params">(<span class="meta">@NonNull</span> Event event)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据event值来计算返回当前event发生之后的状态</span></span><br><span class="line">    <span class="type">State</span> <span class="variable">next</span> <span class="operator">=</span> getStateAfter(event);</span><br><span class="line">    moveToState(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据event值来计算返回当前event发生之后的状态</span></span><br><span class="line"><span class="comment"> * 比如 ON_PAUSE 和 ON_START 执行之后，目前Activity就处于 STARTED 状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> State <span class="title function_">getStateAfter</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">        <span class="keyword">case</span> ON_STOP:</span><br><span class="line">            <span class="keyword">return</span> CREATED;</span><br><span class="line">        <span class="keyword">case</span> ON_START:</span><br><span class="line">        <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">            <span class="keyword">return</span> STARTED;</span><br><span class="line">        <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">            <span class="keyword">return</span> RESUMED;</span><br><span class="line">        <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">            <span class="keyword">return</span> DESTROYED;</span><br><span class="line">        <span class="keyword">case</span> ON_ANY:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unexpected event value &quot;</span> + event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改变当前状态到最新的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToState</span><span class="params">(State next)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前状态已经是next了，那就不需要任何操作直接返回吧</span></span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改mState</span></span><br><span class="line">    mState = next;</span><br><span class="line">    <span class="comment">// 如果当在正在处理之前的event事件，那么就先返回</span></span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandlingEvent = <span class="literal">true</span>; <span class="comment">// 开始处理</span></span><br><span class="line">    sync();</span><br><span class="line">    mHandlingEvent = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断当前是否已经同步过状态了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSynced</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mObserverMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mObserverMap中其实就是一个链表，拿到链表中第一个Observer，也就是最早添加的Observer中的状态</span></span><br><span class="line">    <span class="type">State</span> <span class="variable">eldestObserverState</span> <span class="operator">=</span> mObserverMap.eldest().getValue().mState;</span><br><span class="line">    <span class="comment">// mObserverMap中其实就是一个链表，拿到链表中最后一个Observer，也就是最晚添加的Observer中的状态</span></span><br><span class="line">    <span class="type">State</span> <span class="variable">newestObserverState</span> <span class="operator">=</span> mObserverMap.newest().getValue().mState;</span><br><span class="line">    <span class="comment">// 如果第一个和最后一个Observer中的状态是一样的，并且当前最新的状态mState等于它们，就表示已经同步过了不需要再次同步，否则返回false表示需要同步</span></span><br><span class="line">    <span class="keyword">return</span> eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ######### ######### onResume                       ----  RESUMED</span></span><br><span class="line"><span class="comment"> * ######### onStart            onStop                ----  STARTED</span></span><br><span class="line"><span class="comment"> * onCreate                            onDestroy      ----  CREATED</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 根据当前的state，降级一级返回对应的EVENT</span></span><br><span class="line"><span class="comment"> * 比如当前是CREATED状态，up的话，就是onStart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Event <span class="title function_">upEvent</span><span class="params">(State state)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">        <span class="keyword">case</span> DESTROYED:</span><br><span class="line">            <span class="keyword">return</span> ON_CREATE;</span><br><span class="line">        <span class="keyword">case</span> CREATED:</span><br><span class="line">            <span class="keyword">return</span> ON_START;</span><br><span class="line">        <span class="keyword">case</span> STARTED:</span><br><span class="line">            <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">        <span class="keyword">case</span> RESUMED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unexpected state value &quot;</span> + state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">            mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        <span class="type">ObserverWithState</span> <span class="variable">observer</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">    <span class="comment">// 逆序遍历，从链表尾开始到链表头。每一次descendingIterator方法返回的迭代器都只包括当时的列表，不包括在迭代期间</span></span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator();</span><br><span class="line">    <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">        <span class="type">ObserverWithState</span> <span class="variable">observer</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="comment">// 如果当前observer的状态大于最新的状态mState，那么就需要状态降级</span></span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()</span><br><span class="line">            <span class="comment">// 获取到降级之后的事件</span></span><br><span class="line">            <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> downEvent(observer.mState);</span><br><span class="line">            <span class="comment">// getStateAfter(event) ： 使用降级之后的event计算降级之后的状态，将其暂存到mParentStates中，防止在回调</span></span><br><span class="line">            pushParentState(getStateAfter(event));</span><br><span class="line">            <span class="comment">// 事件分发出去</span></span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">            <span class="comment">// 回调完成就清掉</span></span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// happens only on the top of stack (never in reentrance),</span></span><br><span class="line"><span class="comment">// so it doesn&#x27;t have to take in account parents</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步当前最新的状态 mState 的值到 Observer列表中，并且回调状态变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LifecycleOwner</span> <span class="variable">lifecycleOwner</span> <span class="operator">=</span> mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="literal">null</span>) &#123;</span><br><span class="line">        Log.w(LOG_TAG, <span class="string">&quot;LifecycleOwner is garbage collected, you shouldn&#x27;t try dispatch &quot;</span></span><br><span class="line">                + <span class="string">&quot;new events from it.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否需要同步当前的状态</span></span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="comment">// 如果当前最新的状态mState小于 map中链表头元素的状态，也就是状态变小了，比如从 STARTED-&gt;CREATED</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="comment">// 状态变大了，比如从 CREATED-&gt;STARTED ，修改每个 observer 状态并且回调出去</span></span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="literal">null</span> &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在进入到 handleLifecycleEvent() 方法之后，首先是通过 getStateAfter() 拿到该 Event 对应的下一个 State ，而关于 Event 和 State 的转换关系可以翻看前面。接着调用 moveToState() 方法来修改当前 mState 的值，并且调用 sync() 方法来同步 mObserverMap 中存储的所有观察者，使得这个新的 State 能通知到每个观察者中去。</p>
<p>而在具体同步时，分别会调用 forwardPass() 、 backwardPass() 来将观察者的状态向后、向前转移。</p>
<blockquote>
<p>注意这里的 State 是枚举，并且注意其定义的顺序，先是 DESTROYED ，最后是 RESUMED ，其对应的枚举数值是原来越大的。</p>
<p>所以说，我们前面提到的生命周期从前往后，其实就是这些 State 从小到大变化，也就是这里的 forwardPass() 和 upEvent() 方法；而相反的生命周期从后往前，就是State 的从大到小变化，也就是这里的 backwardPass() 和 downEvent() 方法。</p>
</blockquote>
<p>另外一点，外部通过 addObserver() 方法注册到 LifecycleRegistry 里的LifecycleObserver 实例会被封装成一个状态化的类实例：ObserverWithState 。</p>
<p>这个类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LifecycleRegistry</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObserverWithState</span> &#123;</span><br><span class="line">    State mState;</span><br><span class="line">    LifecycleEventObserver mLifecycleObserver;</span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">newState</span> <span class="operator">=</span> event.getTargetState();</span><br><span class="line">        mState = min(mState, newState);</span><br><span class="line">        mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">        mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lifecycling</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> LifecycleEventObserver <span class="title function_">lifecycleEventObserver</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLifecycleEventObserver</span> <span class="operator">=</span> object <span class="keyword">instanceof</span> LifecycleEventObserver;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isFullLifecycleObserver</span> <span class="operator">=</span> object <span class="keyword">instanceof</span> FullLifecycleObserver;</span><br><span class="line">    <span class="keyword">if</span> (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FullLifecycleObserverAdapter</span>((FullLifecycleObserver) object,</span><br><span class="line">                (LifecycleEventObserver) object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFullLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FullLifecycleObserverAdapter</span>((FullLifecycleObserver) object, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isLifecycleEventObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> (LifecycleEventObserver) object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; klass = object.getClass();</span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> getObserverConstructorType(klass);</span><br><span class="line">    <span class="keyword">if</span> (type == GENERATED_CALLBACK) &#123;</span><br><span class="line">        List&lt;Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">GeneratedAdapter</span>&gt;&gt; constructors =</span><br><span class="line">                sClassToAdapters.get(klass);</span><br><span class="line">        <span class="keyword">if</span> (constructors.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">GeneratedAdapter</span> <span class="variable">generatedAdapter</span> <span class="operator">=</span> createGeneratedAdapter(</span><br><span class="line">                    constructors.get(<span class="number">0</span>), object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SingleGeneratedAdapterObserver</span>(generatedAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">        GeneratedAdapter[] adapters = <span class="keyword">new</span> <span class="title class_">GeneratedAdapter</span>[constructors.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; constructors.size(); i++) &#123;</span><br><span class="line">            adapters[i] = createGeneratedAdapter(constructors.get(i), object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompositeGeneratedAdaptersObserver</span>(adapters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReflectiveGenericLifecycleObserver</span>(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码可以知道，在创建一个 ObserverWithState 实例时，传入一个LifecycleObserver 实例，以及一个初始State 状态。</p>
<p>在其内部会首先将LifecycleObserver 接口通过Lifecycling.lifecycleEventObserver() 方法来将其转换为 LifecycleEventObserver 类型。而具体转换工作简单来说就是根据这个 LifecycleObserver 是 LifecycleEventObserver 还是 FullLifecycleObserver 实例，还是说是两者都实现了，借助FullLifecycleObserverAdapter 类来<br>保证对应接口方法的正常回调，额外的如果实际没有使用这俩接口的话，则会通过反射去拿注解信息，也就是最前面提及的 OnLifecycleEvent 注解方式。</p>
<blockquote>
<p>当然正如前面所言，注解方式现在已经不推荐了，如果是JDK8及其之后的版本推荐使用接口方式而不是注解。</p>
</blockquote>
<p>接着看添加观察者的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LifecycleRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> &#123;</span><br><span class="line">    <span class="type">State</span> <span class="variable">initialState</span> <span class="operator">=</span> mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    <span class="type">ObserverWithState</span> <span class="variable">statefulObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObserverWithState</span>(observer, initialState);</span><br><span class="line">    <span class="comment">// mObserverMap ：以observer为key，以 ObserverWithState 为 value</span></span><br><span class="line">    <span class="type">ObserverWithState</span> <span class="variable">previous</span> <span class="operator">=</span> mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line">    <span class="comment">// 如果之前对于这个 Observer 添加过了，那么就直接返回吧</span></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">LifecycleOwner</span> <span class="variable">lifecycleOwner</span> <span class="operator">=</span> mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isReentrance</span> <span class="operator">=</span> mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    <span class="comment">// 计算当前 lifecycle 处于的状态</span></span><br><span class="line">    <span class="type">State</span> <span class="variable">targetState</span> <span class="operator">=</span> calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="comment">// 如果最终的状态和当前状态不一致，在刚添加之后就要调用observer的回调方法来同步状态</span></span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span> &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当外部注册LifecycleObserver 进来时，会将其包装成ObserverWithState 实例，此时将其初始状态设置为 INITIALIZED ，接着会判断当前State 和这个新创建的 ObserverWithState 的状态是否一样，不一样的话则同步它的状态为最新的。</p>
<p>所以说，同一个 Lifecycle 中注册的观察者们，他们的状态都是一致的，不管是新添加的还是之前添加的。</p>
<p>分析到这里，不难知道：Lifecycle 中产生生命周期变化事件的时机主要分为两部分：</p>
<p>1、往其中刚添加观察者时，该观察者会被立马通知，将其状态更新为Lifecycle当前的最新状态上去。比如上面讲到的 addObserver() 方法。</p>
<p>2、当Lifecycle对应的对象(比如Activity)生命周期发生变化了，此时所有的观察者会被通知状态变化。比如上面讲到的 handleLifecycleEvent。</p>
<h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><h4 id="回调顺序"><a href="#回调顺序" class="headerlink" title="回调顺序"></a>回调顺序</h4><p>前面讲到：不管是 ReportFragment 方式，还是activity.registerActivityLifecycleCallbacks() 方式，最终Lifecycle Event 的发生时机都是：</p>
<p>1、Event.ON_CREATE 、Event.ON_START 以及 Event.ON_RESUME 事件是发生在对应Activity 生命周期方法【之后】的。比如对于Event.ON_START 来说，它发生在 Activity.onStart() 方法之后。</p>
<p>2、Event.ON_PAUSE 、Event.ON_STOP 以及 Event.ON_DESTROY 事件是发生在对应Activity 生命周期方法【之前】的。比如对于Event.ON_STOP 来说，它发生在 Activity.onStop() 方法之前。</p>
<p>这里简单解释下原因：</p>
<p>对于 ReportFragment 来说，它是在 Fragment 的生命周期方法中完成 event 分发的。查看相关源码（调用路径+源码）：</p>
<p>ActivityThread # handleStartActivity()    – Activity # performStart()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Activity</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">performStart</span><span class="params">(String reason)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行到 Application.ActivityLifecycleCallbacks.onActivityPreStarted</span></span><br><span class="line">    dispatchActivityPreStarted();</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="built_in">this</span>, getActivityOptions());</span><br><span class="line">    mFragments.noteStateNotSaved();</span><br><span class="line">    mCalled = <span class="literal">false</span>;</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line">    <span class="comment">// 执行到 Instrumentation.callActivityOnStart ,内部会调用 Activity.onStart() </span></span><br><span class="line">    mInstrumentation.callActivityOnStart(<span class="built_in">this</span>);</span><br><span class="line">    writeEventLog(LOG_AM_ON_START_CALLED, reason);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SuperNotCalledException</span>(</span><br><span class="line">            <span class="string">&quot;Activity &quot;</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">&quot; did not call through to super.onStart()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行到 Fragment.onStart() </span></span><br><span class="line">    mFragments.dispatchStart();</span><br><span class="line">    mFragments.reportLoaderStart();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isAppDebuggable</span> <span class="operator">=</span></span><br><span class="line">            (mApplication.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span></span><br><span class="line">    <span class="comment">// This property is set for all non-user builds except final release</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDlwarningEnabled</span> <span class="operator">=</span> SystemProperties.getInt(<span class="string">&quot;ro.bionic.ld.warning&quot;</span>, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (isAppDebuggable || isDlwarningEnabled) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dlwarning</span> <span class="operator">=</span> getDlWarning();</span><br><span class="line">        <span class="keyword">if</span> (dlwarning != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> getApplicationInfo().loadLabel(getPackageManager())</span><br><span class="line">                    .toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">warning</span> <span class="operator">=</span> <span class="string">&quot;Detected problems with app native libraries\n&quot;</span> +</span><br><span class="line">                             <span class="string">&quot;(please consult log for detail):\n&quot;</span> + dlwarning;</span><br><span class="line">            <span class="keyword">if</span> (isAppDebuggable) &#123;</span><br><span class="line">                  <span class="keyword">new</span> <span class="title class_">AlertDialog</span>.Builder(<span class="built_in">this</span>).</span><br><span class="line">                      setTitle(appName).</span><br><span class="line">                      setMessage(warning).</span><br><span class="line">                      setPositiveButton(android.R.string.ok, <span class="literal">null</span>).</span><br><span class="line">                      setCancelable(<span class="literal">false</span>).</span><br><span class="line">                      show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(<span class="built_in">this</span>, appName + <span class="string">&quot;\n&quot;</span> + warning, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    GraphicsEnvironment.getInstance().showAngleInUseDialogBox(<span class="built_in">this</span>);</span><br><span class="line">    mActivityTransitionState.enterReady(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 执行到 Application.ActivityLifecycleCallbacks.onActivityPostStarted</span></span><br><span class="line">    dispatchActivityPostStarted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Activity.onStart() 方法是早于 Fragment.onStart() 的，也就是说 Activity.onStart() 是早于 Event.ON_START 的。其他方法同理</p>
<p>而对于 activity.registerActivityLifecycleCallbacks() 方式的话，上面代码也能看出来 onActivityPreStarted 和 onActivityPostStarted 的区别了。而 Event.ON_START 是在onActivityPostStarted() 方法中被分发的，所以它的顺序同上。其他方法类似。</p>
<h4 id="ProcessLifecycleOwner"><a href="#ProcessLifecycleOwner" class="headerlink" title="ProcessLifecycleOwner"></a>ProcessLifecycleOwner</h4><p>ProcessLifecycleOwner 是 google 官方基于Lifecycle 封装出来的另外一套工具，用来监测APP 压后台、回前台 的事件。</p>
<p>使用方式很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProcessLifecycleOwner.get().getLifecycle().addObserver(observer)</span><br></pre></td></tr></table></figure>

<p>即可，除了获取Lifecycle实例的方式有些差异之外，其他的都基本差不多。</p>
<blockquote>
<p>额外需要注意的是：ProcessLifecycleOwner 注册的观察者永远不会收到 Event.ON_DESTROY 事件，因为它标志着整个APP的销毁，而此时没有必要，也没有办法回调通知到观察者。因为此时更多的是APP进程被销毁了。</p>
</blockquote>
<p>在正式看之前，首先分析下ProcessLifecycleOwnerInitializer 类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessLifecycleOwnerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        LifecycleDispatcher.init(getContext());</span><br><span class="line">        ProcessLifecycleOwner.init(getContext());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cursor <span class="title function_">query</span><span class="params">(<span class="meta">@NonNull</span> Uri uri, String[] strings, String s, String[] strings1,</span></span><br><span class="line"><span class="params">            String s1)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">(<span class="meta">@NonNull</span> Uri uri)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Uri <span class="title function_">insert</span><span class="params">(<span class="meta">@NonNull</span> Uri uri, ContentValues contentValues)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@NonNull</span> Uri uri, String s, String[] strings)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@NonNull</span> Uri uri, ContentValues contentValues, String s, String[] strings)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如其类名所示，它是用来对ProcessLifecycleOwner初始化的，而继承自 ContentProvider 的做法是比较常见的了，避免开发者再去手动初始化。关于这个可以翻看其他资料，或者查看jetpack中提供的 startup 库。该库后续也会做分析的。</p>
<p>可以看到在初始化的时候，会先调用LifecycleDispatcher.init 方法，然后才调用 ProcessLifecycleOwner.init 方法。下面则按顺序分析。</p>
<h5 id="LifecycleDispatcher"><a href="#LifecycleDispatcher" class="headerlink" title="LifecycleDispatcher"></a>LifecycleDispatcher</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleDispatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicBoolean</span> <span class="variable">sInitialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInitialized.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ((Application) context.getApplicationContext())</span><br><span class="line">                .registerActivityLifecycleCallbacks(<span class="keyword">new</span> <span class="title class_">DispatcherActivityCallback</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DispatcherActivityCallback</span> <span class="keyword">extends</span> <span class="title class_">EmptyActivityLifecycleCallbacks</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">            ReportFragment.injectIfNeededIn(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityStopped</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LifecycleDispatcher</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类逻辑很简单，就是通过传入的 Application context 来注册 Activity 生命周期方法，然后在每个 Activity onCreate 方法调用时，调用ReportFragment.injectIfNeededIn()  方法来为其注入 ReportFragment 或者ActivityLifecycleCallbacks ，这些 在前面都讲过了。</p>
<h5 id="ProcessLifecycleOwner-1"><a href="#ProcessLifecycleOwner-1" class="headerlink" title="ProcessLifecycleOwner"></a>ProcessLifecycleOwner</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessLifecycleOwner</span> <span class="keyword">implements</span> <span class="title class_">LifecycleOwner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ProcessLifecycleOwner</span> <span class="variable">sInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessLifecycleOwner</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        sInstance.attach(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，ProcessLifecycleOwner 是一个进程单例。外部调用它的 init() 方法时，会执行到它的 attach() 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessLifecycleOwner</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> (Application) context.getApplicationContext();</span><br><span class="line">        app.registerActivityLifecycleCallbacks(<span class="keyword">new</span> <span class="title class_">EmptyActivityLifecycleCallbacks</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPreCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity,</span></span><br><span class="line"><span class="params">                    <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;</span><br><span class="line">                <span class="comment">// We need the ProcessLifecycleOwner to get ON_START and ON_RESUME precisely</span></span><br><span class="line">                <span class="comment">// before the first activity gets its LifecycleOwner started/resumed.</span></span><br><span class="line">                <span class="comment">// The activity&#x27;s LifecycleOwner gets started/resumed via an activity registered</span></span><br><span class="line">                <span class="comment">// callback added in onCreate(). By adding our own activity registered callback in</span></span><br><span class="line">                <span class="comment">// onActivityPreCreated(), we get our callbacks first while still having the</span></span><br><span class="line">                <span class="comment">// right relative order compared to the Activity&#x27;s onStart()/onResume() callbacks.</span></span><br><span class="line">                activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> <span class="title class_">EmptyActivityLifecycleCallbacks</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">                        activityStarted();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">                        activityResumed();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">                <span class="comment">// Only use ReportFragment pre API 29 - after that, we can use the</span></span><br><span class="line">                <span class="comment">// onActivityPostStarted and onActivityPostResumed callbacks registered in</span></span><br><span class="line">                <span class="comment">// onActivityPreCreated()</span></span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">                    ReportFragment.get(activity).setProcessListener(mInitializationListener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPaused</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">                activityPaused();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityStopped</span><span class="params">(Activity activity)</span> &#123;</span><br><span class="line">                activityStopped();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先会发送一个 Event.ON_CREATE 事件，表示该 APP 此时已经创建好了。当然了，该方法是从 ContentProvider#onCreate() 中调用过来的，它比 Application#onCreate() 要早，但是却在 Application#attachBaseContext() 之后。所以此时认为APP进程被创建好了没有问题。</p>
<p>接着会调用 Application#registerActivityLifecycleCallbacks() 方法来监听当前应用内所有 Activity 的生命周期变化事件。</p>
<blockquote>
<p>onActivityPreXXX() 、onActivityPostXXX() 等方法是自API29才有的，其他方法是API14开始就有的。</p>
<p>所以说，如果能收到onActivityPreXXX() 这些方法回调的话则表示当前系统版本至少是 API29。这些在前面也分析过了。</p>
</blockquote>
<p>所以这里将逻辑分为两种：API&lt;29 和 API&gt;&#x3D;29的：</p>
<p>1)API&gt;&#x3D;29:</p>
<p>这种方式会在 onActivityPreCreated() 方法中来为 Activity 来注册生命周期监听。而为什么要在 preCreate() 中注册呢？因为对于 Activity Lifecycle来说，它的注册是在 ComponentActivity#onCreate() 中调用 ReportFragment.injectIfNeededIn() 方法来注册的ActivityLifecycleCallbacks。那么这里在其 preCreate() 中就先注册 ActivityLifecycleCallbacks ，保证这里的 ActivityLifecycleCallbacks 先于ComponentActivity 被回调。</p>
<blockquote>
<p>其实你大概看下 Activity#registerActivityLifecycleCallbacks() 方法就能知道，它内部使用的是一个 ArrayList 来存储的这些外部注册的ActivityLifecycleCallbacks，所以先注册的在列表前面，等到回调时也是先被回调的。</p>
</blockquote>
<p>而这样的目的是:保证这里的 Application Lifecycle 中接受到onStart()和 onResume() 事件要比Activity的早。这样的话Application Lifecycle的 Event.ON_START 、Event.ON_RESUME 事件就会早于Activity Lifecycle 。不然的话，当第一个Activity启动之后，Activity 的生命周期先 Start 了，然后整个应用的声明周期才Start? ? 那肯定不对呀，Application 的生命周期肯定是要早于 Activity 的呀!!!</p>
<p>2)API&lt;29:</p>
<p>这种方式没有 ActivityLifecycleCallbacks 中 onActivityPreXXX() 等方法可以用了。那只能是借助于 ReportFragment 了，此时会在 onActivityCreated() 方法中调用：</p>
<p>ReportFragment.get(activity).setProcessListener(mInitializationListener);</p>
<p>来实现类似的监听功能。额外补充如下几点解释：</p>
<p>2.1) 前面的 LifecycleDispatcher 中已经提前往Activity 中注入了 ReportFragment 了，所以此时直接从中获取该 Fragment 就是没问题的</p>
<p>2.2) onActivityCreated() 方法是API14开始就存在的方法，所以可以安全使用。而前面 API&gt;&#x3D;29的已经有地方处理了，因此这里是只有 API&lt;29 的才会执行 setProcessListener() 方法。</p>
<p>2.3) 而关于 ReportFragment#setProcessListener() 方法的话，也比较简单，它内部只提供了：onCreate()、onStart()、onResume() 方法。而这些方法是在 ReportFragment 中对应的生命周期时被回调，比如在ReportFragment#onStart() 方法中，会先调用processListener.onStart() 方法，然后再调用 dispatch() 方法来为 Activity#Lifecycle 中分发 Event.ON_START 事件。所以说processListener 中的方法回调是优先于 Activity Lifecycle 的。这样的话也保证了和前面API&gt;&#x3D;29的逻辑一致性，这样做解决的问题也是一样的：即保证Application Lifecycle 的 Event.ON_START 和  Event.ON_RESUME 优先于 Activity Lifecycle。</p>
<p>所以综合上面 API&lt;29 和 API&gt;&#x3D;29 的逻辑，其最终逻辑都是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessLifecycleOwner</span></span><br><span class="line"><span class="comment">// API&gt;=29</span></span><br><span class="line"></span><br><span class="line">activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> <span class="title class_">EmptyActivityLifecycleCallbacks</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        activityStarted();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onActivityPostResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> &#123;</span><br><span class="line">        activityResumed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// API&lt;29</span></span><br><span class="line"><span class="type">ActivityInitializationListener</span> <span class="variable">mInitializationListener</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ActivityInitializationListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">                activityStarted();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">                activityResumed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终都是汇集到 activityStarted() 和 activityResumed() 方法中。</p>
<p>而 PAUSE 和 STOP 状态呢？这两个都统一在  ActivityLifecycleCallbacks 的 onActivityPaused() 和 onActivityStopped() 中，不区分API版本，因为处理这俩时，额外有一个 Handler 延迟操作，所以其事件发生肯定是在 Activity Lifecycle 之后的，因此无需单独处理。</p>
<p>下面就统一看下这四个相关的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessLifecycleOwner</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">mStartedCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">mResumedCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mPauseSent</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mStopSent</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">activityStarted</span><span class="params">()</span> &#123;</span><br><span class="line">    mStartedCounter++;</span><br><span class="line">    <span class="keyword">if</span> (mStartedCounter == <span class="number">1</span> &amp;&amp; mStopSent) &#123;</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">        mStopSent = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">activityResumed</span><span class="params">()</span> &#123;</span><br><span class="line">    mResumedCounter++;</span><br><span class="line">    <span class="keyword">if</span> (mResumedCounter == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPauseSent) &#123;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class="line">            mPauseSent = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">activityPaused</span><span class="params">()</span> &#123;</span><br><span class="line">    mResumedCounter--;</span><br><span class="line">    <span class="keyword">if</span> (mResumedCounter == <span class="number">0</span>) &#123;</span><br><span class="line">        mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">activityStopped</span><span class="params">()</span> &#123;</span><br><span class="line">    mStartedCounter--;</span><br><span class="line">    dispatchStopIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ProcessLifecycleOwner 中额外还有四个属性来记录一些状态变化：</p>
<p>1、mStartedCounter &#x3D; 0：表示当前处于 onStart() 状态的 Activity 数量；当有Activity 的 onStart() 方法被回调时自增1；当有Activity 的 onStop() 方法被回调时自减1；</p>
<p>2、mResumedCounter &#x3D; 0：表示当前处于 onResume() 状态的 Activity 数量；当有Activity 的onResume() 方法被回调时自增1；当有Activity 的 onPause() 方法被回调时自减1；</p>
<p>3、mPauseSent &#x3D; true：当前是否已经发送过 Event.ON_PAUSE 事件了。当发送过 Event.ON_RESUME 事件时会将其置为false，发送过 Event.ON_PAUSE 事件时会将起置为true，默认是true。</p>
<p>4、mStopSent &#x3D; true：同上，不过此时对应的分别是 Event.ON_STOP 和 Event.ON_START 事件。</p>
<p>所以说，当第一次有Activity被调用 onStart() 方法时，mStartedCounter 从0自增为1，此时 mStopSent 是默认值true，所以在 activityStarted() 方法内会发送 Event.ON_START 事件。</p>
<p>接着该 Activity 被调用 onResume() 方法，mResumedCounter 从0自增为1，此时 mPauseSent 是默认值true所以此时会在 activityResumed() 方法内会发送 Event.ON_RESUME 事件。此时标志着当前APP位于前台状态了。</p>
<p>此时压后台的话，会先执行 Activity 的 onPause ，接着就是它的 onStop 。</p>
<p>即先执行activityStopped() 方法，内部的 mResumedCounter 会自减1，当其减少到0时，表示最后一个Activity onPause 执行过了，那么此时会 post 一个延迟700ms的任务；</p>
<p>接着执行 activityStopped() 方法，此时该方法中将 mStartedCounter 自减1，去执行 dispatchStopIfNeeded() 方法，该方法内会判断 mPauseSent ，此时它是 false (因为前面 mPauseSent() 方法中修改了)，所以不执行其他操作。</p>
<p>接着等post 的任务执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessLifecycleOwner</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">mDelayedPauseRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        dispatchPauseIfNeeded();</span><br><span class="line">        dispatchStopIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchPauseIfNeeded</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mResumedCounter == <span class="number">0</span>) &#123;</span><br><span class="line">        mPauseSent = <span class="literal">true</span>;</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchStopIfNeeded</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mStartedCounter == <span class="number">0</span> &amp;&amp; mPauseSent) &#123;</span><br><span class="line">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">        mStopSent = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设就这样 相安无事 的等待了700ms，那么上面的 runnable 会被执行，此时先执行  dispatchPauseIfNeeded() 方法，而mResumedCounter &#x3D; 0 （因为前面activityPaused() 方法中已经将其自减1了）。此时会将 mPauseSent 置为 true ，然后发送 Event.ON_PAUSE 事件。</p>
<p>接着执行 dispatchStopIfNeeded() 方法，而 mStartedCounter &#x3D; 0 （因为前面activityStopped() 方法中已经将其自减1了），并且 mPauseSent &#x3D; true （因为前面dispatchPauseIfNeeded()方法中已经将其置为true并且发送了Event.ON_PAUSE 事件 ），那么此时会发送 Event.ON_STOP 事件，并且会将 mStopSent 置为true。此时标志着当前应用进入后台了。</p>
<p>而如果在这700ms内不是相安无事呢？比如在700ms期间，该runnable被移除了，那么就不会执行dispatchPauseIfNeeded() 方法，也就不会将mPauseSent置为true，此时mPauseSent仍旧保持前面的 false 状态，此时该Activity 又执行了 onStart() 和 onResume() 方法时，最终执行到 activityResumed() 方法内，会调用：mHandler.removeCallbacks(mDelayedPauseRunnable) 来移除该runnable 。此时该runnable 方法中的逻辑也就不会被执行，所以不会发送后续的Event.ON_PAUSE 和 Event.ON_STOP 了。</p>
<p>而这些情况怎么会发生呢？</p>
<p>1、比如当当前Activity栈中只有一个Activity 时，旋转屏幕Activity发生重建(假设没有指定android:configChanges )，此时该Activity 的生命周期变化会是：onResume() -&gt; onStop() -&gt; onDestroy() -&gt; onCreate() -&gt; onStart() -&gt; onResume() 。因此这种情况时就会将该runnable移除掉，此时Application Lifecycle外部观察者感知不到任何Event。</p>
<p>2、而正常情况下，基本不可能也不会去做到压后台到切回来整体在700ms内完成，一般都是压后台就一直放着去其他应用或者呆在桌面了。所以此时这种情况下runnable正常执行，Application Lifecycle外部观察者正常接受到Event.ON_PAUSE 和 Event.ON_STOP 通知，表示APP压后台了。</p>
<p>所以说，当你对压后台事件的处理的即时性要求不是特别高的话，则可以使用这个库来完成APP的前后台监听。另外锁屏也会被认为是Application生命周期 ON_PAUSE 、ON_STOP 了。</p>
<p>不使用这个库，你也可以使用ActivityLifecycleCallbacks ，然后搭配 onActivityStarted() 和 onActivityStopped() 方法，结合count计数就可以算出来。但是更推荐当前库。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Jetpack/">Jetpack</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/6d1e424c.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Jetpack- ViewModel</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2af50710.html">
        <span class="next-text nav-default">Binder - Java Framework</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
