<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="GLES&EGL-EGL-03"/>




  <meta name="keywords" content="AndroidFrameworks,OpenGLES,EGL," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/4446cd65.html"/>


<meta name="description" content="承接前面  GLES&amp;EGL-EGL-02  文章中的内容，本文接着往下看 EGL 中的操作。 简单回顾在正式开始分析之前，先复习下之前的内容，在前面的  eglCreateWindowSurface() 方法中拿到了 EGLSurface 实例；在前面的eglCreateContext() 方法中拿到了 EGLContext  实例。下面就先回顾下这俩实例。 ① eglCreateWin">
<meta property="og:type" content="article">
<meta property="og:title" content="GLES&amp;EGL-EGL-03">
<meta property="og:url" content="https://youngkaaa.github.io/4446cd65.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="承接前面  GLES&amp;EGL-EGL-02  文章中的内容，本文接着往下看 EGL 中的操作。 简单回顾在正式开始分析之前，先复习下之前的内容，在前面的  eglCreateWindowSurface() 方法中拿到了 EGLSurface 实例；在前面的eglCreateContext() 方法中拿到了 EGLContext  实例。下面就先回顾下这俩实例。 ① eglCreateWin">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-20T11:51:57.000Z">
<meta property="article:modified_time" content="2023-03-03T14:01:37.036Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="OpenGLES">
<meta property="article:tag" content="EGL">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> GLES&EGL-EGL-03 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          GLES&EGL-EGL-03
        
      </h1>

      <time class="post-time">
          8月 20 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>承接前面  <a href="3341fdf3.html">GLES&amp;EGL-EGL-02</a>  文章中的内容，本文接着往下看 EGL 中的操作。</p>
<h3 id="简单回顾"><a href="#简单回顾" class="headerlink" title="简单回顾"></a>简单回顾</h3><p>在正式开始分析之前，先复习下之前的内容，在前面的  eglCreateWindowSurface() 方法中拿到了 EGLSurface 实例；在前面的eglCreateContext() 方法中拿到了 EGLContext  实例。下面就先回顾下这俩实例。</p>
<p>① eglCreateWindowSurface() 方法拿到  EGLSurface 实例 。这个最终的 EGLSurface 实际对应的是 egl侧 (也就是非 libagl)的 egl_surface_t 实例。而这个 egl_surface_t 实例中的 surface 属性存储的是来自 libagl 侧返回的 egl_window_surface_v2_t 实例（他的父类是 egl_surface_t ）。</p>
<p>② eglCreateContext() 方法拿到  EGLContext 实例 。这个最终的 EGLContext 实际对应的是 egl侧 (也就是非 libagl)的 egl_context_t 实例。而这个 egl_context_t 实例中的 context 属性存储的是来自 libagl 侧返回的 ogles_context_t 实例。</p>
<h3 id="eglMakeCurrent"><a href="#eglMakeCurrent" class="headerlink" title="eglMakeCurrent"></a>eglMakeCurrent</h3><p>先看源码，看完源码之后再来总结该方法作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/eglApi.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglMakeCurrent</span><span class="params">(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">clearError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">egl_connection_t</span>* <span class="type">const</span> cnx = &amp;gEGLImpl;</span><br><span class="line">    <span class="keyword">return</span> cnx-&gt;platform.<span class="built_in">eglMakeCurrent</span>(dpy, draw, read, ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/egl_platform_entries.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglMakeCurrentImpl</span><span class="params">(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从全局 sDisplay 列表中拿到 dpy 所对应的 egl_display_t 实例，并且将其包装为 egl_display_ptr</span></span><br><span class="line">    egl_display_ptr dp = <span class="built_in">validate_display</span>(dpy);</span><br><span class="line">    <span class="keyword">if</span> (!dp) <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_DISPLAY, (EGLBoolean)EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这三个参数其中一个不为空，则会判断 egl_display_t 是否 ready ，也就是判断该 dpy 是否初始化过</span></span><br><span class="line">    <span class="keyword">if</span> ( (ctx != EGL_NO_CONTEXT) || (read != EGL_NO_SURFACE) || (draw != EGL_NO_SURFACE) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dp-&gt;<span class="built_in">isReady</span>()) <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_NOT_INITIALIZED, (EGLBoolean)EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextRef _c(dp.<span class="built_in">get</span>(), ctx);</span><br><span class="line">    SurfaceRef _d(dp.<span class="built_in">get</span>(), draw);</span><br><span class="line">    SurfaceRef _r(dp.<span class="built_in">get</span>(), read);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ctx != EGL_NO_CONTEXT) &amp;&amp; !_c.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_CONTEXT, (EGLBoolean)EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这三个后面分别用来存储入参 ctx ，draw ，read 在 libagl 侧的实例</span></span><br><span class="line"><span class="comment">     * 比如对于EGLContext 来说，它在libagl 侧的实例是其内部的 context 属性，对应的是libagl侧的 ogles_context_t 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EGLContext impl_ctx  = EGL_NO_CONTEXT;</span><br><span class="line">    EGLSurface impl_draw = EGL_NO_SURFACE;</span><br><span class="line">    EGLSurface impl_read = EGL_NO_SURFACE;</span><br><span class="line"></span><br><span class="line">    <span class="type">egl_context_t</span>       * c = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">egl_surface_t</span> <span class="type">const</span> * d = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">egl_surface_t</span> <span class="type">const</span> * r = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getContext() 拿到当前线程之前保存的 EGLContext</span></span><br><span class="line"><span class="comment">     * get_context() 将其转换成 egl_context_t 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">egl_context_t</span> * cur_c = <span class="built_in">get_context</span>(<span class="built_in">getContext</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先使用 get_context() 方法来将该 EGLContext 转换为真正的类型，也就是 egl_context_t</span></span><br><span class="line"><span class="comment">     * 将这个 egl_context_t 保存给 c；将 egl_context_t-&gt;context 保存给 impl_ctx</span></span><br><span class="line"><span class="comment">     * 所以 impl_ctx 中保存的就是该 egl_context_t 对应的在 libagl 侧的 ogles_context_t 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx != EGL_NO_CONTEXT) &#123;</span><br><span class="line">        c = <span class="built_in">get_context</span>(ctx);</span><br><span class="line">        impl_ctx = c-&gt;context;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 入参 ctx 为空，但是 draw 或者 read 却不为空，此时直接返回失败</span></span><br><span class="line">        <span class="keyword">if</span> (draw != EGL_NO_SURFACE || read != EGL_NO_SURFACE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_MATCH, (EGLBoolean)EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入参 ctx 为空，同时当前线程之前也没保存 EGLContext ，返回true吧不认为是错误</span></span><br><span class="line">        <span class="keyword">if</span> (cur_c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入参 EGLSurface draw 不为空，则通过 get_surface()  方法将其转换为其真正的类型：egl_surface_t</span></span><br><span class="line"><span class="comment">     * 将该 egl_surface_t 保存给 d ；将 egl_surface_t-&gt;surface 保存给 impl_draw</span></span><br><span class="line"><span class="comment">     * 所以 impl_draw 中保存的就是该 egl_surface_t 对应的在 libagl 侧的 egl_window_surface_v2_t  实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (draw != EGL_NO_SURFACE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_d.<span class="built_in">get</span>()) <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_SURFACE, (EGLBoolean)EGL_FALSE);</span><br><span class="line">        d = <span class="built_in">get_surface</span>(draw);</span><br><span class="line">        impl_draw = d-&gt;surface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上，最终 r 中保存的是入参 EGLSurface read 对应的 egl_surface_t</span></span><br><span class="line"><span class="comment">     * impl_read 中保存的就是该 egl_surface_t 对应的在 libagl 侧的 egl_window_surface_v2_t  实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (read != EGL_NO_SURFACE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_r.<span class="built_in">get</span>()) <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_SURFACE, (EGLBoolean)EGL_FALSE);</span><br><span class="line">        r = <span class="built_in">get_surface</span>(read);</span><br><span class="line">        impl_read = r-&gt;surface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里传入了两对参数列表： draw, read, ctx 和 impl_draw, impl_read, impl_ctx</span></span><br><span class="line"><span class="comment">     * 前者是入参原封不动传入，而后者是前者内部封装保存的来自 agl 的返回值，比如 impl_draw 是 egl_window_surface_v2_t 实例</span></span><br><span class="line"><span class="comment">     * 即：</span></span><br><span class="line"><span class="comment">     * 而第一组中的 draw、read、 ctx 分别类型是(位于egl模块中的)：egl_context_t 、egl_context_t、 egl_surface_t</span></span><br><span class="line"><span class="comment">     * 而第二组中的 impl_draw, impl_read, impl_ctx 分别类型是：(位于agl模块中的): egl_window_surface_v2_t 、 egl_window_surface_v2_t 、ogles_context_t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EGLBoolean result = dp-&gt;<span class="built_in">makeCurrent</span>(c, cur_c,</span><br><span class="line">            draw, read, ctx,</span><br><span class="line">            impl_draw, impl_read, impl_ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// agl 中 makeCurrent 成功了，将其保存到 egl_tls_t 中，其实还是保存了 线程副本</span></span><br><span class="line">    <span class="keyword">if</span> (result == EGL_TRUE) &#123;</span><br><span class="line">        <span class="comment">// c 中保存着入参 EGLContext ctx  所对应真正类型，也就是 egl_context_t</span></span><br><span class="line">        <span class="keyword">if</span> (c) &#123;</span><br><span class="line">            <span class="comment">// 将对应版本的 gl_hooks_t 保存到当前线程 </span></span><br><span class="line">            <span class="built_in">setGLHooksThreadSpecific</span>(c-&gt;cnx-&gt;hooks[c-&gt;version]);</span><br><span class="line">            <span class="comment">// 将入参 ctx 保存起来，下一次就能拿到了</span></span><br><span class="line">            <span class="type">egl_tls_t</span>::<span class="built_in">setContext</span>(ctx);</span><br><span class="line">            _c.<span class="built_in">acquire</span>();</span><br><span class="line">            _r.<span class="built_in">acquire</span>();</span><br><span class="line">            _d.<span class="built_in">acquire</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 入参 EGLContext ctx 为空，那么这里设置默认值</span></span><br><span class="line">            <span class="built_in">setGLHooksThreadSpecific</span>(&amp;gHooksNoContext);</span><br><span class="line">            <span class="type">egl_tls_t</span>::<span class="built_in">setContext</span>(EGL_NO_CONTEXT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 失败了</span></span><br><span class="line">        <span class="type">egl_connection_t</span>* <span class="type">const</span> cnx = &amp;gEGLImpl;</span><br><span class="line">        result = <span class="built_in">setError</span>(cnx-&gt;egl.<span class="built_in">eglGetError</span>(), (EGLBoolean)EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> EGLContext <span class="title">getContext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="type">egl_tls_t</span>::<span class="built_in">getContext</span>(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/egl_tls.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">egl_tls_t::setContext</span><span class="params">(EGLContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 刷新key</span></span><br><span class="line">    <span class="built_in">validateTLSKey</span>();</span><br><span class="line">    <span class="comment">// 将入参 ctx 保存到当前线程，后面就可以通过 getContext 来获取了</span></span><br><span class="line">    <span class="built_in">getTLS</span>()-&gt;ctx = ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EGLContext <span class="title">egl_tls_t::getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果之前调用过 egl_tls_t::setContext 方法，那么 sKey 就会被赋值</span></span><br><span class="line">    <span class="comment">// 所以说先 setContext 之后，才能 getContext</span></span><br><span class="line">    <span class="keyword">if</span> (sKey == TLS_KEY_NOT_INITIALIZED) &#123;</span><br><span class="line">        <span class="keyword">return</span> EGL_NO_CONTEXT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到当前线程中之前保存的 egl_tls_t 实例</span></span><br><span class="line">    <span class="type">egl_tls_t</span>* tls = (<span class="type">egl_tls_t</span> *)<span class="built_in">pthread_getspecific</span>(sKey);</span><br><span class="line">    <span class="keyword">if</span> (!tls) <span class="keyword">return</span> EGL_NO_CONTEXT;</span><br><span class="line">    <span class="keyword">return</span> tls-&gt;ctx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拿到当前线程中之前保存的 egl_tls_t ，没有则会新建一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">egl_tls_t</span>* <span class="title">egl_tls_t::getTLS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">egl_tls_t</span>* tls = (<span class="type">egl_tls_t</span>*)<span class="built_in">pthread_getspecific</span>(sKey);</span><br><span class="line">    <span class="keyword">if</span> (tls == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        tls = <span class="keyword">new</span> <span class="type">egl_tls_t</span>;</span><br><span class="line">        <span class="built_in">pthread_setspecific</span>(sKey, tls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">egl_tls_t::validateTLSKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TlsKeyInitializer</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="built_in">pthread_key_create</span>(&amp;sKey, destructTLSData); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">pthread_once</span>(&amp;sOnceKey, TlsKeyInitializer::create);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eglMakeCurrent() 方法还是老样子，执行到 egl_platform_entries.cpp 中去，对应的是 eglMakeCurrentImpl() 方法。</p>
<p>在该方法中，接受四个参数，这四个参数的类型应该不陌生吧。接着进入该方法中，首先会查询出该 dpy 对应的 egl_display_t 实例，然后就是做参数合法性判断了。</p>
<p>接着往下会通过  getContext() 方法来拿到当前线程之前保存的 EGLContext ，如果在当前线程中，是第一次执行 eglMakeCurrent() 方法的话，那当前线程没有保存，拿到的就是空的。</p>
<p>接着往下就是分别处理三个入参 EGLContext ctx 、EGLSurface draw 和 EGLSurface read, ：</p>
<p>①  处理 EGLContext ctx ：如果 ctx 不是 EGL_NO_CONTEXT 的话，那么会先通过 get_context() 方法来将该 EGLContext ctx 转换为它真正的类型，也就是egl侧 ( 非 libagl ) egl_context_t 类型保存在属性 c 中；同时会将该  egl_context_t-&gt;context 保存给 impl_ctx，因此这个 impl_ctx 属性中保存的就是该 egl_context_t 实例对应的在 libagl 侧的 ogles_context_t 实例；</p>
<p>否则，则做一些状态判断而已，这种情况下的话，c 就是 nullptr ，impl_ctx 就是 EGL_NO_CONTEXT。</p>
<p>②  处理 EGLSurface draw ：如果draw 不是 EGL_NO_SURFACE 的话，会先通过 get_surface() 方法来将该  EGLSurface draw 转换为它真正的类型，也就是egl侧 ( 非 libagl ) egl_surface_t 类型保存在属性 d 中；同时会将该  egl_surface_t-&gt;surface 保存给 impl_draw，因此这个 impl_draw 属性中保存的就是该 egl_surface_t 实例对应的在 libagl 侧的 egl_window_surface_v2_t 实例；</p>
<p>否则，d 就是 nullptr ，impl_draw 就是 EGL_NO_SURFACE。</p>
<p>③ 处理 EGLSurface read ：如果read 不是 EGL_NO_SURFACE 的话，会先通过 get_surface() 方法来将该  EGLSurface read转换为它真正的类型，也就是egl侧 ( 非 libagl ) egl_surface_t 类型保存在属性 r 中；同时会将该  egl_surface_t-&gt;surface 保存给 impl_read，因此这个 impl_read 属性中保存的就是该 egl_surface_t 实例对应的在 libagl 侧的 egl_window_surface_v2_t 实例；</p>
<p>否则，r 就是 nullptr ，impl_read 就是 EGL_NO_SURFACE。</p>
<blockquote>
<p>注意外部传入的 draw 和 read 可能是同一个，所以 c 和 d 属性可能相等，impl_draw 和 impl_read 属性可能相等。</p>
</blockquote>
<p>接着就是调用 dp-&gt;makeCurrent() 方法来完成后续操作了。在看它的源码之前，首先先看看为该方法传入的参数，这些参数代表什么含义，在上面都分析过了。为方便理解，这里将其分为两组：</p>
<p>①  draw、read、 ctx 。这一组中的三个的类型分别是(位于egl模块中的)：egl_context_t 、egl_context_t、 egl_surface_t 实例。</p>
<p>② impl_draw, impl_read, impl_ctx 。这一组中的三个的类型分别是：(位于agl模块中的): egl_window_surface_v2_t 、 egl_window_surface_v2_t 、ogles_context_t</p>
<p>这两组属性变量是一一对应的。比如 draw 对应的是当前 eglMakeCurrentImpl() 方法的入参，类型是 EGLSurface  ，实际对应的是 egl侧 ( 非 libagl ) egl_surface_t 类型。而 impl_draw 则是该 egl_surface_t 实例对应的在 libagl 侧的 egl_window_surface_v2_t 实例；其他俩类似。</p>
<p>另外还有俩属性对应的：c 和 cur_c 。其中前者 c 内部存储的是入参 EGLContext ctx 所对应的真正的类型，也就是egl侧 ( 非 libagl ) egl_context_t 实例。而 cur_c  是当前线程上一次 eglMakeCurrent() 成功时保存的 egl_context_t  实例。</p>
<p>好了，这下可以看  dp-&gt;makeCurrent() 方法了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/egl_display.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_display_t::makeCurrent</span><span class="params">(<span class="type">egl_context_t</span>* c, <span class="type">egl_context_t</span>* cur_c,</span></span></span><br><span class="line"><span class="params"><span class="function">        EGLSurface draw, EGLSurface read, EGLContext <span class="comment">/*ctx*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        EGLSurface impl_draw, EGLSurface impl_read, EGLContext impl_ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EGLBoolean result;</span><br><span class="line"></span><br><span class="line">    ContextRef _cur_c(cur_c);</span><br><span class="line">    SurfaceRef _cur_r(cur_c ? <span class="built_in">get_surface</span>(cur_c-&gt;read) : <span class="literal">nullptr</span>);</span><br><span class="line">    SurfaceRef _cur_d(cur_c ? <span class="built_in">get_surface</span>(cur_c-&gt;draw) : <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; _l(lock);</span><br><span class="line">        <span class="comment">// 入参 c 不为空则使用它内部的 cnx 来完成 egl 方法调用</span></span><br><span class="line">        <span class="keyword">if</span> (c) &#123;</span><br><span class="line">            result = c-&gt;cnx-&gt;egl.<span class="built_in">eglMakeCurrent</span>(disp.dpy, impl_draw, impl_read, impl_ctx);</span><br><span class="line">            <span class="keyword">if</span> (result == EGL_TRUE) &#123;</span><br><span class="line">                c-&gt;<span class="built_in">onMakeCurrent</span>(draw, read);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = cur_c-&gt;cnx-&gt;egl.<span class="built_in">eglMakeCurrent</span>(disp.dpy, impl_draw, impl_read, impl_ctx);</span><br><span class="line">            <span class="keyword">if</span> (result == EGL_TRUE) &#123;</span><br><span class="line">                cur_c-&gt;<span class="built_in">onLooseCurrent</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == EGL_TRUE) &#123;</span><br><span class="line">        _cur_c.<span class="built_in">release</span>();</span><br><span class="line">        _cur_r.<span class="built_in">release</span>();</span><br><span class="line">        _cur_d.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 dp-&gt;makeCurrent() 方法中，会判断入参 c 是否为空，不为空的话则使用它内部的 cnx 来完成后续的 egl 方法调用。</p>
<p>由前面可知 c 和  cur_c 都是 egl侧 ( 非 libagl ) egl_context_t 实例，这俩实例之前肯定是通过 eglCreateContext() 方法实现的，而在创建该实例时，会将全局的 gEGLImpl 保存到其内部属性 cnx 中，也就是这里拿到的 cnx。</p>
<p>接下俩就执行到了 libagl 侧了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/egl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">GLBoolean <span class="title">eglMakeCurrent</span><span class="params">(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 还是先校验参数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">egl_display_t</span>::<span class="built_in">is_valid</span>(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 draw 的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (draw) &#123;</span><br><span class="line">        <span class="type">egl_surface_t</span>* s = (<span class="type">egl_surface_t</span>*)draw;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;<span class="built_in">isValid</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;dpy != dpy)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 read 的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (read &amp;&amp; read!=draw) &#123;</span><br><span class="line">        <span class="type">egl_surface_t</span>* s = (<span class="type">egl_surface_t</span>*)read;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;<span class="built_in">isValid</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;dpy != dpy)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLContext current_ctx = EGL_NO_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 read 、 draw 、 ctx 三者的合法性</span></span><br><span class="line">    <span class="keyword">if</span> ((read == EGL_NO_SURFACE &amp;&amp; draw == EGL_NO_SURFACE) &amp;&amp; (ctx != EGL_NO_CONTEXT))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_MATCH, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((read != EGL_NO_SURFACE || draw != EGL_NO_SURFACE) &amp;&amp; (ctx == EGL_NO_CONTEXT))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_MATCH, EGL_FALSE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入的 context 是空，即 EGL_NO_CONTEXT , 那么使用当前的 context</span></span><br><span class="line"><span class="comment">     * 这里的 getGlThreadSpecific() 和后续会遇到的 setGlThreadSpecific() 方法可以保存一个 ogles_context_t实例到当前线程中</span></span><br><span class="line"><span class="comment">     * 这种方式有点类似 Java 中的 ThreadLocal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ctx == EGL_NO_CONTEXT) &#123;</span><br><span class="line">        current_ctx = (EGLContext)<span class="built_in">getGlThreadSpecific</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再次检查 draw 和 read 的合法性</span></span><br><span class="line"><span class="comment">         * 这里检查的是 draw 和 read 之前是否已经被绑定过其他 ctx 了</span></span><br><span class="line"><span class="comment">         * 即他俩之一之前调用过 makeCurrent 方法绑定了其他的 ctx 了，这种情况会直接返回失败，不能同时绑定俩不同的ctx</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">egl_surface_t</span>* d = (<span class="type">egl_surface_t</span>*)draw;</span><br><span class="line">        <span class="type">egl_surface_t</span>* r = (<span class="type">egl_surface_t</span>*)read;</span><br><span class="line">        <span class="keyword">if</span> ((d &amp;&amp; d-&gt;ctx &amp;&amp; d-&gt;ctx != ctx) ||</span><br><span class="line">            (r &amp;&amp; r-&gt;ctx &amp;&amp; r-&gt;ctx != ctx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 ctx 转换为他实际的类型： ogles_context_t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ogles_context_t</span>* gl = (<span class="type">ogles_context_t</span>*)ctx;</span><br><span class="line">    <span class="comment">// 将入参 ctx 绑定到该线程中去，绑定成功的话会返回 0</span></span><br><span class="line">    <span class="comment">// 入参 ctx 为空的话内部操作是清掉之前的，也叫绑定成功</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">makeCurrent</span>(gl) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 绑定到当前线程成功了，接下来根据入参 ctx 是否为空来分别处理</span></span><br><span class="line">        <span class="keyword">if</span> (ctx) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 从入参 ctx，也就是 ogles_context_t 的 rasterizer.base 位置取出对应的  egl_context_t</span></span><br><span class="line"><span class="comment">             * 此时它的 flags 在上面的 makeCurrent() 方法中已经被置为 IS_CURRENT 了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">egl_context_t</span>* c = <span class="type">egl_context_t</span>::<span class="built_in">context</span>(ctx);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将入参 EGLSurface 转换为其真正的类型 ，但是不确定是 egl_surface_t 的哪个子类，所以只是转为 egl_surface_t </span></span><br><span class="line"><span class="comment">             * 其子类可能是 egl_window_surface_v2_t 或者 egl_pbuffer_surface_t 等等</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">egl_surface_t</span>* d = (<span class="type">egl_surface_t</span>*)draw;</span><br><span class="line">            <span class="type">egl_surface_t</span>* r = (<span class="type">egl_surface_t</span>*)read;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果该 ctx 中原先绑定了 draw，那么断开原先绑定的 draw ，一般情况下第一次的时候这里肯定为空</span></span><br><span class="line"><span class="comment">             * 关于 egl_context_t-&gt;draw 属性存储的是啥，后面会有，它实际存储的就是这里的入参 EGLSurface draw ，也就是 egl_surface_t 子类实例</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;draw) &#123;</span><br><span class="line">                <span class="type">egl_surface_t</span>* s = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">egl_surface_t</span>*&gt;(c-&gt;draw);</span><br><span class="line">                s-&gt;<span class="built_in">disconnect</span>();</span><br><span class="line">                s-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                <span class="keyword">if</span> (s-&gt;zombie)</span><br><span class="line">                    <span class="keyword">delete</span> s;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// read 倒没做额外的，因为 read 一般和 draw 是同一个对象，上面释放过就行了</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;read) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> unlock/disconnect the read surface too </span></span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 将 ctx 中的 draw 和 read 重新绑定为新的</span></span><br><span class="line">            c-&gt;draw = draw;</span><br><span class="line">            c-&gt;read = read;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在上面 makeCurrent 中，会将该 ctx flags 中的 指定位加上 IS_CURRENT ，但并没有清掉之前的 NEVER_CURRENT</span></span><br><span class="line"><span class="comment">             * 也就是说其另外一位还是存在 NEVER_CURRENT 标记，所以说此时 NEVER_CURRENT 和 IS_CURRENT 标记都存在。</span></span><br><span class="line"><span class="comment">             * 而 NEVER_CURRENT 标记是在 eglCreateContext 时被附上的。</span></span><br><span class="line"><span class="comment">             * 因此说：当该 ctx 第一次被 makeCurrent 成功时，走到这里会同时带有 NEVER_CURRENT 和 IS_CURRENT 标记 标记，</span></span><br><span class="line"><span class="comment">             * 然后这里将 NEVER_CURRENT 标记清掉。至此之后，都只是增加和移除 IS_CURRENT 位 ，后续就跟 NEVER_CURRENT 标记位没关系了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;flags &amp; <span class="type">egl_context_t</span>::NEVER_CURRENT) &#123;</span><br><span class="line">                c-&gt;flags &amp;= ~<span class="type">egl_context_t</span>::NEVER_CURRENT;</span><br><span class="line">                GLint w = <span class="number">0</span>;</span><br><span class="line">                GLint h = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (draw) &#123;</span><br><span class="line">                    w = d-&gt;<span class="built_in">getWidth</span>();</span><br><span class="line">                    h = d-&gt;<span class="built_in">getHeight</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 该 ctx 第一次被绑定时会执行这些</span></span><br><span class="line">                <span class="built_in">ogles_surfaceport</span>(gl, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">ogles_viewport</span>(gl, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">                <span class="built_in">ogles_scissor</span>(gl, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// d 就是入参的 draw ，如果它不为空，则调用其 connect 方法，表示开始使用了</span></span><br><span class="line">            <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * d 是 draw ,也就是 EGLSurface ，也就是 egl_window_surface_v2_t</span></span><br><span class="line"><span class="comment">                 * 所以调用的是 ： egl_window_surface_v2_t::connect() 方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (d-&gt;<span class="built_in">connect</span>() == EGL_FALSE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 ctx 设置给 draw 。相当于 ctx 和 draw 这些双向绑定了</span></span><br><span class="line">                d-&gt;ctx = ctx;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 同样还是到 egl_window_surface_v2_t::bindDrawSurface 中</span></span><br><span class="line"><span class="comment">                 * 这里入参 gl 其实就是这个方法的入参 ctx</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                d-&gt;<span class="built_in">bindDrawSurface</span>(gl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理完 draw，接着处理 read ，由于他俩一般都是一样的，所以对于它处理的会简单些</span></span><br><span class="line">            <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                r-&gt;ctx = ctx;</span><br><span class="line">                <span class="comment">// 同样还是到 egl_window_surface_v2_t::bindReadSurface 中</span></span><br><span class="line">                <span class="comment">// 这里入参 gl 其实就是这个方法的入参 ctx</span></span><br><span class="line">                r-&gt;<span class="built_in">bindReadSurface</span>(gl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 入参ctx 为空时 makeCurrent() 方法成功了</span></span><br><span class="line">            <span class="comment">// 此时清理掉 current_ctx 之前的值，因为在  makeCurrent() 中入参 ctx 为空时内部会清掉当前线程之前保存的 EGLContext</span></span><br><span class="line">            <span class="comment">// 那么里面清掉了，到外面这里也得保持同步一起清掉</span></span><br><span class="line">            <span class="keyword">if</span> (current_ctx) &#123;</span><br><span class="line">                <span class="type">egl_context_t</span>* c = <span class="type">egl_context_t</span>::<span class="built_in">context</span>(current_ctx);</span><br><span class="line">                <span class="type">egl_surface_t</span>* d = (<span class="type">egl_surface_t</span>*)c-&gt;draw;</span><br><span class="line">                <span class="type">egl_surface_t</span>* r = (<span class="type">egl_surface_t</span>*)c-&gt;read;</span><br><span class="line">                <span class="comment">// 回收其内部的 read 和 draw</span></span><br><span class="line">                <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                    c-&gt;draw = <span class="number">0</span>;</span><br><span class="line">                    d-&gt;<span class="built_in">disconnect</span>();</span><br><span class="line">                    d-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                    <span class="keyword">if</span> (d-&gt;zombie)</span><br><span class="line">                        <span class="keyword">delete</span> d;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                    c-&gt;read = <span class="number">0</span>;</span><br><span class="line">                    r-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> unlock/disconnect the read surface too </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在正式看代码之前，还是先看看他的入参，通过上面代码可以知道这里的入参都是 impl_draw, impl_read, impl_ctx 。</p>
<p>① EGLDisplay dpy ： eglMakeCurrent() 方法传入进来的参数，一直传到这里。</p>
<p>② EGLSurface draw ： eglMakeCurrent() 方法传入进来的参数 EGLSurface draw ，它实际对应的是  egl侧 ( 非 libagl ) egl_surface_t 实例；而这里的draw  参数实际是该 egl_surface_t 中的  surface 属性，也就是该 egl_surface_t 实例对应的在 libagl 侧的 egl_window_surface_v2_t 实例，而 egl_window_surface_v2_t  是继承自 egl_surface_t 的。</p>
<p>③ EGLSurface read ： 同上，差异就是一个是 draw ，一个是 read。</p>
<p>④ EGLContext ctx ： eglMakeCurrent() 方法传入进来的参数 EGLContext ctx ，它实际对应的是  egl侧 ( 非 libagl ) egl_context_t  实例；而这里的 ctx  参数实际是该 egl_context_t 中的 context 属性，也就是该 egl_context_t 实例对应的在 libagl 侧的 ogles_context_t  实例；</p>
<p>接下来开始分析逻辑。刚进来，首先肯定还是对入参参数的合法性校验，这里不赘述。但是额外需要补充一个点，对于入参 draw 和 read，他俩是 EGLSurface 类型的，实际对应的是 egl_surface_t 的子类，比如 egl_window_surface_v2_t 。但是由于它不止这一个子类，所以内部在将其转为真正的egl侧类型时，只转到了父类 egl_surface_t ，然后调用父类中的方法，而子类会实现这些方法，因此还是调用到 子类中去，在后续的分析中，有时候会把这个 egl_surface_t 的子类直接认为是 egl_window_surface_v2_t ，请不要诧异，并且你需要知道这个子类只是举例，并不是唯一。</p>
<p>接着往下会调用 makeCurrent() 方法来将入参 ctx 对应真正实例 ogles_context_t 传入进去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/egl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">makeCurrent</span><span class="params">(<span class="type">ogles_context_t</span>* gl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先拿到当前线程之前绑定时，存储的 ogles_context_t 实例</span></span><br><span class="line">    <span class="type">ogles_context_t</span>* current = (<span class="type">ogles_context_t</span>*)<span class="built_in">getGlThreadSpecific</span>();</span><br><span class="line">    <span class="comment">// 此时的入参 gl 是当前新的，本次要绑定的  ogles_context_t 实例</span></span><br><span class="line">    <span class="keyword">if</span> (gl) &#123;</span><br><span class="line">        <span class="comment">// 从 ogles_context_t.rasterizer.base 位置取出对应的  egl_context_t</span></span><br><span class="line">        <span class="type">egl_context_t</span>* c = <span class="type">egl_context_t</span>::<span class="built_in">context</span>(gl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果这个 ogles_context_t 是刚被创建出来的，那么它的 flags = egl_context_t::NEVER_CURRENT</span></span><br><span class="line"><span class="comment">         * 如果这个 ogles_context_t 之前被调用 makeCurrent 方法绑定过，那么会将其 flags 置为 egl_context_t::IS_CURRENT</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 因此这里判断的是这个入参 gl 是否之前已经 makeCurrent 方法绑定过</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; <span class="type">egl_context_t</span>::IS_CURRENT) &#123;</span><br><span class="line">            <span class="comment">// 如果入参之前被绑定过则判断它是不是之前的 current ，也就是给该 gl 重复调用了 makeCurrent</span></span><br><span class="line">            <span class="keyword">if</span> (current != gl) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// gl 还没有跟任何线程绑定过，也就是gl可以绑定到当前线程，那么此时先将该线程之前绑定的解绑掉</span></span><br><span class="line">            <span class="comment">// 解绑掉其实就只是将 其内部 flag 上的 IS_CURRENT 标记清除掉</span></span><br><span class="line">            <span class="keyword">if</span> (current) &#123;</span><br><span class="line">                <span class="built_in">glFlush</span>();</span><br><span class="line">                <span class="type">egl_context_t</span>::<span class="built_in">context</span>(current)-&gt;flags &amp;= ~<span class="type">egl_context_t</span>::IS_CURRENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来就可以将 gl 绑定给当前线程了</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; <span class="type">egl_context_t</span>::IS_CURRENT)) &#123;</span><br><span class="line">            <span class="comment">// 保存起来</span></span><br><span class="line">            <span class="built_in">setGlThreadSpecific</span>(gl);</span><br><span class="line">            <span class="comment">// 将其 flga 增加上 IS_CURRENT 标记</span></span><br><span class="line">            c-&gt;flags |= <span class="type">egl_context_t</span>::IS_CURRENT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 入参 gl 为空，清掉当前线程绑定的 context</span></span><br><span class="line">        <span class="keyword">if</span> (current) &#123;</span><br><span class="line">            <span class="built_in">glFlush</span>();</span><br><span class="line">            <span class="type">egl_context_t</span>::<span class="built_in">context</span>(current)-&gt;flags &amp;= ~<span class="type">egl_context_t</span>::IS_CURRENT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setGlThreadSpecific</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 makeCurrent() 方法中，入参是本次即将要绑定的 ctx 实例。在逻辑执行开始之前，会先通过 getGlThreadSpecific() 拿到当前线程中之前调用 eglMakeCurrent() 方法时保存的当时的入参 EGLContext ctx，也就是 ogles_context_t 类型实例，如果是第一次的话，则取出来的 current 是 null。接着会根据入参 gl 是否为空来执行不同的逻辑。</p>
<p>① gl 不为空，即本次要绑定的 ogles_context_t 不为空。</p>
<p>那么取出该 ogles_context_t 实例中的  rasterizer.base 属性，它对应着 egl_context_t 的开始地址。</p>
<p>接着判断它的 flags 属性是否包括 egl_context_t::IS_CURRENT 位标识，包括的话表示该 egl_context_t ，也就是该 ogles_context_t 之前已被绑定过，那么此时额外判断下它之前绑定的是不是当前线程，也就是：current 是否等于 gl ，如果不想等，则表示它之前绑定的不是当前线程，那一个 ogles_context_t 只能绑定一个线程，不能同时绑定俩不同的线程。</p>
<p>如果它的 flags 不包括 egl_context_t::IS_CURRENT 位标识，也就是该 ogles_context_t 之前没被绑定过，此时就可以绑定到当前线程来。因此这里先将之前的 current 从当前线程中移除掉，即移除掉 current.flags 中的 egl_context_t::IS_CURRENT 位标识。</p>
<p>接下来，将入参传进来的 ogles_context_t 绑定到当前线程，绑定时共两步：先调用 setGlThreadSpecific() 方法保存该 ogles_context_t ，这样后续调用 getGlThreadSpecific() 方法时就能拿到之前保存的了；接着修改该 ogles_context_t 中的 egl_context_t.flags ，为其增加 egl_context_t::IS_CURRENT 位标识。</p>
<p>② gl 为空，即绑定一个空的 ogles_context_t ，这里认为这种情况是外部要清掉之前绑定的。因此后续会清理掉  current 。</p>
<blockquote>
<p>setGlThreadSpecific() 方法和 getGlThreadSpecific() 都是往当前线程中保存值，有点类似Java中的 ThreadLocal。</p>
</blockquote>
<p>回到  eglMakeCurrent() 方法中，前面的 makeCurrent() 方法调用成功了才会执行后续的逻辑。所以这里认为它是执行成功了。</p>
<p>而执行成功之后的逻辑，也根据 入参 ctx 是否为空 分为两种，跟上面的 makeCurrent() 方法中的两种情况一一对应：</p>
<h4 id="①-ctx-不为空"><a href="#①-ctx-不为空" class="headerlink" title="① ctx 不为空"></a>① ctx 不为空</h4><p>此时会将入参 draw 和 read 分别保存到入参 ctx 中。</p>
<p>而在保存之前，会对该 ctx 中之前保存的 draw 、read 做回收清理工作，主要是调用其 disconnect() 方法，因为 draw 、read 都是 egl_window_surface_v2_t（这里使用具体的子类来举例，下同），所以实际调用到了 egl_window_surface_v2_t 中的 disconnect() 方法中，在看 disconnect() 之前，推荐先看看 connect() 方法，所以这里先不看，等到后面一起分析。</p>
<p>在保存之后，会对新保存的 draw 和 read 执行初始化操作，即执行 connect() 方法，实际执行到  egl_window_surface_v2_t 中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/egl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_window_surface_v2_t::connect</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// nativeWindow 也就是 Surface ,这里修改 Surface 中的 mReqUsage 属性</span></span><br><span class="line">    <span class="built_in">native_window_set_usage</span>(nativeWindow, </span><br><span class="line">            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dequeue a buffer</span></span><br><span class="line">    <span class="type">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * nativeWindow 也就是 Surface，最终会调用到 Surface::dequeueBuffer 方法中</span></span><br><span class="line"><span class="comment">     * 该方法从生产消费队列中出队一个 GraphicBuffer ，并存储在当前 egl_window_surface_v2_t 实例的 buffer 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (nativeWindow-&gt;<span class="built_in">dequeueBuffer</span>(nativeWindow, &amp;buffer, &amp;fenceFd) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fence 操作，先不管</span></span><br><span class="line">    <span class="function">sp&lt;Fence&gt; <span class="title">fence</span><span class="params">(<span class="keyword">new</span> Fence(fenceFd))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (fence-&gt;<span class="built_in">wait</span>(Fence::TIMEOUT_NEVER) != NO_ERROR) &#123;</span><br><span class="line">        nativeWindow-&gt;<span class="built_in">cancelBuffer</span>(nativeWindow, buffer, fenceFd);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用这个 buffer 来更新当前宽高</span></span><br><span class="line">    width = buffer-&gt;width;</span><br><span class="line">    height = buffer-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据该 buffer 信息，来更新 depth 中的属性</span></span><br><span class="line"><span class="comment">     * depth.format 在之前的 createWindowSurface 方法中会计算并赋值，所以这里基本都不为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (depth.format) &#123;</span><br><span class="line">        depth.width   = width;</span><br><span class="line">        depth.height  = height;</span><br><span class="line">        depth.stride  = depth.width; <span class="comment">// use the width here</span></span><br><span class="line">        <span class="comment">// 计算存储这个宽高所需要的内存空间</span></span><br><span class="line">        <span class="type">uint64_t</span> allocSize = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(depth.stride) *<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(depth.height) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth.stride &lt; <span class="number">0</span> || depth.height &gt; INT_MAX || allocSize &gt; UINT32_MAX) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用计算出来的大小来分配内存</span></span><br><span class="line">        depth.data    = (GGLubyte*)<span class="built_in">malloc</span>(allocSize);</span><br><span class="line">        <span class="comment">// 分配内存失败了</span></span><br><span class="line">        <span class="keyword">if</span> (depth.data == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep a reference on the buffer</span></span><br><span class="line">    buffer-&gt;common.<span class="built_in">incRef</span>(&amp;buffer-&gt;common);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock 方法中传入了 buffer 和 bits ，而这个 bits 是 egl_window_surface_v2_t 中的属性</span></span><br><span class="line"><span class="comment">     * 在 lock() 方法执行完毕之后他就会指向该 buffer 地址，两者此时共享同一块内存地址，</span></span><br><span class="line"><span class="comment">     * 同时该内存地址被锁住，禁止其他人修改。后续使用 gl 去操作 bits 就行了，也就是可以往 buffer 中写入了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lock</span>(buffer, GRALLOC_USAGE_SW_READ_OFTEN | </span><br><span class="line">            GRALLOC_USAGE_SW_WRITE_OFTEN, &amp;bits) != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;connect() failed to lock buffer %p (%ux%u)&quot;</span>,</span><br><span class="line">                buffer, buffer-&gt;width, buffer-&gt;height);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> we should make sure we&#x27;re not accessing the buffer anymore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">egl_window_surface_v2_t::disconnect</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// buffer 和 bits 都有值，那么之前的 lock 方法执行完毕了，此时需要 unlock </span></span><br><span class="line">    <span class="keyword">if</span> (buffer &amp;&amp; bits) &#123;</span><br><span class="line">        bits = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">unlock</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消掉该 buffer ，这个 buffer 就是之前在 connect() 时从 nativeWindow 中出队的那个</span></span><br><span class="line">    <span class="keyword">if</span> (buffer) &#123;</span><br><span class="line">        nativeWindow-&gt;<span class="built_in">cancelBuffer</span>(nativeWindow, buffer, <span class="number">-1</span>);</span><br><span class="line">        buffer-&gt;common.<span class="built_in">decRef</span>(&amp;buffer-&gt;common);</span><br><span class="line">        buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前一个 buffer ，后续如果调用 eglSwapBuffers 方法的话，则它里面会有值</span></span><br><span class="line">    <span class="keyword">if</span> (previousBuffer) &#123;</span><br><span class="line">        previousBuffer-&gt;common.<span class="built_in">decRef</span>(&amp;previousBuffer-&gt;common); </span><br><span class="line">        previousBuffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里按照顺序，先看 connect() ，再看  disconnect() 。</p>
<p>对于 connect() 方法来说，它内部主要完成三件事：</p>
<p>① 调用其内部 nativeWindow 的 dequeueBuffer() 方法来从生产消费队列中出队一个 GraphicBuffer ，将其赋值给内部的 buffer 属性。而它内部的 nativeWindow 属性，是在前面调用 createWindowSurface() 方法来创建该 egl_window_surface_v2_t 实例时保存的，具体保存的就是当时外部传入进来的 Surface 实例。</p>
<p>② 将这个刚出队的 buffer 中的宽高等属性更新到当前 egl_window_surface_v2_t 实例中的对应属性中，比如其内部的 width、height，以及其内部的 depth 实例中。</p>
<p>注意这里 depth 属性是属于其父类 egl_surface_t 的，它是 GGLSurface 类型的，它内部的 format 属性在前面执行 createWindowSurface() 方法时计算并赋值的，所以到这里 depth.format 基本都是有值的。</p>
<p>另外，这里在初始化 depth 内部属性时，还会给其 data 属性分配内存，内存大小会通过 buffer 的宽高属性来计算出来。</p>
<p>③ 最后就是调用 lock() 方法来将该 bufffer 对应的内存锁起来，不让其他人修改，锁定完成后，会将其地址赋值给入参 bits ，也就是当前 egl_window_surface_v2_t 实例中的  bits 属性，后续这个 bits 和 buffer 就对应同一块内存了，访问bits也可以操作这块儿内存了。而这里为啥要 锁定呢？这里先不讲，等到后续会专门讲讲它。暂时我们只需要知道需要有  lock() 这一步操作就行。</p>
<p>好了，接着分析 disconnect() 方法，在 disconnect() 方法中首先会尝试去解锁 buffer所对应的内存，后续其他人就可以复用这块儿内存去操作了。接着会将该 buffer 放回到生产消费队列，别的生产者就可以使用它了。</p>
<p>接着往下会分别调用新绑定的 draw 和 read 的 bindDrawSurface() 方法和 bindReadSurface() 方法，同样还是调用到 egl_window_surface_v2_t 中，这里先看比较复杂的前者：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/egl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_window_surface_v2_t::bindDrawSurface</span><span class="params">(<span class="type">ogles_context_t</span>* gl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 GGLSurface ，然后将 egl_window_surface_v2_t 中的数据b保存到 GGLSurface 中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 前面 makeCurrent 中会先调用其 connect 方法，在该方法中会出队一个 GraphicBuffer 并使用 buffer 指向它</span></span><br><span class="line"><span class="comment">     * 所以此时它就可以直接使用，比如下面拿它的宽高</span></span><br><span class="line"><span class="comment">     * 而前面 connect 方法中还会调用 lock 来将 bits 和 buffer 的内存绑定共享起来，后续操作bits 就行了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    GGLSurface buffer;</span><br><span class="line">    buffer.version = <span class="built_in">sizeof</span>(GGLSurface);</span><br><span class="line">    buffer.width   = <span class="keyword">this</span>-&gt;buffer-&gt;width;</span><br><span class="line">    buffer.height  = <span class="keyword">this</span>-&gt;buffer-&gt;height;</span><br><span class="line">    buffer.stride  = <span class="keyword">this</span>-&gt;buffer-&gt;stride;</span><br><span class="line">    buffer.data    = (GGLubyte*)bits;</span><br><span class="line">    buffer.format  = <span class="keyword">this</span>-&gt;buffer-&gt;format;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * procs 是 GGLContext ,其 colorBuffer 方法对应的是 ggl_colorBuffer</span></span><br><span class="line"><span class="comment">     * 上面封装的 GGLSurface 其实就是为了这里传入进去。方便里面使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    gl-&gt;rasterizer.procs.<span class="built_in">colorBuffer</span>(gl, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (depth.data != gl-&gt;rasterizer.state.buffers.depth.data)</span><br><span class="line">        gl-&gt;rasterizer.procs.<span class="built_in">depthBuffer</span>(gl, &amp;depth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会接收一个参数，而此时外部传入的是入参 EGLContext ctx 对应的真正的 ogles_context_t 实例。</p>
<p>接着会新建一个 GGLSurface 实例，然后将当前 egl_window_surface_v2_t 实例中的属性赋值给它，比如它的宽高信息就是从 egl_window_surface_v2_t.buffer 中拿到的，而这个 buffer 在前面 connect() 时已经有值了；另外还会将 egl_window_surface_v2_t.bits 保存起来，而这个 bits 就是前面 connect() 时，通过调用 lock() 方法赋值的属性，它指向 buffer 对应的内存空间。</p>
<p>接着会调用：gl-&gt;rasterizer.procs.colorBuffer() 方法，并且将这里的入参 gl 和新创建并赋值的 GGLSurface 实例传入进去。这里的 gl-&gt;rasterizer.procs 是啥呢？由于 gl 它是 ogles_context_t 类型的，那我们看看它的初始化，也就是前面  <a href="3341fdf3.html">GLES&amp;EGL-EGL-02</a>  在分析 eglCreateContext() 方法时会有对他的初始化工作，具体是： eglCreateContext() -&gt; ogles_init() 中，而当时对这个  ogles_init() 方法只是很简略的看了看，那么这里再来看看该方法中是怎么对其 rasterizer.procs 属性赋值的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/state.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ogles_context_t</span> *<span class="title">ogles_init</span><span class="params">(<span class="type">size_t</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> base = <span class="built_in">malloc</span>(extra + <span class="built_in">sizeof</span>(<span class="type">ogles_context_t</span>) + <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> (!base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ogles_context_t</span> *c = (<span class="type">ogles_context_t</span> *)((<span class="built_in">ptrdiff_t</span>(base) + extra + <span class="number">31</span>) &amp; ~<span class="number">0x1F</span>L);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">ogles_context_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 c-&gt;rasterizer ，也就是 context_t 类型的属性</span></span><br><span class="line">    <span class="built_in">ggl_init_context</span>(&amp;(c-&gt;rasterizer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先省略其他的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_init_context</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">context_t</span>));</span><br><span class="line">    <span class="comment">// 初始化 context_t 中的 procs 属性</span></span><br><span class="line">    <span class="built_in">ggl_init_procs</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化其他的属性</span></span><br><span class="line">    <span class="built_in">ggl_init_trap</span>(c);</span><br><span class="line">    <span class="built_in">ggl_init_scanline</span>(c);</span><br><span class="line">    <span class="built_in">ggl_init_texture</span>(c);</span><br><span class="line">    <span class="built_in">ggl_init_picker</span>(c);</span><br><span class="line">    <span class="built_in">ggl_init_raster</span>(c);</span><br><span class="line">    c-&gt;formats = <span class="built_in">gglGetPixelFormatTable</span>();</span><br><span class="line">    c-&gt;state.blend.src = GGL_ONE;</span><br><span class="line">    c-&gt;state.blend.dst = GGL_ZERO;</span><br><span class="line">    c-&gt;state.blend.src_alpha = GGL_ONE;</span><br><span class="line">    c-&gt;state.blend.dst_alpha = GGL_ZERO;</span><br><span class="line">    c-&gt;state.mask.color = <span class="number">0xF</span>;</span><br><span class="line">    c-&gt;state.mask.depth = <span class="number">0</span>;</span><br><span class="line">    c-&gt;state.mask.stencil = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    c-&gt;state.logic_op.opcode = GGL_COPY;</span><br><span class="line">    c-&gt;state.alpha_test.func = GGL_ALWAYS;</span><br><span class="line">    c-&gt;state.depth_test.func = GGL_LESS;</span><br><span class="line">    c-&gt;state.depth_test.clearValue = FIXED_ONE;</span><br><span class="line">    c-&gt;shade.w0 = FIXED_ONE;</span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;ditherMatrix, gDitherMatrix, <span class="built_in">sizeof</span>(gDitherMatrix));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_init_procs</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 给 GGLContext 中的这些函数绑定实际的值</span></span><br><span class="line">    <span class="comment">// GGL_INIT_PROC 中其实就是绑定函数，绑定规则是在其前面加上 ggl_ </span></span><br><span class="line">    GGLContext&amp; procs = *(GGLContext*)c;</span><br><span class="line">    <span class="comment">// 比如将 procs.scissor 绑定为当前类中的 ggl_scissor 方法 ，其他方法类似</span></span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, scissor);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, activeTexture);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, bindTexture);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, bindTextureLod);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, colorBuffer);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, readBuffer);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, depthBuffer);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, enable);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, disable);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, enableDisable);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, shadeModel);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, color4xv);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, colorGrad12xv);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, zGrad3xv);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, wGrad3xv);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, fogGrad3xv);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, fogColor3xv);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, blendFunc);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, blendFuncSeparate);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, texEnvi);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, texEnvxv);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, texParameteri);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, texCoord2i);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, texCoord2x);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, texCoordGradScale8xv);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, texGeni);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, colorMask);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, depthMask);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, stencilMask);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, alphaFuncx);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, depthFunc);</span><br><span class="line">    <span class="built_in">GGL_INIT_PROC</span>(procs, logicOp);</span><br><span class="line">    <span class="built_in">ggl_init_clear</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/private/pixelflinger/ggl_context.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GGL_INIT_PROC(p, f)         p.f = ggl_ ## f;</span></span><br></pre></td></tr></table></figure>

<p>ak可以看到，在 ogles_init() 方法中就会对该 ogles_context_t 实例中的 rasterizer.procs 属性赋值，赋值规则是通过 GGL_INIT_PROC 宏定义来实现的，即给定义的函数名前面加上  ggl_ 前缀，然后使用这个新名称作为其对应的实现函数，而这些实现函数基本都在 pixelflinger.cpp 中。</p>
<p>所以我们这里要找的 colorBuffer() 方法实际就是 pixelflinger.cpp 中的 ggl_colorBuffer() 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/private/pixelflinger/ggl_context.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GGL_CONTEXT(con, c)         context_t *(con) = static_cast<span class="string">&lt;context_t *&gt;</span>(c) <span class="comment">/* NOLINT */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_colorBuffer</span><span class="params">(<span class="type">void</span>* con, <span class="type">const</span> GGLSurface* surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GGL_CONTEXT 宏会将传入的 con 转换为 context_t ，然后让 c 指向它</span></span><br><span class="line"><span class="comment">     * 而此时这个 con 实际是 ogles_context_t 类型的，并且它内部定义的第一个属性就是 context_t 类型的 rasterizer</span></span><br><span class="line"><span class="comment">     * 所以这里可以将其转为 context_t 来使用，也就是说后续的 c 就是 ogles_context_t.rasterizer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本次新的 surface 中的格式和该 ogles_context_t 中之前的格式不一样，即格式发生变化了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (surface-&gt;format != c-&gt;state.buffers.color.format)</span><br><span class="line">        <span class="built_in">ggl_state_changed</span>(c, GGL_CB_STATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大小发生变化，此时重新为coverage 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (surface-&gt;width &gt; c-&gt;state.buffers.coverageBufferSize) &#123;</span><br><span class="line">        <span class="built_in">free</span>(c-&gt;state.buffers.coverage);</span><br><span class="line">        c-&gt;state.buffers.coverage = (<span class="type">int16_t</span>*)<span class="built_in">malloc</span>(surface-&gt;width * <span class="number">2</span>);</span><br><span class="line">        c-&gt;state.buffers.coverageBufferSize = c-&gt;state.buffers.coverage ? surface-&gt;width : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将传进来的 GGLSurface 中的属性设置给 context_t 的 buffers.color</span></span><br><span class="line"><span class="comment">     * 后续 gl 操作 buffers.color 时，就相当于操作了 GraphicBuffer 了，可以往里面写入渲染数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">ggl_set_surface</span>(c, &amp;(c-&gt;state.buffers.color), surface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次时，顺带同时设置给 context_t 的 buffers.read</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;state.buffers.read.format == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ggl_set_surface</span>(c, &amp;(c-&gt;state.buffers.read), surface);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ggl_set_scissor</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/buffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_set_surface</span><span class="params">(<span class="type">context_t</span>* c, <span class="type">surface_t</span>* dst, <span class="type">const</span> GGLSurface* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 就是将 src 中的属性挨个赋值到 dst 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dst-&gt;width = src-&gt;width;</span><br><span class="line">    dst-&gt;height = src-&gt;height;</span><br><span class="line">    dst-&gt;stride = src-&gt;stride;</span><br><span class="line">    dst-&gt;data = src-&gt;data;</span><br><span class="line">    dst-&gt;format = src-&gt;format;</span><br><span class="line">    dst-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(dst-&gt;stride &lt; <span class="number">0</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> GGLFormat&amp; <span class="title">pixelFormat</span><span class="params">(c-&gt;formats[dst-&gt;format])</span></span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> bpr = -dst-&gt;stride * pixelFormat.size;</span><br><span class="line">        dst-&gt;data += bpr * (dst-&gt;height<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次提醒下，这里的第一个入参是 gl，实际是 ogles_context_t 类型的，并且在 ogles_context_t 中，其内部定义的第一个属性就是 context_t 类型的 rasterizer 。因此这里可以通过 GGL_CONTEXT 宏来将其转为  context_t 类型来使用，所以后续对于 c 的操作，都是相当于在操作 ogles_context_t.rasterizer 。</p>
<p>在 ggl_colorBuffer() 方法中，会将新传入的 GGLSurface，它内部存储着当前状态下新的属性，将这些新的属性保存到 ogles_context_t.rasterizer 中的对应属性中。所以 在 ggl_colorBuffer() 方法中不管是执行的 ggl_state_changed() 方法，还是 ggl_set_surface() 方法，都是完成对应属性更新赋值的，而具体更新的是哪个属性？该属性有啥用？这些都不用先在这里纠结，等后面实际遇到一个再讲一个吧，不然啥时候能讲完呀。我们先只关注大概的，熟悉了大的框架之后，再慢慢填充细节，不然一直纠结在一块儿就会越陷越深，最后也不知道自己看了个啥。</p>
<p>接着回到 bindDrawSurface() 方法中，往下又遇到了一个 gl-&gt;rasterizer.procs.depthBuffer() 方法，它执行的前提是：当前 egl_window_surface_v2_t 中的 depth.data 和 gl-&gt;rasterizer.state.buffers.depth.data 不相等，而前者在前面 connect() 中刚被赋值，赋值为对应的刚分配内存，所以这里一般是不相等的，接着会执行 gl-&gt;rasterizer.procs.depthBuffer() 方法，那么此时找该方法的实现就很简单了吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_depthBuffer</span><span class="params">(<span class="type">void</span>* con, <span class="type">const</span> GGLSurface* surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 又是这个 宏定义</span></span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">    <span class="keyword">if</span> (surface-&gt;format == GGL_PIXEL_FORMAT_Z_16) &#123;</span><br><span class="line">        <span class="comment">// 将 surface 中新的属性赋值给 c-&gt;state.buffers.depth 中</span></span><br><span class="line">        <span class="built_in">ggl_set_surface</span>(c, &amp;(c-&gt;state.buffers.depth), surface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;state.buffers.depth.format = GGL_PIXEL_FORMAT_NONE;</span><br><span class="line">        <span class="built_in">ggl_enable_depth_test</span>(c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着简单再瞅瞅 bindReadSurface() 方法吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/egl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_window_surface_v2_t::bindReadSurface</span><span class="params">(<span class="type">ogles_context_t</span>* gl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 同样是先将属性封装到一个 GGLSurface 实例中</span></span><br><span class="line">    GGLSurface buffer;</span><br><span class="line">    buffer.version = <span class="built_in">sizeof</span>(GGLSurface);</span><br><span class="line">    buffer.width   = <span class="keyword">this</span>-&gt;buffer-&gt;width;</span><br><span class="line">    buffer.height  = <span class="keyword">this</span>-&gt;buffer-&gt;height;</span><br><span class="line">    buffer.stride  = <span class="keyword">this</span>-&gt;buffer-&gt;stride;</span><br><span class="line">    buffer.data    = (GGLubyte*)bits; <span class="comment">// <span class="doctag">FIXME:</span> hopefully is is LOCKED!!!</span></span><br><span class="line">    buffer.format  = <span class="keyword">this</span>-&gt;buffer-&gt;format;</span><br><span class="line">    <span class="comment">// 调用 readBuffer 方法</span></span><br><span class="line">    gl-&gt;rasterizer.procs.<span class="built_in">readBuffer</span>(gl, &amp;buffer);</span><br><span class="line">    <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_readBuffer</span><span class="params">(<span class="type">void</span>* con, <span class="type">const</span> GGLSurface* surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">    <span class="built_in">ggl_set_surface</span>(c, &amp;(c-&gt;state.buffers.read), surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上面基本一样，就不赘述了。</p>
<p>看完这俩方法，其实可以明白：在 egl_window_surface_v2_t 中的属性，好多都会在 ogles_context_t.rasterizer 中有对应的副本，这里的 egl_window_surface_v2_t 中属性发生变化就应该要更新到 ogles_context_t.rasterizer 中去。比如这里的 egl_window_surface_v2_t.depth.data 就对应的是ogles_context_t-&gt;rasterizer.state.buffers.depth.data ，如果他俩此时不相等了，表示外部的 egl_window_surface_v2_t.depth.data 刚发生了变化，比如刚刚的 egl_window_surface_v2_t::connect() 方法中确实改了这个 data，所以此时就需要调用对应的方法将这个新的值更新进去。其他的属性也类似。</p>
<p>好了，至此，我们就看完了上面的第一种情况，即 ctx 不为空的情况。</p>
<h4 id="②-ctx-为空"><a href="#②-ctx-为空" class="headerlink" title="② ctx 为空"></a>② ctx 为空</h4><p>这种情况的处理就比较简单了，和上面的 makeCurrent() 方法保持一致，将当前线程中之前保存 EGLContext ，也就是 current_ctx 属性给断开，主要是断开其内部的  draw  和 read ，并且重置这俩状态。</p>
<p>至此，就将 libagl 中的  eglMakeCurrent() 逻辑分析完毕了，接下来回到 egl 模块中的  egl_platform_entries.cpp#eglMakeCurrentImpl() 方法内接着往下执行。</p>
<p>如果结果libagl 那边返回的结果是成功了的，此时会执行两个操作：</p>
<p>① 将 c-&gt;cnx-&gt;hooks[c-&gt;version] 的值保存到当前线程中去。这个值对应着当前要是用的 OpenGL ES 版本，是1.x还是2.x。它在前面的 eglCreateContextImpl() 时，会在返回最终的 egl_context_t 实例时计算并保存的，它的取值是：egl_connection_t::GLESv1_INDEX 或者  egl_connection_t::GLESv2_INDEX 。</p>
<p>而这里通过这个 version 拿到 c-&gt;cnx-&gt;hooks 数组中对应的实例保存起来，后续就可以获取使用了。</p>
<p>② 调用 egl_tls_t::setContext(ctx) 方法来将当前 makeCurrent() 成功的 EGLContext 保存到当前线程中，后续通过 getContext() 方法就能拿到了。</p>
<p>至此 eglMakeCurrent() 方法就执行完毕了。因此说，该方法可以将 EGLContext 和 EGLSurface 绑定起来，并且将该 EGLContext 保存到当前线程中，后续就可以在该线程中执行 OpenGL ES 操作来绘制内容了。</p>
<h3 id="eglSwapBuffers"><a href="#eglSwapBuffers" class="headerlink" title="eglSwapBuffers"></a>eglSwapBuffers</h3><p>前面执行完 eglMakeCurrent() 方法之后，此时 EGLSurface 和 EGLContext 就绑定起来了，后续就可以使用 OpenGL ES ，也就是一系列的 glXXXX 方法来操作该 EGLSurface 了，也就是使用画笔在这个画板上绘画了。</p>
<p>而每绘画完一帧，就需要调用当前方法来刷新该帧，并且准备好下一帧的空间。</p>
<p>下面看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/eglApi.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglSwapBuffers</span><span class="params">(EGLDisplay dpy, EGLSurface surface)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">clearError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">egl_connection_t</span>* <span class="type">const</span> cnx = &amp;gEGLImpl;</span><br><span class="line">    <span class="keyword">return</span> cnx-&gt;platform.<span class="built_in">eglSwapBuffers</span>(dpy, surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时从 eglApi 中还是会调用到 egl_platform_entries.cpp 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/egl_platform_entries.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglSwapBuffersImpl</span><span class="params">(EGLDisplay dpy, EGLSurface surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里后两个参数分别传入的是 null 和 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eglSwapBuffersWithDamageKHRImpl</span>(dpy, surface, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglSwapBuffersWithDamageKHRImpl</span><span class="params">(EGLDisplay dpy, EGLSurface draw,</span></span></span><br><span class="line"><span class="params"><span class="function">        EGLint *rects, EGLint n_rects)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 拿到该 dpy 对应的 egl_display_t 实例</span></span><br><span class="line">    <span class="type">const</span> egl_display_ptr dp = <span class="built_in">validate_display</span>(dpy);</span><br><span class="line">    <span class="keyword">if</span> (!dp) <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    SurfaceRef _s(dp.<span class="built_in">get</span>(), draw);</span><br><span class="line">    <span class="keyword">if</span> (!_s.<span class="built_in">get</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_SURFACE, (EGLBoolean)EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * draw 是 EGLSurface，那么它的实际类型就是 egl侧(非 libagl 的)的 egl_surface_t </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">egl_surface_t</span>* <span class="type">const</span> s = <span class="built_in">get_surface</span>(draw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这三个先不考虑</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(dp-&gt;traceGpuCompletion)) &#123;</span><br><span class="line">        EGLSyncKHR sync = <span class="built_in">eglCreateSyncKHR</span>(dpy, EGL_SYNC_FENCE_KHR, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (sync != EGL_NO_SYNC_KHR) &#123;</span><br><span class="line">            FrameCompletionThread::<span class="built_in">queueSync</span>(sync);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(dp-&gt;finishOnSwap)) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> pixel;</span><br><span class="line">        <span class="type">egl_context_t</span> * <span class="type">const</span> c = <span class="built_in">get_context</span>( <span class="type">egl_tls_t</span>::<span class="built_in">getContext</span>() );</span><br><span class="line">        <span class="keyword">if</span> (c) &#123;</span><br><span class="line">            <span class="comment">// glReadPixels() ensures that the frame is complete</span></span><br><span class="line">            s-&gt;cnx-&gt;hooks[c-&gt;version]-&gt;gl.<span class="built_in">glReadPixels</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">                    GL_RGBA,GL_UNSIGNED_BYTE,&amp;pixel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;cnx-&gt;angleBackend != EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">sendSurfaceMetadata</span>(s)) &#123;</span><br><span class="line">            <span class="built_in">native_window_api_disconnect</span>(s-&gt;<span class="built_in">getNativeWindow</span>(), NATIVE_WINDOW_API_EGL);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_NATIVE_WINDOW, (EGLBoolean)EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 eglSwapBuffersImpl 过来的话，n_rects 就是 0，所以会走这里</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (n_rects == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;cnx-&gt;egl.<span class="built_in">eglSwapBuffers</span>(dp-&gt;disp.dpy, s-&gt;surface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">android_native_rect_t</span>&gt; <span class="title">androidRects</span><span class="params">((<span class="type">size_t</span>)n_rects)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n_rects; ++r) &#123;</span><br><span class="line">        <span class="type">int</span> offset = r * <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> x = rects[offset];</span><br><span class="line">        <span class="type">int</span> y = rects[offset + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> width = rects[offset + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> height = rects[offset + <span class="number">3</span>];</span><br><span class="line">        <span class="type">android_native_rect_t</span> androidRect;</span><br><span class="line">        androidRect.left = x;</span><br><span class="line">        androidRect.top = y + height;</span><br><span class="line">        androidRect.right = x + width;</span><br><span class="line">        androidRect.bottom = y;</span><br><span class="line">        androidRects.<span class="built_in">push_back</span>(androidRect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;cnx-&gt;angleBackend != EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE) &#123;</span><br><span class="line">        <span class="built_in">native_window_set_surface_damage</span>(s-&gt;<span class="built_in">getNativeWindow</span>(), androidRects.<span class="built_in">data</span>(), androidRects.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据当前EGL实现库中是否包含 eglSwapBuffersWithDamageKHR 方法来决定是否要调用他</span></span><br><span class="line">    <span class="comment">// 如果包含这个优化的方法，就调用 Android 平台优化过的 eglSwapBuffersWithDamageKHR 交换缓冲区方法</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;cnx-&gt;egl.eglSwapBuffersWithDamageKHR) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;cnx-&gt;egl.<span class="built_in">eglSwapBuffersWithDamageKHR</span>(dp-&gt;disp.dpy, s-&gt;surface, rects, n_rects);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则将会调用通用eglSwapBuffers</span></span><br><span class="line">        <span class="keyword">return</span> s-&gt;cnx-&gt;egl.<span class="built_in">eglSwapBuffers</span>(dp-&gt;disp.dpy, s-&gt;surface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，兜兜转转，还是会调用到 libagl 侧的 eglSwapBuffers() 方法中。</p>
<blockquote>
<p>这里暂时只分析 eglSwapBuffers() 方法，尽管另外一个 egl.eglSwapBuffersWithDamageKHR() 方法也可能会被调用，但是由于 libagl 中没有对 eglSwapBuffersWithDamageKHR() 方法进行实现，所以也没办法看它，只能看 eglSwapBuffers() 方法咯。但是大同小异，看懂一个的话，另外一个差不太多。</p>
</blockquote>
<p>下面看 libagl 侧的 eglSwapBuffers() 实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/egl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglSwapBuffers</span><span class="params">(EGLDisplay dpy, EGLSurface draw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 基本操作，检查参数合法性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">egl_display_t</span>::<span class="built_in">is_valid</span>(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将其转为 egl_surface_t ，但实际是其某个子类</span></span><br><span class="line">    <span class="type">egl_surface_t</span>* d = <span class="built_in">static_cast</span>&lt;<span class="type">egl_surface_t</span>*&gt;(draw);</span><br><span class="line">    <span class="keyword">if</span> (!d-&gt;<span class="built_in">isValid</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;dpy != dpy)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比如执行到 egl_window_surface_v2_t::swapBuffers 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    d-&gt;<span class="built_in">swapBuffers</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次尝试绑定，和前面 eglMakeCurrent 中差不多</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ctx != EGL_NO_CONTEXT) &#123;</span><br><span class="line">        d-&gt;<span class="built_in">bindDrawSurface</span>((<span class="type">ogles_context_t</span>*)d-&gt;ctx);</span><br><span class="line">        <span class="comment">// if this surface is also the read surface of the context</span></span><br><span class="line">        <span class="comment">// it is bound to, make sure to update the read buffer as well.</span></span><br><span class="line">        <span class="comment">// The EGL spec is a little unclear about this.</span></span><br><span class="line">        <span class="type">egl_context_t</span>* c = <span class="type">egl_context_t</span>::<span class="built_in">context</span>(d-&gt;ctx);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;read == draw) &#123;</span><br><span class="line">            d-&gt;<span class="built_in">bindReadSurface</span>((<span class="type">ogles_context_t</span>*)d-&gt;ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 libagl 的 eglSwapBuffers() 方法中，逻辑比较简单，最重要的就是其调用的 swapBuffers() 方法，该方法中完成了绝大部分的逻辑。而这个 swapBuffers() 方法调用的是 egl_surface_t 中的，也就是由入参 EGLSurface 转换过来的。从前面的知识可知：EGLSurface 实际对应的是 egl_surface_t 的子类实现，下面就以 egl_window_surface_v2_t 为例子进行分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/egl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_window_surface_v2_t::swapBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当前这种情况下，dirtyRegion 为空，所以内部的逻辑暂时不考虑</span></span><br><span class="line"><span class="comment">     * 而如果外部调用了 eglSetSwapRectangleANDROID 方法的话，则这里的值就不是空的了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 整个 buffer 区域都认为是脏区，所以这里将 整个buffer 的区域并集并入到 dirtyRegion 中</span></span><br><span class="line"><span class="comment">         * 而这里的 buffer ，是之前在 makeCurrent 中调用了 connect 方法来从Surface 中出队的一个 GraphicBuffer</span></span><br><span class="line"><span class="comment">         * 然后在 connect 中会 lock 住它。然后就开始执行 gl 方法来在它上面进行绘制了</span></span><br><span class="line"><span class="comment">         * 绘制完成后，调用当前方法了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dirtyRegion.<span class="built_in">andSelf</span>(<span class="built_in">Rect</span>(buffer-&gt;width, buffer-&gt;height));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一次调用 swapBuffers 时， previousBuffer 为空，buffer 不为空</span></span><br><span class="line"><span class="comment">         * 而后续调用 swapBuffers 时，previousBuffer 就不为空了，指向的是上次的 buffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (previousBuffer) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * subtract 相当于 相当于 A &amp; ~B ，也就是 A 和 非B 求交集</span></span><br><span class="line"><span class="comment">             * 所以这里求出的 copyBack 是判断出 本次脏区和老的脏区 是否完全覆盖，不是的话，</span></span><br><span class="line"><span class="comment">             * 则需要将老脏区所没[被覆盖]的区域赋值到新buffer中去,因为该区域也要显示嘛</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">/*const*/</span> <span class="function">Region <span class="title">copyBack</span><span class="params">(Region::subtract(oldDirtyRegion, dirtyRegion))</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!copyBack.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="type">void</span>* prevBits;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">lock</span>(previousBuffer, GRALLOC_USAGE_SW_READ_OFTEN, &amp;prevBits) == NO_ERROR) &#123;</span><br><span class="line">                    <span class="comment">// copy from previousBuffer to buffer</span></span><br><span class="line">                    <span class="built_in">copyBlt</span>(buffer, bits, previousBuffer, prevBits, copyBack);</span><br><span class="line">                    <span class="built_in">unlock</span>(previousBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将本次脏区保存起来，供下一次使用</span></span><br><span class="line">        oldDirtyRegion = dirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置掉 previousBuffer 中存储的值，它存储的是上一次 swapBuffer 时的 GraphicBuffer 。</span></span><br><span class="line"><span class="comment">     * 它的赋值在下面，马上就能看到了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (previousBuffer) &#123;</span><br><span class="line">        previousBuffer-&gt;common.<span class="built_in">decRef</span>(&amp;previousBuffer-&gt;common); </span><br><span class="line">        previousBuffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在前面 connect 时，会给刚出队的 buffer 进行 lock 操作，也就是会将该buffer 对用的内存锁住，放置其他人修改</span></span><br><span class="line"><span class="comment">     * 然后接着 balabala 一阵 gl 操作之后，此时 buffer 中已经存储着被 gl 操作绘制完的、待消费的数据了</span></span><br><span class="line"><span class="comment">     * 所以在将其放回到 生产消费者队列之前，得先将其 unlock 掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">unlock</span>(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后使用 previousBuffer 指向它</span></span><br><span class="line">    previousBuffer = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将填充好数据的 buffer 入队到生产消费队列中等待消费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    nativeWindow-&gt;<span class="built_in">queueBuffer</span>(nativeWindow, buffer, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 最后将 buffer  置空</span></span><br><span class="line">    buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个 buffer 被生产者填充完数据放入了队列，那么同时得再从队列中取出来一个，用于下一帧绘制</span></span><br><span class="line"><span class="comment">     * 下面的操作就跟之前的 connect() 方法中类似了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (nativeWindow-&gt;<span class="built_in">dequeueBuffer</span>(nativeWindow, &amp;buffer, &amp;fenceFd) == NO_ERROR) &#123;</span><br><span class="line">        <span class="function">sp&lt;Fence&gt; <span class="title">fence</span><span class="params">(<span class="keyword">new</span> Fence(fenceFd))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (fence-&gt;<span class="built_in">wait</span>(Fence::TIMEOUT_NEVER)) &#123;</span><br><span class="line">            nativeWindow-&gt;<span class="built_in">cancelBuffer</span>(nativeWindow, buffer, fenceFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 新出队的 Buffer 的宽高和之前的宽高作比较，如果不一样的话，则需要重新分配内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((width != buffer-&gt;width) || (height != buffer-&gt;height)) &#123;</span><br><span class="line">            width = buffer-&gt;width;</span><br><span class="line">            height = buffer-&gt;height;</span><br><span class="line">            <span class="comment">// 如果之前分配过内存，比如在 connect 中</span></span><br><span class="line">            <span class="keyword">if</span> (depth.data) &#123;</span><br><span class="line">                <span class="comment">// 先释放之前的内存</span></span><br><span class="line">                <span class="built_in">free</span>(depth.data);</span><br><span class="line">                <span class="comment">// 再重新分配新的内存</span></span><br><span class="line">                depth.width   = width;</span><br><span class="line">                depth.height  = height;</span><br><span class="line">                depth.stride  = buffer-&gt;stride;</span><br><span class="line">                <span class="type">uint64_t</span> allocSize = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(depth.stride) * <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(depth.height) * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (depth.stride &lt; <span class="number">0</span> || depth.height &gt; INT_MAX || allocSize &gt; UINT32_MAX) &#123;</span><br><span class="line">                    <span class="built_in">setError</span>(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">                    <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">                depth.data = (GGLubyte*)<span class="built_in">malloc</span>(allocSize);</span><br><span class="line">                <span class="keyword">if</span> (depth.data == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">setError</span>(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">                    <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新出队的 buffer 都需要自增引用</span></span><br><span class="line">        buffer-&gt;common.<span class="built_in">incRef</span>(&amp;buffer-&gt;common);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并且 lock 住，和前面 connect 是一样的，最终 bits 指向这个新的 buffer 锁定之后的内存地址</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lock</span>(buffer, GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, &amp;bits) != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;eglSwapBuffers() failed to lock buffer %p (%ux%u)&quot;</span>,</span><br><span class="line">                    buffer, buffer-&gt;width, buffer-&gt;height);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setError</span>(EGL_BAD_CURRENT_SURFACE, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析这里的 swapBuffers() 方法之前，我想讲一下 EGL ，以及 OpenGL ES 的使用中，在当前方法之前的前置操作，相当于是当前方法执行的背景环境吧，更方便理解:</p>
<p>我们按照前面的步骤，获取 display，创建 EGLContent 和 EGLSurface 之后，再调用 eglMakeCurrent() 方法。此时会将 EGLContext 和 EGLSurface 绑定起来，注意这个时候同样会调用 EGLSurface 的 connect() 方法，该方法中会从其内部的 nativeWindow ，也就是 Surface 中，出队一个 GraphicBuffer ，存储在其内部的 buffer 属性中。</p>
<p>接着就可以使用 OpenGL ES 中一系列的 glXXX() 方法来在这个 EGLSurface 上绘制内容了，绘制的内容就会被存储在 buffer 所对应的内存中，为了防止在绘制过程中，别人也修改这段内存，所以需要在该 GraphicBuffer 出队之后，立马调用 lock() 方法来将其锁住。</p>
<p>等绘制完一帧之后，就可以调用当前 eglSwapBuffer() 方法来提交已经绘制好的内容，此时也就会执行到这里。</p>
<p>看完上面的背景条件，我们后续的分析就更容易理解了。在这里的swapBuffers() 方法中，会依次执行如下几步：</p>
<p>① 重置掉 previousBuffer 中的属性，因为它即将要被赋予新的值了。</p>
<p>② 调用 unlock() 方法来解锁 buffer 对应的内存，因此时 gl 绘制操作已经结束了，当前 buffer 中已经填充好了数据，接下来要将其放到生产消费队列中等待消费者去消费了，所以得将其解锁了。加锁只是为了防止在 gl 绘制过程中，其他人同时修改。</p>
<p>③ 将 buffer 保存给 previousBuffer ，然后将该 buffer 通过 nativeWindow-&gt;queueBuffer() 方法入队。入队之后将 buffer 置为 0。</p>
<p>④ 接下就类似于前面 connect() 中的逻辑了。先调用 nativeWindow-&gt;dequeueBuffer() 方法来再从队列中出队一个 GraphicBuffer ，复制给 buffer 。接着判断前后这俩 GraphicBuffer 的宽高是否发生了变化，是的话则更新内部 width、height 以及 depth 中的属性。接着还是调用 lock() 方法来将这个新出队的 buffer 锁住，同时 bits 属性也会指向它。接着后续就可以再使用 gl 去绘制下一帧内容了。</p>
<p>至此，就完成了对 eglSwapBuffers() 方法的分析。在后续的操作中，可以使用 gl 操作绘制内容，然后调用 eglSwapBuffers() 方法来将绘制好的帧提交到生产消费队列中，等待消费者那边去处理，其实也就是显示出来。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/OpenGLES/">OpenGLES</a>
		  
			<a href="/tags/EGL/">EGL</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/e803de1e.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">GLES&EGL-GLES-01</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/3341fdf3.html">
        <span class="next-text nav-default">GLES&EGL-EGL-02</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
