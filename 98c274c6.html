<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="BufferQueue 简介"/>




  <meta name="keywords" content="BufferQueue," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/98c274c6.html"/>


<meta name="description" content="在 Android 图形系统中有一个很重要的角色：BufferQueue ，从其名称也能看出来，它是一个队列。而这个队列的作用是什么呢？引用下官方对于它的总结：  BufferQueues 是 Android 图形组件之间的粘合剂，它们是一对队列，可以调解缓冲区从生产方到消耗方的固定周期。一旦生产方移交其缓冲区，SurfaceFlinger 便会负责将所有内容合成到显示部分。 摘自：bufferq">
<meta property="og:type" content="article">
<meta property="og:title" content="BufferQueue 简介">
<meta property="og:url" content="https://youngkaaa.github.io/98c274c6.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="在 Android 图形系统中有一个很重要的角色：BufferQueue ，从其名称也能看出来，它是一个队列。而这个队列的作用是什么呢？引用下官方对于它的总结：  BufferQueues 是 Android 图形组件之间的粘合剂，它们是一对队列，可以调解缓冲区从生产方到消耗方的固定周期。一旦生产方移交其缓冲区，SurfaceFlinger 便会负责将所有内容合成到显示部分。 摘自：bufferq">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/BufferQueue/pic1.png">
<meta property="article:published_time" content="2022-07-05T02:48:56.000Z">
<meta property="article:modified_time" content="2023-02-07T12:24:23.584Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="BufferQueue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/BufferQueue/pic1.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> BufferQueue 简介 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          BufferQueue 简介
        
      </h1>

      <time class="post-time">
          7月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>在 Android 图形系统中有一个很重要的角色：BufferQueue ，从其名称也能看出来，它是一个队列。而这个队列的作用是什么呢？引用下官方对于它的总结：</p>
<blockquote>
<p>BufferQueues 是 Android 图形组件之间的粘合剂，它们是一对队列，可以调解缓冲区从生产方到消耗方的固定周期。一旦生产方移交其缓冲区，SurfaceFlinger 便会负责将所有内容合成到显示部分。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://source.android.com/docs/core/graphics?hl=zh-cn#bufferqueue">bufferqueue</a></p>
</blockquote>
<p>使用关键词来说就是：Android图形系统，队列，解决图形生产&amp;消费问题</p>
<p>再附上官方对于它的图解：</p>
<p><img src="/./BufferQueue/pic1.png" alt="image.png"></p>
<p>可以看到，这是一个生产-消费者模型。生产者Producer生产数据到BufferQueue 中，然后消费者Consumer从BufferQueue中取出数据来消费。不过针对这里场景来说Producer就是一些图形生产者，比如相机Hal。而Consumer消来说就是图形消费者，比如SurfaceFlinger。</p>
<h3 id="基础类介绍"><a href="#基础类介绍" class="headerlink" title="基础类介绍"></a>基础类介绍</h3><h4 id="GraphicBuffer"><a href="#GraphicBuffer" class="headerlink" title="GraphicBuffer"></a>GraphicBuffer</h4><p>GraphicBuffer的知识点很多，牵扯共享内存等逻辑，在后面会单独分析它。这里我们可以暂时把他理解为存放图形数据信息的缓冲区，即一块儿内存区域，生产者可以往其中存放数据。</p>
<p>另外，我们知道每一个图形都有自己的宽、高、格式等配置信息，这些配置信息如果发生变化的话，那么该图形的大小就会发生变化，那么用于存储该图形的缓存区也需要变化，不然可能会出现存储区大小不够等异常情况。</p>
<h4 id="BufferItem"><a href="#BufferItem" class="headerlink" title="BufferItem"></a>BufferItem</h4><p>先看看它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferItem.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferItem</span> : <span class="keyword">public</span> Flattenable&lt;BufferItem&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他不重要的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">enum</span> &#123; INVALID_BUFFER_SLOT = <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BufferItem</span>();</span><br><span class="line">    ~<span class="built_in">BufferItem</span>();</span><br><span class="line">    <span class="built_in">BufferItem</span>(<span class="type">const</span> BufferItem&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    BufferItem&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BufferItem&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line">  </span><br><span class="line">    sp&lt;Fence&gt; mFence;</span><br><span class="line"></span><br><span class="line">    Rect mCrop;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> mTransform;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> mScalingMode;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> mTimestamp;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mIsAutoTimestamp;</span><br><span class="line"></span><br><span class="line">    android_dataspace mDataSpace;</span><br><span class="line"></span><br><span class="line">    HdrMetadata mHdrMetadata;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> mFrameNumber;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mSlot;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mIsDroppable;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mAcquireCalled;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mTransformToDisplayInverse;</span><br><span class="line"></span><br><span class="line">    Region mSurfaceDamage;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mAutoRefresh;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mQueuedBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mIsStale;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mApi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它是一个数据类，使用它的主要场景是：生产者调用 queueBuffer() 方法时，会生成一个 BufferItem 实例，并给其中的属性字段赋值，最后将其保存到 BufferQueueCore中的mQueue队列中等待后续消费者去消费。</p>
<p>因此这里主要看其中的字段值含义，下面解释下其中一些关键字段的含义：</p>
<p>1、INVALID_BUFFER_SLOT：定义了默认的无效slot 索引值，后续关于BufferSlot 索引相关的判断，只要其等于INVALID_BUFFER_SLOT 就表示其索引值不合法。</p>
<p>2、mGraphicBuffer：指向BufferSlot实例中的 mGraphicBuffer 。</p>
<p>举个例子：比如对于生产者来说，其一般是先调用 dequeueBuffer 方法来从 BufferQueue 中出队一个 BufferSlot ，而实际出队操作拿到的是其索引值slot，有了这个索引值后续就可以调用 requestBuffer() 方法，拿到该索引值对应的 BufferSlot 中的 GraphicBuffer 地址，也就是拿到用于存储生产者数据的缓冲区内存地址，接下来就可以往该GraphicBuffer 中填充数据了。等填充完数据后调用 queueBuffer() 方法来将该 slot 索引对应的BufferSlot 入队，表示生产完成了，等待消费。此时会创建一个 BufferItem 实例，将其 mGraphicBuffer 指向该 BufferSlot 的 mGraphicBuffer 。表示该 BufferItem 此时已被填充好数据，填充数据的地址是其 也就是说此时 BufferItem 的 mGraphicBuffer 。</p>
<p>暂时理解这些可能有些艰难，可以暂且往后接着看，等到后面理解了 BufferSlot、BufferItem 以及 BufferQueue 运行机制之后再来翻看理解。</p>
<p>3、mTimestamp：生产者生产完数据之后，调用 queueBuffer() 方法时为该图形数据指定的展示时间戳，即期望该图形数据在什么时刻展示出来。类似于视频编解码中的pts。</p>
<p>关于它的赋值：在调用 queueBuffer() 方法时，处理传入 slot 索引之外，还要传入一个QueueBufferInput实例，该实例中指定了本次入队的图形数据信息，其中就包括了其期望的展示时间戳，最终会将QueueBufferInput 中指定的配置信息赋值给BufferItem实例中，这里的 mTimestamp 就是其中一个。</p>
<p>关于它的使用：在消费者端调用acquireBuffer() 方法来获取一个待处理的图形数据时，可以指定所期望的时间戳，然后根据BufferItem.mTimestamp 值和传入的期望时间戳来获取合适的数据以消费，当然也可实现丢帧操作，这些后续再讲。</p>
<p>4、mIsAutoTimestamp：和上面 mTimestamp 类似。当生产者生产完数据之后，如果可以明确指定其期望展示时间戳，则给 mTimestamp 赋值，否则可以通过 QueueBufferInput 来给 mIsAutoTimestamp 赋值，如果将其赋值为 true ，那么表示该图形数据的展示事件戳是自动的，即后续消费者获取待消费数据时不做丢帧处理，而是挨个都处理。</p>
<p>5、mFrameNumber：表示当前要入队的BufferItem是该BufferQueue中已入队的第几个。</p>
<p>关于它的赋值：在BufferQueue 中存在一个计数器：BufferQueueCore.mFrameCounter ，每当有生产者调用其 queueBuffer() 方法入队一次时，都会将mFrameCounter自增1，然后将自增之后的值赋值给本次即将要入队的 BufferItem.mFrameNumber。</p>
<p>关于它的使用：类似于上面的 mTimestamp ，同样是在消费者调用 acquireBuffer() 方法时，在指定期望时间戳之外，还可以指定最大帧，会影响消费者在获取待处理数据时的丢帧策略。</p>
<p>6、mSlot ： 存储着对应 BufferSlot 的索引值。</p>
<p>具体可以翻看上面 mGraphicBuffer 中的例子。当前 mSlot 中存储的就是在其举例中一直提到的 slot 索引值。</p>
<p>7、mIsDroppable：生产者生产的该图形数据是否可以被丢弃，或者说是是否可以被新的数据替换掉。当它是true时，在后续生产者入队其他图形数据时可能会使用新的数据将旧的(mIsDroppable&#x3D;true)替换掉。</p>
<p>8、mAcquireCalled：该BufferItem被生产者放入mQueue之后，是否有消费者通过 acquireBuffer 获取到了该 BufferItem。在将其置为true的同时，会将 BufferItem 的state 置为 ACQUIRE。</p>
<p>其他的字段暂且不说了，等后续遇到的时候再讲。</p>
<p>这里需要记住，对于BufferItem 来说，它是存储在 BufferQueueCore.mQueue 队列中的，代表着有生产者生产了新的数据，将其放入到了该队列中，后续消费者就可以从该队列中取出这些BufferItem 来消费了。</p>
<h4 id="BufferSlot"><a href="#BufferSlot" class="headerlink" title="BufferSlot"></a>BufferSlot</h4><p>先看其定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferSlot.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferSlot</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    BufferSlot()</span><br><span class="line">    : mGraphicBuffer(nullptr),</span><br><span class="line">      mEglDisplay(EGL_NO_DISPLAY),</span><br><span class="line">      mBufferState(),</span><br><span class="line">      mRequestBufferCalled(<span class="literal">false</span>),</span><br><span class="line">      mFrameNumber(<span class="number">0</span>),</span><br><span class="line">      mEglFence(EGL_NO_SYNC_KHR),</span><br><span class="line">      mFence(Fence::NO_FENCE),</span><br><span class="line">      mAcquireCalled(<span class="literal">false</span>),</span><br><span class="line">      mNeedsReallocation(<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;GraphicBuffer&gt; mGraphicBuffer;</span><br><span class="line"></span><br><span class="line">    EGLDisplay mEglDisplay;</span><br><span class="line"></span><br><span class="line">    BufferState mBufferState;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mRequestBufferCalled;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> mFrameNumber;</span><br><span class="line"></span><br><span class="line">    EGLSyncKHR mEglFence;</span><br><span class="line"></span><br><span class="line">    sp&lt;Fence&gt; mFence;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mAcquireCalled;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mNeedsReallocation;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于BufferSlot来说，我的理解是：它相当于是对 GraphicBuffer 的一层封装，将与GraphicBuffer 相关的一些其他一些属性都封装在一起方便使用。</p>
<p>下面分析其关键属性含义：</p>
<p>1、mGraphicBuffer：跟上面 GraphicBuffer 中的解释类似。</p>
<p>BufferSlot 内部的 mGraphicBuffer 指向了一个 GraphicBuffer 实例，当然这个实例地址可能是空的也可能是合法非空的。</p>
<p>①当其为空或不合法时，表示该 BufferSlot 内还没有分配 GraphicBuffer实例，没有对应的缓存区内存地址。此时外部生产者就算获取到了该BufferSlot实例也无法使用，因为没有缓存区来存储生产的数据。此时要正常使用的话，必须得申请分配一个 GraphicBuffer 。</p>
<p>② 当其合法时，表示该 BufferSlot 之前已经分配过 GraphicBuffer 缓存区内存了。此时生产者基本可以直接使用。当然能否直接使用的前提是其缓存区大小合适，存在一种情况：原BufferSlot内部存在 GraphicBuffer 缓存区，但是太小了，不足以让生产者存放当前要生产的数据，这种情况需要重新申请分配缓冲区内存。</p>
<p>记住这两种情况，有 mGraphicBuffer 的 BufferSlot 和没有 mGraphicBuffer 的 BufferSlot 的待遇是不同的。</p>
<p>2、mBufferState：表示该 BufferSlot 当前所处的状态，不同的状态表示其有不同的使用者。</p>
<p>关于其更多解释，详见下面的 BufferState 。</p>
<p>3、mRequestBufferCalled：表示消费者是否对于该 BufferSlot 调用过 requestBuffer() 方法了。</p>
<p>4、mFrameNumber：类似上面 BufferItem的 mFrameNumber ，其赋值的时机也类似。</p>
<p>5、mEglDisplay：Egl相关，等到后面分析OpenGLES时再讲吧。敬请期待。</p>
<p>其他的属性就先不分析了，等到后续遇到了再讲。</p>
<p>关于BufferSlot ，可以将其认为是对 GraphicBuffer 的一层封装。尤其得将其和 BufferItem 区分开。</p>
<h4 id="BufferState"><a href="#BufferState" class="headerlink" title="BufferState"></a>BufferState</h4><p>先看其定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferSlot.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BufferState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    BufferState()</span><br><span class="line">    : mDequeueCount(<span class="number">0</span>),</span><br><span class="line">      mQueueCount(<span class="number">0</span>),</span><br><span class="line">      mAcquireCount(<span class="number">0</span>),</span><br><span class="line">      mShared(<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> mDequeueCount;</span><br><span class="line">    <span class="type">uint32_t</span> mQueueCount;</span><br><span class="line">    <span class="type">uint32_t</span> mAcquireCount;</span><br><span class="line">    <span class="comment">// 当前BufferSlot 是否是共享的</span></span><br><span class="line">    <span class="type">bool</span> mShared;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A buffer can be in one of five states, represented as below:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span></span><br><span class="line">    <span class="comment">// --------|---------|---------------|-------------|---------------|</span></span><br><span class="line">    <span class="comment">// FREE    |  false  |       0       |      0      |       0       |</span></span><br><span class="line">    <span class="comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span></span><br><span class="line">    <span class="comment">// QUEUED  |  false  |       0       |      1      |       0       |</span></span><br><span class="line">    <span class="comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span></span><br><span class="line">    <span class="comment">// SHARED  |  true   |      any      |     any     |      any      |</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// FREE indicates that the buffer is available to be dequeued by the</span></span><br><span class="line">    <span class="comment">// producer. The slot is &quot;owned&quot; by BufferQueue. It transitions to DEQUEUED</span></span><br><span class="line">    <span class="comment">// when dequeueBuffer is called.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// DEQUEUED indicates that the buffer has been dequeued by the producer, but</span></span><br><span class="line">    <span class="comment">// has not yet been queued or canceled. The producer may modify the</span></span><br><span class="line">    <span class="comment">// buffer&#x27;s contents as soon as the associated release fence is signaled.</span></span><br><span class="line">    <span class="comment">// The slot is &quot;owned&quot; by the producer. It can transition to QUEUED (via</span></span><br><span class="line">    <span class="comment">// queueBuffer or attachBuffer) or back to FREE (via cancelBuffer or</span></span><br><span class="line">    <span class="comment">// detachBuffer).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// QUEUED indicates that the buffer has been filled by the producer and</span></span><br><span class="line">    <span class="comment">// queued for use by the consumer. The buffer contents may continue to be</span></span><br><span class="line">    <span class="comment">// modified for a finite time, so the contents must not be accessed until</span></span><br><span class="line">    <span class="comment">// the associated fence is signaled. The slot is &quot;owned&quot; by BufferQueue. It</span></span><br><span class="line">    <span class="comment">// can transition to ACQUIRED (via acquireBuffer) or to FREE (if another</span></span><br><span class="line">    <span class="comment">// buffer is queued in asynchronous mode).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// ACQUIRED indicates that the buffer has been acquired by the consumer. As</span></span><br><span class="line">    <span class="comment">// with QUEUED, the contents must not be accessed by the consumer until the</span></span><br><span class="line">    <span class="comment">// acquire fence is signaled. The slot is &quot;owned&quot; by the consumer. It</span></span><br><span class="line">    <span class="comment">// transitions to FREE when releaseBuffer (or detachBuffer) is called. A</span></span><br><span class="line">    <span class="comment">// detached buffer can also enter the ACQUIRED state via attachBuffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// SHARED indicates that this buffer is being used in shared buffer</span></span><br><span class="line">    <span class="comment">// mode. It can be in any combination of the other states at the same time,</span></span><br><span class="line">    <span class="comment">// except for FREE (since that excludes being in any other state). It can</span></span><br><span class="line">    <span class="comment">// also be dequeued, queued, or acquired multiple times.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">isFree</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !isAcquired() &amp;&amp; !isDequeued() &amp;&amp; !isQueued();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">isDequeued</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDequeueCount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">isQueued</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mQueueCount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">isAcquired</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mAcquireCount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">isShared</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mShared;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">        *this = BufferState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="title function_">string</span><span class="params">()</span> <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        mDequeueCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">detachProducer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDequeueCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mDequeueCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">attachProducer</span><span class="params">()</span> &#123;</span><br><span class="line">        mDequeueCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDequeueCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mDequeueCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        mQueueCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDequeueCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mDequeueCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">freeQueued</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQueueCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mQueueCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQueueCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mQueueCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        mAcquireCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">acquireNotInQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        mAcquireCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAcquireCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mAcquireCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">detachConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAcquireCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mAcquireCount--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">attachConsumer</span><span class="params">()</span> &#123;</span><br><span class="line">        mAcquireCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BufferState 结构体很简单，内部就只有四个字段，这四个字段的组合就可以表示出 BufferState 的几种状态。下面解释其中的状态：</p>
<p>1、FREE：标识这个缓冲区是可以 dequeue 给生产者使用，此时其所有者是 BufferQueue 。而当它被调用 dequeueBuffer 时, 状态会转变为 DEQUEUED。BufferState的默认状态就是 FREE。</p>
<p>2、DEQUEUED：表示此缓冲区已经通过生产者出队, 但是还没有入队或者取消。此时其所有者是生产者。而当调用 queueBuffer&#x2F;attachBuffer 时其状态就会变成 QUEUED ；当调用 cancelBuffer&#x2F;detachBuffer 时,状态就会变成 FREE。</p>
<p>3、QUEUED：表示缓冲区已经被生产者填充, 可以入队提供给消费者使用，此时其所有者属于BufferQueue。当调用 acquireBuffer 时状态会转变为 ACQUIRED 。</p>
<p>4、ACQUIRED：表示这个 buffer 已经被消费者获得, 此时所有者是消费者, 在调用 releaseBuffer&#x2F;detachBuffer 时会转变为 FREE。</p>
<p>5、SHARED：表示此缓冲区处于共享模式中, 它可以和其他的几种状态组合(但是不能和FREE状态组合), 它也可以多次的入队&#x2F;出队&#x2F;获取。</p>
<p>而这五种状态是通过 BufferState 中的四个属性来计算的。其状态和属性的计算规则详见上面代码中的注释。</p>
<h4 id="BufferQueueCore"><a href="#BufferQueueCore" class="headerlink" title="BufferQueueCore"></a>BufferQueueCore</h4><p>先看其代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueCore.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferQueueCore</span> :</span> public virtual RefBase &#123;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fifo 代表了一个 Vector 容器 ，在下面会 mQueue 中就是 Fifo 类型，也就是 Vector 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">typedef</span> Vector&lt;BufferItem&gt; Fifo;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mIsAbandoned;</span><br><span class="line"></span><br><span class="line">    sp&lt;IConsumerListener&gt; mConsumerListener;</span><br><span class="line"></span><br><span class="line">    BufferQueueDefs::SlotsType mSlots;</span><br><span class="line"></span><br><span class="line">    Fifo mQueue;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="type">int</span>&gt; mFreeSlots;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="type">int</span>&gt; mFreeBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="type">int</span>&gt; mUnusedSlots;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="type">int</span>&gt; mActiveBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mMaxBufferCount;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mMaxAcquiredBufferCount;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mMaxDequeuedBufferCount;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mBufferHasBeenQueued;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> mFrameCounter;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mIsAllocating;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mAllowAllocation;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mAsyncMode;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> mSharedBufferMode;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mSharedBufferSlot;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> mLastQueuedSlot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BufferQueueDefs.h</span></span><br><span class="line"></span><br><span class="line">namespace BufferQueueDefs &#123;</span><br><span class="line">   <span class="keyword">typedef</span> BufferSlot SlotsType[NUM_BUFFER_SLOTS];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一直在讲BufferQueue ，终于出来一个和BufferQueue有点关系的类了。</p>
<p>BufferQueueCore 类正如其命名，它是BufferQueue中的核心类，它的内部持有了 BufferSlots 、BufferItem 等数据。其主要作用也是为了持有数据，持有数据的目的是方便生产者和消费者存取操作。通常它是被一对生产者和消费者所包装，这俩包装了同一个BufferQueueCore 实例，生产者和消费者从同一个 BufferQueueCore实例中取出&amp;存入数据，从而实现了数据的传输。</p>
<p>下面分析下其中主要的属性：</p>
<p>1、mIsAbandoned：当前 BufferQueue 是否已被废弃，放弃。默认是置为false 的，当其被置为true时，生产消费者模型将会停止运行。</p>
<p>2、mConsumerListener：外部设置进来的监听器。可以看看 IConsumerListener 接口的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerListener.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerListener</span> :</span> public virtual RefBase &#123;</span><br><span class="line">public:</span><br><span class="line">    ConsumerListener() &#123;&#125;</span><br><span class="line">    virtual ~ConsumerListener();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当生产者入队了一个新的待处理的数据时回调出去，通知给消费者侧</span></span><br><span class="line"><span class="comment">     * 具体详见：BufferQueueProducer::queueBuffer 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">onFrameAvailable</span><span class="params">(<span class="type">const</span> BufferItem&amp; item)</span> = <span class="number">0</span>; <span class="comment">/* Asynchronous */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和上面的 onFrameAvailable 类似，不过它是替换掉队列中最后一个时回调</span></span><br><span class="line"><span class="comment">     * 具体详见：BufferQueueProducer::queueBuffer 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">onFrameReplaced</span><span class="params">(<span class="type">const</span> BufferItem&amp; <span class="comment">/* item */</span>)</span> &#123;&#125; <span class="comment">/* Asynchronous */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当有数据被释放时回调。比如</span></span><br><span class="line"><span class="comment">     * ①调用 BufferQueueConsumer::acquireBuffer 时，内部发生丢帧操作后会回调这个</span></span><br><span class="line"><span class="comment">     * ②当调用BufferQueueConsumer::releaseBuffer 时会回调这个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">onBuffersReleased</span><span class="params">()</span> = <span class="number">0</span>; <span class="comment">/* Asynchronous */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>详见其注释。而它的赋值是在 BufferQueueConsumer 的 connect() 和 disconnect() 方法中。</p>
<p>3、mSlots：BufferQueueDefs::SlotsType 类型，而它是一个别名，实际对应的是：BufferSlot[NUM_BUFFER_SLOTS] 数组，其中NUM_BUFFER_SLOTS&#x3D;64。</p>
<p>因此可以说：创建了一个BufferQueueCore 实例时，内部会有一个长度为64的BufferSlot 数组，也就是有了64个 BufferSlot 实例可以使用了，但是这64个BufferSlot 中的属性都是默认值或者0，等待后续被赋值。</p>
<p>而前面一直说的 slot 索引指的就是其在 mSlots数组中的索引，mSlots 数组中的内容不会调整顺序，所以只需要在 生产者消费者之间传递 slot索引值即可，拿到slot索引值然后从 mSlots 数组中就可以查找到对应的 BufferSlot 实例了。</p>
<p>4、mQueue：它是一个 Fifo 实例，其实是一个 <code>Vector&lt;BufferItem&gt;</code>实例，一个存放 BufferItem 的容器列表。</p>
<p>mQueue 内部存储着若干个 BufferItem，也就是存储着来自开发者生产的并且queue入队了的数据，将其封装成一个个的BufferItem实例存储在 mQueue 中，后续在消费者侧获取待处理数据时，就是从 mQueue 中获取数据来处理的。</p>
<p>5、mFreeSlots：它内部存储着：状态是FREE，并且其 mGraphicBuffer &#x3D; null(也就是没有与GraphicBuffer缓存区绑定) 的BufferSlot 的索引值。</p>
<p>6、mFreeBuffers：它内部存储着：状态是FREE，并且其 mGraphicBuffer 合法有值 (也就是已经与GraphicBuffer缓存区绑定了) 的BufferSlot 的索引值。</p>
<p>其实 mFreeSlots 和 mFreeBuffers 的区别就在于：该 BufferSlot 是否已经与 GraphicBuffer 绑定过了。如果绑定过的话，则生产者取出之后基本都是可直接用的，否则还需要重新申请分配缓存区空间。这些在后面讲 BufferQueueProducer::dequeueBuffer() 方法时会遇到。</p>
<p>7、mUnusedSlots：它内部存储着：当前没有使用的 BufferSlot 集合。感觉这个集合和mFreeSlots 有点重复了。</p>
<p>8、mActiveBuffers：它内部存储着：BufferSlot状态不为FREE（即DEQUEUED、QUEUED、ACQUIRED、SHARED）的BufferSlot 的索引值。不是FREE 那么肯定是绑定了 GraphicBuffer 的。</p>
<p>因此：mSlots &#x3D; mFreeSlots + mFreeBuffers + mActiveBuffers + mUnusedSlots 。相当于这四个集合对 mSlots 中的64个BufferSlot进行了分组，分组之后可以让后续存取变得更加高效，属于是空间换时间了。</p>
<p>而在 BufferQueueCore 的构造方法中，会对 mFreeSlots 这些集合进行初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferQueueCore.cpp</span></span><br><span class="line"></span><br><span class="line">BufferQueueCore::BufferQueueCore() :</span><br><span class="line">    mMutex(),</span><br><span class="line">    mIsAbandoned(<span class="literal">false</span>),</span><br><span class="line">    mConsumerControlledByApp(<span class="literal">false</span>),</span><br><span class="line">    mConsumerName(getUniqueName()),</span><br><span class="line">    mConsumerListener(),</span><br><span class="line">    mConsumerUsageBits(<span class="number">0</span>),</span><br><span class="line">    mConsumerIsProtected(<span class="literal">false</span>),</span><br><span class="line">    mConnectedApi(NO_CONNECTED_API),</span><br><span class="line">    mLinkedToDeath(),</span><br><span class="line">    mConnectedProducerListener(),</span><br><span class="line">    mSlots(),</span><br><span class="line">    mQueue(),</span><br><span class="line">    mFreeSlots(),</span><br><span class="line">    mFreeBuffers(),</span><br><span class="line">    mUnusedSlots(),</span><br><span class="line">    mActiveBuffers(),</span><br><span class="line">    mDequeueCondition(),</span><br><span class="line">    mDequeueBufferCannotBlock(<span class="literal">false</span>),</span><br><span class="line">    mQueueBufferCanDrop(<span class="literal">false</span>),</span><br><span class="line">    mLegacyBufferDrop(<span class="literal">true</span>),</span><br><span class="line">    mDefaultBufferFormat(PIXEL_FORMAT_RGBA_8888),</span><br><span class="line">    mDefaultWidth(<span class="number">1</span>),</span><br><span class="line">    mDefaultHeight(<span class="number">1</span>),</span><br><span class="line">    mDefaultBufferDataSpace(HAL_DATASPACE_UNKNOWN),</span><br><span class="line">    mMaxBufferCount(BufferQueueDefs::NUM_BUFFER_SLOTS),</span><br><span class="line">    mMaxAcquiredBufferCount(<span class="number">1</span>),</span><br><span class="line">    mMaxDequeuedBufferCount(<span class="number">1</span>),</span><br><span class="line">    mBufferHasBeenQueued(<span class="literal">false</span>),</span><br><span class="line">    mFrameCounter(<span class="number">0</span>),</span><br><span class="line">    mTransformHint(<span class="number">0</span>),</span><br><span class="line">    mIsAllocating(<span class="literal">false</span>),</span><br><span class="line">    mIsAllocatingCondition(),</span><br><span class="line">    mAllowAllocation(<span class="literal">true</span>),</span><br><span class="line">    mBufferAge(<span class="number">0</span>),</span><br><span class="line">    mGenerationNumber(<span class="number">0</span>),</span><br><span class="line">    mAsyncMode(<span class="literal">false</span>),</span><br><span class="line">    mSharedBufferMode(<span class="literal">false</span>),</span><br><span class="line">    mAutoRefresh(<span class="literal">false</span>),</span><br><span class="line">    mSharedBufferSlot(INVALID_BUFFER_SLOT),</span><br><span class="line">    mSharedBufferCache(Rect::INVALID_RECT, <span class="number">0</span>, NATIVE_WINDOW_SCALING_MODE_FREEZE,</span><br><span class="line">            HAL_DATASPACE_UNKNOWN),</span><br><span class="line">    mLastQueuedSlot(INVALID_BUFFER_SLOT),</span><br><span class="line">    mUniqueId(getUniqueId()) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 刚开始就把所有的 buffer slot 索引插入到 mFreeSlots 中</span></span><br><span class="line"><span class="comment">   * 因为 mFreeSlots 表示的是：当前所有的状态为FREE的Slot，这些Slot没有关联上具体的GraphicBuffer，用的时候还需要关联上GraphicBuffer</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> numStartingBuffers = getMaxBufferCountLocked();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; numStartingBuffers; s++) &#123;</span><br><span class="line">    mFreeSlots.insert(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS;</span><br><span class="line">       s++) &#123;</span><br><span class="line">    mUnusedSlots.push_front(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BufferQueueCore::getMaxBufferCountLocked</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxBufferCount = mMaxAcquiredBufferCount + mMaxDequeuedBufferCount +</span><br><span class="line">            ((mAsyncMode || mDequeueBufferCannotBlock) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// limit maxBufferCount by mMaxBufferCount always</span></span><br><span class="line">    maxBufferCount = <span class="built_in">std</span>::min(mMaxBufferCount, maxBufferCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxBufferCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="IGraphicBufferProducer"><a href="#IGraphicBufferProducer" class="headerlink" title="IGraphicBufferProducer"></a>IGraphicBufferProducer</h4><p>先看其代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IGraphicBufferProducer.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IGraphicBufferProducer</span> :</span> public IInterface</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 省略其他无关代码</span></span><br><span class="line">  </span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">requestBuffer</span><span class="params">(<span class="type">int</span> slot, sp&lt;GraphicBuffer&gt;* buf)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">setMaxDequeuedBufferCount</span><span class="params">(<span class="type">int</span> maxDequeuedBuffers)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">setAsyncMode</span><span class="params">(<span class="type">bool</span> async)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">dequeueBuffer</span><span class="params">(<span class="type">int</span>* slot, sp&lt;Fence&gt;* fence, <span class="type">uint32_t</span> w, <span class="type">uint32_t</span> h,</span></span><br><span class="line"><span class="params">                                   PixelFormat format, <span class="type">uint64_t</span> usage, <span class="type">uint64_t</span>* outBufferAge,</span></span><br><span class="line"><span class="params">                                   FrameEventHistoryDelta* outTimestamps)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">detachBuffer</span><span class="params">(<span class="type">int</span> slot)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">detachNextBuffer</span><span class="params">(sp&lt;GraphicBuffer&gt;* outBuffer,</span></span><br><span class="line"><span class="params">            sp&lt;Fence&gt;* outFence)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">attachBuffer</span><span class="params">(<span class="type">int</span>* outSlot,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">queueBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">const</span> QueueBufferInput&amp; input,</span></span><br><span class="line"><span class="params">            QueueBufferOutput* output)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">connect</span><span class="params">(<span class="type">const</span> sp&lt;IProducerListener&gt;&amp; listener,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> api, <span class="type">bool</span> producerControlledByApp, QueueBufferOutput* output)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">disconnect</span><span class="params">(<span class="type">int</span> api, DisconnectMode mode = DisconnectMode::Api)</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Binder server 端的定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnGraphicBufferProducer</span> :</span> public BnInterface&lt;IGraphicBufferProducer&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">status_t</span>    <span class="title function_">onTransact</span><span class="params">( <span class="type">uint32_t</span> code,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> Parcel&amp; data,</span></span><br><span class="line"><span class="params">                                    Parcel* reply,</span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里定义的 IGraphicBufferProducer 接口是直接继承自 IInterface 的，以及其中的BnGraphicBufferProducer 定义，说明它是支持 Binder 远程调用的。关于 Binder 的解释详见我其他文章，这里不赘述。</p>
<p>IGraphicBufferProducer 接口内部定义了对于生产者来说的一些常用方法，比如 dequeueBuffer() 和 queueBuffer() 。而它的主要实现类是：BufferQueueProducer 后续会讲到。</p>
<h4 id="IGraphicBufferConsumer"><a href="#IGraphicBufferConsumer" class="headerlink" title="IGraphicBufferConsumer"></a>IGraphicBufferConsumer</h4><p>先看其代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IGraphicBufferConsumer.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IGraphicBufferConsumer</span> :</span> public IInterface &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">  </span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">acquireBuffer</span><span class="params">(BufferItem* buffer, <span class="type">nsecs_t</span> presentWhen,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint64_t</span> maxFrameNumber = <span class="number">0</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">detachBuffer</span><span class="params">(<span class="type">int</span> slot)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">attachBuffer</span><span class="params">(<span class="type">int</span>* outSlot, <span class="type">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">releaseBuffer</span><span class="params">(<span class="type">int</span> buf, <span class="type">uint64_t</span> frameNumber, EGLDisplay display,</span></span><br><span class="line"><span class="params">                                   EGLSyncKHR fence, <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">status_t</span> <span class="title function_">releaseHelper</span><span class="params">(<span class="type">int</span> buf, <span class="type">uint64_t</span> frameNumber, <span class="type">const</span> sp&lt;Fence&gt;&amp; releaseFence)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> releaseBuffer(buf, frameNumber, EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">consumerConnect</span><span class="params">(<span class="type">const</span> sp&lt;IConsumerListener&gt;&amp; consumer,</span></span><br><span class="line"><span class="params">                                     <span class="type">bool</span> controlledByApp)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">status_t</span> <span class="title function_">consumerDisconnect</span><span class="params">()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnGraphicBufferConsumer</span> :</span> public SafeBnInterface&lt;IGraphicBufferConsumer&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    BnGraphicBufferConsumer()</span><br><span class="line">          : SafeBnInterface&lt;IGraphicBufferConsumer&gt;(<span class="string">&quot;BnGraphicBufferConsumer&quot;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">status_t</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply,</span></span><br><span class="line"><span class="params">                        <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span> override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和前面的 IGraphicBufferProducer 类似，有生产者对应的接口，那自然有消费者对应的接口。其主要实现类是：BufferQueueConsumer。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇主要介绍 BufferQueue 中相关的基础类，下一篇在进行源码逻辑的分析。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/BufferQueue/">BufferQueue</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/dff29dd0.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">BufferQueue 分析</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/c801eba.html">
        <span class="next-text nav-default">Jetpack- Activity Result Api</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
