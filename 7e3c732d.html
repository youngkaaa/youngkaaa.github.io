<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="leakcanary install 分析"/>




  <meta name="keywords" content="leakcanary," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/7e3c732d.html"/>


<meta name="description" content="在Android开发中，经常会遇到内存泄露的问题。但由于这些内存泄露问题的发生都是很隐晦的，平时在使用时基本感知不到内存泄露的发生，所以也基本很少去处理它。但唯一能感知到的就是在APP正常使用中，APP闪退，查看日志发现是系统抛出了 OutOfMemoryError 错误，也就是常说的 OOM ，表示当前 Java虚拟机没有足够的空间来分配内存了。 当程序遇到 OOM 时，并不代表在抛出 OOM">
<meta property="og:type" content="article">
<meta property="og:title" content="leakcanary install 分析">
<meta property="og:url" content="https://youngkaaa.github.io/7e3c732d.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="在Android开发中，经常会遇到内存泄露的问题。但由于这些内存泄露问题的发生都是很隐晦的，平时在使用时基本感知不到内存泄露的发生，所以也基本很少去处理它。但唯一能感知到的就是在APP正常使用中，APP闪退，查看日志发现是系统抛出了 OutOfMemoryError 错误，也就是常说的 OOM ，表示当前 Java虚拟机没有足够的空间来分配内存了。 当程序遇到 OOM 时，并不代表在抛出 OOM">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-25T13:40:56.000Z">
<meta property="article:modified_time" content="2023-03-13T12:45:39.177Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="leakcanary">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> leakcanary install 分析 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          leakcanary install 分析
        
      </h1>

      <time class="post-time">
          2月 25 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>在Android开发中，经常会遇到内存泄露的问题。但由于这些内存泄露问题的发生都是很隐晦的，平时在使用时基本感知不到内存泄露的发生，所以也基本很少去处理它。但唯一能感知到的就是在APP正常使用中，APP闪退，查看日志发现是系统抛出了 OutOfMemoryError 错误，也就是常说的 OOM ，表示当前 Java虚拟机没有足够的空间来分配内存了。</p>
<p>当程序遇到 OOM 时，并不代表在抛出 OOM 错误处的代码有问题，它可能只是压死骆驼的最后一根稻草，前面有太多的内存泄露，或者内存占用，等到这里执行时刚好达到 JVM 的上限，此时抛出 OOM了。</p>
<h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><p>所以说，产生 OOM 的原因主要有两个：内存泄露 和 内存溢出。</p>
<p>① 内存泄露是指给你分配的内存，你用完后没有“释放”。虽然在 Java 中会通过 GC 去自动回收，但自动回收也有前提即该堆中的对象实例不能被引用，否则无法被回收。比如你在一个静态变量中持有了对象实例，而静态属性一般生命周期是伴随着整个应用的生命周期，所以该对象实例可能会一直被持有而迟迟不能被释放。</p>
<p>当然场景还有很多，总的一个准则就是：生命周期长的持有引用了生命周期端的对象实例，这样的话会导致证明周期短的对象实例内存泄露。</p>
<p>② 内存溢出指的是你的代码逻辑中向系统申请很大的内存，超过了系统所能提供的最大值，此时就会抛出 OOM异常。这种情况也是最好排查和解决的。</p>
<p>上面两种情况最终都会产生相同的结果，也就是OOM 异常。但是前者内存泄露更隐晦，因此也更难解决，需要去一个个的解决内存泄露的问题。而后者相比之下是更好定位和解决的。</p>
<p>这里看一个 Android官方对于第二种内存溢出情况的解决场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// View.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildDrawingCacheImpl</span><span class="params">(<span class="type">boolean</span> autoScale)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Bitmap</span></span><br><span class="line">        bitmap = Bitmap.createBitmap(mResources.getDisplayMetrics(),</span><br><span class="line">                width, height, quality);</span><br><span class="line">        bitmap.setDensity(getResources().getDisplayMetrics().densityDpi);</span><br><span class="line">        <span class="keyword">if</span> (autoScale) &#123;</span><br><span class="line">            mDrawingCache = bitmap;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mUnscaledDrawingCache = bitmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opaque &amp;&amp; use32BitCache) bitmap.setHasAlpha(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建 Bitmap 失败了，内存溢出了</span></span><br><span class="line"><span class="comment">         * 那么此时跳过 DrawingCache</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (autoScale) &#123;</span><br><span class="line">            mDrawingCache = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mUnscaledDrawingCache = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCachingFailed = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在对于申请内存过大系统无法分配时，会抛出 OOM 异常，此时使用 try catch 来捕获到该异常，进而进行兜底操作，即不再去分配 Bitmap 。诶好像有点不对，OOM也能被 try catch ？？</p>
<p>没错，确实可以被 try catch， 因为它也属于 Throwable 接口的一个子类，但是捕获它有意义嘛？那得分类讨论：</p>
<p>① 如果是上面举例中的一次性分配内存过大，导致内存溢出引起的OOM ，那么就有意义。你可以把这里抛出的 OOM 可以理解为就是系统通知你内存分配失败而已，所以你只需要对内存内配失败做兜底处理即可。</p>
<p>② 如果是内存泄露引起的OOM，那么你 try catch 就显得没什么意义了，你在这里发生OOM的地方 try catch 了，对这里没问题了，那你能保证下面也没问题嘛？因为当前JVM处于内存几乎耗空的状态，你后续可能任何一个很小的内存分配都会导致再次抛出OOM，所以说这种情况下没必要去加 try catch ，加了也解决不了啥问题。你能做的就是去解决前面的内存泄露问题。</p>
<p>而内存泄露问题怎么解决呢？在 Android 中常用的就是 <a target="_blank" rel="noopener" href="https://github.com/square/leakcanary">LeakCanary 库</a>。关于它的使用，可以去看官方介绍 ：<a target="_blank" rel="noopener" href="https://square.github.io/leakcanary/">https://square.github.io/leakcanary/</a> ，下面主要分析原理。</p>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p>在 leakcanary 项目中，存在好多个模块，而我们主要关注Android平台的版本，所以我们从 leakcanary-object-watcher-android 模块来开始分析，在该模块中定义了Manifest配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.squareup.leakcanary.objectwatcher&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义 provider --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;leakcanary.internal.MainProcessAppWatcherInstaller&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.leakcanary-installer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">&quot;@bool/leak_canary_watcher_auto_install&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里定义的 Manifest 中只有一个 provider 定义，那我们来看看它对应的 MainProcessAppWatcherInstaller 类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainProcessAppWatcherInstaller.kt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MainProcessAppWatcherInstaller</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到 Application 实例</span></span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    <span class="comment">// 调用到 AppWatcher.manualInstall 中去完成安装逻辑</span></span><br><span class="line">    AppWatcher.manualInstall(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是在 ContentProvider 的 onCreate() 方法中调用了 AppWatcher.manualInstall() 方法，并无其他逻辑了。也就是说当前ContentProvider 子类的作用就只是用来执行该方法完成初始化工作。</p>
<p>其实这种方式很常见，这种方式编写的sdk，开发者接入时就不需要手动去在自己的 Application 中初始化了，因为它借助了 ContentProvider 的特性，而这种方式官方其实也在使用，比如 ProcessLifecycleOwnerInitializer 用于 Lifecycle 初始化，以及官方甚至为此还出了个库：<a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/app-startup">app-startup</a> 。</p>
<p>所以说，后续逻辑的重点就是在 AppWatcher.manualInstall() 方法中了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppWatcher.kt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manualInstall</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  retainedDelayMillis: <span class="type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>)</span></span>,</span><br><span class="line">  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 检查主线程，必须在主线程调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  checkMainThread()</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 避免重复调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (isInstalled) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException(</span><br><span class="line">      <span class="string">&quot;AppWatcher already installed, see exception cause for prior install call&quot;</span>, installCause</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入参 retainedDelayMillis 必须大于等于0</span></span><br><span class="line">  check(retainedDelayMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="string">&quot;retainedDelayMillis <span class="variable">$retainedDelayMillis</span> must be at least 0 ms&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给 installCause 赋值，这样的话后续 isInstalled 属性就会返回 true</span></span><br><span class="line">  installCause = RuntimeException(<span class="string">&quot;manualInstall() first called here&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将入参 retainedDelayMillis 保存起来，它代表后续需要等待多长时间后去检测</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.retainedDelayMillis = retainedDelayMillis</span><br><span class="line"></span><br><span class="line">  <span class="comment">// debug 包会打开日志输出</span></span><br><span class="line">  <span class="keyword">if</span> (application.isDebuggableBuild) &#123;</span><br><span class="line">    LogcatSharkLog.install()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 反射拿到 InternalLeakCanary 实例，然后调用其 invoke(application) 方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  LeakCanaryDelegate.loadLeakCanary(application)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 遍历 watchersToInstall 列表中的项，然后挨个调用 install 方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  watchersToInstall.forEach &#123;</span><br><span class="line">    it.install()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是进行一系列的检查工作：</p>
<p>① 该方法调用的线程，必须在主线程中。</p>
<p>② 判断当前方法是否重复调用，是的话直接返回，避免外部重复调用该方法</p>
<p>③ 入参 retainedDelayMillis 是否大于等于0，这里使用的是默认值 5s</p>
<p>检查完毕之后，就可以进行初始化工作了。先给 installCause 赋值，这样的话后续 isInstalled 就会返回 true 表示已初始化。</p>
<p>接着会调用：LeakCanaryDelegate.loadLeakCanary() 方法来完成初始化工作，该方法的调用先放着，我们接着往后看。</p>
<p>最后会遍历入参 watchersToInstall 列表，挨个调用其内部 InstallableWatcher 实例的 install() 方法。而这里改参数外部传入的是 appDefaultWatchers(application) 方法返回的默认值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppWatcher.kt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">appDefaultWatchers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  reachabilityWatcher: <span class="type">ReachabilityWatcher</span> = objectWatcher</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;InstallableWatcher&gt; &#123;</span><br><span class="line">  <span class="comment">// 内部会放置四个 InstallableWatcher 接口实例</span></span><br><span class="line">  <span class="keyword">return</span> listOf(</span><br><span class="line">    ActivityWatcher(application, reachabilityWatcher),</span><br><span class="line">    FragmentAndViewModelWatcher(application, reachabilityWatcher),</span><br><span class="line">    RootViewWatcher(reachabilityWatcher),</span><br><span class="line">    ServiceWatcher(reachabilityWatcher)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，该方法内部会默认放置四个 InstallableWatcher 接口实例对象：</p>
<p>① ActivityWatcher ，用来监测 Activity 的内存泄露问题；</p>
<p>② FragmentAndViewModelWatcher ，用来监测 Fragment 和 ViewModel 的内存泄露问题；</p>
<p>③ RootViewWatcher ，用来监测 DecorView 的内存泄露问题；</p>
<p>④ ServiceWatcher，用来监测 Service 的内存泄露问题；</p>
<p>所以在 manualInstall() 方法中的最后，会挨个调用上面这些 InstallableWatcher 实例的 install 方法来开始监测。关于这四个类后面会专门来分析，这里先跳过。</p>
<p>接下来就该看前面提到的 LeakCanaryDelegate.loadLeakCanary() 方法中是怎么处理的了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeakCanaryDelegate.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> LeakCanaryDelegate &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">  <span class="keyword">val</span> loadLeakCanary <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 反射拿到 InternalLeakCanary 实例</span></span><br><span class="line">      <span class="keyword">val</span> leakCanaryListener = Class.forName(<span class="string">&quot;leakcanary.internal.InternalLeakCanary&quot;</span>)</span><br><span class="line">      <span class="comment">// 拿到其实例，将其转换为 (Application) -&gt; Unit 类型</span></span><br><span class="line">      leakCanaryListener.getDeclaredField(<span class="string">&quot;INSTANCE&quot;</span>).<span class="keyword">get</span>(<span class="literal">null</span>) <span class="keyword">as</span> (Application) -&gt; <span class="built_in">Unit</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      <span class="comment">// 遇到异常，加载失败，则使用空的实现</span></span><br><span class="line">      NoLeakCanary</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">object</span> NoLeakCanary : (Application) -&gt; <span class="built_in">Unit</span>, OnObjectRetainedListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onObjectRetained</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a这里会通过反射拿到 leakcanary.internal.InternalLeakCanary 类的实例，然后拿到其实例对象将其转换为 (Application) -&gt; Unit 类型来使用。(Application) -&gt; Unit 类型是什么呢？它是Kotlin中定义函数类型的方式，详见官方文档：<a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/lambdas.html#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B">函数类型</a> ，这里可以将其理解为是一个接收 Application 参数，返回值为 void 的函数。</p>
<p>接下来看看 leakcanary.internal.InternalLeakCanary 类的庐山真面目：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InternalLeakCanary.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> InternalLeakCanary : (Application) -&gt; <span class="built_in">Unit</span>, OnObjectRetainedListener &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    _application = application</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前是否允吸在非 debug 模式下运行</span></span><br><span class="line">    checkRunningInDebuggableBuild()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里会给 objectWatcher 注册 OnObjectRetainedListener 回调</span></span><br><span class="line"><span class="comment">     * 当观察的对象5s之后都没有被回收的话，那么会回调到这里的 [onObjectRetained]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AppWatcher.objectWatcher.addOnObjectRetainedListener(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 GC 触发器，其实就是将 Runtime.getRuntime().gc() 包装了一下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> gcTrigger = GcTrigger.Default</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> configProvider = &#123; LeakCanary.config &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 handlerThread 用来处理消息</span></span><br><span class="line">    <span class="keyword">val</span> handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)</span><br><span class="line">    handlerThread.start()</span><br><span class="line">    <span class="keyword">val</span> backgroundHandler = Handler(handlerThread.looper)</span><br><span class="line"></span><br><span class="line">    heapDumpTrigger = HeapDumpTrigger(</span><br><span class="line">      application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger,</span><br><span class="line">      configProvider</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 Application 应用的前台 压后台变化回调</span></span><br><span class="line">    application.registerVisibilityListener &#123; applicationVisible -&gt;</span><br><span class="line">      <span class="keyword">this</span>.applicationVisible = applicationVisible</span><br><span class="line">      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往该 Application 中注册 registerActivityLifecycleCallbacks 回调</span></span><br><span class="line">    <span class="comment">// 用来监听获取当前处于 onResume 前台状态的 Activity</span></span><br><span class="line">    registerResumedActivityListener(application)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加一个 快捷方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addDynamicShortcut(application)</span><br><span class="line"></span><br><span class="line">    mainHandler.post &#123;</span><br><span class="line">      backgroundHandler.post &#123;</span><br><span class="line">        SharkLog.d &#123;</span><br><span class="line">          <span class="keyword">when</span> (<span class="keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()) &#123;</span><br><span class="line">            <span class="keyword">is</span> Yup -&gt; application.getString(R.string.leak_canary_heap_dump_enabled_text)</span><br><span class="line">            <span class="keyword">is</span> Nope -&gt; application.getString(</span><br><span class="line">              R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先， InternalLeakCanary 是继承自 (Application) -&gt; Unit 的，也就是它自身可以当做是一个函数来使用，即带括号调用，传入 Application 参数，被调用时会触发其内部的 invoke() 方法。同时它还实现了 OnObjectRetainedListener 接口。</p>
<p>在其 invoke() 方法中，会将入参保存起来，然后调用 AppWatcher.objectWatcher.addOnObjectRetainedListener() 方法来将自身实例注册进去，那么后续在那边监测到有对象可能存在泄露时，就会通过调用该实例的 onObjectRetained() 方法来通知到这边了。</p>
<p>接下来会拿到 gcTrigger 默认实现的实例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GcTrigger.kt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> GcTrigger &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Attempts to run garbage collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">runGc</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default implementation of [GcTrigger].</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">object</span> Default : GcTrigger &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">runGc</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 实际就是会调用系统的 gc 方法来触发gc垃圾回收</span></span><br><span class="line">      Runtime.getRuntime().gc()</span><br><span class="line">      <span class="comment">// 休眠，等待回收完成，并且将对应的应用放入对应的队列中去</span></span><br><span class="line">      enqueueReferences()</span><br><span class="line">      System.runFinalization()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueueReferences</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: InterruptedException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> AssertionError()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说后续可以使用这个 gcTrigger 实例来触发JVM的gc操作。</p>
<p>接着会创建一个 HeapDumpTrigger 实例，将创建出来的 gcTrigger 等实例传入进去。</p>
<p>这里创建的 HeapDumpTrigger 实例后续会使用它来完成 hprof 文件的生成，而这个文件中保存了当前 Java 堆上的所有内存使用信息，能够完整的反映虚拟机当前的内存状态。所以说获取到该文件，并分析是最好的排查方式。</p>
<p>而生成 hprof 文件是通过<code>Debug.dumpHprofData()</code> 方法来完成的，而该方法的执行正是在 HeapDumpTrigger 类中来触发的。</p>
<p>接下来就是注册回调了，第一个回调就是registerVisibilityListener ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VisibilityTracker.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> Application.<span class="title">registerVisibilityListener</span><span class="params">(listener: (<span class="type">Boolean</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> visibilityTracker = VisibilityTracker(listener)</span><br><span class="line">  registerActivityLifecycleCallbacks(visibilityTracker)</span><br><span class="line">  registerReceiver(visibilityTracker, IntentFilter().apply &#123;</span><br><span class="line">    addAction(ACTION_SCREEN_ON)</span><br><span class="line">    addAction(ACTION_SCREEN_OFF)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他内部会通过注册该该 Application.registerActivityLifecycleCallbacks() 方法来监测Activity的生命周期变化，同时监测锁屏亮屏广播事件，这些结合起来来判断当前App 的前台、后台变化事件，主要逻辑是在 VisibilityTracker 类中实现的，具体逻辑简述如下：</p>
<p>原理很简单，使用计数方式，当有 Activity onStart 时计数加一，当计数是从0变成1则表示当前App从后台变为前台；在 Activty onStop 时计数减一，当 计数从1变为0时表示当前APP压后台了，当然同时还结合了锁屏、亮屏的情况。</p>
<p>当然在官方提供的 Lifecycle 中额外提供了 App 前后台的监测，详见： <a href="8dd4bfe0.html">Jetpack- Lifecycle</a> 中的ProcessLifecycleOwner ，推荐使用它。</p>
<p>注册的另外一个回调是调用 registerResumedActivityListener() 方法，起内部也是调用 Application.registerActivityLifecycleCallbacks() 方法来检测的，用来保存当前处于 onResume 状态，也就是处于前台的 Activivty 。</p>
<p>好了，至此就基本分析完了 AppWatcher.manualInstall() 方法中的逻辑，也就是完成了 leakcanary 的 install 操作。此时完成了对 Activity 、Fragment 等对象的监测。而后续他们状态的监测，处理逻辑详见：<a href="4f3e124f.html">leakcanary回收检测原理</a></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/leakcanary/">leakcanary</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/4f3e124f.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">leakcanary回收检测原理</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/3e87a46f.html">
        <span class="next-text nav-default">Retrofit-执行中的秘密</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
