<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="GLES&EGL-Loader-驱动加载"/>




  <meta name="keywords" content="AndroidFrameworks,OpenGLES,EGL," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/3c88db7.html"/>


<meta name="description" content="本文主要介绍 frameworks&#x2F;native&#x2F;opengl&#x2F;libs&#x2F;EGL&#x2F;Loader.cpp 类中是怎么完成OpenGL ES 和 EGL 实现库加载逻辑的。 正如前面文章 GLES&amp;EGL-EGL-01 中所介绍的的 EGL 操作的第一步：调用 eglGetDisplay() 方法来完成显示设备的获取。在这一步中，会通过 Loa">
<meta property="og:type" content="article">
<meta property="og:title" content="GLES&amp;EGL-Loader-驱动加载">
<meta property="og:url" content="https://youngkaaa.github.io/3c88db7.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="本文主要介绍 frameworks&#x2F;native&#x2F;opengl&#x2F;libs&#x2F;EGL&#x2F;Loader.cpp 类中是怎么完成OpenGL ES 和 EGL 实现库加载逻辑的。 正如前面文章 GLES&amp;EGL-EGL-01 中所介绍的的 EGL 操作的第一步：调用 eglGetDisplay() 方法来完成显示设备的获取。在这一步中，会通过 Loa">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-20T13:48:56.000Z">
<meta property="article:modified_time" content="2023-03-03T14:01:51.799Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="OpenGLES">
<meta property="article:tag" content="EGL">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> GLES&EGL-Loader-驱动加载 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          GLES&EGL-Loader-驱动加载
        
      </h1>

      <time class="post-time">
          8月 20 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>本文主要介绍 frameworks&#x2F;native&#x2F;opengl&#x2F;libs&#x2F;EGL&#x2F;Loader.cpp 类中是怎么完成OpenGL ES 和 EGL 实现库加载逻辑的。</p>
<p>正如前面文章 <a href="aa48ac49.html">GLES&amp;EGL-EGL-01</a> 中所介绍的的 EGL 操作的第一步：调用 eglGetDisplay() 方法来完成显示设备的获取。在这一步中，会通过 Loader::open() 方法来完成对 OpenGL ES 、EGL 实现库的加载逻辑。</p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/Loader.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Loader::open</span><span class="params">(<span class="type">egl_connection_t</span>* cnx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> openTime = <span class="built_in">systemTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">should_unload_system_driver</span>(cnx)) &#123;</span><br><span class="line">        <span class="built_in">unload_system_driver</span>(cnx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否已经被加载过了</span></span><br><span class="line">    <span class="keyword">if</span> (cnx-&gt;dso) &#123;</span><br><span class="line">        <span class="keyword">return</span> cnx-&gt;dso;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setEmulatorGlesValue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂不考虑</span></span><br><span class="line">    <span class="keyword">if</span> (android::GraphicsEnv::<span class="built_in">getInstance</span>().<span class="built_in">shouldUseAngle</span>()) &#123;</span><br><span class="line">        cnx-&gt;shouldUseAngle = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cnx-&gt;shouldUseAngle = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Android10 开始引入 ANGLE，简单来说就是用来将 opengl 翻译为 vulkan ，先忽略</span></span><br><span class="line">    <span class="type">driver_t</span>* hnd = <span class="built_in">attempt_to_load_angle</span>(cnx);</span><br><span class="line">    <span class="keyword">if</span> (!hnd) &#123;</span><br><span class="line">        <span class="comment">// Secondly, try to load from driver apk.</span></span><br><span class="line">        <span class="comment">// 尝试加载相关驱动的更新，这个也可以忽略</span></span><br><span class="line">        hnd = <span class="built_in">attempt_to_load_updated_driver</span>(cnx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一步：读取系统属性中指定了后缀的驱动名，尝试去加载这些驱动库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> failToLoadFromDriverSuffixProperty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!hnd) &#123;</span><br><span class="line">        <span class="type">char</span> prop[PROPERTY_VALUE_MAX + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> key : HAL_SUBNAME_KEY_PROPERTIES) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">property_get</span>(key, prop, <span class="literal">nullptr</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尝试去加载相关 so 。比如这里 prop 读取出来是 emulation</span></span><br><span class="line">            hnd = <span class="built_in">attempt_to_load_system_driver</span>(cnx, prop, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (hnd) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(key, DRIVER_SUFFIX_PROPERTY) == <span class="number">0</span>) &#123;</span><br><span class="line">                failToLoadFromDriverSuffixProperty = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二步：尝试去加载没有后缀的驱动库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!hnd) &#123;</span><br><span class="line">        <span class="comment">// 尝试加载系统驱动 ，加载成功后的结果保存在 driver_t hnd 中</span></span><br><span class="line">        hnd = <span class="built_in">attempt_to_load_system_driver</span>(cnx, <span class="literal">nullptr</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第三步：尝试通过模糊匹配方式去加载驱动库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!hnd &amp;&amp; !failToLoadFromDriverSuffixProperty) &#123;</span><br><span class="line">        hnd = <span class="built_in">attempt_to_load_system_driver</span>(cnx, <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hnd) &#123;</span><br><span class="line">        android::GraphicsEnv::<span class="built_in">getInstance</span>().<span class="built_in">setDriverLoaded</span>(android::GraphicsEnv::Api::API_GL,</span><br><span class="line">                                                            <span class="literal">false</span>, <span class="built_in">systemTime</span>() - openTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第四步：尝试将 EGL 和 GLES v1 和 v2 的库都加载进来，并将其加载的句柄保存起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!cnx-&gt;libEgl) &#123;</span><br><span class="line">        cnx-&gt;libEgl = <span class="built_in">load_wrapper</span>(EGL_WRAPPER_DIR <span class="string">&quot;/libEGL.so&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cnx-&gt;libGles1) &#123;</span><br><span class="line">        cnx-&gt;libGles1 = <span class="built_in">load_wrapper</span>(EGL_WRAPPER_DIR <span class="string">&quot;/libGLESv1_CM.so&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cnx-&gt;libGles2) &#123;</span><br><span class="line">        cnx-&gt;libGles2 = <span class="built_in">load_wrapper</span>(EGL_WRAPPER_DIR <span class="string">&quot;/libGLESv2.so&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cnx-&gt;libEgl || !cnx-&gt;libGles2 || !cnx-&gt;libGles1) &#123;</span><br><span class="line">        android::GraphicsEnv::<span class="built_in">getInstance</span>().<span class="built_in">setDriverLoaded</span>(android::GraphicsEnv::Api::API_GL,</span><br><span class="line">                                                            <span class="literal">false</span>, <span class="built_in">systemTime</span>() - openTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    android::GraphicsEnv::<span class="built_in">getInstance</span>().<span class="built_in">setDriverLoaded</span>(android::GraphicsEnv::Api::API_GL, <span class="literal">true</span>,</span><br><span class="line">                                                        <span class="built_in">systemTime</span>() - openTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)hnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Loader::open() 方法中，接收一个 egl_connection_t 类型的入参，而外部传入的正是全局属性：gEGLImpl ，因此在当前方法内部修改了入参 cnx 中的属性，实际是修改了 gEGLImpl 。</p>
<p>这里首先会判断 cnx-&gt;dso 属性是否为空，为空的话表示当前还没有加载对应的实现库，如果加载过的话，外部会将加载之后库的句柄保存给其 dso属性。</p>
<p>接着会调用 setEmulatorGlesValue() 方法来处理和设置模拟器属性。</p>
<h4 id="setEmulatorGlesValue"><a href="#setEmulatorGlesValue" class="headerlink" title="setEmulatorGlesValue"></a>setEmulatorGlesValue</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/Loader.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setEmulatorGlesValue</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="built_in">property_get</span>(<span class="string">&quot;ro.kernel.qemu&quot;</span>, prop, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="comment">// 尝试读取上面的参数值，如果是 1 的话表示是模拟器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atoi</span>(prop) != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上面读取出来的 ro.kernel.qemu  是 1 的话，则这里再读取：ro.kernel.qemu.gles</span></span><br><span class="line">    <span class="built_in">property_get</span>(<span class="string">&quot;ro.kernel.qemu.gles&quot;</span>,prop,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果读取出来的 ro.kernel.qemu.gles 是1，表示模拟器宿主支持gpu，所以将 qemu.gles 置为 1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">atoi</span>(prop) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">&quot;Emulator has host GPU support, qemu.gles is set to 1.&quot;</span>);</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;qemu.gles&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不然的话接着去读取 /vendor/lib/egl 文件夹下是否有文件so，</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* vendor_lib_path =</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">        <span class="string">&quot;/vendor/lib64/egl&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="string">&quot;/vendor/lib/egl&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> has_vendor_lib = (<span class="built_in">access</span>(vendor_lib_path, R_OK) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * /vendor/lib/egl 文件夹下有so,将 qemu.gles  设置为 2,表示此时走软件绘制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (has_vendor_lib) &#123;</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">&quot;Emulator has vendor provided software renderer, qemu.gles is set to 2.&quot;</span>);</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;qemu.gles&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 既没有 gpu ，也没有软件绘制库，此时将其设置为 0</span></span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">&quot;Emulator without GPU support detected. &quot;</span></span><br><span class="line">              <span class="string">&quot;Fallback to legacy software renderer, qemu.gles is set to 0.&quot;</span>);</span><br><span class="line">        <span class="built_in">property_set</span>(<span class="string">&quot;qemu.gles&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是处理模拟器环境下的逻辑，主要是判断当前运行环境是模拟器的话，则会根据当前模拟器是否支持GPU绘制，其实就是该模拟器中是否启用了主机的硬件加速功能；</p>
<p>具体会在当前方法中将检查的结果保存到系统属性：qemu.gles 中：</p>
<p>① qemu.gles &#x3D; 1 时，表示该模拟器支持主机硬件加速，此时可以理解为使用硬件绘制，会将自身绘制转给主机GPU去处理。</p>
<p>② qemu.gles &#x3D; 2 时，该模拟器不支持主机硬件加速，但是在指定目录下找到了软件绘制库，此时它使用软件绘制。</p>
<p>③ qemu.gles &#x3D; 0 时，该模拟器既不支持主机硬件加速，也没有软件绘制库存在。</p>
<p>回到 Loader::open() 方法接着往后看，跳过一些暂时不考虑的逻辑。我们可以看到在该方法中主要会有三次so加载的尝试，而这三次中，只要成功一次即可。</p>
<p>而这三次加载工作，都是交给 attempt_to_load_system_driver() 方法的，再往内部实际是 load_system_driver() 方法来实现的。所以我们这里从里往外来看。</p>
<h4 id="load-system-driver"><a href="#load-system-driver" class="headerlink" title="load_system_driver()"></a>load_system_driver()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/Loader.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">load_system_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* kind, <span class="type">const</span> <span class="type">char</span>* suffix, <span class="type">const</span> <span class="type">bool</span> exact)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MatchFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line">        <span class="function"><span class="type">static</span> std::string <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* libraryName, <span class="type">const</span> <span class="type">bool</span> exact)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 库的搜索路径，分32位和63位</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> searchPaths[] = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">                    <span class="string">&quot;/vendor/lib64/egl&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/system/lib64/egl&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                    <span class="string">&quot;/vendor/lib/egl&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/system/lib/egl&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 分别在上面的库搜索路径下去搜索该库名</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> dir : searchPaths) &#123;</span><br><span class="line">                std::string absolutePath;</span><br><span class="line">                <span class="comment">// 找到了就将 absolutePath 返回出去</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find</span>(absolutePath, libraryName, dir, exact)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> absolutePath;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 没有找到，则返回空字符串</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">string</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @param result   保存最终搜索到的库路径，如果没找到则没有值，找的话则有值</span></span><br><span class="line"><span class="comment">         * @param pattern  要查找的库名，比如 libGLES_emulation</span></span><br><span class="line"><span class="comment">         * @param search   要查找的路径，即在该路径下尝试查找该库</span></span><br><span class="line"><span class="comment">         * @param exact    是否使用精确查找，true 即只找 search/pattern.so 文件，找到了则返回true 否则返回false</span></span><br><span class="line"><span class="comment">         *                 false 时，则在 search 目录下遍历查找以 pattern 开头，以 .so 结尾的文件找到则返回true否则返回false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">find</span><span class="params">(std::string&amp; result,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> std::string&amp; pattern, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> search, <span class="type">bool</span> exact)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 精确查找时</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (exact) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 比如是 32位时，传入的 search 可能是 : /vendor/lib/egl 或者 /system/lib64/egl ， </span></span><br><span class="line"><span class="comment">                 * pattern 可能是 libGLES_emulation</span></span><br><span class="line"><span class="comment">                 * 那么这里拼接出来的最终库的绝对路径可能为： /vendor/lib/egl/libGLES_emulation.so</span></span><br><span class="line"><span class="comment">                 * 然后判断该文件是否存在，存在则表示找到了，此时将上面绝对路径存在入参result中返回出去</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                std::string absolutePath = std::<span class="built_in">string</span>(search) + <span class="string">&quot;/&quot;</span> + pattern + <span class="string">&quot;.so&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">access</span>(absolutePath.<span class="built_in">c_str</span>(), R_OK)) &#123;</span><br><span class="line">                    result = absolutePath;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 非精确查找，也就是模糊查找</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            DIR* d = <span class="built_in">opendir</span>(search);</span><br><span class="line">            <span class="keyword">if</span> (d != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">dirent</span>* e;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 遍历 search 目录下的文件</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span> ((e = <span class="built_in">readdir</span>(d)) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 跳过 libGLES_android.so ，这是软件绘制的实现，目前是模糊查找，这个库如果不跳过的话模糊查找永远都能找到</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">&quot;libGLES_android.so&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">// always skip the software renderer</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 模糊匹配，即匹配库前缀和要求的库名一样，并且后缀是 .so 的文件，不管这俩除外中间的属性值</span></span><br><span class="line">                    <span class="comment">// 即匹配 pattern&#123;*&#125;.so 文件</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strstr</span>(e-&gt;d_name, pattern.<span class="built_in">c_str</span>()) == e-&gt;d_name) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(e-&gt;d_name + <span class="built_in">strlen</span>(e-&gt;d_name) - <span class="number">3</span>, <span class="string">&quot;.so&quot;</span>)) &#123;</span><br><span class="line">                            result = std::<span class="built_in">string</span>(search) + <span class="string">&quot;/&quot;</span> + e-&gt;d_name;</span><br><span class="line">                            <span class="built_in">closedir</span>(d);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">closedir</span>(d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 外部传入 kind 的取值可能是 GLES 、EGL 、GLESv1_CM 、 GLESv2</span></span><br><span class="line"><span class="comment">     * 所以这里 libraryName 对应的应该是： libGLES 、libEGL 、 libGLESv1_CM 、 libGLESv2</span></span><br><span class="line"><span class="comment">     * 后面都只使用上面取值的其中一种来举例，不一一列出这些取值了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::string libraryName = std::<span class="built_in">string</span>(<span class="string">&quot;lib&quot;</span>) + kind;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果设置了后缀，那么在其后面拼接 _suffix , 比如厂商定制的，会传入后缀，</span></span><br><span class="line"><span class="comment">     * 比如高通的对应的是 adreno ，那么最终可能就是 : libEGL_adreno.so</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (suffix) &#123;</span><br><span class="line">        libraryName += std::<span class="built_in">string</span>(<span class="string">&quot;_&quot;</span>) + suffix;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!exact) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 没有配置后缀，那么此时判断当前是否是模糊查找。如果是模糊匹配的话，则不使用 suffix，只使用 kind</span></span><br><span class="line"><span class="comment">         * 比如传入的是 GLES ，那么则匹配以 libGLES_ 开头，以 .so 结尾的文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        libraryName += std::<span class="built_in">string</span>(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 MatchFile::find 方法去找到对应 so 的绝对路径</span></span><br><span class="line">    std::string absolutePath = MatchFile::<span class="built_in">find</span>(libraryName.<span class="built_in">c_str</span>(), exact);</span><br><span class="line">    <span class="comment">// 没找到的话，则直接返回 null </span></span><br><span class="line">    <span class="keyword">if</span> (absolutePath.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时将找到的 so 文件绝对路径保存起来</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> driver_absolute_path = absolutePath.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试去加载该 so 文件，返回该 so 句柄</span></span><br><span class="line">    <span class="type">void</span>* dso = <span class="built_in">do_android_load_sphal_library</span>(driver_absolute_path,</span><br><span class="line">                                              RTLD_NOW | RTLD_LOCAL);</span><br><span class="line">    <span class="keyword">if</span> (dso == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* err = <span class="built_in">dlerror</span>();</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;load_driver(%s): %s&quot;</span>, driver_absolute_path, err ? err : <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dso;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看load_system_driver()方法的入参含义：</p>
<p>① kind ：字符串类型，代表当前要查找并加载的库类型，取值可能是：GLES 、EGL 、GLESv1_CM 或者 GLESv2。</p>
<p>② suffix ：字符串类型，代表当前要查找并加载的库的后缀名，取值可能是：adreno ，它对应着高通的驱动实现。</p>
<p>③ exact：布尔类型，表示当前是否是精确查找&#x2F;加载。如果是 true的话表示当前只查找名称和后缀一样的库，false的话则无视后缀suffix去匹配。</p>
<p>进入到该方法中，首先会定义 MatchFile 类，这个类的作用就是用来查找对应的库文件。注意这查找库文件时，有两个路径：&#x2F;vendor&#x2F;lib&#x2F;egl 和 &#x2F;system&#x2F;lib&#x2F;egl ，任意一个路径找到都行。</p>
<blockquote>
<p>当然还额外区分32位和64位，他们的差别就是 lib 和 lib64。</p>
</blockquote>
<p>而 MatchFile 类中最重要的就是其提供的 find 方法，具体的注释写的比较清楚了，这里不赘述。</p>
<p>看完这个 MatchFile 类之后，接着来看当前方法的逻辑。</p>
<p>下面假设传入的 kind 是： GLES 。</p>
<p>首先会在入参 kind 的基础上，在其头部拼上  “lib”前缀，此时库名变成了： libGLES</p>
<p>接着判断有无后缀，有后缀的话则在前面基础上接着在尾部拼上: _suffix 。比如 suffix&#x3D; emulation 时，拼接的结果是：libGLES_emulation。</p>
<p>而如果没有指定后缀，指定了 exact &#x3D;false ，也就是启用模糊查找，此时会在后面拼接 _ 。因此此时拼接的结果就是 libGLES_ 。</p>
<p>然后调用 MathcFile 实例的 find() 方法去查找该库，查找到的话会返回该库对应的路径absolutePath。</p>
<p>最后调用 do_android_load_sphal_library() 方法来加载该路径下的库，将加载之后的句柄，或者说是其内存地址返回出去。后续使用这个句柄就可以访问该so库中的函数等属性。</p>
<h4 id="attempt-to-load-system-driver"><a href="#attempt-to-load-system-driver" class="headerlink" title="attempt_to_load_system_driver"></a>attempt_to_load_system_driver</h4><p>接着回到 attempt_to_load_system_driver 方法来看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/Loader.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">Loader::<span class="type">driver_t</span>* <span class="title">Loader::attempt_to_load_system_driver</span><span class="params">(<span class="type">egl_connection_t</span>* cnx, <span class="type">const</span> <span class="type">char</span>* suffix,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        <span class="type">const</span> <span class="type">bool</span> exact)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    android::GraphicsEnv::<span class="built_in">getInstance</span>().<span class="built_in">setDriverToLoad</span>(android::GraphicsEnv::Driver::GL);</span><br><span class="line"></span><br><span class="line">    <span class="type">driver_t</span>* hnd = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 首先去查找 GLES 库 ,它内部包括着 EGL 以及 OpenGL ES 1.x 和 2.x 的实现</span></span><br><span class="line">    <span class="type">void</span>* dso = <span class="built_in">load_system_driver</span>(<span class="string">&quot;GLES&quot;</span>, suffix, exact);</span><br><span class="line">    <span class="keyword">if</span> (dso) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 加载 GLES 成功的话，则使用它来初始化EGL 以及 OpenGL ES 1.x 和 2.x 的api</span></span><br><span class="line"><span class="comment">         * 因此这里的最后一个参数 mask 传入的是 EGL | GLESv1_CM | GLESv2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">initialize_api</span>(dso, cnx, EGL | GLESv1_CM | GLESv2);</span><br><span class="line">        <span class="comment">// 将加载之后的句柄保存在 driver_t 结构体实例中 ，然后返回出去</span></span><br><span class="line">        hnd = <span class="keyword">new</span> <span class="built_in">driver_t</span>(dso);</span><br><span class="line">        <span class="keyword">return</span> hnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果加载 GLES 库失败的话，则尝试挨个去加载实现，即挨个去加载 EGL ，OpenGL ES 1.x 2.x的实现库 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dso = <span class="built_in">load_system_driver</span>(<span class="string">&quot;EGL&quot;</span>, suffix, exact);</span><br><span class="line">    <span class="keyword">if</span> (dso) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * EGL 的实现库加载成功，则初始化 EGL 对应的api</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">initialize_api</span>(dso, cnx, EGL);</span><br><span class="line">        hnd = <span class="keyword">new</span> <span class="built_in">driver_t</span>(dso);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 加载 OpenGL ES 1.x的实现库</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dso = <span class="built_in">load_system_driver</span>(<span class="string">&quot;GLESv1_CM&quot;</span>, suffix, exact);</span><br><span class="line">        <span class="built_in">initialize_api</span>(dso, cnx, GLESv1_CM);</span><br><span class="line">        hnd-&gt;<span class="built_in">set</span>(dso, GLESv1_CM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 加载 OpenGL ES 2.x的实现库</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dso = <span class="built_in">load_system_driver</span>(<span class="string">&quot;GLESv2&quot;</span>, suffix, exact);</span><br><span class="line">        <span class="built_in">initialize_api</span>(dso, cnx, GLESv2);</span><br><span class="line">        hnd-&gt;<span class="built_in">set</span>(dso, GLESv2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 attempt_to_load_system_driver() 方法中，主要是完成 EGL 、OpenGL ES 1.x 和 2.x 对应实现库的加载和赋值。</p>
<p>先看看当前方法的入参：</p>
<p>① cnx ：它是 egl_connection_t 类型的，其实就是在 <a href="aa48ac49.html">GLES&amp;EGL-EGL-01</a> 讲到的 gEGLImpl。内部会在加载完驱动之后，修改它内部的对应的属性。</p>
<p>② suffix ：在查找库时，该库对应的后缀名。</p>
<p>③ exact： 是否是精确查找模式，即库名要完全匹配才算是找着了。</p>
<p>接着往下看，在该方法中主要有两次尝试来完成对应的驱动加载：</p>
<p>① 尝试加载 GLES 库，如果这个库存在并且加载成功的话，那么通过 initialize_api() 方法来初始化 EGL 和 OpenGL ES 1.x 和 2.x 的函数实现。</p>
<p>② GLES 库加载失败的话，那么会分别去尝试加载 EGL 、GLESv1_CM 和 GLESv2 这三个库，并分别用加载到的这三个库的地址，调用 initialize_api() 方法来分别初始化 EGL 、 OpenGL ES 1.x 和 2.x 的函数实现。</p>
<p>而这两种尝试的情况只会走一个。如果先尝试加载 libGLES 的成功了就不会去加载剩下那三个了，如果失败了才会去尝试加载那三个库。因为 libGLES 库一个顶仨，它内部将 EGL 、OpenGL ES 1.x和2.x的实现都包括了，而如果没有这个库，那么就去尝试加载另外三个库，这三个库分别就是 EGL、OpenGL ES 1.x和2.x的实现了。</p>
<p>在加载库时，调用的是前面讲到的 load_system_driver() 方法，传入的三个参数中，只有第一个kind会发生变化，其他俩参数都是由入参决定的。</p>
<p>而第一个参数kind第一次传入的是 “GLES”，表示当前尝试去加载 libGLES_XXX.so 文件，如果加载成功的话，返回值 dso 不为空。此时会调用 initialize_api() 方法来使用刚加载到的该库 dso 来初始化 cnx 中的属性，而具体初始化其中哪些属性呢？通过第三个参数来指定，这里传入的是：EGL | GLESv1_CM | GLESv2 ，即此时需要初始化 EGL 、OpenGL ES 1.x 和2.x 的API实现。</p>
<p>接下来看 initialize_api() 方法是怎么初始化的吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/Loader.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loader::initialize_api</span><span class="params">(<span class="type">void</span>* dso, <span class="type">egl_connection_t</span>* cnx, <span class="type">uint32_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要初始化 EGL 相关实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; EGL) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dlsym(handle，symbol) : handle 是使用dlopen函数之后返回的句柄，</span></span><br><span class="line"><span class="comment">         * -                       symbol是要求获取的函数的名称，函数，返回值是void*,指向函数的地址，供调用使用</span></span><br><span class="line"><span class="comment">         * 而获取到的 getProcAddress 函数的作用是返回一个 EGL/GL(ES) 的符号地址，作用跟后面的 dlsym() 类似</span></span><br><span class="line"><span class="comment">         * 该函数是 egl 中提供的，可以在 eglApi 中找到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        getProcAddress = (getProcAddressType)<span class="built_in">dlsym</span>(dso, <span class="string">&quot;eglGetProcAddress&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 后续准备修改 cnx-&gt;egl 属性了，这里先暂存起来</span></span><br><span class="line"><span class="comment">         * 而 curr 指向的是 cnx-&gt;egl 这个结构体内的函数列表，也就是 egl.cpp # gEGLImpl</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">egl_t</span>* egl = &amp;cnx-&gt;egl;</span><br><span class="line">        __eglMustCastToProperFunctionPointerType* curr =(__eglMustCastToProperFunctionPointerType*)egl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * egl_names : egl_entries.in  文件，所以这里 api 指向的就是该文件的内容</span></span><br><span class="line"><span class="comment">         * 下面就开始遍历 egl_names ，也就是遍历 egl_entries.in  文件中的api名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">char</span> <span class="type">const</span> * <span class="type">const</span> * api = egl_names;</span><br><span class="line">        <span class="keyword">while</span> (*api) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 遍历每个方法，先通过 dlsym 方法从加载的库里面找对应方法的指针位置</span></span><br><span class="line"><span class="comment">             * 拿不到的话则通过刚才拿到的 eglGetProcAddress 函数来取对应的api函数实现</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">char</span> <span class="type">const</span> * name = *api;</span><br><span class="line">            __eglMustCastToProperFunctionPointerType f = (__eglMustCastToProperFunctionPointerType)<span class="built_in">dlsym</span>(dso, name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                f = <span class="built_in">getProcAddress</span>(name);</span><br><span class="line">                <span class="comment">// 还是没找到，那该函数对应的指针就是 null ，也就是不存在该函数的实现，这个 dso库中没有实现该api规范</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    f = (__eglMustCastToProperFunctionPointerType)<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将这些函数挨个保存在 curr 当前指向的函数api上，而 curr 指向的实际是 egl ，也就是入参 cnx 的 egl</span></span><br><span class="line"><span class="comment">             * 因此这里就是给 cnx-&gt;egl 中的方法赋值了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            *curr++ = f;</span><br><span class="line">            api++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 给 cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX]-&gt;gl 中的函数定义赋值，找到对应的函数实现</span></span><br><span class="line"><span class="comment">     * gl_names_1 数组中存储的应该是 1.x 版本的OpenGL ES api</span></span><br><span class="line"><span class="comment">     * 另外的 gl_names 数组中存储的应该是 2.x 版本的OpenGL ES api,他内部的API数也明显多于前者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; GLESv1_CM) &#123;</span><br><span class="line">        <span class="comment">// 处理OpenGL es 版本1和2之间差异方法</span></span><br><span class="line">        <span class="built_in">init_api</span>(dso, gl_names_1, gl_names,</span><br><span class="line">            (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                &amp;cnx-&gt;hooks[<span class="type">egl_connection_t</span>::GLESv1_INDEX]-&gt;gl, getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; GLESv2) &#123;</span><br><span class="line">        <span class="comment">// 处理OpenGL es 版本1和2之间差异方法</span></span><br><span class="line">        <span class="built_in">init_api</span>(dso, gl_names, <span class="literal">nullptr</span>,</span><br><span class="line">            (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                &amp;cnx-&gt;hooks[<span class="type">egl_connection_t</span>::GLESv2_INDEX]-&gt;gl,</span><br><span class="line">            getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法接收三个参数：</p>
<p>① dso ：它是 void* 类型的，实际对应着前面查找并加载了的so库文件，后期可以通过它来访问该so库文件中内容。</p>
<p>② cnx ： 它是 egl_connection_t 类型的实例，实际就是在 <a href="aa48ac49.html">GLES&amp;EGL-EGL-01</a> 讲到的 gEGLImpl。当前方法中就会根据加载到的so库的dso参数，来为它内部的对应的属性赋值。</p>
<p>③ mask ：它表示当前传入的dso所对应的so库中存储的是EGL的还是 OpenGL ES 的实现。通过这个参数可以确定内部要怎么使用这个dso，去给cnx中哪些属性赋值。比如外部传入的是：EGL | GLESv1_CM | GLESv2 表示内部需要同时为 EGL 、OpenGL ES 1.x 和2.x 的属性赋值。</p>
<p>接着往下就是判断mask来做不同的处理，比如mask 中包括 EGL 时，表示此时需要为 EGL 相关的属性赋值，具体就是 cnx-&gt;egl 属性。</p>
<p>这里首先会从 dso 中读取出 eglGetProcAddress() 函数的实现，然后后续可能会用到这个函数，这个函数的解释详见这里：<a target="_blank" rel="noopener" href="https://registry.khronos.org/EGL/sdk/docs/man/html/eglGetProcAddress.xhtml">eglGetProcAddress</a> 。</p>
<p>接着会遍历 cnx-&gt;egl 属性中的函数定义，该属性是：egl_t 类型的，而这个 egl_t 结构体中就只是将 EGL&#x2F;egl_entries.in 文件中内容读取了出来，因此这里的 curr 就是用来遍历这个  egl_t 结构体内函数定义的。然后挨个从 dso 中找到具体的实现函数并赋值。</p>
<p>在dso中查找时，有两次尝试：</p>
<p>①通过 dlsym 去查找，找到了就赋值并开始下一次循环</p>
<p>②上面第一步没找着，那么通过调用上面找到的 eglGetProcAddress() 函数来查找。</p>
<p>如果两次都没找着，则赋值为 null ，表示该 dso 中没有实现该api。</p>
<blockquote>
<p>至于这里的 egl_t ，以及 EGL&#x2F;egl_entries.in 文件这些的解释，详见 <a href="aa48ac49.html">GLES&amp;EGL-EGL-01</a> 讲到的 基础知识 模块。</p>
</blockquote>
<p>这样的话 ，EGL 相关的api对应的实现就赋值完成了，对应到 cnx-&gt;egl 属性中，后期就可以调用 cnx-&gt;egl 中对应的函数了，这些函数最终就会执行到 dso 中对应的实现中去。</p>
<p>接着往下会初始化 GLESv1_CM 和 GLESv2 ，也就是分别给OpenGL ES 1.x和 2.x的API 实现去赋值。这里具体调用的是 init_api() 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/Loader.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loader::init_api</span><span class="params">(<span class="type">void</span>* dso,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">char</span> <span class="type">const</span> * <span class="type">const</span> * api,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">char</span> <span class="type">const</span> * <span class="type">const</span> * ref_api,</span></span></span><br><span class="line"><span class="params"><span class="function">        __eglMustCastToProperFunctionPointerType* curr,</span></span></span><br><span class="line"><span class="params"><span class="function">        getProcAddressType getProcAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> SIZE = <span class="number">256</span>;</span><br><span class="line">    <span class="type">char</span> scrap[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 整个遍历的就是 api</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (*api) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="type">const</span> * name = *api;</span><br><span class="line">        <span class="keyword">if</span> (ref_api) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="type">const</span> * ref_name = *ref_api;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果传入了 ref_api ，那么会判断当前 api name 是否跟 ref_api ref_name 相等</span></span><br><span class="line"><span class="comment">             * 如果不相等的话则自增 ref_api ，也就是找 ref_api 的下一个来做比较</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 直到找到相等的才接着往下走</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 如果 ref_api 不为空的话，一般它对应的数组都是大于等于 api 的，也就是api一般是 ref_api 的子集</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">strcmp</span>(name, ref_name) != <span class="number">0</span>) &#123;</span><br><span class="line">                *curr++ = <span class="literal">nullptr</span>;</span><br><span class="line">                ref_api++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先通过 dlsym 去dso中查找该 api的实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        __eglMustCastToProperFunctionPointerType f =</span><br><span class="line">            (__eglMustCastToProperFunctionPointerType)<span class="built_in">dlsym</span>(dso, name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dlsym 方式没找着的话则通过 getProcAddress 方法来找</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// couldn&#x27;t find the entry-point, use eglGetProcAddress()</span></span><br><span class="line">            f = <span class="built_in">getProcAddress</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 还是没找着的话，则尝试去掉当前方法的后缀：OES 再去查找一次（当然前提是有这个后缀）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="type">ssize_t</span> index = <span class="built_in">ssize_t</span>(<span class="built_in">strlen</span>(name)) - <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> ((index&gt;<span class="number">0</span> &amp;&amp; (index&lt;SIZE<span class="number">-1</span>)) &amp;&amp; (!<span class="built_in">strcmp</span>(name+index, <span class="string">&quot;OES&quot;</span>))) &#123;</span><br><span class="line">                <span class="built_in">strncpy</span>(scrap, name, index);</span><br><span class="line">                scrap[index] = <span class="number">0</span>;</span><br><span class="line">                f = (__eglMustCastToProperFunctionPointerType)<span class="built_in">dlsym</span>(dso, scrap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 还是没找着的话，则尝试给当前方法后面加上 OES 再去查找一次（当然前提是它的原后缀不是 OES）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="type">ssize_t</span> index = <span class="built_in">ssize_t</span>(<span class="built_in">strlen</span>(name)) - <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (index&gt;<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(name+index, <span class="string">&quot;OES&quot;</span>)) &#123;</span><br><span class="line">                <span class="built_in">snprintf</span>(scrap, SIZE, <span class="string">&quot;%sOES&quot;</span>, name);</span><br><span class="line">                f = (__eglMustCastToProperFunctionPointerType)<span class="built_in">dlsym</span>(dso, scrap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还是为空那就赋值为默认实现吧 gl_unimplemented</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            f = (__eglMustCastToProperFunctionPointerType)gl_unimplemented;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * GL_EXT_debug_label is special, we always report it as</span></span><br><span class="line"><span class="comment">             * supported, it&#x27;s handled by GLES_trace. If GLES_trace is not</span></span><br><span class="line"><span class="comment">             * enabled, then these are no-ops.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;glInsertEventMarkerEXT&quot;</span>)) &#123;</span><br><span class="line">                f = (__eglMustCastToProperFunctionPointerType)gl_noop;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;glPushGroupMarkerEXT&quot;</span>)) &#123;</span><br><span class="line">                f = (__eglMustCastToProperFunctionPointerType)gl_noop;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">&quot;glPopGroupMarkerEXT&quot;</span>)) &#123;</span><br><span class="line">                f = (__eglMustCastToProperFunctionPointerType)gl_noop;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *curr++ = f;</span><br><span class="line">        api++;</span><br><span class="line">        <span class="keyword">if</span> (ref_api) ref_api++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init_api() 方法中的逻辑算是比较简单的，但是它这个入参 api 和 ref_api 就很容易把人搞晕。</p>
<p>在 initialize_api() 方法中调用了两次init_api() 方法，这两次发你别传入的参数是：</p>
<p>第一次 mask &amp; GLESv1_CM ：</p>
<blockquote>
<p>api &#x3D; gl_names_1</p>
<p>ref_api &#x3D; gl_names</p>
<p>curr &#x3D; cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX]-&gt;gl</p>
</blockquote>
<p>第二次 mask &amp; GLESv2：</p>
<blockquote>
<p>api &#x3D; gl_names</p>
<p>ref_api &#x3D; null</p>
<p>curr &#x3D; cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX]-&gt;gl</p>
</blockquote>
<p>可以看到这里的 api 、ref_api 传入了两种搭配，为啥呢？</p>
<p>因为调用 init_api() 方法是为了给 cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX]-&gt;gl 或者 cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX]-&gt;gl 赋值的，也就是给  gl_t 结构体内的函数赋值。</p>
<p>我们看看 gl_t 结构体的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/hooks.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gl_t</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;entries.in&quot;</span></span></span><br><span class="line">&#125; gl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到它内部的函数定义是直接引用了 entries.in 文件中的所有，而它内部的这些定义是针对 OpenGL ES 2.x的，1.x的是在entries_gls1.in 文件中的，前者有一千多个API，后者只有三百个，并且前者是包括后者的。</p>
<p>而这里定义 cnx-&gt;hooks-&gt;gl 时，为了方便统一都是定义成 gl_t 类型，即统一都是一千多个函数。但是对于GLES 1.x 来说，他实际只有其中的三百多个，所以当是 GLES 1.x时，这里只会给gl_names_1 数组中的这些函数赋值，其他函数都是使用默认实现。而这个逻辑正是通过 api 和 ref_api 来实现 。</p>
<p>回到initialize_api() 方法中来，如果外部传入的 mask 满足：mask &amp; GLESv1_CM 和 mask &amp; GLESv2 情况时，会调用 init_api() 方法来初始化 cnx-&gt;hooks[]-&gt;gl 中的函数，而 cnx-&gt;hooks 是个长度为2的数组，其0 1 索引分别对应的是 egl_connection_t::GLESv1_INDEX 和 egl_connection_t::GLESv2_INDEX ，也就是分别对应着 GLES 1.x 的 2.x 的函数实现。</p>
<blockquote>
<p>注意这里修改的cnx-&gt;hooks[] ，其实和外部frameworks&#x2F;native&#x2F;opengl&#x2F;libs&#x2F;EGL&#x2F;egl.cpp 文件中的 gHooks 数组是一样的，因此 gHooks 数组中的属性也会被赋值。</p>
</blockquote>
<p>因此，小结来说：initialize_api() 方法会给 cnx-&gt;egl 以及 cnx-&gt;hooks[]-&gt;gl 中的函数定义赋值，赋值为 dso 中的对应的函数实现。当然具体初始化的是哪个，还得看mask。</p>
<p>回到 attempt_to_load_system_driver() 方法来，剩下的逻辑就好理解了吧。</p>
<p>这里额外补充下该方法的返回值：driver_t 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/Loader.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">driver_t</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">driver_t</span><span class="params">(<span class="type">void</span>* gles)</span></span>;</span><br><span class="line">        ~<span class="built_in">driver_t</span>();</span><br><span class="line">        <span class="comment">// returns -errno</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">set</span><span class="params">(<span class="type">void</span>* hnd, <span class="type">int32_t</span> api)</span></span>;</span><br><span class="line">        <span class="comment">// 保存着加载过来的 gles so 句柄 , 作用是用来判断 GPU driver 是否已经加载了</span></span><br><span class="line">        <span class="comment">// dso[0] : 存放了 libEGL.so 的句柄（dlopen 的返回值，后面一致）</span></span><br><span class="line">        <span class="comment">// dso[1] : 存放了 libGLESv1_CM.so 的句柄</span></span><br><span class="line">        <span class="comment">// dso[2] : 存放了 libGLESv2.so 的句柄</span></span><br><span class="line">        <span class="type">void</span>* dso[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/opengl/libs/EGL/Loader.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Loader::<span class="type">driver_t</span>::<span class="built_in">set</span>(<span class="type">void</span>* hnd, <span class="type">int32_t</span> api)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (api) &#123;</span><br><span class="line">        <span class="keyword">case</span> EGL:</span><br><span class="line">            dso[<span class="number">0</span>] = hnd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GLESv1_CM:</span><br><span class="line">            dso[<span class="number">1</span>] = hnd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GLESv2:</span><br><span class="line">            dso[<span class="number">2</span>] = hnd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Loader::<span class="type">driver_t</span>::<span class="built_in">driver_t</span>(<span class="type">void</span>* gles)</span><br><span class="line">&#123;</span><br><span class="line">    dso[<span class="number">0</span>] = gles;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">1</span> ; i&lt;<span class="built_in">NELEM</span>(dso) ; i++)</span><br><span class="line">        dso[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>driver_t 结构体内存在一个 void* dso 数组，长度为3，当加载 GLES 库成功时，dos[0] 用来保存他，其他俩都置为 Null；否则这三个挨个保存的是 EGL、GLESv1_CM 和 GLESv2 so库对应的句柄。</p>
<p>回到 open() 方法总来接着往后看，在 setEmulatorGlesValue() 方法之后，跳过一些暂时不考虑的逻辑，在 Loader::open() 方法中主要会有三次so加载的尝试，而这三次中，只要成功一次即可。</p>
<p>①第一次加载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> failToLoadFromDriverSuffixProperty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!hnd) &#123;</span><br><span class="line">        <span class="type">char</span> prop[PROPERTY_VALUE_MAX + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> key : HAL_SUBNAME_KEY_PROPERTIES) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">property_get</span>(key, prop, <span class="literal">nullptr</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尝试去加载相关 so 。比如这里 prop 读取出来是 emulation</span></span><br><span class="line">            hnd = <span class="built_in">attempt_to_load_system_driver</span>(cnx, prop, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (hnd) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(key, DRIVER_SUFFIX_PROPERTY) == <span class="number">0</span>) &#123;</span><br><span class="line">                failToLoadFromDriverSuffixProperty = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时会尝试先从系统中读取出：ro.hardware.egl 和 ro.board.platform 属性的值，然后将读取出来的属性值 prop 作为加载库时的<strong>后缀</strong>，传入到 attempt_to_load_system_driver() 方法中去尝试加载对应的库。</p>
<p>而这个后缀，一般不同的厂商会有不同的名称，比如高通的是adreno 后缀。</p>
<p>所以这里实际操作是：精确查找，带指定后缀的库。也就是去加载这些库：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libGLES_$&#123;prop&#125;.so</span><br><span class="line">或者：</span><br><span class="line">libEGL_$&#123;prop&#125;.so, libGLESv1_CM_$&#123;prop&#125;.so, libGLESv2_$&#123;prop&#125;.so</span><br></pre></td></tr></table></figure>


<p>②第二次加载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hnd = <span class="built_in">attempt_to_load_system_driver</span>(cnx, <span class="literal">nullptr</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>即不指定后缀，使用精确模式去查找。也就是去加载这些库：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libGLES.so,</span><br><span class="line">或者</span><br><span class="line">libEGL.so, libGLESv1_CM.so, libGLESv2.so</span><br></pre></td></tr></table></figure>


<p>③第三次加载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hnd = <span class="built_in">attempt_to_load_system_driver</span>(cnx, <span class="literal">nullptr</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>即不指定后缀，使用模糊查找方式去加载，也就是去加载这些库：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libGLES_*.so</span><br><span class="line">或者</span><br><span class="line">libEGL_*.so, libGLESv1_CM_*.so, libGLESv2_*.so</span><br></pre></td></tr></table></figure>


<p>接着再往后，会通过 load_wrapper() 方法去分别加载 &#x2F;system&#x2F;lib&#x2F; (64位是&#x2F;system&#x2F;lib64&#x2F;) 目录下的：libEGL.so 、libGLESv1_CM.so 、libGLESv2.so ，加载之后的句柄分别赋值给 cnx-&gt;libEgl 、cnx-&gt;libGles1 和 cnx-&gt;libGles2 ，这些等后面遇到了再说吧。</p>
<p>最后 open() 方法将最后加载结果， driver_t 实例返回出去。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/OpenGLES/">OpenGLES</a>
		  
			<a href="/tags/EGL/">EGL</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/4ee2033c.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">站点文章索引</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/60dbf32.html">
        <span class="next-text nav-default">GLES&EGL-GLES-03</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
