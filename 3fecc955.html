<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="AQS-ReentrantLock-Lock-源码分析"/>




  <meta name="keywords" content="Java," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/3fecc955.html"/>


<meta name="description" content="在Java并发并发编程中，逃不开的一个包就是：java.util.concurrent ，也就是常说的 ：JUC。在这个包下面提供了许多为并发编程而提供的工具类，比如常见的 ReentrantLock 、CountDownLatch 等，这些工具类基本都用到过，但是可能并不清楚其原理，所以这里就简单分析下这些常用类的原理实现。 如果你看过这个包下面的类结构的话，不难发现这些基本都是基于一个叫做：A">
<meta property="og:type" content="article">
<meta property="og:title" content="AQS-ReentrantLock-Lock-源码分析">
<meta property="og:url" content="https://youngkaaa.github.io/3fecc955.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="在Java并发并发编程中，逃不开的一个包就是：java.util.concurrent ，也就是常说的 ：JUC。在这个包下面提供了许多为并发编程而提供的工具类，比如常见的 ReentrantLock 、CountDownLatch 等，这些工具类基本都用到过，但是可能并不清楚其原理，所以这里就简单分析下这些常用类的原理实现。 如果你看过这个包下面的类结构的话，不难发现这些基本都是基于一个叫做：A">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/3fecc955/pic_01.png">
<meta property="og:image" content="https://youngkaaa.github.io/3fecc955/pic_02.png">
<meta property="og:image" content="https://youngkaaa.github.io/3fecc955/pic_03.png">
<meta property="og:image" content="https://youngkaaa.github.io/3fecc955/pic_04.png">
<meta property="article:published_time" content="2021-05-05T13:48:56.000Z">
<meta property="article:modified_time" content="2023-03-15T14:01:26.797Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/3fecc955/pic_01.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> AQS-ReentrantLock-Lock-源码分析 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          AQS-ReentrantLock-Lock-源码分析
        
      </h1>

      <time class="post-time">
          5月 05 2021
      </time>
    </header>



    
            <div class="post-content">
            <p>在Java并发并发编程中，逃不开的一个包就是：java.util.concurrent ，也就是常说的 ：JUC。在这个包下面提供了许多为并发编程而提供的工具类，比如常见的 ReentrantLock 、CountDownLatch 等，这些工具类基本都用到过，但是可能并不清楚其原理，所以这里就简单分析下这些常用类的原理实现。</p>
<p>如果你看过这个包下面的类结构的话，不难发现这些基本都是基于一个叫做：AbstractQueuedSynchronizer 的抽象类，他也就是我们常常听到的 AQS ，本文就以常用的 ReentrantLock 作为切入点，分析下 AQS 的源码实现。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在此之前，首先了解一下后续可能会用到的基础知识。</p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><p>我们知道，在线程 Thread 中存在一个 interrupt() 方法用来中断该 Thread 线程，但是这里说的中断，可能并不是大多数人理解的中断该线程的执行，即立马将该线程停止运行。下面我们举几个例子：</p>
<p>第一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">&quot;running....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行后，会一直打印 “running….” 表示该线程正在运行中，等外部执行其 interrupt() 方法来中断该线程时，打印出：”interrupt” 之后，该线程并没有终止执行，而是接着打印 “running….” ，因此 interrupt() 方法并没有像我们想象的那样去终止掉该线程的执行。</p>
<p>那到底怎么才能通过它来完成如源码注释中所言的：“Interrupts this thread” 效果呢，看看下一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                System.out.println(<span class="string">&quot;running....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread interrupted!!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;interrupt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，就可以成功的通过 interrupt() 方法来终止掉该线程的执行。</p>
<p>我们在代码中加入了 Thread.currentThread().isInterrupted() 的条件判断，该方法是用来检查当前线程是否已经被其他线程中断了，也就是是否被其他线程调用过 interrupt() 方法。</p>
<p>所以说，interrupt() 方法并不能直接终止掉线程的执行，而只是将该线程标记为已终止状态，而开发者可以通过 isInterrupted() 方法来拿到其终止状态。</p>
<p>有点像我们前面讲过的 <a href="898ecc0a.html">OkHttp</a> 中的 cancel() ，它会将一个固定的属性置为 true ，后续在操作开始前会判断该属性；又比如在<a href="b72a4fb1.html">协程开发</a>中，就要求在编写协程任务是支持可取消，即通过扩展属性 CoroutineScope.isActive 来判断当前 Job 是否被取消了 。</p>
<p>那么这个 interrupt() 方法就这一个作用嘛？并不是，在常见的 Object 中的 wait() 、join() ，或者 Thread 中的 sleep() 方法，这些都会导致当前调用时的线程被阻塞，直到某种条件被满足，比如被 notify()，或者sleep() 的时间到了；而这些阻塞操作可能影响的时间有长有短，如果很长不想等待了怎么办呢？可以调用其对应线程的 interrupt() 方法来中断等待，那么后续在 wait() 或者 sleep() 方法等待处就会被唤醒进而接收到一个 InterruptedException 异常，表示你的阻塞操作被别人终止了，并且此时在抛出异常的同时会将该线程的中断状态重置掉，也就是说，你在接受到 InterruptedException 之后，再去调用：Thread.currentThread().isInterrupted() 方法去获取该线程的中断状态时，返回的就是 false ，这点需要额外注意。</p>
<p>当然以上说的 wait() 、 sleep() 等阻塞方法可以感知到 interrupt() 方法的调用，从而中断掉自身阻塞的逻辑，这一能力是源码帮我们实现好了的。</p>
<blockquote>
<p>当然能感知到 interrupt() 方法的不止 wait() 、 sleep() 这几个方法，这里不列举了，可以自己去看看 Thread 类中 interrupt() 方法上的注释。</p>
</blockquote>
<p>这里需要额外补充一个挂起线程使其变成阻塞状态的方法：LockSupport.park() ：</p>
<p>LockSupport.park 方法和 wait() 类似，它也可以实现线程的挂起，但是和他不同的是，wait() 方法在感知到 interrupt() 方法时，会从之前 wait() 的地方抛出异常，并且将线程的中断状态重置为 false ；而 LockSupport.park 方法挂起指定线程之后，也能感知到 interrupt() 方法，然后从park() 方法处恢复接着往后执行，但不会将线程的中断状态重置掉。</p>
<p>同样与 LockSupport.park() 方法挂起线程相对应的还有一个 LockSupport.unpark() 方法用来恢复线程执行。</p>
<p>当然 LockSupport.park 方法和 wait() 这些方法的差异点不止这些，但这里暂时只讲这些，这些就够后面学习源码用了，他们之间细致的差别，后续可能会专门讲。</p>
<p>另外，关于前面提到的：线程中断状态，true or false 值的获取有两个容易混淆的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的中断状态，返回其状态同时会重置为初始状态，即 false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的中断状态，不会重置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这俩方法一个是静态方法，一个是类方法。</p>
<p>① 前者返回当前线程的中断状态，同时会将其中断状态重置为false ，也就是说如果一个线程被 interrupt() 方法中断了，那么第一次调用：interrupted() 方法时返回 true ，后续再调用就返回的是 false 了。</p>
<p>② 返回当前线程的中断状态，不会重置中断状态，所以说如果一个线程被 interrupt() 方法中断了，你多次调用 isInterrupted() 方法返回的都是 true。</p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>在 AbstractQueuedSynchronizer 类中定义了一个内部类 Node ，它用来表示一个请求当前锁的线程，当然他内部不止是有对应的线程信息，还有其他的属性，这里先简单看看它的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示线程获取锁的请求已经取消了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示当前节点后面的节点中的线程正在处于阻塞park状态，它需要当前线程完事儿之后把它唤醒</span></span><br><span class="line"><span class="comment">     * 这是给当前节点设置的状态，但是代表的是对后续节点的操作</span></span><br><span class="line"><span class="comment">     * 如果当前节点的状态是 SIGNAL ，则表示其后面一定还有一个等待中的线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示节点在条件队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享锁模式下会用到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取值就是：上面的几个常量 + 其初始值 0</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点的前一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点的后一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该节点所对应的线程实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件队列中下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到当前节点的前一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里 Node 是双向链表的一个元素，因为它内部存在 prev 、next 分别指向其前一个、后一个节点。</p>
<p>同时内部还有一个 nextWaiter ，它表示当前 Node 如果处于条件队列中时，它所指向的下一个节点。</p>
<p>有点晕，怎么又来一个 条件队列。我们在上面描述 nextWaiter 说的是：该 Node 如果位于条件队列时，那么其 nextWaiter 表示的是它指向的第一个节点，那么此时条件队列就是一个单向链表；</p>
<p>而前面的 next、prev 中又说他们俩分别表示该节点对应的下一个、上一个节点，那么表示它又可以放入到一个双向队列中去，而此时这个双向队列我们叫做：阻塞队列。</p>
<p>所以说，这个 Node 可以被放入到 阻塞队列，也可以被放入到 条件队列中去。而阻塞队列是一个双向队列，此时会使用到该 Node 中的 next 和 prev 字段，此时其 nextWaiter 属性为  null ；条件队列是一个单向队列，此时会使用到该 Node 中的 nextWaiter 字段，此时其 next 和 prev 属性为 null。</p>
<p>接着来简单讲讲什么是 阻塞队列，什么是条件队列：</p>
<p>① 阻塞队列是一个双向链表，它内部存储着那些正在等待着当前锁的线程。比如对于某个锁，前后有线程 A ，线程B ，线程C 分别来请求它，第一个来的线程A 先占有了该锁，等线程B 来的时候，发现锁被占用了，此时会将其包装成 Node 实例，放入到阻塞队列中；接着线程C来了，同样没有拿到锁，此时同样会将其包装成Node 实例，又放入到阻塞队列中，此时阻塞队列中的内容应该是：</p>
<p><img src="/3fecc955/pic_01.png" alt="image.png"></p>
<p>由于线程 A 目前正持有锁，所以它不是阻塞状态，也就不在所谓的<br>“阻塞队列”中。</p>
<p>而对于阻塞队列来说，AbstractQueuedSynchronizer 中有两个属性：head 、 tail 分别表示阻塞队列的头结点和尾节点。因此针对上面的例子来说，目前 head 应该是指向线程A对应的Node，tail 应该指向线程C对应的Node。而同时线程A目前正在执行中，所以head 其实应该是指向阻塞队列中那个持有锁，正在运行的线程Node实例。</p>
<p>因此说，虽然head 在双端队列中，但是它实际并不属于阻塞队列，真正的阻塞队列头结点应该是 head.next。</p>
<p>② 条件队列是针对 Condition 而言的，因为可以通过 Lock 对象实例的  newCondition() 方法创建一个 Condition 实例，后续使用该 Condition 的await() 等方法进行阻塞条件等待，直到某个条件满足时  signal() 方法来唤醒它。此时会用到条件队列，它是一个单向链表，在这个单向链表中也会放置若干个 Node 实例，表示在该 Condition 上正在阻塞的那些线程。它的结构可能是：</p>
<p><img src="/3fecc955/pic_02.png" alt="image.png"></p>
<p>对于条件队列来说，更具体的分析详见：<a href="591e1c31.html">AQS-ReentrantLock-Condition-源码分析</a></p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 全称 Compare And Swap , 即比较并交换值。它是无锁编程中使用到的，适合于那种读多写少的场景。</p>
<p>在使用 CAS 时，需要输入两个数值：一个旧值（期望操作前的值）和一个新值。比如：现在准备使用 CAS 来将内存地址为 V 的值，将其从 A 改成 B，那么 CAS 会有两步操作：</p>
<p>① 先检查此刻内存地址 V 对应的值是否还是旧值 A。<br>② 如果是的话，将其修改为B ，此时返回true表示修改成功；如果不是的话，说明有其他线程抢先修改了内存地址 V 处的值，因此此时会返回 false ，也就是修改失败。</p>
<p>并且 CAS 整体是一个原子操作，因此在 CAS 修改成功的情况下，能够保证是线程安全的。但是如果修改失败，一般会继续尝试，这个操作也叫做自旋。</p>
<p>对于 CAS 的具体操作是使用的 Unsafe 类。这里对于 CAS 只介绍到这里，足够看懂后续代码分析就行。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>关于 ReentrantLock 的使用，我们直接使用源码中给出的示例来看吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即先创建 ReentrantLock 实例，然后在需要加锁时，调用其  lock() 方法，然后开始执行你要加锁的逻辑就行，最后调用其 unlock() 方法来释放锁，当然推荐的方式是；将你要加锁的逻辑放在 try 代码块中的，同时 unlock() 释放锁的逻辑放在 finally 代码块中，用于保证释放锁操作总是能被执行。</p>
<blockquote>
<p>这个  try finally 结构的代码你应该记住，这是使用 ReentrantLock 的模板</p>
</blockquote>
<p>接下来我们先看看它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认使用非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定使用公平锁还是非公平锁</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即在 ReentrantLock 中默认使用的是非公平锁，另外可以通过其另外一个构造方法来指定是使用公平锁还是非公平锁。接下来我们简单看看那这里面的 NonfairSync 和 FairSync 的类结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">       <span class="comment">// 省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// 省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码逻辑</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">       <span class="comment">// 省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>k可以看到，在其内部定义了一个 Sync 抽象类，继承自 AbstractQueuedSynchronizer ，然后额外提供了两个 Sync 抽象类的子类实现：NonfairSync 和 FairSync ，分别代表非公平锁和公平锁的实现。</p>
<p>而后续我们默认先分析公平锁的情况。</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><blockquote>
<p>注意后续分析的都是公平锁的实现，也就是 FairSync 子类中的逻辑</p>
</blockquote>
<p>我们先从 ReentrantLock 的 lock() 方法看起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在 lock() 方法中代码很简单，就寥寥几行而已，但它完成的事儿可并不少。</p>
<p>当调用 ReentrantLock 的 lock() 方法时，实际会将逻辑转交给 sync 实例去完成，也就是公平锁实现 FairSync 中，它内部也只是调用了其父类 AbstractQueuedSynchronizer 中的 acquire() 方法而已，传入的参数是1。</p>
<p>这里需要补充一下，ReentrantLock 也叫做可重入锁，这里为什么会传入 1，因为 ReentrantLock 是可重入锁，这也是它类名中的 Reentrant 的意思，同时还是独占锁。下面简单的介绍下这两种锁类型：</p>
<p>① 可重入锁：即同一个线程在持有锁的情况下，此线程如果再次访问了该锁的其他的方法，这个线程不需要再去竞争锁而是直接获得该锁。可重入锁设计目的是为了避免死锁的。</p>
<p>而当同一个线程再次获取到锁时，会自增对应的状态值，表示锁被持有两次，那么后续就需要两次 unlock() 操作才可以完全释放这个锁，而上面说的“状态值” 可以使用数值来计数，比如自增1 表示持有锁一次，释放锁一次则自减1，当该数值为 0 时表示锁被完全释放。所以这里传入的 1 就表示目前只需要请求持有锁一次。</p>
<p>② 独占锁，也叫排他锁，它是针对共享锁而言的，即每次只能有一个线程能持有锁，而共享锁则是允许多个线程同时获取锁。</p>
<p>好了，对他们的解释就简单到这里，我们回到 AbstractQueuedSynchronizer 中的 acquire() 方法中接着往下看代码，在该方法中一共有四个方法的调用，我们下面挨个分析下：</p>
<h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h4><p>这里调用到子类 FairSync 中去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到父类 AbstractQueuedSynchronizer 中定义的 state 的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 如果是0，那么当前还没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * hasQueuedPredecessors()：判断阻塞队列中是否存在其他线程还在等待中</span></span><br><span class="line"><span class="comment">         * compareAndSetState： CAS方式将 state 设置为 acquires</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 即：阻塞队列中目前没有其他线程在等待，那么在当前线程中尝试修改state，</span></span><br><span class="line"><span class="comment">         * 如果 state=0 的话将其设置为 acquires = 1，表示占用这个锁成功，返回true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时 c 不等于 0，那么表示早已有线程现在正占用锁</span></span><br><span class="line"><span class="comment">     * 那么我们判断下现在占用锁的那个线程那个是不是当前线程，是的话则自增 state 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="comment">// 整型溢出了</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取锁失败，返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在公平锁对应的 FairSync 实现中，也就是上面的代码中在尝试获取锁时主要分为如下几步：</p>
<p>① 调用 getState() 方法拿到父类 AbstractQueuedSynchronizer 中定义的 state 当前的值。</p>
<p>这里的 state 正是前面讲可重入锁时提到的“对应的状态值”，因为可重入性，锁可能会被同一个线程持有多次，那么就可以使用当前 state 来表示到底当前锁被持有了多少次，一开始锁没有被持有时它对应是 0 ，后续假设被线程A请求并持有之后，state自增为1，接着往后如果又被该线程A请求并持有的话，state自增为2，那么此时在线程A 中就需要有两次 unlock() 操作，将 state 一次次的自减为0，才表示该锁被完全释放。</p>
<p>同时注意该 state 使用了 volatile 关键字修饰，表示它是线程间可见的，即在一个线程中修改它的值，其他线程中的副本也会被同时修改。同时他还可以避免指令重排。后续这个 state 会通过 CAS 方式进行修改，修改之后的值其他线程同步可见。</p>
<p>② 判断 state 的值是否是0，是的话表示当前锁还处于未被抢占状态，所以此时会先调用 hasQueuedPredecessors() 方法来判断是否还有其他线程正在排队等待当前锁，有的话则返回 false 表示当前 tryAcquire() 方法中尝试获取锁失败；如果没有的话，则会调用 compareAndSetState() 方法，也就是通过 CAS 方式来修改 state 的值，从0修改为1，如果成功的将 state 的值从 0 修改为 1了，此时会执行 setExclusiveOwnerThread() 方法来将当前线程实例保存到当前 FairSync 实例的父类 AbstractQueuedSynchronizer 的父类 AbstractOwnableSynchronizer 中，表示当前线程成功的抢占到了当前锁，当前锁归他所有了。</p>
<p>这里按顺序解释下：先看看 hasQueuedPredecessors() 方法中的逻辑，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 队列中第二个不为空且其对应的线程不是当前线程</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * h ! =t 表示双端队列不为空</span></span><br><span class="line"><span class="comment">     * s = h.next 拿到双端队列中第二个 Node，也就是阻塞队列的第一个，判断该 Node 中的线程是不是当前线程</span></span><br><span class="line"><span class="comment">     * 是的话则返回 false 表示正是当前线程在等，相当于没有别的线程在等待，</span></span><br><span class="line"><span class="comment">     * 不是的话返回true表示有别的线程在等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 hasQueuedPredecessors() 方法中，会判断当前阻塞队列中是否有其他线程正在排队等着这个锁释放呢，有的话该方法返回 true ；没有的话返回 false。</p>
<p>因为当前是公平锁实现，所以每个线程在请求锁的时候，都得看看有没有其他线程在等待，没有的话你才能使用该锁，否则你只能乖乖排队去。</p>
<p>看完了 hasQueuedPredecessors() 方法，再来看看 compareAndSetState() ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// stateOffset 其实对应的就是当前类中的 state 属性</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compareAndSetState() 方法中就是使用 CAS 方式来修改当前实例中的 state 的值，即此时尝试将 state 的值从 0 设置为 acquires ，也就是1 。如果 CAS 成功了，表示到现在，还没有别的线程抢走这个锁，因为现在  state 还是 0，如果其他线程把这个锁抢走了，此时 state 肯定已经在别的线程自增过了，那么此处 CAS 想把它从 0 变成1 肯定是失败的，因为 state 现在早已不是 0 了。</p>
<p>而由于当前 compareAndSetState() 方法是在 hasQueuedPredecessors() 方法返回 false 时才会执行的，因此如果当前 compareAndSetState() 方法执行了并且返回 true 时，表示当前线程抢占该锁成功了；如果返回 false ，表示抢占锁失败了。</p>
<p>而如果抢占锁成功的话，则会调用下一个方法：setExclusiveOwnerThread() 来将该线程实例保存到当前 FairSync 实例中，为什么这么说呢？因为 FairSync 继承自 Sync ，而 Sync 继承自 AbstractQueuedSynchronizer ，同时 AbstractQueuedSynchronizer 又继承自 AbstractOwnableSynchronizer ，下面看看 AbstractOwnableSynchronizer 中的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractOwnableSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractOwnableSynchronizer</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title function_">getExclusiveOwnerThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这下懂了 setExclusiveOwnerThread() 方法是啥意思了吧，他把抢占到当前锁的线程保存起来，表示该线程抢占到了这个锁，也叫独占了这个锁。</p>
<p>所以总结下第②步中的逻辑就是：当 state &#x3D;&#x3D; 0时，此时判断阻塞队里中是否还有其他线程在等待该锁，没有的话则尝试将 state 从 0 修改为 1 ，修改成功表示当前线程抢占该锁成功，将其保存起来。</p>
<p>③ 如果 state 不是 0 ，表示此时该锁已被占用，那它到底是被谁占用了呢？通过 getExclusiveOwnerThread() 方法就可以知道。如果它被别的线程抢占了，那没办法，咱们当前线程就老老实实排队等吧，如果之前它是被当前线程抢占的，那此时当前线程就是再次请求该锁，也就是重入，而 ReentrantLock 是支持重入的，所以此时直接再占有一次，此时会将 state 的值自增1。注意这里自增之后，还会判断int是否溢出，没有溢出的话会调用 setState() 将其设置到 state 中去。</p>
<p>咦？为啥前面用的是 compareAndSetState() 方法来设置，而这里就是调用 setState() 方法来直接修改 state 的值？因为现在是线程重入的情况，即都是在同一个线程执行的，没有并发问题。</p>
<p>④ 最后返回 false ，也就是说其他情况都返回false ，那么总结下什么情况下返回true呢？</p>
<p>第一种是：当前锁处于释放状态，且没有别的线程在等待该锁，然后同时当前线程抢占该锁成功了，会返回true；</p>
<p>第二种是：当前线程之前就抢占持有了该锁，此时重入时会直接再次持有该锁，返回true 。</p>
<p>总的来说，就是当前线程成功抢占到了该锁时，当前方法会返回 true 。</p>
<p>至此，tryAcquire() 方法分析完毕，回到 AbstractQueuedSynchronizer 中的 acquire() 方法内，看下一个方法 addWaiter。</p>
<h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p>先看其代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前线程，以及传入的 mode = Node.EXCLUSIVE 包装起来</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先使用快速入列法来尝试一下，如果失败了，则进行更加完备的CAS入列算法</span></span><br><span class="line"><span class="comment">     * 只有在必要的情况下才会使用更加复杂耗时的算法，也就是乐观的态度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * tail 默认值是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tail 默认值是 null ，所以第一次时这里不会走进去，而是走下面的 enq()</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * node 表示要插入的节点，此时这里先把要插入的节点 prev 指向 pred，也就是指向 tail 队列末尾</span></span><br><span class="line"><span class="comment">         * 这里只是修改了node的prev，并没有将其放入到队列中，只有下面CAS成功后才会放入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过CAS方式判断当前当前队列tail是否等于pred</span></span><br><span class="line"><span class="comment">         * 是的话表示当前队列没有其他线程修改，那么将其tail置为node，也就是说当前node插入到队列末尾，然后进入</span></span><br><span class="line"><span class="comment">         * 条件体内，将 pred 的 next 置为node，此时 pred 变成了倒数第二个节点，node 变成了最后一个节点</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果不是的话，表示其他线程修改过该队列，此时不做操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas失败,或在 tail == null 时调用 enq </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意此时外部传入的 mode &#x3D; Node.EXCLUSIVE &#x3D; null</p>
</blockquote>
<p>进入到该方法中之后，会首先创建一个 Node 实例，然后将当前线程实例和入参 mode &#x3D; null 保存起来。因此在创建出来的 Node 实例中：其 thread 被赋值为当前线程实例，nextWaiter 被赋值为 null ；</p>
<p>接下俩，会拿到 tail 也就是双端队列的尾节点的值，判断它不为空，则会进程链表操作，准备将这个新创建出来的 Node 插入到双端列表的末尾，也就是插入到阻塞队列的末尾。</p>
<p>接下来看看链表插入逻辑：首先会将新 Node 的 prev 指向 pred ，也就是 tail ；然后接下来应该是要将 pred.next 指向当前新 Node 了吧，也就是将其正式插入阻塞队列中来。但由于多线程并发，可能其他线程刚刚已经往阻塞队列中插入了一个另外新的 Node 实例，那这里要是还是往之前的 pred ，也就是之前的 tail 后面插入当前新Node的话，就会把其他线程插入的覆盖掉。所以这里额外还使用了一次 CAS ，即调用 compareAndSetTail() 方法来比对当前这一刻 tail 是否还是 pred ，是的话表示没有其他线程修改过，我们直接插入我们新的 Node 就行；如果不是 pred 了，表示其他线程插入了自己的Node，此时我们就不能再插入了，此时 pred.next 就不会指向当前新 Node 。</p>
<p>如果上面没有入队成功，一种情况是 tail 是null，即当前阻塞队列是空的；另外一种是别的线程抢先插入了自己的 Node 。那接下来得去调用 enq() 方法来将该 Node 插入到阻塞队列了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋，不断CAS尝试，如果插入失败会一直CAS重试，直到插入成功</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还是先拿到尾节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 如果当前队列为空，也就是 tail=null ，此时 head 肯定也是null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * CAS 判断如果当前 head 还是 null 的话，就将新创建出来的 Node 赋值给它，</span></span><br><span class="line"><span class="comment">             * 并且将 tail 赋值 为 head，此时队列里面就一个元素，tail == head</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果当前 head 不是 null 表示其他线程有修改过 head，此时不做操作，等待下一次循环重试</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 跟 addWaiter() 方法中类似</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 enq() 方法中，主要逻辑跟前面的 addWaiter() 方法中的差不多，额外多了当前阻塞队列为空的判断，即 tail &#x3D;&#x3D; null，当 tail &#x3D;&#x3D; null 时，head 肯定也是 null  ，表示当前阻塞队列为空，为啥呢？因为 head 和 tail 初始值都是null，并且后续赋值是同时的，即给 head 赋值之后，也会给 tail 赋值，所以 tail 不为空时head也不为空，tail 为空时head也是空。</p>
<p>因此当 tail 等于null 时，此时会创建一个新的，没有存储任何线程的 Node ，将其设置给 head ，然后同时让 tail 指向 head ，当然了，在设置给 head 时肯定要通过 CAS 了，即 compareAndSetHead() 方法的作用。给 head 设置完之后，就接着下次循环去走 else 中的逻辑，此时就跟前面讲的 addWaiter() 方法中的逻辑类似了。</p>
<p>总结下 addWaiter() 方法：该方法内部会首先尝试快速插入到阻塞队列中去，如果成功则返回新插入的这个 node 就行，如果失败则会调用逻辑更加完备的 enq() 方法来完成 node 的插入操作。为啥要这样设计呢？为啥不能直接走 enq() 就行了嘛，搞得这么麻烦！其实这种方式可以优化指令提升效率，毕竟绝大多数情况下第一次快速插入就会成功，走不到后面的 enq() 中，更详细的原因详见：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/65591522/answer/232685841">https://www.zhihu.com/question/65591522/answer/232685841</a> 。</p>
<blockquote>
<p>注意，上面的 enq() 方法返回的是要插入Node节点，成功插入之后，【它的上一个节点】。比如当一次就成功插入时，它返回的就是插入之前的尾节点，因为插入之后那个新插入的Node变成了现在的尾节点，而之前的尾节点是倒数第二个节点了。</p>
<p>虽然在 addWaiter() 方法中 enq() 方法的返回值被忽略掉了，但是我们还是需要提一下它。</p>
<p>而 addWaiter() 方法返回的却是那个新插入的 Node 节点实例。</p>
</blockquote>
<p>至此，addWaiter() 方法分析完了，回到 AbstractQueuedSynchronizer 中的 acquire() 方法内，看下一个方法acquireQueued。</p>
<h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前节点的前继节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果前面新插入的节点的前一个节点是 head，那么此时尝试再次获取锁看是否轮到自己执行了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果当前线程尝试获取锁 成功了，也就是说轮到该线程来执行了，其他后续线程必须等我释放锁他们才有机会执行他们的逻辑</span></span><br><span class="line"><span class="comment">                 * 那么此时只有我一个线程在访问数据，也就不存在并发问题，不用CAS自旋了，直接修改</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 先将当前线程对应的 Node 设置为 head，因为 head 表示的是正在持有锁的线程，也就是正在运行的线程</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                setHead(node);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// p 是之前的 head ，此时将其next 置为 null ，也就是它从链表中断开了，方便后续gc回收</span></span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 置为 false 表示当前线程获取锁成功了</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 返回当前线程在等待获取锁的过程中是否被其他线程调用过 interrupt() 方法中断过</span></span><br><span class="line"><span class="comment">                 * interrupted 默认是 false</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果当前节点的前一个节点不是 head 或者是 head ，但是调用 tryAcquire() 方法尝试获取锁失败了</span></span><br><span class="line"><span class="comment">             * 此时才会执行到这里</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 先调用 shouldParkAfterFailedAcquire(p, node) 方法来判断该node 是否需要阻塞 park</span></span><br><span class="line"><span class="comment">             * 需要的话则调用 parkAndCheckInterrupt() 方法来挂起该线程</span></span><br><span class="line"><span class="comment">             * 不需要的话则结束本次循环，进入下一次循环再试</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// failed 默认 false ，成功获取锁是 true ，并且获取锁是一直自旋阻塞着，所以最终肯定能拿到锁</span></span><br><span class="line">        <span class="comment">// 但是如果在运行过程中出现异常的话，则 failed 就不会被最终赋值，而保持 false </span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析该方法之前，先看看它的入参代表啥意思：</p>
<p>① node ：前面 addWaiter() 方法新创建的，内部保存了当前 thread 的，并且已经成功插入到阻塞队列中的 Node 实例。</p>
<p>② arg ：acquire() 方法传入的入参，实际是 1。</p>
<p>接下来看看  acquireQueued() 方法中的逻辑。</p>
<p>其内部主要是一个 for 死循环，在循环中，首先会拿到当前Node 的前一个节点 p ，然后判断该节点是否是 head，也就是判断当前 Node 的前一个节点是否是 head，如果是的话，才有可能轮到当前节点来获取锁，为什么呢？分情况讨论：</p>
<p>① head 对应的 Node ，其内部的 thread 为 null。</p>
<p>这种情况怎么发生的呢？还记得前面 enq() 方法中当 tail 为 null 时新创建的 Node 实例嘛？当时创建该 Node 实例时，他内部的属性并没有赋值，包括 thread &#x3D; null ，然后将该 Node 设置给 head ，然后 tail 也指向 head ，接着开始下一次循环，在下一次循环中会将当前线程对应的 Node 插入进去，此时链表是这样的：</p>
<p><img src="/3fecc955/pic_03.png" alt="image.png"></p>
<p>此时的线程A 对应的Node 就满足当前这种情况，即它的前一个节点是 head 。那么此时就轮到线程A去占有锁了，所以它可以去试试获取锁。</p>
<p>② head 对应的 Node ，其内部的 thread 不为 null。</p>
<p>那么表示 head 对应的线程正持有锁，那么当前线程作为它的下一个节点，可以尝试去获取下锁试试。这种情况就类似于这种情况：</p>
<p><img src="/3fecc955/pic_04.png" alt="image.png"></p>
<p>此时 head 的线程A 正在持有锁，而当前线程是 线程B ，它作为阻塞队列中的第一个，它有资格去试一下。</p>
<p>为什么说是 head 对应Node 的线程是正在持有锁的？往下看就知道了。</p>
<p>所以说当前 Node 的前一个节点是 head 时，它会去调用 tryAcquire() 方法去尝试获取锁。</p>
<p>如果获取锁成功了，则表示后续其他线程要获取该锁就得乖乖等着了，好好排队等着我释放锁吧。所以此时只有我当前这一个线程能访问这里的数据，也就不存在并发问题了，所以后续直接通过 setHead() 方法来修改当前head 值为当前 Node 实例，而不是再去 CAS 比对了。注意这里将当前线程对应的Node 设置给 head 了，而当前线程是刚获取到锁的，因此说：head 对应的线程是当前正在持有锁的，其后面的 Node 才是阻塞队列中的节点，因为后续节点都是要阻塞等待我当前线程释放锁的。因此你看上面的图就没疑问了吧。</p>
<p>设置完 head 之后，还会把 原来 head 从链表中断开，也就是将其 next 置为null ，后续该 Node 就完全从队列中移除了，可以被垃圾回收掉。</p>
<p>最后返回 interrupted 的值，它表示当前线程在阻塞获取锁的过程中，是否被其他线程调用过 interrupt() 方法中断过，而我们上面分析下来的流程是当前线程刚进来立马拿到锁的情况，并没有阻塞。但实际情况是如果前面有正在持有锁的，它没拿到锁，此时会通过 LockSupport.park()  方法来将其休眠阻塞，然后在阻塞过程中可能会被其他线程中断的情况，那么这个 interrupted 的值可能就是 true 了。</p>
<p>接着往下，如果前面的条件不满足，则当前线程没有获取到锁。此时会先调用 shouldParkAfterFailedAcquire() 方法来判断当前线程是否需要被挂起等待，我们看看这个方法中是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到前一个节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果前一个节点的状态是 SIGNAL ，则表示前一个节点正在持有锁，并且它完事儿之后会通知你</span></span><br><span class="line"><span class="comment">     * 那么我们直接返回 true 让外部把当前节点对应的线程休眠掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ws == AbstractQueuedSynchronizer.Node.SIGNAL)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 前一个节点处于 CANCEL 状态，那么从这个已被取消的前一个节点开始往前一直遍历</span></span><br><span class="line"><span class="comment">     * 找到下一个没被取消的节点，跳过中间那些已经被取消的连续节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 往前找到了一个没被取消的节点，那么让该节点的next指向当前节点</span></span><br><span class="line"><span class="comment">         * 相当于从链表中删除了那些连续的被取消的节点</span></span><br><span class="line"><span class="comment">         * 然后下面返回 false ，外部会执行下次循环重试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 那么此时前一个节点的状态就是 PROPAGATE 或者初始值 0</span></span><br><span class="line"><span class="comment">         * 此时将前一个节点的状态改为  SIGNAL ，表示前一个节点结束释放锁之后，需要唤醒下一个线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 前一个节点不是 SIGNAL 的话都返回false，即走下次重试</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来看看当前 shouldParkAfterFailedAcquire() 方法接受的两个入参的含义：</p>
<p>① pred : 当前线程对应的节点Node 的前一个节点</p>
<p>② node ：当前线程对应的节点 Node 实例，也就是前面刚在 addWaiter() 方法中入队的那个。</p>
<p>而在当前 shouldParkAfterFailedAcquire() 方法中，会拿到 pred 中的 waitStatus ，然后判断它的值：</p>
<p>① 如果 waitStatus  是 Node.SIGNAL 的话，则直接返回 true ，也就是外部可以去挂起当前线程了</p>
<p>② 如果 waitStatus  大于 0  的话，也就是说它是  Node.CANCELLED ，也就是当前节点前面的那个节点Node 已被取消了，此时会从 pred 节点开始往前找，找到一个没有取消的 Node ，然后将其 next 赋值为当前 Node 实例。也就是往前跳过那些已经取消的前置节点 Node ，注意这些被取消的节点同时也就从链表中删除了，等到下一次进来时，就不会走到当前条件中了。最后返回 false 。</p>
<p>③ 其他情况时，也就是 waitStatus 的取值是 Node.PROPAGATE 或者 0 时。此时会调用 compareAndSetWaitStatus() 方法来将 pred 中的 waitStatus 修改为 Node.SIGNAL ，也就是将当前 Node 的前一个节点的 waitStatus 修改为 Node.SIGNAL。最后返回 false。</p>
<p>可以看出来，只有第一种情况时，会返回true 来让外部去将当前线程休眠掉，而其他的情况都是返回 false ，即让外部去重试，执行下一次循环。所以说，只有当前节点的前一个节点的 waitStatus 是 Node.SIGNAL  时，当前节点对应的线程才可以被休眠阻塞，那 waitStatus &#x3D; Node.SIGNAL  代表了什么呢？</p>
<p>如果一个节点Node 的 waitStatus &#x3D; Node.SIGNAL 时，表示它后续节点对应的线程正在阻塞等待，那么该节点执行完毕释放锁之后，就应该唤醒后面那个正在等待的节点的线程。因此，在上面的  shouldParkAfterFailedAcquire() 方法中，当前线程能不能被阻塞，一直都需要看前一个节点的 waitStatus 是不是 Node.SIGNAL ，是的话则直接阻塞休眠，不是的话则尝试修改它，一旦修改成功那么下一次循环再进来 shouldParkAfterFailedAcquire() 方法时就会返回 true 了。</p>
<p>举个例子：</p>
<p>比如在前面 addWaiter() 方法中将一个新的节点 NodeA 入队时，只给该 NodeA 的 thread 和 nextWaiter 赋值了，分别赋值的是：Thread.currentThread()&#x3D;线程A 和 Node.EXCLUSIVE &#x3D; null，而其内部的 waitStatus 还是默认值 0，然后这个 waitStatus  &#x3D; 0 的 NodeA 后续执行到这里时，会把它前面节点的 waitStatus 修改为 Node.SIGNAL ，然后自身对应的线程A进入休眠，注意此时 NodeA 的  waitStatus 还是默认值 0；</p>
<p>然后假设接着又有一个线程B进来了，然后再经过  addWaiter() 方法创建 NodeB 添加到链表中，接着又走到这里，此时会将前面那个 NodeA 的 waitStatus  置为  Node.SIGNAL ，然后自身线程B 开始休眠阻塞，注意此时 NodeB 中的 waitStatus 还是默认值 0；</p>
<p>如此往复下去………</p>
<p>所以说，只有下一个线程进来之后，被加入到链表中之后，才会修改其前面的 Node 中的 waitStatus 为  Node.SIGNAL ，修改成功了它才能放心的去“睡觉去”，因为它知道，它的前一个执行完毕之后，会“叫醒”他的。而前一个节点怎么知道它完事儿之后要不要“叫醒”下一个呢？正是看它自己的 waitStatus 是不是  Node.SIGNAL。</p>
<p>好了，这个方法懂了吧，我们返回到 acquireQueued() 方法中，如果 shouldParkAfterFailedAcquire() 方法返回了 false ，则会进入到下一次循环中再执行一次；如果为 true 的话，则会调用 parkAndCheckInterrupt() 方法来将当前线程 park 掉，也就是前面说的 阻塞休眠。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以理解为：将当前线程从线程调度器中拆下来，那么当前线程后续不会被调度执行，</span></span><br><span class="line"><span class="comment">     * 也就是实现了休眠当前线程的目的</span></span><br><span class="line"><span class="comment">     * park() 方法执行之后，当前线程就会休眠，从而后续的代码就不会被执行了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 休眠结束了，该线程接着往后执行</span></span><br><span class="line"><span class="comment">     * 拿到当前线程的中断状态，并且会重置掉中断状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 parkAndCheckInterrupt() 方法中首先会调用 LockSupport.park() 方法来将当前线程挂起，相当于是将其从线程调度器中摘下来，那么后续就不会调度到它，那么它后续的逻辑就不会被执行。而外部看起来就是当前线程被阻塞在这里了。那么该线程就开始在这儿一直等啊等啊等……</p>
<p>而后续它被唤醒的情况有三种，满足其一即可唤醒它：</p>
<p>① 其他线程调用了 LockSupport.unpark() 方法来将它唤醒</p>
<p>② 其他线程调用了 Thread.interrupted() 方法来将它唤醒</p>
<p>③ 假唤醒，不止它，Object.wait() 也有这个问题。但是这种没事儿，外部是 for 循环，所以假唤醒也没事儿，后续还是会进来被再次 park 。</p>
<p>等了一会儿，有人把它唤醒了，但是它不知道它是怎么被唤醒的，所以它可以通过执行 Thread.interrupted() 方法，拿到当前线程的中断状态，如果返回 true 表示它是被其他线程调用了 Thread.interrupted() 方法来将它唤醒，此时返回 true ，否则返回 false。注意这里调用的 Thread.interrupted() 方法会在拿到中断状态结果之后，将中断结果重置掉，即下次返回就是 false 了。</p>
<p>回到  acquireQueued() 方法中，如果  parkAndCheckInterrupt() 方法返回true，会将 interrupted 赋值为 true，表示当前线程是被外部中断而醒来的，接着醒来后接着往后执行下一次循环，去尝试竞争锁，如果竞争到了则好说；没竞争到则接着休眠吧，表示本次醒来没啥用，又没轮到他。</p>
<p>直到最后，该线程被唤醒了，并且竞争成功，抢占到了锁，此时返回 interrupted 的值，此时它是 true 的话表示该线程被中断过，因为 interrupted 的值一开始是 false ，只要被设置为 true 一次，后续就一直是 true 。</p>
<p>至此，acquireQueued() 方法分析完了。并且它内部经过休眠之后，等该方法执行完返回出来时就表示该线程已经获取到锁了，回到 AbstractQueuedSynchronizer 中的 acquire() 方法内。</p>
<p>如果 acquireQueued() 方法返回 false 的话，则表示该线程没有被中断过，一直休眠等待，后续被 unpark 唤醒抢占到了锁；如果它返回 true 的话，表示该线程是被其他线程中断过，并且此时获取到了锁，此时外部会执行selfInterrupt() 方法来将其内部的中断状态置为 true ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为啥要这样做呢？因为在前面的 parkAndCheckInterrupt() 方法中，调用的 Thread.interrupted() 方法将中断状态重置掉了，而这里就是将其恢复成之前的已中断状态 ，那么后续在 ReentrantLock 外部，该线程中要不要去处理这个中断状态就是它的事儿了，我这个 ReentrantLock 中只保证不会给你把中断状态吞掉就行。</p>
<p>看完 lock() 方法，下面看看另外一个 lockInterruptibly() 方法，看看它和 lock() 有啥区别：</p>
<h3 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h3><p>如果你听懂了上面的代码，那么下面的代码就很好理解了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 开始之前先检查下当前线程是否已经被中断了</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 尝试去获取锁，失败了的话才会去执行后续的 doAcquireInterruptibly</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 还是先创建一个 Node 然后放入到阻塞队列中去</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 不同的是这里，这里被中断而唤醒之后，会抛出异常，终止获取锁的流程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上面的 lock() 方法不同的是，通过当前方法去获取锁，等待阻塞锁的过程，如果被其他线程中断了，那么会直接抛出 InterruptedException 异常终止获取锁的过程 ，此时走到 finally 代码块中，此时 failed &#x3D; true，进而去执行cancelAcquire() 方法来将该 Node 的 waitStatus 设置为 Node.CANCELLED 并从阻塞队列中移除掉。</p>
<p>所以说，lock() 方法中会在线程中断时照样去抢占锁，而 lockInterruptibly() 方法在线程中断时会直接抛出异常，退出锁竞争。</p>
<h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><p>前面使用 lock() 方法获取了锁，那么后续就可以使用的当前方法来释放锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用子类的实现，去尝试释放锁, 若锁被完全释放, 则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 执行进来，表示当前锁被完全释放，即 state 现在是 0</span></span><br><span class="line">        <span class="comment">// head 表示的就是当前持有锁的 node，所以这里直接释放 head</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//  2. h.waitStatus !=0 其实就是 h.waitStatus &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒head的后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 unlock() 方法中，回去调用 release() 方法，传入 1 表示需要将 state 减一，因为前面 lock() 时，每次 lock() 都会自增1 ，那么每次unlock() 就需要减去1。</p>
<p>在 release() 方法内部会调用其子类的 tryRelease() 方法去尝试释放锁，我们看看其子类怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前锁个数上面减去releases，也就是减去1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前调用 unlock 方法的线程并不是持有锁的线程</span></span><br><span class="line"><span class="comment">     * 那么就抛出 IllegalMonitorStateException 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果 state 减去本次要释放的个数之后是 0  了，表示锁被完全释放了</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 清掉之前保存的线程</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目前逻辑还归当前线程执行，后续线程还没有被唤醒，所以不存在并发问题直接修改</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，主要就是将 state 减去入参对应的个数1 ，然后还会判断当前调用 unlock() 方法的线程当前是否持有锁，只要持有锁，那么就肯定调用过 setExclusiveOwnerThread() 方法将该线程保存了起来，所以这里就使用它来判断当前线程是否是持有锁的那个。</p>
<p>最后会根据最终的 state 值是否为 0 来判断出当前锁是否被完全释放了，是的话则会调用 setExclusiveOwnerThread(null) 来清掉之前保存的线程。</p>
<p>回到 release() 方法中，所以说只有锁被完全释放了，才会执行后续的方法体内的逻辑。</p>
<p>后续，会拿到 head 节点，也就是当前持有锁，但是刚调用 unlock() 方法完全释放了锁的那个线程，此时它释放了锁，是不是它还得去通知下一个节点，唤醒它告诉他我现在释放锁了，该你去占有锁了。</p>
<p>此时会判断 head 的 waitStatus ，不等于 0才会去调用 unparkSuccessor() 方法来唤醒后续的Node ，为啥是不等于0呢？正如前面所言，阻塞队列中的 Node 中的 waitStatus  的值只会有三种： 默认值0，SIGNAL ，以及 CANCELLED ，但是 CANCELLED 的 Node 在次之前就会被清理掉，所以只会有： 默认值0，SIGNAL&#x3D; -1，所以这里的不等于0，其实就是判断其 waitStatus &#x3D; SIGNAL  ，此时才需要去唤醒下一个 Node ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// node 其实就是 head ，头结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 将当前节点中的 waitStatus 的值修改为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 拿到当前要释放的节点的下一个，也就是即将要被唤醒的那个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断下一个节点是否合法，即他是 null 或者 waitStatus &gt; 0 即被取消了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后唤醒后续节点，这样的话该节点就会从之前 park 的地方醒来接着往后执行，进而获取到锁</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面便唤醒了下一个Node 节点的线程，该线程会从之前 park 的地方醒来接着往后去执行，进而获取到锁，因为它此时是阻塞队列的第一个。</p>
<p>好了，以上便是公平锁 FairSync 实现下的逻辑分析了，下面看看非公平锁的实现。</p>
<h3 id="lock-1"><a href="#lock-1" class="headerlink" title="lock"></a>lock</h3><p>还是从 lock() 方法看起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平锁，所以上来就先获取尝试状态，不管队列里面有没有其他的在排队</span></span><br><span class="line"><span class="comment">     * 先判断当前锁状态是否是0，是的话就更新成1返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 抢占锁成功</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 没有抢占到，此时则正常走 acquire 逻辑</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非公平锁来说，一上来他就直接抢占锁，不管别人有没有在排队，直接使用 CAS 去尝试修改 state ，将其从 0 修改为1，如果 state 此时正好是 0 的话，表示当前锁当前处于被释放状态，那么它直接抢占到了，调用 etExclusiveOwnerThread() 方法将其保存起来，如果当前 state 不是 0 则回去走 acquire() 的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 还是先调用 tryAcquire 去尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// state == 0表达当前锁没有被占用</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 那么 CAS 修改 state 的值为 1，修改成功则表示抢占到锁了，那么返回true</span></span><br><span class="line">        <span class="comment">// 这里和公平锁不一样</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 保存起来，独占锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则返回false，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire() 方法中逻辑跟前面一样，先会去调用 tryAcquire() 方法尝试获取锁，此时走到 nonfairTryAcquire() 方法中，该方法中逻辑类似于前面公平锁 FairSync 中的 tryAcquire() 方法。唯一的差异就是在判断 state 等于0时，此时会直接去修改 state 的值来抢占锁，修改成功则表示抢占成功，而公平锁 FairSync 中的实现是还会调用 hasQueuedPredecessors() 方法来判断当前阻塞队列中是否还有正在等待的其他线程，有的话它不会去抢占该锁，而是乖乖去排队，没有的话它才会去抢占该锁。</p>
<p>所以说，公平锁和非公平锁的差异共两点：</p>
<p>① 非公平锁在一开始调用 lock() 方法时就会去抢占锁，不成功才回去走剩余逻辑</p>
<p>② 非公平锁后续在每次  tryAcquire() 方法中，都是判断如果没有人占用锁，自己都是直接抢，不管其他人有没有排队。</p>
<p>而如果都不满足，进入到阻塞队列之后，那公平锁和非公平锁就没啥区别了，都是要乖乖排队。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大，省去了公平锁中的恢复线程等调度延迟损耗。当然，非公平锁让获取锁的时间变得更加不确定，可能会存在线程饿死的情况。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Java/">Java</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/591e1c31.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">AQS-ReentrantLock-Condition-源码分析</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/4d381682.html">
        <span class="next-text nav-default">Java 动态代理原理分析</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
