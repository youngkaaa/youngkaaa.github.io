<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Android Activity 启动流程全解析"/>








  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/8f14e4f4.html"/>


<meta name="description" content="作为 Android 四大组件之一的 Activity ，平时在应用开发时，经常会用到它。甚至对于 Android 应用层开发来说，你可以没用过其他组件，但是 Activity 你肯定使用过。平时这么常用的东西，我对于其内部的原理，代码流程是怎么处理的却并不清楚。所以为了加深对 Activity 的理解，我们来分析下 Activity 的启动流程。 由于 Activity 中牵扯的其他知识点很多，">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Activity 启动流程全解析">
<meta property="og:url" content="https://youngkaaa.github.io/8f14e4f4.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="作为 Android 四大组件之一的 Activity ，平时在应用开发时，经常会用到它。甚至对于 Android 应用层开发来说，你可以没用过其他组件，但是 Activity 你肯定使用过。平时这么常用的东西，我对于其内部的原理，代码流程是怎么处理的却并不清楚。所以为了加深对 Activity 的理解，我们来分析下 Activity 的启动流程。 由于 Activity 中牵扯的其他知识点很多，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-13T13:50:58.000Z">
<meta property="article:modified_time" content="2023-03-12T13:09:08.215Z">
<meta property="article:author" content="咔咔咔">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Android Activity 启动流程全解析 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Android Activity 启动流程全解析
        
      </h1>

      <time class="post-time">
          1月 13 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>作为 Android 四大组件之一的 Activity ，平时在应用开发时，经常会用到它。甚至对于 Android 应用层开发来说，你可以没用过其他组件，但是 Activity 你肯定使用过。平时这么常用的东西，我对于其内部的原理，代码流程是怎么处理的却并不清楚。所以为了加深对 Activity 的理解，我们来分析下 Activity 的启动流程。</p>
<p>由于 Activity 中牵扯的其他知识点很多，比如事件分发，Window 机制，View 树等，而本文主要是侧重于 Activity 的启动流程，以及其内部的一些生命周期方法的调用分析。</p>
<p>在分析 Activity 启动流程时会遇到好多关于 Binder 使用的逻辑，但本文中并不分析其中的 IBinder 进程间通讯逻辑，这些逻辑属于 Binder 的内容，可以去看看：<a href="4ee2033c.html">这篇文章中的 Binder系列文章</a> 中的分析。</p>
<blockquote>
<p>由于我先写的 Service 的文章，后写的当前 Activity 的，所以这篇文章中会不自觉的默认读者是看过它了，因此会对一些前置知识一笔带过。所以建议你先去看看 <a href="49929abd.html">Android Service 启动流程全解析</a></p>
</blockquote>
<h2 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity"></a>startActivity</h2><p>该方法的定义是在 Context 中的，而我们平常遇到的 Context  的实现类有好多，比如 ContextImpl ，ContextWrapper 等，以及这俩的子类 Activivty 等，但是最终的实现基本都是 ContextImpl ，所以我们从 ContextImpl 中看起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ContextImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@NonNull</span> ActivityThread mMainThread;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startActivity</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    startActivity(intent, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startActivity</span><span class="params">(Intent intent, Bundle options)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 FLAG_ACTIVITY_NEW_TASK 的标识，即使用非 Activity 的 Context 来启动 Activity 时必须指定 FLAG_ACTIVITY_NEW_TASK</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">targetSdkVersion</span> <span class="operator">=</span> getApplicationInfo().targetSdkVersion;</span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span></span><br><span class="line">            &amp;&amp; (targetSdkVersion &lt; Build.VERSION_CODES.N</span><br><span class="line">                    || targetSdkVersion &gt;= Build.VERSION_CODES.P)</span><br><span class="line">            &amp;&amp; (options == <span class="literal">null</span></span><br><span class="line">                    || ActivityOptions.fromBundle(options).getLaunchTaskId() == -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AndroidRuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Calling startActivity() from outside of an Activity &quot;</span></span><br><span class="line">                        + <span class="string">&quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</span></span><br><span class="line">                        + <span class="string">&quot; Is this really what you want?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到当前 ActivityThread 中的 Instrumentation 实例</span></span><br><span class="line">    <span class="comment">// 然后调用到 Instrumentation 中的 execStartActivity() 方法中去</span></span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), <span class="literal">null</span>,</span><br><span class="line">            (Activity) <span class="literal">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ContextImpl 中，会做一些参数校验，然后将 startActivity 的逻辑交给 ActivityThread 中的 Instrumentation 去处理了。</p>
<p>ActivityThread 它虽然在类名中带了个 Thread ，但是它跟Java中的 Thread 类没有任何关系，他扮演了好几个角色：</p>
<p>① 它是 Android 应用进程被创建启动之后，在其内部的第一个线程中所运行的类；</p>
<p>② 它是system_server 中那些系统服务与应用进程进行”沟通”的“接口人”。当应用进程启动时，会在其第一个线程中运行处理 ActivityThread 类，此时会将其内部的 mAppThread ，也就是 ApplicationThread 实例作为当前进程的”引用”，通过Binder发送给位于 system_server 进程的 ActivityManagerService 去保存，后期可以使用它来与该进程进行通讯。</p>
<p>③ 它是主线程 Looper 创建和运行的类。在一个应用进程被创建启动起来之后，其中第一个线程会进行 Looper 的创建，以及开始 loop() 处理消息。所以会把这个”第一个线程” 叫做 主线程，或者 UI线程。但实际除了它是第一个被启动的线程之外，它和别的后续在当前进程启动的线程没有啥差异。所以如果非要把 ActivityThread  和线程扯上关系的话，那就是： ActivityThread 是创建主线程 Looper 的。</p>
<p>对于 ActivityThread  的简单概括就这几点吧，一时也反应不上来其他的，等后续源码分析时再做补充吧。</p>
<p>而对于ActivityThread   中的 Instrumentation  实例，它的赋值以及作用暂时先不讲，等到后面进程创建时再说吧，你暂时只需要知道它现在肯定已经被赋值初始化过了就行。</p>
<p>我们接着往后看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.Instrumentation.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ActivityResult <span class="title function_">execStartActivity</span><span class="params">(</span></span><br><span class="line"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span><br><span class="line"><span class="params">        Intent intent, <span class="type">int</span> requestCode, Bundle options)</span> &#123;</span><br><span class="line">    <span class="type">IApplicationThread</span> <span class="variable">whoThread</span> <span class="operator">=</span> (IApplicationThread) contextThread;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">referrer</span> <span class="operator">=</span> target != <span class="literal">null</span> ? target.onProvideReferrer() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="literal">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    <span class="keyword">if</span> (mActivityMonitors != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> mActivityMonitors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ActivityMonitor</span> <span class="variable">am</span> <span class="operator">=</span> mActivityMonitors.get(i);</span><br><span class="line">                <span class="type">ActivityResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                    result = am.onStartActivity(intent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (am.match(who, <span class="literal">null</span>, intent)) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拿到 ActivityTaskManagerService 系统服务在当前进程中的 Binder 代理对象实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ActivityTaskManager.getService().startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="literal">null</span> ? target.mEmbeddedID : <span class="literal">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="literal">null</span>, options);</span><br><span class="line">        <span class="comment">// 检查AMS返回的启动结果</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkStartActivityResult</span><span class="params">(<span class="type">int</span> res, Object intent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ActivityManager.isStartResultFatalError(res)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面就是一些经常遇到的启动 Activity 异常，比如没找到对应的 Activity</span></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_INTENT_NOT_RESOLVED:</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">            <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ActivityNotFoundException</span>(</span><br><span class="line">                        <span class="string">&quot;Unable to find explicit activity class &quot;</span></span><br><span class="line">                        + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                        + <span class="string">&quot;; have you declared this activity in your AndroidManifest.xml?&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ActivityNotFoundException</span>(</span><br><span class="line">                    <span class="string">&quot;No Activity found to handle &quot;</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_PERMISSION_DENIED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Not allowed to start activity &quot;</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AndroidRuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_ACTIVITY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;PendingIntent is not an activity&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_VOICE_COMPATIBLE:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(</span><br><span class="line">                    <span class="string">&quot;Starting under voice control not allowed for: &quot;</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;Session calling startVoiceActivity does not match active session&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_HIDDEN_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;Cannot start voice activity on a hidden session&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;Session calling startAssistantActivity does not match active session&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_ASSISTANT_HIDDEN_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;Cannot start assistant activity on a hidden session&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CANCELED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AndroidRuntimeException</span>(<span class="string">&quot;Activity could not be started for &quot;</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AndroidRuntimeException</span>(<span class="string">&quot;Unknown error code &quot;</span></span><br><span class="line">                    + res + <span class="string">&quot; when starting &quot;</span> + intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 execStartActivity() 方法中主要的逻辑就两步：</p>
<p>① 先通过 ActivityTaskManager.getService() 来拿到 system_server 进程中的 ActivityTaskManagerService 系统服务在当前进程中的 Binder 代理对象实例。然后调用其 startActivity() 方法来完成后续的逻辑。</p>
<p>② 调用 checkStartActivityResult() 方法来处理上面第①步 中拿到的返回值，如果启动失败则根据返回值来抛出不同的异常，比如常遇到的：”Unable to find explicit activity class XXX ; have you declared this activity in your AndroidManifest.xml?”。</p>
<p>接下来我们重点看看上面 第① 步中的逻辑分析，先看看 ActivityTaskManager.getService() 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityTaskManager.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IActivityTaskManager <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityTaskManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage(trackingBug = 129726065)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Singleton</span>&lt;IActivityTaskManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> IActivityTaskManager <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过 ServiceManager 获取到服务名为： &quot;activity_task&quot; 的 ActivityTaskManagerService 服务的代理对象实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">b</span> <span class="operator">=</span> ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再将该 Binder 代理对象实例包装成 IActivityTaskManager 接口，方便使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> IActivityTaskManager.Stub.asInterface(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 ActivityTaskManager.getService() 中，会获取 IActivityTaskManagerSingleton 单例中的值，第一次时会去调用其 create() 方法。在它的 create() 方法中会通过 ServiceManager.getService() 方法来获取 ActivityTaskManagerService Binder 服务在当前进程的 Binder代理对象实例，然后再将其包装成 IActivityTaskManager 的实例返回给外部去使用。</p>
<p>如果你不懂 ServiceManager.getService()  方法，不知道什么是 Binder 代理对象实例，那么建议你去看看 <a href="2af50710.html">Binder - Java Framework</a> 中的分析，当然还是建议你最好去看完 Binder 的全系列文章。</p>
<p>如果你不明白为什么 Context.ACTIVITY_TASK_SERVICE 对应的是 ActivityTaskManagerService 服务实例，那么建议你去看看：<a href="d663666b.html">Android 系统服务加载启动</a> 。</p>
<p>接着就该去看 ActivityTaskManagerService 中的 startActivity() 方法逻辑了，但是在此之前，我们先看看传过去的参数中几个需要解释的：</p>
<p>①  whoThread ，它是 IApplicationThread 类型的实例，实际对应的是当前进程中  ActivityThread 实例中的 mAppThread 实例，传递给到 system_server 进程那边，告诉他目前是哪个进程发起的调用。他后续好安排这些新老页面的生命周期方法调度。</p>
<p>② requestCode ，它是给 startActivityForResult() 方法来使用的，但是这里调用的是 startActivity() 呀？这种情况下它会被置为 -1 ，即 -1 告诉 ActivityTaskManagerService 我们不需要后续结果。</p>
<p>好了接着去看 ActivityTaskManagerService 中的 startActivity() 方法吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityTaskManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/*validateIncomingUser*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> validateIncomingUser)</span> &#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;startActivityAsUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">&quot;startActivityAsUser&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getActivityStartController() 拿到其内部的 ActivityStartController 实例</span></span><br><span class="line"><span class="comment">     * obtainStarter() : 使用入参 intent 和 &quot;startActivityAsUser&quot; 来创建 ActivityStarter 实例</span></span><br><span class="line"><span class="comment">     * 接着挨个将入参设置到这个 ActivityStarter 中，最后执行其 execute() 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">&quot;startActivityAsUser&quot;</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setMayWait(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，此时是刚从调用方应用进程中切换到 system_server 进程中来执行后续逻辑的。</p>
<p>而在  ActivityTaskManagerService 的 startActivity() 方法中，会创建一个 ActivityStarter 实例，然后将这些入参设置保存到该  ActivityStarter 实例中，最后调用其 execute() 方法来完成后续逻辑：</p>
<p>而对于 ActivityStarter 实例来说，它内部同时存在一个 Request 对象实例，该实例会存储着前面通过 ActivityStarter 设置进来的那些属性值，比如我们看看其中一个 setMayWait() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityStarter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Request</span> <span class="variable">mRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>();</span><br><span class="line"></span><br><span class="line">ActivityStarter <span class="title function_">setMayWait</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    mRequest.mayWait = <span class="literal">true</span>;</span><br><span class="line">    mRequest.userId = userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里使用到了类似 Builder 模式的方式来完成链式调用，适合这种参数很多，但是不都是必传的情况，可以使用链式来选择性的设置属性。</p>
<p>比如而这里 setMayWait() 方法中，会先将其内部的 Request 中的 mayWait 置为 true ，然后将入参保存到 Request 中。</p>
<p>我们接着来看其 execute() 方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityStarter.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 由于前面调用了 setMayWait() 方法，所以这里它是 true</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.mayWait) &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                    mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid,</span><br><span class="line">                    mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                    mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup,</span><br><span class="line">                    mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup,</span><br><span class="line">                    mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在  execute() 方法中根据 mayWait 的值，进行不同分支的执行，这里它是 true 所以走第一个 startActivityMayWait() 方法中的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityStarter.java</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="type">int</span> callingUid,</span></span><br><span class="line"><span class="params">    String callingPackage, <span class="type">int</span> requestRealCallingPid, <span class="type">int</span> requestRealCallingUid,</span></span><br><span class="line"><span class="params">    Intent intent, String resolvedType, IVoiceInteractionSession voiceSession,</span></span><br><span class="line"><span class="params">    IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> startFlags, ProfilerInfo profilerInfo, WaitResult outResult,</span></span><br><span class="line"><span class="params">    Configuration globalConfig, SafeActivityOptions options, <span class="type">boolean</span> ignoreTargetSecurity,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> userId, TaskRecord inTask, String reason,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="line"><span class="params">    PendingIntentRecord originatingPendingIntent, <span class="type">boolean</span> allowBackgroundActivityStart)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了一个 ActivityRecord 数组用来接收结果</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord[] outRecord = <span class="keyword">new</span> <span class="title class_">ActivityRecord</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 到这里接着往下走</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">            voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">            callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">            ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">            allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent,</span><br><span class="line">            allowBackgroundActivityStart);</span><br><span class="line"></span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span><br><span class="line"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> callingPid, <span class="type">int</span> callingUid,</span></span><br><span class="line"><span class="params">        String callingPackage, <span class="type">int</span> realCallingPid, <span class="type">int</span> realCallingUid, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">        SafeActivityOptions options, <span class="type">boolean</span> ignoreTargetSecurity, <span class="type">boolean</span> componentSpecified,</span></span><br><span class="line"><span class="params">        ActivityRecord[] outActivity, TaskRecord inTask, String reason,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="line"><span class="params">        PendingIntentRecord originatingPendingIntent, <span class="type">boolean</span> allowBackgroundActivityStart)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Need to specify a reason.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里接着往下走</span></span><br><span class="line">    mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">            aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">            callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">            options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">            inTask, allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent,</span><br><span class="line">            allowBackgroundActivityStart);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mLastStartActivityRecord[0] is set in the call to startActivity above.</span></span><br><span class="line">        outActivity[<span class="number">0</span>] = mLastStartActivityRecord[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getExternalResult(mLastStartActivityResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span><br><span class="line"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> callingPid, <span class="type">int</span> callingUid,</span></span><br><span class="line"><span class="params">        String callingPackage, <span class="type">int</span> realCallingPid, <span class="type">int</span> realCallingUid, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">        SafeActivityOptions options,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> ignoreTargetSecurity, <span class="type">boolean</span> componentSpecified, ActivityRecord[] outActivity,</span></span><br><span class="line"><span class="params">        TaskRecord inTask, <span class="type">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="line"><span class="params">        PendingIntentRecord originatingPendingIntent, <span class="type">boolean</span> allowBackgroundActivityStart)</span> &#123;</span><br><span class="line">    mSupervisor.getActivityMetricsLogger().notifyActivityLaunching(intent);</span><br><span class="line">    <span class="type">int</span> <span class="variable">err</span> <span class="operator">=</span> ActivityManager.START_SUCCESS;</span><br><span class="line">    <span class="comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Bundle</span> <span class="variable">verificationBundle</span></span><br><span class="line">            <span class="operator">=</span> options != <span class="literal">null</span> ? options.popAppVerificationBundle() : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WindowProcessController</span> <span class="variable">callerApp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 查找发起方进程的信息，如果没有查找到则认为是没有权限</span></span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;</span><br><span class="line">        callerApp = mService.getProcessController(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="literal">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.getPid();</span><br><span class="line">            callingUid = callerApp.mInfo.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Unable to find app for caller &quot;</span> + caller</span><br><span class="line">                    + <span class="string">&quot; (pid=&quot;</span> + callingPid + <span class="string">&quot;) when starting: &quot;</span></span><br><span class="line">                    + intent.toString());</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 检查要启动的 Activity 是已被注册了，没有注册的话则返回 ActivityManager.START_INTENT_NOT_RESOLVED</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class="literal">null</span>) &#123;</span><br><span class="line">        err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要启动的 Activity 对应的类路径不存在，返回 ActivityManager.START_CLASS_NOT_FOUND</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn&#x27;t find the specific class specified in the Intent.</span></span><br><span class="line">        <span class="comment">// Also the end of the line.</span></span><br><span class="line">        err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前面就已经发现错误了，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (err != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">            resultStack.sendActivityResultLocked(</span><br><span class="line">                    -<span class="number">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SafeActivityOptions.abort(options);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测调用者app是否有启动权限</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">abort</span> <span class="operator">=</span> !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">            requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity,</span><br><span class="line">            inTask != <span class="literal">null</span>, callerApp, resultRecord, resultStack);</span><br><span class="line">    abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line">    abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPackage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                aInfo.packageName, userId)) &#123;</span><br><span class="line">            <span class="type">IIntentSender</span> <span class="variable">target</span> <span class="operator">=</span> mService.getIntentSenderLocked(</span><br><span class="line">                    ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage,</span><br><span class="line">                    callingUid, userId, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">Intent</span>[]&#123;intent&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                            | PendingIntent.FLAG_ONE_SHOT, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">newIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> intent.getFlags();</span><br><span class="line">            flags |= Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;</span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_NEW_DOCUMENT)) != <span class="number">0</span>) &#123;</span><br><span class="line">                flags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK;</span><br><span class="line">            &#125;</span><br><span class="line">            newIntent.setFlags(flags);</span><br><span class="line"></span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_INTENT, <span class="keyword">new</span> <span class="title class_">IntentSender</span>(target));</span><br><span class="line">            <span class="keyword">if</span> (resultRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">                newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            intent = newIntent;</span><br><span class="line"></span><br><span class="line">            resolvedType = <span class="literal">null</span>;</span><br><span class="line">            callingUid = realCallingUid;</span><br><span class="line">            callingPid = realCallingPid;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 内部会通过 PackageManagerService 查找要启动的 Activity 信息，</span></span><br><span class="line"><span class="comment">             * 如果有多个匹配的 Activity，则会弹窗让用户选择启动哪个</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, <span class="number">0</span>,</span><br><span class="line">                    computeResolveFilterUid(</span><br><span class="line">                            callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">            aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,</span><br><span class="line">                    <span class="literal">null</span> <span class="comment">/*profilerInfo*/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PERMISSIONS_REVIEW) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">focusedStack</span> <span class="operator">=</span></span><br><span class="line">                        mRootActivityContainer.getTopDisplayFocusedStack();</span><br><span class="line">                Slog.i(TAG, <span class="string">&quot;START u&quot;</span> + userId + <span class="string">&quot; &#123;&quot;</span> + intent.toShortString(<span class="literal">true</span>, <span class="literal">true</span>,</span><br><span class="line">                        <span class="literal">true</span>, <span class="literal">false</span>) + <span class="string">&quot;&#125; from uid &quot;</span> + callingUid + <span class="string">&quot; on display &quot;</span></span><br><span class="line">                        + (focusedStack == <span class="literal">null</span> ? DEFAULT_DISPLAY : focusedStack.mDisplayId));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个 ActivityRecord 实例，在其构造方法里面会创建 AppToken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityRecord</span>(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="literal">null</span>,</span><br><span class="line">            mSupervisor, checkedOptions, sourceRecord);</span><br><span class="line">    <span class="comment">// 先将其保存到入参中外部就能拿到结果了</span></span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        outActivity[<span class="number">0</span>] = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始启动，注意此时会将上面刚创建出来的 ActivityRecord 传入进去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask, outActivity, restrictedBgActivity);</span><br><span class="line">    mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(res, outActivity[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就这样，一层层的调用了好几个方法，最终来到当前的 startActivity() 方法中，在该方法中会对要启动的 Activity 进行启动前检查。</p>
<p>比如该 Activity 没有在 Manifeset 中注册的话，则会返回 ActivityManager.START_INTENT_NOT_RESOLVED 错误 ，这样的话在前面讲到的 Instrumentation 中的 checkStartActivityResult() 方法中就会抛出 ActivityNotFoundException 异常提示你：”Unable to find explicit activity class XXX ; have you declared this activity in your AndroidManifest.xml?”</p>
<p>当然还有好多条件判断这里就不一一列出了。在判断完成之后，会创建一个 ActivityRecord 实例，将绝大部分入参参数都封装到里面去，然后接着往下会再执行下一个重载的 startActivity() 方法中。</p>
<p>在分析下一个方法之前，先简单了解下 ActivityRecord ：</p>
<h3 id="ActivityRecord"><a href="#ActivityRecord" class="headerlink" title="ActivityRecord"></a>ActivityRecord</h3><p>ActivityRecord 是应用层 Activity 在 ActivityTaskManagerService (之前是 ActivityManagerService ) 中的代表，每一个在应用进程中启动的 Activity ，在system_server 进程中的 ActivityTaskManagerService 中都有一个ActivityRecord 实例来与之对应，并且这个 ActivityRecord 会伴随着 Activity 的启动而创建，也伴随着 Activity 的终止而销毁。</p>
<p>下面简单看看它内部定义的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityRecord.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ActivityRecord</span> <span class="keyword">extends</span> <span class="title class_">ConfigurationContainer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略常量定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityTaskManagerService mAtmService; <span class="comment">// owner</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IApplicationToken.Stub appToken; <span class="comment">// window manager token</span></span><br><span class="line">    AppWindowToken mAppWindowToken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityInfo info; <span class="comment">// all about me</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> This is duplicated state already contained in info.applicationInfo - remove</span></span><br><span class="line">    ApplicationInfo appInfo; <span class="comment">// information about activity&#x27;s app</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> launchedFromPid; <span class="comment">// always the pid who started the activity.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> launchedFromUid; <span class="comment">// always the uid who started the activity.</span></span><br><span class="line">    <span class="keyword">final</span> String launchedFromPackage; <span class="comment">// always the package who started the activity.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> mUserId;          <span class="comment">// Which user is this running for?</span></span><br><span class="line">    <span class="keyword">final</span> Intent intent;    <span class="comment">// the original intent that generated us</span></span><br><span class="line">    <span class="keyword">final</span> ComponentName mActivityComponent;  <span class="comment">// the intent component, or target of an alias.</span></span><br><span class="line">    <span class="keyword">final</span> String shortComponentName; <span class="comment">// the short component name of the intent</span></span><br><span class="line">    <span class="keyword">final</span> String resolvedType; <span class="comment">// as per original caller;</span></span><br><span class="line">    <span class="keyword">final</span> String packageName; <span class="comment">// the package implementing intent&#x27;s component</span></span><br><span class="line">    <span class="keyword">final</span> String processName; <span class="comment">// process where this component wants to run</span></span><br><span class="line">    <span class="keyword">final</span> String taskAffinity; <span class="comment">// as per ActivityInfo.taskAffinity</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> stateNotNeeded; <span class="comment">// As per ActivityInfo.flags</span></span><br><span class="line">    <span class="type">boolean</span> fullscreen; <span class="comment">// The activity is opaque and fills the entire space of this task.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> See if it possible to combine this with the fullscreen field.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> hasWallpaper; <span class="comment">// Has a wallpaper window as a background.</span></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="type">boolean</span> noDisplay;  <span class="comment">// activity is not displayed?</span></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mHandoverLaunchDisplayId</span> <span class="operator">=</span> INVALID_DISPLAY; <span class="comment">// Handover launch display id to next activity.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> componentSpecified;  <span class="comment">// did caller specify an explicit component?</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> rootVoiceInteraction;  <span class="comment">// was this the root activity of a voice interaction?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它内部定义的属性很多，这里省略了大部分的。而光看贴出来的这些就能看到 Activity 的影子，因为好多都是和 Activity 相关的属性。</p>
<p>下面看看它的构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityRecord.java</span></span><br><span class="line"></span><br><span class="line">ActivityRecord(ActivityTaskManagerService _service, WindowProcessController _caller,</span><br><span class="line">        <span class="type">int</span> _launchedFromPid, <span class="type">int</span> _launchedFromUid, String _launchedFromPackage, Intent _intent,</span><br><span class="line">        String _resolvedType, ActivityInfo aInfo, Configuration _configuration,</span><br><span class="line">        ActivityRecord _resultTo, String _resultWho, <span class="type">int</span> _reqCode, <span class="type">boolean</span> _componentSpecified,</span><br><span class="line">        <span class="type">boolean</span> _rootVoiceInteraction, ActivityStackSupervisor supervisor,</span><br><span class="line">        ActivityOptions options, ActivityRecord sourceRecord) &#123;</span><br><span class="line">    mAtmService = _service;</span><br><span class="line">    mRootActivityContainer = _service.mRootActivityContainer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建出 Token 实例，它继承自 IApplicationToken.Stub ，后续在 WMS 中会使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    appToken = <span class="keyword">new</span> <span class="title class_">Token</span>(<span class="built_in">this</span>, _intent);</span><br><span class="line">    info = aInfo;</span><br><span class="line">    launchedFromPid = _launchedFromPid;</span><br><span class="line">    launchedFromUid = _launchedFromUid;</span><br><span class="line">    launchedFromPackage = _launchedFromPackage;</span><br><span class="line">    mUserId = UserHandle.getUserId(aInfo.applicationInfo.uid);</span><br><span class="line">    intent = _intent;</span><br><span class="line">    shortComponentName = _intent.getComponent().flattenToShortString();</span><br><span class="line">    resolvedType = _resolvedType;</span><br><span class="line">    componentSpecified = _componentSpecified;</span><br><span class="line">    rootVoiceInteraction = _rootVoiceInteraction;</span><br><span class="line">    mLastReportedConfiguration = <span class="keyword">new</span> <span class="title class_">MergedConfiguration</span>(_configuration);</span><br><span class="line">    resultTo = _resultTo;</span><br><span class="line">    resultWho = _resultWho;</span><br><span class="line">    requestCode = _reqCode;</span><br><span class="line">    setState(INITIALIZING, <span class="string">&quot;ActivityRecord ctor&quot;</span>);</span><br><span class="line">    frontOfTask = <span class="literal">false</span>;</span><br><span class="line">    launchFailed = <span class="literal">false</span>;</span><br><span class="line">    stopped = <span class="literal">false</span>;</span><br><span class="line">    delayedResume = <span class="literal">false</span>;</span><br><span class="line">    finishing = <span class="literal">false</span>;</span><br><span class="line">    deferRelaunchUntilPaused = <span class="literal">false</span>;</span><br><span class="line">    keysPaused = <span class="literal">false</span>;</span><br><span class="line">    inHistory = <span class="literal">false</span>;</span><br><span class="line">    visible = <span class="literal">false</span>;</span><br><span class="line">    nowVisible = <span class="literal">false</span>;</span><br><span class="line">    mDrawn = <span class="literal">false</span>;</span><br><span class="line">    idle = <span class="literal">false</span>;</span><br><span class="line">    hasBeenLaunched = <span class="literal">false</span>;</span><br><span class="line">    mStackSupervisor = supervisor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建 ActivityRecord 实例时，其内部的 appToken 就会被自动初始化，初始化为 Token 实例，关于它的用途后续在将 Window 体系时会用到，这里先跳过。</p>
<p>好了，我们接着往下看下一个 startActivity() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityStarter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span><br><span class="line"><span class="params">            ActivityRecord[] outActivity, <span class="type">boolean</span> restrictedBgActivity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> START_CANCELED;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack startedActivityStack;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">        <span class="comment">// 执行到下一个方法中去</span></span><br><span class="line">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, outActivity, restrictedBgActivity);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">// 省略其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span><br><span class="line"><span class="params">        ActivityRecord[] outActivity, <span class="type">boolean</span> restrictedBgActivity)</span> &#123;</span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor, restrictedBgActivity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找是否已存在可用的任务栈</span></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">reusedActivity</span> <span class="operator">=</span> getReusableIntentActivity();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该 Activity 已存在且可复用，则调用其 onNewIntent() 方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">topStack</span> <span class="operator">=</span> mRootActivityContainer.getTopDisplayFocusedStack();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">topFocused</span> <span class="operator">=</span> topStack.getTopActivity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">top</span> <span class="operator">=</span> topStack.topRunningNonDelayedActivityLocked(mNotTop);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">dontStart</span> <span class="operator">=</span> top != <span class="literal">null</span> &amp;&amp; mStartActivity.resultTo == <span class="literal">null</span></span><br><span class="line">            &amp;&amp; top.mActivityComponent.equals(mStartActivity.mActivityComponent)</span><br><span class="line">            &amp;&amp; top.mUserId == mStartActivity.mUserId</span><br><span class="line">            &amp;&amp; top.attachedToProcess()</span><br><span class="line">            &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">            || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK))</span><br><span class="line">            &amp;&amp; (!top.isActivityTypeHome() || top.getDisplayId() == mPreferredDisplayId);</span><br><span class="line">    <span class="keyword">if</span> (dontStart) &#123;</span><br><span class="line">        topStack.mLastPausedActivity = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            mRootActivityContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(mOptions);</span><br><span class="line">        <span class="keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deliverNewIntent(top);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> START_DELIVERED_TO_TOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> START_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前要启动的 Activity 是否是 FLAG_ACTIVITY_NEW_TASK 的</span></span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.resultTo == <span class="literal">null</span> &amp;&amp; mInTask == <span class="literal">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        newTask = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 则为其创建新的 Activity 栈</span></span><br><span class="line">        result = setTaskFromReuseOrCreateNewTask(taskToAffiliate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 复用之前的 Activity 栈</span></span><br><span class="line">        result = setTaskFromSourceRecord();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="literal">null</span>) &#123;</span><br><span class="line">        result = setTaskFromInTask();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">topTaskActivity</span> <span class="operator">=</span></span><br><span class="line">                mStartActivity.getTaskRecord().topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="literal">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 继续往后启动 Activity</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mRootActivityContainer.resumeFocusedStacksTopActivities(</span><br><span class="line">                    mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mStartActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        mSupervisor.mRecentTasks.add(mStartActivity.getTaskRecord());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// com.android.server.wm.RootActivityContainer.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">resumeFocusedStacksTopActivities</span><span class="params">(</span></span><br><span class="line"><span class="params">    ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.readyToResume()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="literal">null</span> &amp;&amp; (targetStack.isTopStackOnDisplay()</span><br><span class="line">            || getTopDisplayFocusedStack() == targetStack)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 接着往后去启动 Activity</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.android.server.wm.ActivityStack.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInResumeTopActivity) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mInResumeTopActivity = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 接着去往下执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mInResumeTopActivity = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拿到任务栈顶部resume状态的Activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">next</span> <span class="operator">=</span> topRunningActivityLocked(<span class="literal">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pausing</span> <span class="operator">=</span> getDisplay().pauseBackStacks(userLeaving, next, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先将之前的 Activity Pause 掉</span></span><br><span class="line"><span class="comment">         * 比如在 client1 中 Activity1 中启动了 client2 中的 Activity2</span></span><br><span class="line"><span class="comment">         * 此时的操作就是 AMS 发送消息到 client1 中的 Activity1，让他暂停自己，暂停自己后，AMS 会接着启动下一个Activity2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="literal">false</span>, next, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面暂停了之前的Activity之后，接着执行到这里，那么这里就要开始启动下一个 Activity 了</span></span><br><span class="line"><span class="comment">     * 只有之前启动过的Activity才会返回 true ，也就是说判断当前要启动的 Activity 是否是第二次启动了(即当前是onStop状态吧)</span></span><br><span class="line"><span class="comment">     * 存在的话直接启动，不存在则先创建进程再启动 Activity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (next.attachedToProcess()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果该 Activity 对应的进程已经存在了，那么直接启动就行了。所以这里创建 ClientTransaction</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span></span><br><span class="line">                    ClientTransaction.obtain(next.app.getThread(), next.appToken);</span><br><span class="line">            ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">            <span class="comment">// 将对应启动需要的参数保存到 ClientTransaction 中</span></span><br><span class="line">            <span class="keyword">if</span> (next.newIntents != <span class="literal">null</span>) &#123;</span><br><span class="line">                transaction.addCallback(</span><br><span class="line">                        NewIntentItem.obtain(next.newIntents, <span class="literal">true</span> <span class="comment">/* resume */</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 启动了的 Activity 就发送 ResumeActivityItem 事务给 client</span></span><br><span class="line"><span class="comment">             * 即要求它去执行自己的 onResume 方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            transaction.setLifecycleStateRequest(</span><br><span class="line">                    ResumeActivityItem.obtain(next.app.getReportedProcState(),</span><br><span class="line">                            getDisplay().mDisplayContent.isNextTransitionForward()));</span><br><span class="line">            <span class="comment">// 执行 ClientTransaction</span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(transaction);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// resume 该 Activity 失败了</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">&quot;Resume failed; resetting state to &quot;</span></span><br><span class="line">                    + lastState + <span class="string">&quot;: &quot;</span> + next);</span><br><span class="line">            next.setState(lastState, <span class="string">&quot;resumeTopActivityInnerLocked&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastResumedActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">                lastResumedActivity.setState(RESUMED, <span class="string">&quot;resumeTopActivityInnerLocked&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;Restarting because process died: &quot;</span> + next);</span><br><span class="line">            <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">                next.hasBeenLaunched = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; lastFocusedStack != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; lastFocusedStack.isTopStackOnDisplay()) &#123;</span><br><span class="line">                next.showStartingWindow(<span class="literal">null</span> <span class="comment">/* prev */</span>, <span class="literal">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="literal">false</span> <span class="comment">/* taskSwitch */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 此时是resume 该 Activity 失败了，那么此时重新启动它</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mStackSupervisor.startSpecificActivityLocked(next, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 该 Activity 还没有启动过，则需要重新启动它</span></span><br><span class="line">        <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">            next.hasBeenLaunched = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                <span class="comment">// 显示启动时的 Window 白屏窗口</span></span><br><span class="line">                next.showStartingWindow(<span class="literal">null</span> <span class="comment">/* prev */</span>, <span class="literal">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="literal">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">&quot;Restarting: &quot;</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">&quot;resumeTopActivityLocked: Restarting &quot;</span> + next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新启动 Activity 吧</span></span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>妈呀，又是这么长的调用路径。这一路下来最终执行到了 resumeTopActivityInnerLocked() 方法中，在该方法中主要完成两件事儿：</p>
<p>① 调用 startPausingLocked() 方法来暂停当前 Activity ，也就是调用它的 onPause() 方法。而此时新的 Activity 还没启动呢，因此我们说在 onPause() 方法中不能做耗时工作，因为它会影响后续的，下一页页面的启动。</p>
<p>② 启动下一个 Activity ，而这也分为两种情况：</p>
<ol>
<li><p>下一个 Activity 已经被启动过了，那么此时只需要将其 resume 就行；这种情况则是创建一个 ClientTransaction 实例，然后为其设置一个 ResumeActivityItem 实例进去，接着调用 mService.getLifecycleManager().scheduleTransaction() 方法来通知到该 Activity 所在的进程去，让他将该 Activity resume 掉。</p>
<p>但是如果执行 resume 操作失败了，还是会调用 mStackSupervisor.startSpecificActivityLocked() 方法作为兜底，来重新启动该 Activity。</p>
</li>
<li><p>下一个 Activity 还没被启动，那么则需要新创建一个实例，也就是从头开始执行生命周期。此时会调用 mStackSupervisor.startSpecificActivityLocked() 方法来从头启动该 Activity。</p>
</li>
</ol>
<p>所以总结看来这里有三种情况需要分析：</p>
<ol>
<li>startPausingLocked() 方法中暂停当前 Activity</li>
<li>mService.getLifecycleManager().scheduleTransaction() 方法去将下一个要启动的 Activity resume 掉</li>
<li>调用 mStackSupervisor.startSpecificActivityLocked() 方法来重新启动该 Activity 。(这种包括 ①resume 下一个 Activity失败的情况和②下一个Activity 还没启动只能重新启动 这两种情况 )</li>
</ol>
<p>注意，只要调用了 mStackSupervisor.startSpecificActivityLocked() 方法，那么必然会调用：next.showStartingWindow() 方法来展示一个启动前的白屏 Window ，这也就是你冷启动时先白屏的原因了。</p>
<p>那么下面我们按顺序来讲：</p>
<h3 id="startPausingLocked"><a href="#startPausingLocked" class="headerlink" title="startPausingLocked"></a>startPausingLocked</h3><p>这是上面讲到的第一种情况，即在启动下一个 Activity 之前会调用当前方法来暂停掉当前的 Activity。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityStarter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">startPausingLocked</span><span class="params">(<span class="type">boolean</span> userLeaving, <span class="type">boolean</span> uiSleeping,</span></span><br><span class="line"><span class="params">            ActivityRecord resuming, <span class="type">boolean</span> pauseImmediately)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (prev.attachedToProcess()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">&quot;Enqueueing pending pause: &quot;</span> + prev);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行 mService.getLifecycleManager().scheduleTransaction 方法来完成 pause 的事务</span></span><br><span class="line"><span class="comment">             * 注意这里传入的是上一个 app 的 prev.app.getThread() ，以及一个 PauseActivityItem 实例</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),</span><br><span class="line">                    prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                            prev.configChangeFlags, pauseImmediately));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Ignore exception, if process died other code will cleanup.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Exception thrown during pause&quot;</span>, e);</span><br><span class="line">            mPausingActivity = <span class="literal">null</span>;</span><br><span class="line">            mLastPausedActivity = <span class="literal">null</span>;</span><br><span class="line">            mLastNoHistoryActivity = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPausingActivity = <span class="literal">null</span>;</span><br><span class="line">        mLastPausedActivity = <span class="literal">null</span>;</span><br><span class="line">        mLastNoHistoryActivity = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中也是通过 mService.getLifecycleManager().scheduleTransaction() 方法来完成的，而这里的 mService 实际是 ActivityTaskManagerService 实例，其getLifecycleManager() 方法返回其内部的 ClientLifecycleManager 实例。</p>
<p>我们接下来看看它做了啥：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ClientLifecycleManager .java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTransaction</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread client, <span class="meta">@NonNull</span> IBinder activityToken,</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> ActivityLifecycleItem stateRequest)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 ClientTransaction 实例，内部会将入参都封装起来</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">clientTransaction</span> <span class="operator">=</span> transactionWithState(client, activityToken,</span><br><span class="line">            stateRequest);</span><br><span class="line">    scheduleTransaction(clientTransaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ClientTransaction <span class="title function_">transactionWithState</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread client,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IBinder activityToken, <span class="meta">@NonNull</span> ActivityLifecycleItem stateRequest)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">clientTransaction</span> <span class="operator">=</span> ClientTransaction.obtain(client, activityToken);</span><br><span class="line">    clientTransaction.setLifecycleStateRequest(stateRequest);</span><br><span class="line">    <span class="keyword">return</span> clientTransaction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IApplicationThread</span> <span class="variable">client</span> <span class="operator">=</span> transaction.getClient();</span><br><span class="line">    <span class="comment">// 其实还是执行到 ClientTransaction 中</span></span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// android.app.servertransaction.ClientTransaction.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mClient 类型是 IApplicationThread ，在 ClientTransaction 的 obtain 方法中被赋值</span></span><br><span class="line"><span class="comment">     * 这里实际是调用到奥 mClients 对应的应用进程中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mClient.scheduleTransaction(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClientTransaction <span class="title function_">obtain</span><span class="params">(IApplicationThread client, IBinder activityToken)</span> &#123;</span><br><span class="line">    <span class="type">ClientTransaction</span> <span class="variable">instance</span> <span class="operator">=</span> ObjectPool.obtain(ClientTransaction.class);</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">ClientTransaction</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mClient 的赋值在这里</span></span><br><span class="line">    instance.mClient = client;</span><br><span class="line">    instance.mActivityToken = activityToken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先外部调用 scheduleTransaction() 方法时，传入了当前要执行 pause操作的 Activity 所对应进程的 IApplicationThread 实例，然后内部会创建一个 ClientTransaction 对象实例，将 IApplicationThread  实例保存到其内部的 mClient 属性中，接着调用下一个scheduleTransaction() 方法，最终执行到 ClientTransaction 中的 schedule() 方法内，其内部会调用 mClient 的 scheduleTransaction()  方法，也就是通过 Binder 调用到要暂停的那个 Activity 所在进程中的 ActivivtyThread 中。</p>
<p>你要是不明白 这里的 IApplicationThread ，以及为啥调用到 ActivivtyThread  中。那么建议你先记住，然后接着往下看去找答案。</p>
<p>所以说 ClientTransaction  就代表了一个：对于 应用进程中 scheduleTransaction() 方法调用的事务操作。所以在通过 ClientTransaction 的 obtain() 方法创建 ClientTransaction  实例时，需要指定你要操作的 应用进程的 IApplicationThread   实例，这样的话后续才能指定 Binder 方法调用。以及通过它的其他方法来保存数据。</p>
<p>所以说，这里的场景下，ClientTransaction  中传入的是：要 Pause 的那个 Activity 所对应的进程。</p>
<p>那么接下来就从 system_server 进程调用到了 要 Pause 的那个 Activity 所对应的进程中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程 Looper 绑定的 Handler</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">H</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">H</span>();</span><br><span class="line"><span class="comment">// 一开始就创建好的 TransactionExecutor 实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TransactionExecutor</span> <span class="variable">mTransactionExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionExecutor</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略内部常量定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *这里是在 主线程 中执行的</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> (ClientTransaction) msg.obj;</span><br><span class="line">            mTransactionExecutor.execute(transaction);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 省略其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> msg.obj;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> SomeArgs) &#123;</span><br><span class="line">            ((SomeArgs) obj).recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&lt;&lt;&lt; done: &quot;</span> + codeToString(msg.what));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ApplicationThread</span> <span class="keyword">extends</span> <span class="title class_">IApplicationThread</span>.Stub &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这里就是从 AMS system_server 进程传过来的 ClientTransaction 对象实例，里面包含着当前应该怎么启动 actvivty 的信息</span></span><br><span class="line"><span class="comment">         * 这里是执行在 binder 线程池中的 ，所以后面我们需要转到主线程去执行 transaction 逻辑</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 这里会执行到 ActivityThread 的父类 ClientTransactionHandler 中去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ActivityThread.<span class="built_in">this</span>.scheduleTransaction(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// android.app.ClientTransactionHandler.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> &#123;</span><br><span class="line">    transaction.preExecute(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 还是往主线程 mH 中发送一条 H.EXECUTE_TRANSACTION 消息</span></span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在转到了：要 Pause 的那个 Activity 所对应的进程中来执行了，首先是指定的到 ApplicationThread 中的 scheduleTransaction() 方法中来，然后接着调用 ActivityThread 中的 scheduleTransaction() 方法，最终执行到它的父类 ClientTransactionHandler 中去执行，其也是往主线程Handler  mH 中发送一条 H.EXECUTE_TRANSACTION 消息。</p>
<p>接着就到了 mH 中去处理了，等主线程调度到该消息时，会执行到其 handleMessage() 方法中去，此时拿到传过来的ClientTransaction实例 ，然后在主线程中执行：mTransactionExecutor.execute() 方法来处理这个 ClientTransaction 实例中的事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  android.app.servertransaction.TransactionExecutor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ClientTransaction transaction)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先处理 ClientTransaction 中设置的 ClientTransactionItem，比如 LaunchActivityItem</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再去处理 ClientTransaction 中设置的 ActivityLifecycleItem </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 execute() 方法中逻辑比较简单，就两步：</p>
<p>① 调用 executeCallbacks() 方法来处理 ClientTransaction 中设置的 ClientTransactionItem</p>
<p>② 调用 executeLifecycleState() 方法去处理 ClientTransaction 中设置的 ActivityLifecycleItem </p>
<p>好了我们暂且先讲到这里，关于 mTransactionExecutor.execute() 方法中的 executeCallbacks() 和 executeLifecycleState() 方法 在当前 Activity 所在的进程中 是怎么处理的我们先暂且放下不管，等到后面再分析。</p>
<p>至此，在那个：要被 Pause 的 Activity 所对应的进程中 执行的逻辑分析完了，也就是在 system_server 进程中执行的 mService.getLifecycleManager().scheduleTransaction() 方法执行完毕了。</p>
<p>对于当前这种情况来说，就是那个要被 Pause 的 Activity 已经被 Pause了，也就是它的 onPause() 方法已经被调用了。</p>
<h3 id="scheduleTransaction"><a href="#scheduleTransaction" class="headerlink" title="scheduleTransaction"></a>scheduleTransaction</h3><p>这是上面讲到的第二种情况，即在启动下一个Activity 时，发现它已经被启动过了，那么此时我们只需要将其 resume 就行了，所以会创建一个 ClientTransaction 实例，然后为其设置一个 ResumeActivityItem 实例进去，接着调用 mService.getLifecycleManager().scheduleTransaction() 方法来通知到该 Activity 所在的进程去，让他将该 Activity resume 。</p>
<p>这种情况跟上面的一样，不同的是这里传入的时 ResumeActivityItem ，即用来将下一个 Activity 变成 Resume 状态。而上面当时传入的是 PauseActivityItem ，即用来将当前 Activity 变成 Pause 状态。</p>
<p>###startSpecificActivityLocked </p>
<p>这是上面讲到的第三种情况，它包括两种场景：</p>
<p>1、在启动下一个Activity 时，发现它已经被启动过了，但是我们在尝试将它 resume 时失败了，此时兜底执行该方法来重新启动下一个 Activity 。</p>
<p>2、在启动下一个Activity 时，发现它并没有被启动，此时只能重新启动它了。</p>
<p>下面来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityStackSupervisor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">startSpecificActivityLocked</span><span class="params">(ActivityRecord r, <span class="type">boolean</span> andResume, <span class="type">boolean</span> checkConfig)</span> &#123;</span><br><span class="line">    <span class="comment">// 先查找下一个 Activivty 对应的进程信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowProcessController</span> <span class="variable">wpc</span> <span class="operator">=</span></span><br><span class="line">            mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">knownToBeDead</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果要启动的Activity进程已经创建，执行 realStartActivityLocked 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (wpc != <span class="literal">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Exception when starting activity &quot;</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        knownToBeDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果要启动的 Activity 所对应的进程还没有创建，那么这里尝试去创建并启动该进程</span></span><br><span class="line"><span class="comment">         * 实际是去执行 ActivityManagerInternal::startProcess 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> PooledLambda.obtainMessage(</span><br><span class="line">                ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,</span><br><span class="line">                r.info.applicationInfo, knownToBeDead, <span class="string">&quot;activity&quot;</span>, r.intent.getComponent());</span><br><span class="line">        mService.mH.sendMessage(msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建该 Activity  时得分为两种情况来讨论：</p>
<p>① 该 Activity 所对应的进程当前已存在，那么直接去调用 realStartActivityLocked() 方法去启动就行了</p>
<p>② 该 Activity 所对应的进程还不存在呢，此时先去创建其对应的进程，具体是通过 ActivityManagerInternal::startProcess() 方法来实现的。</p>
<p>接下来我们分为两种情况来分别讲：</p>
<h4 id="realStartActivityLocked"><a href="#realStartActivityLocked" class="headerlink" title="realStartActivityLocked"></a>realStartActivityLocked</h4><p>这种情况对应的是上面的：要启动的 Activity 所对应的进程当前已存在，那么直接去调用当前方法去启动就行了。</p>
<p>先看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityStackSupervisor.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> andResume, <span class="type">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">task</span> <span class="operator">=</span> r.getTaskRecord();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> task.getStack();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!proc.hasThread()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建一个 ClientTransaction 实例，注意这里传入的 proc.getThread() 表示的是当前要启动的 Activity 的进程</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">clientTransaction</span> <span class="operator">=</span> ClientTransaction.obtain(</span><br><span class="line">                    proc.getThread(), r.appToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> r.getDisplay().mDisplayContent;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 往前面创建的 ClientTransaction 实例中设置了 LaunchActivityItem</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent),</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),</span><br><span class="line">                    r.icicle, r.persistentState, results, newIntents,</span><br><span class="line">                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),</span><br><span class="line">                            r.assistToken));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 通过 setLifecycleStateRequest() 方法来设置该 activity 启动后最终的状态，即是 ResumeActivityItem 还是 PauseActivityItem</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">            &#125;</span><br><span class="line">            clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 调用到要启动的 Activity 所对应的进程中去完成上面的事务</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            </span><br><span class="line">            r.launchFailed = <span class="literal">true</span>;</span><br><span class="line">            proc.removeActivity(r);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        endDeferResume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是会构建一个 ClientTransaction 实例，然后往该实例中添加了 callback &#x3D; LaunchActivityItem 表示后续需要启动该 Activity ，同时还设置了 ResumeActivityItem 或者 PauseActivityItem ，表示启动该 Activity 之后，该 Activity 最终的状态，是要执行到 onResume() 还是 onPause() 。</p>
<p>接着还是调用  mService.getLifecycleManager().scheduleTransaction() 方法来将该ClientTransaction  实例发送到要启动的Activity 的进程中去完成后续的启动工作。</p>
<h4 id="ActivityManagerInternal-startProcess"><a href="#ActivityManagerInternal-startProcess" class="headerlink" title="ActivityManagerInternal::startProcess"></a>ActivityManagerInternal::startProcess</h4><p>这种情况对应的是上面的：要启动的 Activity 所对应的进程还不存在呢，此时会调用当前方法来创建其对应的进程。</p>
<p>而这里的 ActivityManagerInternal  是一个抽象类，它内部的 startProcess() 方法是抽象方法，它对应的实现类是 ActivityManagerService 中的 LocalService ，在 ActivityManagerService 被创建时会将该 LocalService  添加到 LocalServices 中，详见：<a href="d663666b.html">Android 系统服务加载启动</a></p>
<p>所以也就是调用到 ActivityManagerService  中去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startProcess</span><span class="params">(String processName, ApplicationInfo info,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> knownToBeDead, String hostingType, ComponentName hostingName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">synchronized</span> (ActivityManagerService.<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行到其外部类 ActivityManagerService 中去</span></span><br><span class="line">            startProcessLocked(processName, info, knownToBeDead, <span class="number">0</span> <span class="comment">/* intentFlags */</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">HostingRecord</span>(hostingType, hostingName),</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/* allowWhileBooting */</span>, <span class="literal">false</span> <span class="comment">/* isolated */</span>,</span><br><span class="line">                    <span class="literal">true</span> <span class="comment">/* keepIfLarge */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是执行到了 ActivityManagerService   中的 startProcessLocked() 方法中去，那么接下来的流程就和  <a href="49929abd.html">Android Service 启动流程全解析</a> 中的  startProcessLocked 章节是一样的了，这里还是再讲一遍：</p>
<p>下面简单看看创建进程的代码流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ProcessRecord <span class="title function_">startProcessLocked</span><span class="params">(String processName,</span></span><br><span class="line"><span class="params">        ApplicationInfo info, <span class="type">boolean</span> knownToBeDead, <span class="type">int</span> intentFlags,</span></span><br><span class="line"><span class="params">        HostingRecord hostingRecord, <span class="type">boolean</span> allowWhileBooting,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isolated, <span class="type">boolean</span> keepIfLarge)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用到其内部的 mProcessList 实例中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,</span><br><span class="line">            hostingRecord, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>, keepIfLarge,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* ABI override */</span>, <span class="literal">null</span> <span class="comment">/* entryPoint */</span>, <span class="literal">null</span> <span class="comment">/* entryPointArgs */</span>,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// com.android.server.am.ProcessList.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ProcessRecord <span class="title function_">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> knownToBeDead, <span class="type">int</span> intentFlags, HostingRecord hostingRecord,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> allowWhileBooting, <span class="type">boolean</span> isolated, <span class="type">int</span> isolatedUid, <span class="type">boolean</span> keepIfLarge,</span></span><br><span class="line"><span class="params">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> SystemClock.elapsedRealtime();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="comment">// 是否设置过 android:isolatedProcess ，默认当做没设置吧，也就是 isolated = false</span></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">        checkSlow(startTime, <span class="string">&quot;startProcess: after getProcessRecord&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">&quot;Bad process: &quot;</span> + info.uid</span><br><span class="line">                        + <span class="string">&quot;/&quot;</span> + info.processName);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">&quot;Clearing bad process: &quot;</span> + info.uid</span><br><span class="line">                    + <span class="string">&quot;/&quot;</span> + info.processName);</span><br><span class="line">            mService.mAppErrors.resetProcessCrashTimeLocked(info);</span><br><span class="line">            <span class="keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,</span><br><span class="line">                        UserHandle.getUserId(info.uid), info.uid,</span><br><span class="line">                        info.processName);</span><br><span class="line">                mService.mAppErrors.clearBadProcessLocked(info);</span><br><span class="line">                <span class="keyword">if</span> (app != <span class="literal">null</span>) &#123;</span><br><span class="line">                    app.bad = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式创建进程之前，还会再检查下当前状态，这里省略掉这些代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正的去创建启动进程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> startProcessLocked(app, hostingRecord, abiOverride);</span><br><span class="line">    checkSlow(startTime, <span class="string">&quot;startProcess: done starting proc!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> success ? app : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy(&quot;mService&quot;)</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span><br><span class="line"><span class="params">        String abiOverride)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(app, hostingRecord,</span><br><span class="line">            <span class="literal">false</span> <span class="comment">/* disableHiddenApiChecks */</span>, <span class="literal">false</span> <span class="comment">/* mountExtStorageFull */</span>, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> disableHiddenApiChecks, <span class="type">boolean</span> mountExtStorageFull,</span></span><br><span class="line"><span class="params">            String abiOverride)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (app.pendingStart) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">seInfo</span> <span class="operator">=</span> app.info.seInfo</span><br><span class="line">                + (TextUtils.isEmpty(app.info.seInfoUser) ? <span class="string">&quot;&quot;</span> : app.info.seInfoUser);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意这里 entryPoint = &quot;android.app.ActivityThread&quot;,他就是最终进程创建出来后去加载执行的类</span></span><br><span class="line"><span class="comment">         * 到时候会在新进程中的线程中，执行其 main 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">entryPoint</span> <span class="operator">=</span> <span class="string">&quot;android.app.ActivityThread&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids,</span><br><span class="line">                runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                startTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        Slog.e(ActivityManagerService.TAG, <span class="string">&quot;Failure starting process &quot;</span> + app.processName, e);</span><br><span class="line">        mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, app.userId, <span class="string">&quot;start failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startProcessLocked</span><span class="params">(HostingRecord hostingRecord,</span></span><br><span class="line"><span class="params">            String entryPoint,</span></span><br><span class="line"><span class="params">            ProcessRecord app, <span class="type">int</span> uid, <span class="type">int</span>[] gids, <span class="type">int</span> runtimeFlags, <span class="type">int</span> mountExternal,</span></span><br><span class="line"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> startTime)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mService.mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里的 entryPoint = &quot;android.app.ActivityThread&quot; </span></span><br><span class="line"><span class="comment">             * 调用 startProcess() 会 fork 出一个新的进程，然后反射创建出 &quot;android.app.ActivityThread&quot; 对象实例，执行其 main 方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> Process.<span class="type">ProcessStartResult</span> <span class="variable">startResult</span> <span class="operator">=</span> startProcess(hostingRecord,</span><br><span class="line">                    entryPoint, app,</span><br><span class="line">                    uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    invokeWith, startTime);</span><br><span class="line">            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                    startSeq, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            Slog.e(ActivityManagerService.TAG, <span class="string">&quot;Failure starting process &quot;</span></span><br><span class="line">                    + app.processName, e);</span><br><span class="line">            app.pendingStart = <span class="literal">false</span>;</span><br><span class="line">            mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                    <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, app.userId, <span class="string">&quot;start failure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app.pid &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么创建进程并不是我们这这篇文章的重心，所以我们只需要直接最终创建出来的进程在一启动，也就是其内部的第一个线程启动后，会执行 ActivityThread 的 main() 方法。接下来，我们去看 ActivityThread 的 main() 方法中做了哪些事情吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    CloseGuard.setEnabled(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">configDir</span> <span class="operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化主线程 Looper 对象实例</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">startSeq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="literal">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建出 ActivityThread 实例，此时它内部的 mH 、mAppThread 等成员属性就会被初始化赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    <span class="comment">// 调用其 attach() 方法</span></span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始 Looper 循环，即主线程的消息循环，开始处理消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其 main() 方法中，主要是创建出 ActivityThread 实例，然后调用其 attach() 方法来进行初始化绑定工作，最后执行主线程的 Looper 循环。</p>
<p>注意当前是该进程中第一个线程中执行的逻辑，这个线程也就会被当做是主线程。但其实在进程中，并不分主线程，子线程之说，只有我们在 Android 中经常会讲，我们一般讲的主线程就是该进程中的第一个线程。</p>
<p>另外这里调用 attach() 方法时传入的第一个参数是 false ，而在 SystemServer 中初始化系统服务时，也会创建一个 ActivityThread 实例，那个时候调用 attach() 方法来绑定时传入的第一个参数就是 true ，详见：<a href="d663666b.html">Android 系统服务加载启动。</a></p>
<p>接下来来看这个 attach() 方法中做了什么操作吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(<span class="type">boolean</span> system, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">    sCurrentActivityThread = <span class="built_in">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时入参 system = false </span></span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        <span class="comment">// 拿到 ActivityManagerService 在当前进程中的 Binder 代理对象实例</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">IActivityManager</span> <span class="variable">mgr</span> <span class="operator">=</span> ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 调用到 ActivityManagerService 中的 attachApplication 方法内</span></span><br><span class="line"><span class="comment">             * 传入的第一个参数 mAppThread 的类型是 ApplicationThread ，它继承自 IApplicationThread.Stub</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册回调监听</span></span><br><span class="line">        BinderInternal.addGcWatcher(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                <span class="type">long</span> <span class="variable">dalvikMax</span> <span class="operator">=</span> runtime.maxMemory();</span><br><span class="line">                <span class="type">long</span> <span class="variable">dalvikUsed</span> <span class="operator">=</span> runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">&quot;Dalvik max=&quot;</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">&quot; total=&quot;</span> + (runtime.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">&quot; used=&quot;</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                    mSomeActivitiesChanged = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ActivityTaskManager.getService().releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">&quot;system_process&quot;</span>,</span><br><span class="line">                UserHandle.myUserId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation = <span class="keyword">new</span> <span class="title class_">Instrumentation</span>();</span><br><span class="line">            mInstrumentation.basicInit(<span class="built_in">this</span>);</span><br><span class="line">            <span class="type">ContextImpl</span> <span class="variable">context</span> <span class="operator">=</span> ContextImpl.createAppContext(</span><br><span class="line">                    <span class="built_in">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">            mInitialApplication = context.mPackageInfo.makeApplication(<span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">            mInitialApplication.onCreate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Unable to instantiate Application():&quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ViewRootImpl.<span class="type">ConfigChangedCallback</span> <span class="variable">configChangedCallback</span></span><br><span class="line">            <span class="operator">=</span> (Configuration globalConfig) -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">            <span class="comment">// We need to apply this change to the resources immediately, because upon returning</span></span><br><span class="line">            <span class="comment">// the view hierarchy will be informed about it.</span></span><br><span class="line">            <span class="keyword">if</span> (mResourcesManager.applyConfigurationToResourcesLocked(globalConfig,</span><br><span class="line">                    <span class="literal">null</span> <span class="comment">/* compat */</span>)) &#123;</span><br><span class="line">                updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(),</span><br><span class="line">                        mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This actually changed the resources! Tell everyone about it.</span></span><br><span class="line">                <span class="keyword">if</span> (mPendingConfiguration == <span class="literal">null</span></span><br><span class="line">                        || mPendingConfiguration.isOtherSeqNewer(globalConfig)) &#123;</span><br><span class="line">                    mPendingConfiguration = globalConfig;</span><br><span class="line">                    sendMessage(H.CONFIGURATION_CHANGED, globalConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册监听</span></span><br><span class="line">    ViewRootImpl.addConfigCallback(configChangedCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 attach() 方法中其实最主要的逻辑就一个：调用 ActivityManagerService 中的 attachApplication() 方法，注意这里传入的第一个参数：mAppThread 。它是 ActivityThread  中的成员变量，类型是 ApplicationThread ，它在前面 ActivityThread   实例创建时就已经被初始化了。而 ApplicationThread 是啥呢？你不觉得它很熟悉吗？前面在讲 system_server 中来调用 Service 所在进程去执行其 onStartCommand() 方法时，也是走到了 Service 所在进程的 ActivityThread 中的 ApplicationThread 中的对应方法内的。</p>
<p>其实 ApplicationThread  是继承自 IApplicationThread.Stub 的，也就是作为  IApplicationThread 的服务端实现，而其对应的实例就是 ActivityThread 中的 mAppThread 。</p>
<p>因此，我们可以知道这里调用 调用 ActivityManagerService 中的 attachApplication() 方法的目的是应该是通知 system_server 进程那边的 ActivityManagerService 实例，告诉他： 哥们，你刚不是创建了我么？我现在创建好了，并且已经启动啦，此时我执行了 ActivityThread 中的 attach() 方法中了，我把我的联系方式 mAppThread  通过 Binder 发送给你，你那边存一下，后面有事要找我的话，就通过 mAppThread 联系我就行。</p>
<p>注意，接下来就从当前新创建的进程中切换到了 system_server 进程中去执行了。</p>
<p>接下来我们看看 ActivityManagerService  中是怎么处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attachApplication</span><span class="params">(IApplicationThread thread, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">callingPid</span> <span class="operator">=</span> Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">callingUid</span> <span class="operator">=</span> Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">origId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> pid, <span class="type">int</span> callingUid, <span class="type">long</span> startSeq)</span> &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="type">long</span> bindApplicationTimeMillis;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">processName</span> <span class="operator">=</span> app.processName;</span><br><span class="line">    <span class="comment">// 注册 Binder 死亡监听</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">AppDeathRecipient</span> <span class="variable">adr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppDeathRecipient</span>(</span><br><span class="line">                app, pid, thread);</span><br><span class="line">        thread.asBinder().linkToDeath(adr, <span class="number">0</span>);</span><br><span class="line">        app.deathRecipient = adr;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        mProcessList.startProcessLocked(app,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HostingRecord</span>(<span class="string">&quot;link fail&quot;</span>, processName));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);</span><br><span class="line"></span><br><span class="line">    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;</span><br><span class="line">    app.setCurrentSchedulingGroup(app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT);</span><br><span class="line">    app.forcingToImportant = <span class="literal">null</span>;</span><br><span class="line">    updateProcessForegroundLocked(app, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    app.hasShownUi = <span class="literal">false</span>;</span><br><span class="line">    app.setDebugging(<span class="literal">false</span>);</span><br><span class="line">    app.cached = <span class="literal">false</span>;</span><br><span class="line">    app.killedByAm = <span class="literal">false</span>;</span><br><span class="line">    app.killed = <span class="literal">false</span>;</span><br><span class="line">    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);</span><br><span class="line"></span><br><span class="line">    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BackupRecord</span> <span class="variable">backupTarget</span> <span class="operator">=</span> mBackupTargets.get(app.userId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.isolatedEntryPoint != <span class="literal">null</span>) &#123;</span><br><span class="line">            thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                    instr2.mClass,</span><br><span class="line">                    profilerInfo, instr2.mArguments,</span><br><span class="line">                    instr2.mWatcher,</span><br><span class="line">                    instr2.mUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, autofillOptions, contentCaptureOptions);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里的 thread ，就是刚从那个新创建进程中传过来的，在当前 system_server 进程中的binder代理对象实例</span></span><br><span class="line"><span class="comment">             * 调用它对应的方法就可以执行到那个新创建进程中去</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 这边是调用过去通知它可以创建那边的 Application 了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, <span class="literal">null</span>, profilerInfo,</span><br><span class="line">                    <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Configuration</span>(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, autofillOptions, contentCaptureOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (profilerInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            profilerInfo.closeFd();</span><br><span class="line">            profilerInfo = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ProcessRecord # makeActive</span></span><br><span class="line"><span class="comment">         * 这样的话后续就可以获取该 IApplicationThread 了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        app.makeActive(thread, mProcessStats);</span><br><span class="line">        checkTime(startTime, <span class="string">&quot;attachApplicationLocked: immediately after bindApplication&quot;</span>);</span><br><span class="line">        <span class="comment">// 将该 ProcessRecord ，也就是该 IApplicationThread 保存到 mProcessList 中</span></span><br><span class="line">        mProcessList.updateLruProcessLocked(app, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        checkTime(startTime, <span class="string">&quot;attachApplicationLocked: after updateLruProcessLocked&quot;</span>);</span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// todo: Yikes!  What should we do?  For now we will try to</span></span><br><span class="line">        <span class="comment">// start another process, but that could easily get us in</span></span><br><span class="line">        <span class="comment">// an infinite loop of restarting processes...</span></span><br><span class="line">        Slog.wtf(TAG, <span class="string">&quot;Exception thrown during bind of &quot;</span> + app, e);</span><br><span class="line"></span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line">        mProcessList.startProcessLocked(app, <span class="keyword">new</span> <span class="title class_">HostingRecord</span>(<span class="string">&quot;bind-fail&quot;</span>, processName));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this record from the list of starting applications.</span></span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_PROCESSES &amp;&amp; mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES,</span><br><span class="line">            <span class="string">&quot;Attach application locked removing on hold: &quot;</span> + app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * badApp 默认是false，如果接下来的 startActivity、startService 。。。。 </span></span><br><span class="line"><span class="comment">     * 等逻辑操作时有一个遇到异常，那么就会置为true，那么就不会尝试后面的其他逻辑了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">badApp</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">didSomething</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面绑定完成 Application 后，表示新创建的进程ok啦，现在接着执行创建进程之前需要做的事儿，</span></span><br><span class="line"><span class="comment">     * 比如是因为 startActivity 而创建的进程，还是 startService 而创建的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1、完成之前的 Activity 启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 接着去尝试完成之前要启动的那个 Activity</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Exception thrown launching activities in &quot;</span> + app, e);</span><br><span class="line">            badApp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、完成之前的 Service 启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行 startService 剩余的逻辑</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">            checkTime(startTime, <span class="string">&quot;attachApplicationLocked: after mServices.attachApplicationLocked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Exception thrown starting services in &quot;</span> + app, e);</span><br><span class="line">            badApp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、完成之前的 广播发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">            checkTime(startTime, <span class="string">&quot;attachApplicationLocked: after sendPendingBroadcastsLocked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If the app died trying to launch the receiver we declare it &#x27;bad&#x27;</span></span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Exception thrown dispatching broadcasts in &quot;</span> + app, e);</span><br><span class="line">            badApp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; backupTarget != <span class="literal">null</span> &amp;&amp; backupTarget.app == app) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BACKUP) Slog.v(TAG_BACKUP,</span><br><span class="line">                <span class="string">&quot;New app is backup target, launching agent for &quot;</span> + app);</span><br><span class="line">        notifyPackageUse(backupTarget.appInfo.packageName,</span><br><span class="line">                            PackageManager.NOTIFY_PACKAGE_USE_BACKUP);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.scheduleCreateBackupAgent(backupTarget.appInfo,</span><br><span class="line">                    compatibilityInfoForPackage(backupTarget.appInfo),</span><br><span class="line">                    backupTarget.backupMode, backupTarget.userId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">&quot;Exception thrown creating backup agent in &quot;</span> + app, e);</span><br><span class="line">            badApp = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badApp) &#123;</span><br><span class="line">        app.kill(<span class="string">&quot;error during init&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_PROCESS_BEGIN);</span><br><span class="line">        checkTime(startTime, <span class="string">&quot;attachApplicationLocked: after updateOomAdjLocked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StatsLog.write(</span><br><span class="line">            StatsLog.PROCESS_START_TIME,</span><br><span class="line">            app.info.uid,</span><br><span class="line">            app.pid,</span><br><span class="line">            app.info.packageName,</span><br><span class="line">            StatsLog.PROCESS_START_TIME__TYPE__COLD,</span><br><span class="line">            app.startTime,</span><br><span class="line">            (<span class="type">int</span>) (bindApplicationTimeMillis - app.startTime),</span><br><span class="line">            (<span class="type">int</span>) (SystemClock.elapsedRealtime() - app.startTime),</span><br><span class="line">            app.hostingRecord.getType(),</span><br><span class="line">            (app.hostingRecord.getName() != <span class="literal">null</span> ? app.hostingRecord.getName() : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 attachApplication() 方法中主要完成两部分逻辑：</p>
<p>① 调用 thread.bindApplication() 方法来通知刚才新创建好的那个进程，可以去完成其内部的 Application 等实例的创建了，并且还会将传入的“联系方式” thread 保存到 mProcessList 中去，这样的话后续就可以从 mProcessList 中查找到这个新创建的进程的“联系方式” 来通知它一些事情了。关于这块儿的逻辑详见后面最后一个章节处。</p>
<p>② 完成之前在 system_server 中没完成的事儿，比如之前启动 Activity 遇到了需要新创建进程的情况，或者之前启动 Service 遇到了需要新创建进程的情况等。此时去接着完成 Activity 、Service 的创建工作。而对于本文来说，就是去调用 mAtmInternal.attachApplication() 方法来完成之前没启动完的 Activivty 。</p>
<p>所以我们接下来看看 mAtmInternal.attachApplication() 方法中处理了啥吧，这里的 mAtmInternal 是 ActivityTaskManagerInternal 类型的，它在 ActivityManagerService 被创建启动时设置进来的，实际对应的是 ActivityTaskManagerService 中的 LocalService 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.server.wm.ActivityTaskManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">attachApplication</span><span class="params">(WindowProcessController wpc)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLockWithoutBoost) &#123;</span><br><span class="line">        <span class="keyword">return</span> mRootActivityContainer.attachApplication(wpc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// com.android.server.wm.RootActivityContainer.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">attachApplication</span><span class="params">(WindowProcessController app)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">processName</span> <span class="operator">=</span> app.mName;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">didSomething</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">displayNdx</span> <span class="operator">=</span> mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityDisplay</span> <span class="variable">display</span> <span class="operator">=</span> mActivityDisplays.get(displayNdx);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityStack</span> <span class="variable">stack</span> <span class="operator">=</span> display.getFocusedStack();</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.getAllRunningVisibleActivitiesLocked(mTmpActivityList);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">top</span> <span class="operator">=</span> stack.topRunningActivityLocked();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mTmpActivityList.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">activity</span> <span class="operator">=</span> mTmpActivityList.get(i);</span><br><span class="line">                <span class="comment">// 如果这些 Activity 的 app ，也就是进程信息还为空，则表示他们之前没被启动</span></span><br><span class="line">                <span class="keyword">if</span> (activity.app == <span class="literal">null</span> &amp;&amp; app.mUid == activity.info.applicationInfo.uid</span><br><span class="line">                        &amp;&amp; processName.equals(activity.processName)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 调用 realStartActivityLocked() 方法去完成其启动逻辑</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (mStackSupervisor.realStartActivityLocked(activity, app,</span><br><span class="line">                                top == activity <span class="comment">/* andResume */</span>, <span class="literal">true</span> <span class="comment">/* checkConfig */</span>)) &#123;</span><br><span class="line">                            didSomething = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Exception in new application when starting activity &quot;</span></span><br><span class="line">                                + top.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        ensureActivitiesVisible(<span class="literal">null</span>, <span class="number">0</span>, <span class="literal">false</span> <span class="comment">/* preserve_windows */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里最终还是会调用到 realStartActivityLocked() 方法中去完成该 Activity 的启动，因为他们的进程已经创建好了。而realStartActivityLocked() 方法前面刚讲过。</p>
<p>至此，我们 Activity 启动的分析就差不多了，但是还剩两个点前面没有讲：</p>
<p>①  mTransactionExecutor.execute() 方法中的 executeCallbacks() 方法和 executeLifecycleState() </p>
<p>② 上面 ActivityManagerService 中的 attachApplication() 方法内会调用 thread.bindApplication() 方法来通知刚才新创建好的那个进程，可以去完成其内部的 Application 等实例的创建。</p>
<p>所以下面就将这两点补充说明下：</p>
<p>###TransactionExecutor.execute</p>
<p>这里再贴一下该方法中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  android.app.servertransaction.TransactionExecutor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ClientTransaction transaction)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先处理 ClientTransaction 中设置的 ClientTransactionItem，比如 LaunchActivityItem</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再去处理 ClientTransaction 中设置的 ActivityLifecycleItem </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 execute() 方法中逻辑比较简单，就两步：</p>
<p>① 调用 executeCallbacks() 方法来处理 ClientTransaction 中设置的 ClientTransactionItem</p>
<p>② 调用 executeLifecycleState() 方法去处理 ClientTransaction 中设置的 ActivityLifecycleItem </p>
<p>下面我们分别讲解这俩方法：</p>
<p>####executeCallbacks</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到 ClientTransaction 中设置的 ClientTransactionItem</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="literal">null</span> || callbacks.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">token</span> <span class="operator">=</span> transaction.getActivityToken();</span><br><span class="line">    <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityLifecycleItem</span> <span class="variable">finalStateRequest</span> <span class="operator">=</span> transaction.getLifecycleStateRequest();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalState</span> <span class="operator">=</span> finalStateRequest != <span class="literal">null</span> ? finalStateRequest.getTargetState()</span><br><span class="line">            : UNDEFINED;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">lastCallbackRequestingState</span> <span class="operator">=</span> lastCallbackRequestingState(transaction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面挨个处理这些 ClientTransactionItem</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> callbacks.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ClientTransactionItem</span> <span class="variable">item</span> <span class="operator">=</span> callbacks.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">postExecutionState</span> <span class="operator">=</span> item.getPostExecutionState();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">closestPreExecutionState</span> <span class="operator">=</span> mHelper.getClosestPreExecutionState(r,</span><br><span class="line">                item.getPostExecutionState());</span><br><span class="line">        <span class="keyword">if</span> (closestPreExecutionState != UNDEFINED) &#123;</span><br><span class="line">            cycleToPath(r, closestPreExecutionState, transaction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先调用该 ClientTransactionItem 的 execute 方法，然后再调用其 postExecute 方法</span></span><br><span class="line">        item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            r = mTransactionHandler.getActivityClient(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postExecutionState != UNDEFINED &amp;&amp; r != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">shouldExcludeLastTransition</span> <span class="operator">=</span></span><br><span class="line">                    i == lastCallbackRequestingState &amp;&amp; finalState == postExecutionState;</span><br><span class="line">            cycleToPath(r, postExecutionState, shouldExcludeLastTransition, transaction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 executeCallbacks() 方法中，会先从 system_server 传来的 ClientTransaction 实例中拿到其之前设置的 ClientTransactionItem 列表来挨个执行他们的 execute() 方法和 postExecute() 方法。</p>
<p>而 ClientTransactionItem 的子类有： LaunchActivityItem ，ActivityRelaunchItem，ConfigurationChangeItem，NewIntentItem，WindowVisibilityItem 等。看这些类名就大概能猜出来些大概的，我们这里只关注 LaunchActivityItem  ，它是在前面 realStartActivityLocked() 方法中会创建并添加到 ClientTransaction 中的，我们接下来看看他的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.servertransaction.LaunchActivityItem.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span><br><span class="line"><span class="params">        PendingTransactionActions pendingActions)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityStart&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个对应的  ActivityClientRecord ，将那些从 ActivityTaskManagerService 发送过来的的 token 等属性保存起来。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityClientRecord</span>(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client, mAssistToken);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行到外部 ClientTransactionHandler ，也就是 ActivityThread 中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="literal">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其 execute() 方法实现中，会先将从 ActivityTaskManagerService 那边发送过来的数据，比如 token 等信息保存到 ActivityClientRecord 中，然后再调用 ActivityThread 的 handleLaunchActivity() 方法来完成启动。</p>
<blockquote>
<p>在 ActivityTaskManagerService 对应的 system_server 进程中存在 ActivityRecord 实例来代表client端的一个 Activity 实例；而在应用client端又有一个 ActivityClientRecord实例，它对应着当前client 进程中的一个 Activity  实例记录。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Activity <span class="title function_">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span><br><span class="line"><span class="params">        PendingTransactionActions pendingActions, Intent customIntent)</span> &#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleConfigurationChanged(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">&quot;Handling launch of &quot;</span> + r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled</span><br><span class="line">            &amp;&amp; (r.activityInfo.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">        HardwareRenderer.preload();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 WindowManagerGlobal 单例对象实例，它内部存储着当前进程中所有的 Window</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    GraphicsEnvironment.hintActivityLaunch();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 Activity 的启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并启动成功了</span></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> <span class="title class_">Configuration</span>(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="literal">null</span>) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(<span class="literal">true</span>);</span><br><span class="line">            pendingActions.setCallOnPostCreate(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建失败，则通知给 ActivityTaskManagerService 那边</span></span><br><span class="line">            ActivityTaskManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="literal">null</span>,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Activity <span class="title function_">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、从 ActivityClientRecord 获取待启动的Activity的组件信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ActivityInfo</span> <span class="variable">aInfo</span> <span class="operator">=</span> r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ComponentName</span> <span class="variable">component</span> <span class="operator">=</span> r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="literal">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> <span class="title class_">ComponentName</span>(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ContextImpl 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ContextImpl</span> <span class="variable">appContext</span> <span class="operator">=</span> createBaseContextForActivity(r);</span><br><span class="line">    <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> appContext.getClassLoader();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2、创建 activity 实例 , 反射拿到对应的 Activity</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 注意这里调用的是 Instrumentation 的 newActivity() 方法来创建该Activity实例</span></span><br><span class="line"><span class="comment">         * 利用这点，可以实现插件化Activity插桩来启动未注册的Activity</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="literal">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Unable to instantiate activity &quot;</span> + component</span><br><span class="line">                + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3、创建 Application 对象（如果没有的话）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> r.packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Performing launch of &quot;</span> + r);</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + <span class="string">&quot;: app=&quot;</span> + app</span><br><span class="line">                + <span class="string">&quot;, appName=&quot;</span> + app.getPackageName()</span><br><span class="line">                + <span class="string">&quot;, pkg=&quot;</span> + r.packageInfo.getPackageName()</span><br><span class="line">                + <span class="string">&quot;, comp=&quot;</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                + <span class="string">&quot;, dir=&quot;</span> + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">CharSequence</span> <span class="variable">title</span> <span class="operator">=</span> r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">&quot;Launching activity &quot;</span></span><br><span class="line">                    + r.activityInfo.name + <span class="string">&quot; with config &quot;</span> + config);</span><br><span class="line">            <span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="literal">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="literal">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 4、attach 方法为 activity 关联上下文环境</span></span><br><span class="line"><span class="comment">             * 这里执行到 Activity 的 attach 方法中去，里面会做相关初始化，包括 Window 相关的，比如给Window设置好WindowManager等</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 因为 attach 先于 onCreate() 方法执行的，所以等到 onCreate 中 setContentView 时window就早已 ready 了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            activity.attach(appContext, <span class="built_in">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                    r.assistToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="literal">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="literal">null</span>;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">theme</span> <span class="operator">=</span> r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里调用 Activity 的 onCreate 方法，里面会调用 setContentView</span></span><br><span class="line"><span class="comment">             * 而在 setContentView 中实际使用的是 Window 的 setContentView 方法，而 Window 在前面 attach 方法就已经创建好了，是PhoneWindow</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 所以 在这里调用执行完毕之后，用户使用 setContentView 设置的该 Activity 的布局就已经加入到 DecorView 中咯</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 5、调用生命周期 onCreate</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SuperNotCalledException</span>(</span><br><span class="line">                    <span class="string">&quot;Activity &quot;</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">&quot; did not call through to super.onCreate()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">        &#125;</span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Unable to start activity &quot;</span> + component</span><br><span class="line">                + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里逻辑很长，但是却很好理解，因为基本都是我们平时开发会遇到的，其中注释写的很明白了这里就不赘述了。本文只关注 Activity 的创建流程，所以没啥好讲的了，如果你想学习 Window 的创建流程，那你可以从这里作为切入点来看。</p>
<p>接下来我们看看 LaunchActivityItem 中的另外一个方法：postExecute() :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.servertransaction.LaunchActivityItem.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span><br><span class="line"><span class="params">        PendingTransactionActions pendingActions)</span> &#123;</span><br><span class="line">    client.countLaunchingActivities(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也没啥，就是将相关计数减一，表示当前 Activity 启动成功了。</p>
<p>这里只讲了 ClientTransactionItem 的一个子类 ： LaunchActivityItem ，其他的子类就不做分析了，留作思考。</p>
<p>接下来看第二个方法 executeLifecycleState 中的逻辑：</p>
<h4 id="executeLifecycleState"><a href="#executeLifecycleState" class="headerlink" title="executeLifecycleState"></a>executeLifecycleState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到 ClientTransaction 中设置的 ActivityLifecycleItem</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityLifecycleItem</span> <span class="variable">lifecycleItem</span> <span class="operator">=</span> transaction.getLifecycleStateRequest();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleItem == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">token</span> <span class="operator">=</span> transaction.getActivityToken();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生命周期过渡。因为从 LaunchActivityItem 中会回调 onCreate， ResumeActivityItem 中会回调 onResume</span></span><br><span class="line"><span class="comment">     * 中间的 onStart 没有调用，所以这里就是补上中间的生命周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), <span class="literal">true</span> <span class="comment">/* excludeLastState */</span>, transaction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面补上遗漏的生命周期方法之后，然后调用其 execute 和 postExecute 方法 ，达到最后的 生命周期</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>executeLifecycleState() 方法中的逻辑和上面的executeCallbacks() 方法类似，不同的是这里处理的是 ClientTransaction 实例中的 ActivityLifecycleItem 列表，然后挨个执行他们的 execute() 方法和 postExecute() 方。</p>
<p>而 ActivityLifecycleItem 的子类也有好几个，比如 PauseActivityItem 、ResumeActivityItem 、StopActivityItem 等。</p>
<p>比如上面在讲 startPausingLocked() 方法时，说他是用来暂停当前 Activity 的，因为马上要启动下一个Activity 了，当时就是给 ClientTransaction 设置的 PauseActivityItem ；以及在上面讲 realStartActivityLocked() 方法时，会给 ClientTransaction 设置上面的 LaunchActivityItem  之外（它在上面executeCallbacks方法中刚处理过了），还会设置 ResumeActivityItem 。</p>
<p>所以这些设置的  PauseActivityItem  或者 ResumeActivityItem 就会在这里被处理，我们主要看看 ResumeActivityItem 中的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.servertransaction.ResumeActivityItem.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span><br><span class="line"><span class="params">        PendingTransactionActions pendingActions)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityResume&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和 LaunchActivityItem 类似，这里的 client 是 ActivityThread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    client.handleResumeActivity(token, <span class="literal">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,</span><br><span class="line">            <span class="string">&quot;RESUME_ACTIVITY&quot;</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里同样是调用到  ActivityThread 中的 handleResumeActivity() 方法内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(IBinder token, <span class="type">boolean</span> finalStateRequest, <span class="type">boolean</span> isForward,</span></span><br><span class="line"><span class="params">        String reason)</span> &#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先执行 Activity onResume 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActivitiesToBeDestroyed.containsKey(token)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> r.activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) &#123;</span><br><span class="line">        Slog.v(TAG, <span class="string">&quot;Resume &quot;</span> + r + <span class="string">&quot; started activity: &quot;</span> + a.mStartedActivity</span><br><span class="line">                + <span class="string">&quot;, hideForNow: &quot;</span> + r.hideForNow + <span class="string">&quot;, finished: &quot;</span> + a.mFinished);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">forwardBit</span> <span class="operator">=</span> isForward</span><br><span class="line">            ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">willBeVisible</span> <span class="operator">=</span> !a.mStartedActivity;</span><br><span class="line">    <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            willBeVisible = ActivityTaskManager.getService().willActivityBeVisible(</span><br><span class="line">                    a.getActivityToken());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在前面 handleLaunchActivity -&gt;  performLaunchActivity 中按如下顺序已经执行完毕：</span></span><br><span class="line"><span class="comment">     * 1、Activity # attach 中已经将 Window 初始化</span></span><br><span class="line"><span class="comment">     * 2、然后 Instrumentation # callActivityOnCreate 中执行完了 onCreate 方法，其中的 setContentView</span></span><br><span class="line"><span class="comment">     *   也已执行完毕，该 Activity 中 Window 内的 DecorView 也被初始化好了，且用户设置的 layout 也被 add进DecorView了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 然后执行到这里的，所以 DecorView 啥的都是可用的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">        WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">            r.mPreserveWindow = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">ViewRootImpl</span> <span class="variable">impl</span> <span class="operator">=</span> decor.getViewRootImpl();</span><br><span class="line">            <span class="keyword">if</span> (impl != <span class="literal">null</span>) &#123;</span><br><span class="line">                impl.notifyChildRebuilt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 将 DecorView 加入到 window 中去 ,所以一般都是 onResume 时才能看到页面，注意这里传入的是DecorView</span></span><br><span class="line"><span class="comment">                 * WindowManagerImpl # addView</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Launch &quot;</span> + r + <span class="string">&quot; mStartedActivity set&quot;</span>);</span><br><span class="line">        r.hideForNow = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cleanUpPendingRemoveWindows(r, <span class="literal">false</span> <span class="comment">/* force */</span>);</span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="literal">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.newConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">            performConfigurationChangedForActivity(r, r.newConfig);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) &#123;</span><br><span class="line">                Slog.v(TAG, <span class="string">&quot;Resuming activity &quot;</span> + r.activityInfo.name + <span class="string">&quot; with newConfig &quot;</span></span><br><span class="line">                        + r.activity.mCurrentConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            r.newConfig = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Resuming &quot;</span> + r + <span class="string">&quot; with isForward=&quot;</span> + isForward);</span><br><span class="line">        WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">        <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                != forwardBit) &#123;</span><br><span class="line">            l.softInputMode = (l.softInputMode</span><br><span class="line">                    &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                    | forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">                <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">                wm.updateViewLayout(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.activity.mVisibleFromServer = <span class="literal">true</span>;</span><br><span class="line">        mNumVisibleActivities++;</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里把 activity 的顶级布局 mDecor 通过 windowManager.addView() 方法，把视图添加到 window，并设置 mDecor 可见。到这里视图是真正可见了。</span></span><br><span class="line"><span class="comment">             * 值得注意的是：视图的真正可见是在 onResume 方法之后的。</span></span><br><span class="line"><span class="comment">             * 另外一点，Activity 视图渲染到 Window 后，会设置 window 焦点变化，先走到 DecorView 的 onWindowFocusChanged 方法，</span></span><br><span class="line"><span class="comment">             * 最后是到 Activity 的 onWindowFocusChanged 方法，表示首帧绘制完成，此时 Activity 可交互。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 所以尽管在当前位置时，Activity 要展示的 View 已经 add 到 PhoneWindow 中的 decorView 中了，但是其实不可见，</span></span><br><span class="line"><span class="comment">             * 只有将 decorView add 到 WindowManager 之后才能在屏幕内可见。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.nextIdle = mNewActivities;</span><br><span class="line">    mNewActivities = r;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">&quot;Scheduling idle handler for &quot;</span> + r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个 Idler，内部会处理开机完成的通知</span></span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> <span class="title class_">Idler</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，也是去调用 ActivityThread 中的 handleResumeActivity() 方法，进而调用到 performResumeActivity() 方法中去完成其 onResume() 方法的调用执行。</p>
<blockquote>
<p>上面的代码注释中补充了一些 Window 相关的注释，如果不明白可以先忽略，毕竟本文是介绍 Activity 启动流程的，而不是 Window 那些。</p>
</blockquote>
<p>至此就完成了 Activity 生命周期方法的执行。比如在上面讲 realStartActivityLocked() 方法时，会给 ClientTransaction 设置上面的 LaunchActivityItem  和 ResumeActivityItem ，因此它对应的 Activity 的 onCreate() 和 onResume() 方法就会被调用，是吧？？？</p>
<p>不对！！ onCreate() 和 onResume() 方法中间那几个方法呢？</p>
<p>我们看看上面 executeLifecycleState() 方法中的逻辑，在执行 LifecycleItem 的 execute() 方法之前还会调用 cycleToPath() 方法，在该方法中会完成 onCreate() -&gt; onResume() 中间的 onStart() 方法的调用，代码这里就不贴了。</p>
<p>###IApplicationThread.bindApplication</p>
<p>在前面讲 ActivityManagerService 中的  attachApplication() 方法时，讲到他会先调用  thread.bindApplication() 方法通知刚创建的那个进程让他去初始化自身应用，然后在  ActivityManagerService  接着往后才会去处理那些之前没处理完的 Activity 启动、Service 启动等工作，那么这里就看看  thread.bindApplication() 方法中做了什么。</p>
<p>bindApplication() 方法最终会调用到刚创建好的那个进程中的 ActivityThread 中的 ApplicationThread 中的 bindApplication() 方法内，然后他会将这些传过来的参数封装到一个 AppBindData 类实例中，然后接着会往 ActivityThread 中的 mH 中发送一条 H.BIND_APPLICATION 消息，进而执行到 handleBindApplication() 方法内，这段代码我就不贴了，我们直接看最终的  handleBindApplication() 方法就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.app.ActivityThread.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindApplication</span><span class="params">(AppBindData data)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 Instrumentation 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> InstrumentationInfo ii;</span><br><span class="line">    <span class="keyword">if</span> (data.instrumentationName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ii = <span class="keyword">new</span> <span class="title class_">ApplicationPackageManager</span>(<span class="literal">null</span>, getPackageManager())</span><br><span class="line">                    .getInstrumentationInfo(data.instrumentationName, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Unable to find instrumentation info for: &quot;</span> + data.instrumentationName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warn of potential ABI mismatches.</span></span><br><span class="line">        <span class="keyword">if</span> (!Objects.equals(data.appInfo.primaryCpuAbi, ii.primaryCpuAbi)</span><br><span class="line">                || !Objects.equals(data.appInfo.secondaryCpuAbi, ii.secondaryCpuAbi)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Package uses different ABI(s) than its instrumentation: &quot;</span></span><br><span class="line">                    + <span class="string">&quot;package[&quot;</span> + data.appInfo.packageName + <span class="string">&quot;]: &quot;</span></span><br><span class="line">                    + data.appInfo.primaryCpuAbi + <span class="string">&quot;, &quot;</span> + data.appInfo.secondaryCpuAbi</span><br><span class="line">                    + <span class="string">&quot; instrumentation[&quot;</span> + ii.packageName + <span class="string">&quot;]: &quot;</span></span><br><span class="line">                    + ii.primaryCpuAbi + <span class="string">&quot;, &quot;</span> + ii.secondaryCpuAbi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInstrumentationPackageName = ii.packageName;</span><br><span class="line">        mInstrumentationAppDir = ii.sourceDir;</span><br><span class="line">        mInstrumentationSplitAppDirs = ii.splitSourceDirs;</span><br><span class="line">        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);</span><br><span class="line">        mInstrumentedAppDir = data.info.getAppDir();</span><br><span class="line">        mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();</span><br><span class="line">        mInstrumentedLibDir = data.info.getLibDir();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ii = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ContextImpl </span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ContextImpl</span> <span class="variable">appContext</span> <span class="operator">=</span> ContextImpl.createAppContext(<span class="built_in">this</span>, data.info);</span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Process.isIsolated()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">oldMask</span> <span class="operator">=</span> StrictMode.allowThreadDiskWritesMask();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setupGraphicsSupport(appContext);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            StrictMode.setThreadPolicyMask(oldMask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HardwareRenderer.setIsolatedProcess(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Application app;</span><br><span class="line">    <span class="keyword">final</span> StrictMode.<span class="type">ThreadPolicy</span> <span class="variable">savedPolicy</span> <span class="operator">=</span> StrictMode.allowThreadDiskWrites();</span><br><span class="line">    <span class="keyword">final</span> StrictMode.<span class="type">ThreadPolicy</span> <span class="variable">writesAllowedPolicy</span> <span class="operator">=</span> StrictMode.getThreadPolicy();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建 Application , 并且调用其内部的 attachBaseContext()</span></span><br><span class="line"><span class="comment">         * 注意这里传入的第二个参数是 null ，所以 makeApplication 里面不会调用 Application 的 onCreate 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        app.setAutofillOptions(data.autofillOptions);</span><br><span class="line"></span><br><span class="line">        app.setContentCaptureOptions(data.contentCaptureOptions);</span><br><span class="line"></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                <span class="comment">// 初始化 ContentProvider</span></span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Exception thrown in onCreate() of &quot;</span></span><br><span class="line">                + data.instrumentationName + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 然后再开始调用 Application 的 onCreate()</span></span><br><span class="line"><span class="comment">             * 调用顺序如下：</span></span><br><span class="line"><span class="comment">             * 1、Application # attachBaseContext</span></span><br><span class="line"><span class="comment">             * 2、ContentProvider # onCreate</span></span><br><span class="line"><span class="comment">             * 3、Application # onCreate</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                  <span class="string">&quot;Unable to create application &quot;</span> + app.getClass().getName()</span><br><span class="line">                  + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">                || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityThread 中的 handleBindApplication() 方法内省略了一些暂时不关心的内容。剩下的内容可以看出其中创建了 Application 对象实例，并且完成了 ContentProvider 的初始化等工作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单梳理下整个流程：</p>
<p>① 假设我们目前在应用A中，此时进程为A，在 Activity A 中然后发起了 startActivity() 方法，去启动一个没有指定 android:process 的 Activity B。</p>
<p>首先在【进程 A】 中完成一些参数校验，然后拿到 ActivityTaskManagerService 在当前进程的 Binder 代理对象实例，调用其对应方法调用到 【system_server进程】 中的 ActivityTaskManagerService  中，去完成一系列的判断处理，然后先会调用 startPausingLocked() 方法进而调用到【进程 A】中去暂停掉 Activity ，然后接着往后最后走到  realStartActivityLocked() 方法中，进而又调用到【进程 A】中去创建和启动 Activity B 。</p>
<p>② 假设我们目前在应用A中，此时进程为A，在 Activity A 中然后发起了 startActivity() 方法，去启动一个指定 android:process&#x3D;“B” 的 Activity B。</p>
<p>首先在【进程 A】 中完成一些参数校验，然后拿到 ActivityTaskManagerService 在当前进程的 Binder 代理对象实例，调用其对应方法调用到 【system_server进程】 中的 ActivityTaskManagerService  中，去完成一系列的判断处理，然后先会调用 startPausingLocked() 方法进而调用到【进程 A】中去暂停掉 Activity ；</p>
<p>然后接着往后最后走会调用 ActivityManagerInternal::startProcess() 方法去创建进程B，然后ActivityTaskManagerService中自身逻辑执行完毕，等待后续进程B启动之后通知它。</p>
<p>接着很快，进程B创建成功了，然后在【进程B】内部会创建第一个线程去执行 ActivityThread 的 main() 方法，然后会在【进程B】 中拿到 ActivityTaskManagerService 的Binder代理对象实例，调用其 attachApplication() 方法通知 ActivityTaskManagerService ,此时从【进程B】执行到了【system_server进程】 中，在 ActivityTaskManagerService  中接受到这个通知之后，会先调用 thread.bindApplication() 方法，又调用到了 【进程B】中去执行创建 Application 等逻辑，其执行完毕之后又自动回到【system_server进程】中往下去处理之前没处理完的 Activity 启动和Service创建等工作，其执行完毕之后，又从 【system_server进程】回到了 【进程B】中的 main() 方法内，往后会执行 Looper.loop() 方法来等待处理消息。这样的话，【进程B】中就相当于是一个 应用被冷启完成了。</p>

            </div>
          

    
      <footer class="post-footer">
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/d414997b.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">ARouter 原理分析</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/49929abd.html">
        <span class="next-text nav-default">Android Service 启动流程全解析</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
