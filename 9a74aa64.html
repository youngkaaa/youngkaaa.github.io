<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Binder - Binder驱动数据处理"/>




  <meta name="keywords" content="Binder," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/9a74aa64.html"/>


<meta name="description" content="前文讲到了 Client 进程怎么获取 SM 的代理对象，怎么发起数据传输请求到 Binder驱动中。 即通过 ioctl 方法将要传输的数据从Client进程发送到处于内核空间的 Binder 之后，后续的逻辑是什么样的呢？那么就得看看Binder 驱动相关的知识了。 Binder驱动作为驱动，它并不直接操作硬件设备，而是主要操作设备内存。并且Binder主要是在Android设备上使用的。 初">
<meta property="og:type" content="article">
<meta property="og:title" content="Binder - Binder驱动数据处理">
<meta property="og:url" content="https://youngkaaa.github.io/9a74aa64.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="前文讲到了 Client 进程怎么获取 SM 的代理对象，怎么发起数据传输请求到 Binder驱动中。 即通过 ioctl 方法将要传输的数据从Client进程发送到处于内核空间的 Binder 之后，后续的逻辑是什么样的呢？那么就得看看Binder 驱动相关的知识了。 Binder驱动作为驱动，它并不直接操作硬件设备，而是主要操作设备内存。并且Binder主要是在Android设备上使用的。 初">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-08T02:48:56.000Z">
<meta property="article:modified_time" content="2022-12-27T13:15:22.018Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Binder">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Binder - Binder驱动数据处理 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Binder - Binder驱动数据处理
        
      </h1>

      <time class="post-time">
          6月 08 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>前文讲到了 Client 进程怎么获取 SM 的代理对象，怎么发起数据传输请求到 Binder驱动中。</p>
<p>即通过 ioctl 方法将要传输的数据从Client进程发送到处于内核空间的 Binder 之后，后续的逻辑是什么样的呢？那么就得看看Binder 驱动相关的知识了。</p>
<p>Binder驱动作为驱动，它并不直接操作硬件设备，而是主要操作设备内存。并且Binder主要是在Android设备上使用的。</p>
<p>初始化并使用Binder驱动主要分为四步：init() 来初始化该驱动设备，open() 来打开它；mmap() 来完成其和对应进程的内存映射，最后一步就是通过ioctl()来与它进行数据传输交互了。</p>
<p>而Binder驱动是运行在内核空间的，用户空间去调用这些方法时，是会从用户态陷入内核态的。比如当调用 init() 方法时，当前进程会陷入内核态去执行对应的binder驱动内方法，比如 binder_init() 方法等。</p>
<p>Binder驱动的主要逻辑都位于 common&#x2F;drivers&#x2F;android&#x2F;binder.c 文件内，下面的大部分内容都是在该文件中(或者从它开始)。</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file_operations 结构体实例，指定相应文件操作的方法</span></span><br><span class="line"><span class="comment"> * 后续操作 open 等对应方法时，执行的就是 binder_open 等操作了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">binder_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> *device_name, *device_names, *device_tmp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">device</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	ret = binder_alloc_shrinker_init();</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;binder_transaction_log.cur, ~<span class="number">0U</span>);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;binder_transaction_log_failed.cur, ~<span class="number">0U</span>);</span><br><span class="line"></span><br><span class="line">	binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">&quot;binder&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">		binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">&quot;proc&quot;</span>,</span><br><span class="line">						 binder_debugfs_dir_entry_root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;state&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    <span class="literal">NULL</span>,</span><br><span class="line">				    &amp;binder_state_fops);</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;stats&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    <span class="literal">NULL</span>,</span><br><span class="line">				    &amp;binder_stats_fops);</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;transactions&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    <span class="literal">NULL</span>,</span><br><span class="line">				    &amp;binder_transactions_fops);</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;transaction_log&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    &amp;binder_transaction_log,</span><br><span class="line">				    &amp;binder_transaction_log_fops);</span><br><span class="line">		debugfs_create_file(<span class="string">&quot;failed_transaction_log&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    &amp;binder_transaction_log_failed,</span><br><span class="line">				    &amp;binder_transaction_log_fops);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Copy the module_parameter string, because we don&#x27;t want to</span></span><br><span class="line"><span class="comment">	 * tokenize it in-place.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!device_names) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_device_names_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line">	device_tmp = device_names;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * device_tmp : binder,hwbinder,vndbinder</span></span><br><span class="line"><span class="comment">	 * 将其使用 , 来分割开，得到每个 binder 驱动的名称，然后调用  init_binder_device 来初始化并注册该驱动</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> ((device_name = strsep(&amp;device_tmp, <span class="string">&quot;,&quot;</span>))) &#123;</span><br><span class="line">		ret = init_binder_device(device_name);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">err_init_binder_device_failed:</span><br><span class="line">	hlist_for_each_entry_safe(device, tmp, &amp;binder_devices, hlist) &#123;</span><br><span class="line">		misc_deregister(&amp;device-&gt;miscdev);</span><br><span class="line">		hlist_del(&amp;device-&gt;hlist);</span><br><span class="line">		kfree(device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kfree(device_names);</span><br><span class="line"></span><br><span class="line">err_alloc_device_names_failed:</span><br><span class="line">	debugfs_remove_recursive(binder_debugfs_dir_entry_root);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_binder_device</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 先申请一个 binder_device 实例内存，</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!binder_device)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 然后开始给它赋值</span></span><br><span class="line"><span class="comment">	 * binder_fops 中保存的是对应函数的指针, 指定相应文件操作的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	binder_device-&gt;miscdev.fops = &amp;binder_fops;</span><br><span class="line">	<span class="comment">// 次版本号</span></span><br><span class="line">	binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">	<span class="comment">// 设备名</span></span><br><span class="line">	binder_device-&gt;miscdev.name = name;</span><br><span class="line"></span><br><span class="line">	binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">	binder_device-&gt;context.name = name;</span><br><span class="line">	mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 使用刚赋值好的 binder_device-&gt;miscdev 把该 binder 注册成 misc 驱动</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = misc_register(&amp;binder_device-&gt;miscdev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(binder_device);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * binder_devices 是一个全局 hlist_head ,也就是链表头结点，</span></span><br><span class="line"><span class="comment">	 * 这里 hlist_add_head 就是将 binder_device-&gt;hlist 插入到 binder_devices 这个链表中</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 而当前init_binder_device 方法会被调用多次，所以 binder_devices 链表中按顺序会存在多个 hlist_node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// binder 驱动设备的注册</span></span><br><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure>

<p>可以看到，在一开始会使用 device_initcall() 宏来将当前类中的 binder_init() 方法包裹起来。简单来说就是：这样操作可以将 binder_init 方法注册进系统，等后续内核启动时就会执行该方法来启动该驱动，也就是后续会执行 binder_init() 方法</p>
<p>在binder_init()中将逻辑基本都转移到了 init_binder_device() 中。在该方法内，会创建 binder_device 实例并给其属性赋值，先看看这个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * hlist_node 节点，在 binder.c # binder_init() -&gt; init_binder_device 方法</span></span><br><span class="line"><span class="comment">	 * 中会将其添加到 binder.c 全局的 binder_devices 变量中去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 代表一个 misc 驱动设别 device</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_init() -&gt; init_binder_device 方法 方法中赋值，</span></span><br><span class="line"><span class="comment">	 * 内部存储着 binder 设备的版本号、fOp等</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_init() -&gt; init_binder_device 方法中赋初始值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">binder_context_mgr_node</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open() 方法中初始化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">context_mgr_node_lock</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open() 方法中赋初始值 INVALID_UID</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">kuid_t</span> binder_context_mgr_uid;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open() 方法中赋初始值 &quot;binder&quot; , &quot;hwbinder&quot; 或者 &quot;vndbinder&quot;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// miscdevice.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">	<span class="type">int</span> minor;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *nodename;</span><br><span class="line">	<span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在binder_device 结构体内，这里会着重给其中的miscdevice 实例内部属性赋值，比如会将 miscdev.fops 赋值为 binder_fops 。而 binder_fops 是一个静态的 file_operations 结构体实例，其内部提前给内部属性赋值指向当前类中的具体方法，比如其 mmap 属性会赋值成binder_map 函数，这样的话后续调用 mmap() 方法时才会调用到这里的 binder_map()函数内来，其他的 binder_open、binder_ioctl 方法类似，也都是在这里设置的映射关系。</p>
<p>初始化这些属性之后，接下来就是调用 misc_register() 并将其传入来注册驱动。其余逻辑在注释中也有说明了。</p>
<p>这样的话，就完成了 Binder驱动的注册。</p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>如前面所说，当在用户态调用 open(“&#x2F;dev&#x2F;binder”, O_RDWR) 方法时，该进程会从用户态转为内核态，进而执行到 binder_open() 方法中来。比如前文的进程单例 ProcessState ，在某个进程内首次调用 ProcessState::self() 方法时，会执行 ProcessState 构造方法，在其构造方法内会调用 open_driver() 方法来打开Binder驱动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessState.cpp</span></span><br><span class="line"></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))   <span class="comment">// 返回值赋值给 mDriverFD</span></span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mExecutingThreadsCount</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS) <span class="comment">// binder 默认的最大可并发访问的线程数为 16</span></span><br><span class="line">    , <span class="built_in">mStarvationStartTimeMs</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mManagesContexts</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mCallRestriction</span>(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 省略部分逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开 binder 驱动</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其他逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并将返回值对应的binder驱动文件标识符返回保存给 ProcessState.mDriverFD 。</p>
<p>陷入内核态之后，执行的 binder_open() 方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 为 binder_proc 分配内存</span></span><br><span class="line"><span class="comment">	 * 在用户进程空间中，会调用 open(&quot;/dev/binder&quot;, O_RDWR) 方法来打开binder 驱动</span></span><br><span class="line"><span class="comment">	 * 进而会调用到当前方法，此时为该进程在 binder driver 中创建一个 binder_proc 实例来代表该用户进程</span></span><br><span class="line"><span class="comment">	 * 比如用户空间基本都是通过 ProcessState.self() 方法来完成上述逻辑的</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 下面会将创建好的 binder_proc 实例保存到 filp-&gt;private_data 中返回出去，后续该进程在调用 binder 等其他方法</span></span><br><span class="line"><span class="comment">	 * 比如 mmap  ioctl 等时，就可以把 open() 方法返回的 fd 传入进来，然后在 binder driver 中调用  filp-&gt;private_data</span></span><br><span class="line"><span class="comment">	 * 就可以拿到该用户进程之前 open 时创建的 binder_proc 实例了，进而拿到里面的其他针对于该进程独特的属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 下面就开始挨个初始化 binder_proc 中的属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	spin_lock_init(&amp;proc-&gt;inner_lock);</span><br><span class="line">	spin_lock_init(&amp;proc-&gt;outer_lock);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * current: 获取当前进程</span></span><br><span class="line"><span class="comment">	 * current.group_leader : 指向 当前进程 所在进程组的领头进程</span></span><br><span class="line"><span class="comment">	 * https://blog.csdn.net/echoisland/article/details/6729061</span></span><br><span class="line"><span class="comment">	 * https://www.jianshu.com/p/691d02380312</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	get_task_struct(current-&gt;group_leader);</span><br><span class="line">	<span class="comment">// 保存当前进程的进程组信息</span></span><br><span class="line">	proc-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">	mutex_init(&amp;proc-&gt;files_lock);</span><br><span class="line">	proc-&gt;cred = get_cred(filp-&gt;f_cred);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 详见当前文件中的 static HLIST_HEAD(binder_devices) 定义处的解释</span></span><br><span class="line"><span class="comment">	 * https://zhuanlan.zhihu.com/p/82375193</span></span><br><span class="line"><span class="comment">	 * 此处其实就是初始化 proc-&gt;todo</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * current-&gt;policy : 获取当前进程的调度策略，目前主要有以下五种:</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * SCHED_NORMAL : 用于普通进程，通过CFS调度器实现;</span></span><br><span class="line"><span class="comment">	 * SCHED_BATCH : 用于非交互的处理器消耗型进程;</span></span><br><span class="line"><span class="comment">	 * SCHED_IDLE : 是在系统负载很低时使用;</span></span><br><span class="line"><span class="comment">	 * SCHED_FIFO : （先入先出调度算法）和 SCHED_RR（轮流调度算法）都是实时调度策略.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * https://www.jianshu.com/p/691d02380312</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">		proc-&gt;default_priority.sched_policy = current-&gt;policy;</span><br><span class="line">		proc-&gt;default_priority.prio = current-&gt;normal_prio;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		proc-&gt;default_priority.sched_policy = SCHED_NORMAL;</span><br><span class="line">		proc-&gt;default_priority.prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binder_dev = container_of(filp-&gt;private_data, <span class="keyword">struct</span> binder_device,</span><br><span class="line">				  miscdev);</span><br><span class="line">	proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line">	binder_alloc_init(&amp;proc-&gt;alloc);</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化 proc-&gt;pid</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 然后将初始化好的 binder_proc 赋值给入参 filp-&gt;private_data</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;binder_procs_lock);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Binder 驱动中通过 static HLIST_HEAD(binder_procs);，创建了全局的哈希链表binder_procs，</span></span><br><span class="line"><span class="comment">	 * 用于保存所有的 binder_proc 队列，每次新创建的 binder_proc 对象都会加入 binder_procs 链表中</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * hlist_add_head 在上面的 binder_init() 方法中也存在，</span></span><br><span class="line"><span class="comment">	 * 不同的是在 binder_init() 方法中是将创建的 binder_device 插入到全局链表 binder_devices 中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	mutex_unlock(&amp;binder_procs_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line">		<span class="type">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * proc debug entries are shared between contexts, so</span></span><br><span class="line"><span class="comment">		 * this will fail if the process tries to open the driver</span></span><br><span class="line"><span class="comment">		 * again with a different context. The priting code will</span></span><br><span class="line"><span class="comment">		 * anyway print all contexts that a given PID has, so this</span></span><br><span class="line"><span class="comment">		 * is not a problem.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		proc-&gt;debugfs_entry = debugfs_create_file(strbuf, <span class="number">0444</span>,</span><br><span class="line">			binder_debugfs_dir_entry_proc,</span><br><span class="line">			(<span class="type">void</span> *)(<span class="type">unsigned</span> <span class="type">long</span>)proc-&gt;pid,</span><br><span class="line">			&amp;binder_proc_fops);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 binder_open() 方法中，会创建一个 binder_proc 结构体实例，该结构体实例定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * binder_pro代表了使用binder driver的process，保存了process的相关信息</span></span><br><span class="line"><span class="comment"> * binder driver会为每一个调用过open函数打开“dev/binder”文件的进程创建一个binder_proc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中会通过它来将当前 binder_proc 实例插入到全局链表中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * binder_thread 红黑树，进程内使用 binder driver 的线程都会被保存在这颗红黑树中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * binder_node（binder实体）红黑树，进程所持有的 binder_node 都保存在这颗红黑树中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * binder_ref（binder引用）红黑树，进程所持有的 biner_ref 都会保存在颗红黑树中，红黑树以 binder_ref.desc 排序</span></span><br><span class="line"><span class="comment">	 * 通过 desc 可以查找到对应的 binder_node，而 desc 其实就是 handle ，比如 Service Manager 的 handle = 0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 同 refs_by_desc，不过以 binder_ref.node 来排序</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">waiting_threads</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化为 current-&gt;group_leader-&gt;pid</span></span><br><span class="line"><span class="comment">	 * 也就是初始化为创建当前 binder_proc 实例时的进程ID</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> pid;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化的</span></span><br><span class="line"><span class="comment">	 * 指向调用 binder_open 方法的当前进程 task_struct 信息，即进程描述符</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化为 get_files_struct(current)</span></span><br><span class="line"><span class="comment">	 * 文件描述符列表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">files_lock</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line">	<span class="type">int</span> deferred_work;</span><br><span class="line">	<span class="type">bool</span> is_dead;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化的</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * binder_work 列表，等待被处理的 binder_work</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">delivered_death</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 最大线程数量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> max_threads;</span><br><span class="line">	<span class="type">int</span> requested_threads;</span><br><span class="line">	<span class="type">int</span> requested_threads_started;</span><br><span class="line">	<span class="type">int</span> tmp_ref;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化</span></span><br><span class="line"><span class="comment">	 * 内部存储的是当前进程的调度策略</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">default_priority</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_entry</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_alloc</span> <span class="title">alloc</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在 binder.c # binder_open 中初始化为 filp-&gt;private_data-&gt;context</span></span><br><span class="line"><span class="comment">	 * 每个进程的 context 都对应着同一个 binder_dev 的 context</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 在 binder_opne 中可以知道：</span></span><br><span class="line"><span class="comment">	 * 每个进程的 context 域，实际上都是全局的 binder_dev 的 context 域，即 proc-&gt;context = &amp;binder_dev-&gt;context；</span></span><br><span class="line"><span class="comment">	 * 所以当 SMgr 进程向驱动发送 BINDER_SET_CONTEXT_MGR 命令，驱动执行完这个函数后，</span></span><br><span class="line"><span class="comment">	 * 每个其它进程都可以通过他的 context 域找到 binder_context_mgr_node 节点，</span></span><br><span class="line"><span class="comment">	 * 然后就可以通过这个节点找到对应的 SMgr，然后执行查询或添加服务等操作．</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这两个都是在 binder.c # binder_open 中初始化的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span> inner_lock;</span><br><span class="line">	<span class="type">spinlock_t</span> outer_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到该结构体内属性很多，但是它的担任的角色却很简单：它是一个发起方进程在内核Binder驱动中的代表，这个发起方进程(也就是当前进程)的信息会保存在该结构体实例内，比如当前发起方进程的进程信息、进程调度策略等。</p>
<p>给当前发起方进程新创建的 binder_proc 赋值完之后，会将起保存到入参 filp-&gt;private_data 中去。</p>
<blockquote>
<p>这里 binder_open() 会给入参 struct file *filp 中的 private_data 属性赋值为刚创建的 binder_proc 实例。</p>
<p>后续的 binder_mmap() 、 binder_ioctl() 方法中同样都会有一个入参  struct file *filp 。而前面保存的 binder_proc 实例后续可以通过这个入参 filp-&gt;private_data 来获取。</p>
</blockquote>
<p>其余逻辑详见注释。</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>同样的，在当前进程调用 mmap 操作之后会执行到 binder_mmap() 中来。比如ProcessState中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessState.cpp</span></span><br><span class="line">ProcessState::ProcessState(<span class="type">const</span> <span class="type">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) <span class="comment">// binder 默认的最大可并发访问的线程数为 16</span></span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(nullptr)</span><br><span class="line">    , mBinderContextUserData(nullptr)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">    , mCallRestriction(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mDriverFD 是上面 open_driver(&quot;/dev/binder&quot;) 的返回值</span></span><br><span class="line"><span class="comment">     * 也就是 binder 驱动的文件描述符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 省略部分逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此说，只要在某个进程第一次调用 ProcessState::self() 方法时，就会自动在该进程执行 mmap() 操作从而完成当前进程和Binder内核的内存映射工作。</p>
<p>当执行该方法之后，该进程陷入内核态执行到 binder_mmap() 方法中来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * filp-&gt;private_data 就是前面在 binder_open 中创建的 binder_proc</span></span><br><span class="line"><span class="comment">	 * 在 binder_open 中会将创建的 binder_proc 放入到 filp-&gt;private_data 中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *failure_string;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * proc-&gt;tsk 是前面在 binder_open 中初始化的，初始化为调用 binder_open 时的  current-&gt;group_leader</span></span><br><span class="line"><span class="comment">	 * 这里则是检查调用 binder_open  和 binder_mmap 的是不是同一个进程</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;tsk != current-&gt;group_leader)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保证映射内存大小不超过 4M</span></span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">		ret = -EPERM;</span><br><span class="line">		failure_string = <span class="string">&quot;bad vm_flags&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_bad_arg;</span><br><span class="line">	&#125;</span><br><span class="line">	vma-&gt;vm_flags |= VM_DONTCOPY | VM_MIXEDMAP;</span><br><span class="line">	vma-&gt;vm_flags &amp;= ~VM_MAYWRITE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 指定 vma 中的 vm_ops 操作方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">	vma-&gt;vm_private_data = proc;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据 vma 来修改 proc-&gt;alloc 中的属性</span></span><br><span class="line"><span class="comment">	 * 注意此时的 proc 是 mmap 发起方用户空间的 binder_proc 信息</span></span><br><span class="line"><span class="comment">	 * 假设此时是从 app 进程往 Service Manager 的进程传递信息，此时是在 app 进程调用的该方法，</span></span><br><span class="line"><span class="comment">	 * 那么此时 proc 就是 app 用户进程空间在 binder  driver 内的一个代表</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	mutex_lock(&amp;proc-&gt;files_lock);</span><br><span class="line">	proc-&gt;files = get_files_struct(current);</span><br><span class="line">	mutex_unlock(&amp;proc-&gt;files_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_bad_arg:</span><br><span class="line">	pr_err(<span class="string">&quot;%s: %d %lx-%lx %s failed %d\n&quot;</span>, __func__,</span><br><span class="line">	       proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binder_alloc_mmap_handler</span><span class="params">(<span class="keyword">struct</span> binder_alloc *alloc,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *failure_string;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果 alloc-&gt;buffer 已经有值了，则表示其已经被 mmap 过了，直接返回</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc-&gt;buffer) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		failure_string = <span class="string">&quot;already mapped&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_already_mapped;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	alloc-&gt;buffer = (<span class="type">void</span> __user *)vma-&gt;vm_start;</span><br><span class="line">	mutex_unlock(&amp;binder_alloc_mmap_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 分配物理内存页</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc-&gt;pages = kcalloc((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE,</span><br><span class="line">			       <span class="keyword">sizeof</span>(alloc-&gt;pages[<span class="number">0</span>]),</span><br><span class="line">			       GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (alloc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">&quot;alloc page array&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 为 binder_buffer 结构体分配内存</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	buffer = kzalloc(<span class="keyword">sizeof</span>(*buffer), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">&quot;alloc buffer struct&quot;</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_buf_struct_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 开始为 binder_buffer 结构体实例中的属性赋值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	buffer-&gt;user_data = alloc-&gt;buffer;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 把 buffer 插入到 alloc-&gt;buffers 后面去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_add(&amp;buffer-&gt;entry, &amp;alloc-&gt;buffers);</span><br><span class="line">	<span class="comment">// 默认是空闲的 buffer</span></span><br><span class="line">	buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将 buffer 插入到 alloc-&gt;free_buffers 树中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	binder_insert_free_buffer(alloc, buffer);</span><br><span class="line"></span><br><span class="line">	alloc-&gt;free_async_space = alloc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 修改 alloc-&gt;vma_vm_mm  和 alloc-&gt;vma</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	binder_alloc_set_vma(alloc, vma);</span><br><span class="line">	mmgrab(alloc-&gt;vma_vm_mm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_alloc_buf_struct_failed:</span><br><span class="line">	kfree(alloc-&gt;pages);</span><br><span class="line">	alloc-&gt;pages = <span class="literal">NULL</span>;</span><br><span class="line">err_alloc_pages_failed:</span><br><span class="line">	mutex_lock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">	alloc-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">err_already_mapped:</span><br><span class="line">	mutex_unlock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">	binder_alloc_debug(BINDER_DEBUG_USER_ERROR,</span><br><span class="line">			   <span class="string">&quot;%s: %d %lx-%lx %s failed %d\n&quot;</span>, __func__,</span><br><span class="line">			   alloc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end,</span><br><span class="line">			   failure_string, ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了 binder_mmap() 方法内，首先会先通过入参 filp-&gt;private_data 拿到之前binder_open()时创建并存储的当前进程的binder_proc 实例。然后做一些合法性判断，最后在 binder_alloc_mmap_handler() 方法内完成内存页的申请。具体会将申请的内存页保存到  proc-&gt;alloc-&gt;pages 中。</p>
<h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><p>binder 驱动最主要的逻辑都在该方法内。当发起方进程调用 ioctl() 方法来往Binder 驱动（或者说对发起方进程来说，它是想往接收方进程去发的）发送数据时，会执行到 binder_ioctl() 方法中，比如前文提及的 IPCThreadState 中的 talkWithDriver 方法内，会调用 ioctl() 去将 binder_write_read 结构体实例传送到Binder驱动中。然后该进程会陷入内核态执行到 binder_mmap() 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 拿到当前调用 ioctl 的用户进程信息。因为在该用户进程中，肯定先执行过 open 操作，返回了一个 int 的fd</span></span><br><span class="line"><span class="comment">	 * 详见 binder_open</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 可以从 cmd 中取出指定位，这些指定位上存储着 arg 的 size</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * https://blog.csdn.net/yanlinembed/article/details/53418659</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 如果 binder_stop_on_user_error&gt;=2,会进入等待</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取当前调用 ioctl 的线程信息，上层的 线程对应的 binder驱动中是一个 binder_thread 实例</span></span><br><span class="line"><span class="comment">	 * 正如前面所说：进程信息在binder驱动中是使用 binder_proc 来表示；线程则使用 binder_thread 来表示</span></span><br><span class="line"><span class="comment">	 * 而这里传入的入参 proc 就是从 filp-&gt;private_data 中取出来的，表示发起方进程信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 从 proc.thread 中查找当前进程id对应的 binder_thread 是否存在</span></span><br><span class="line"><span class="comment">	 * 存在的话返回，不存在则为当前进程新建一个 binder_thread 插入 proc.thread 中并返回</span></span><br><span class="line"><span class="comment">	 * 在 Binder 驱动中，凡是用到跨进程通信机制的线程，都会对应一个 binder_thread 节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thread = binder_get_thread(proc);</span><br><span class="line">	<span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * 进行 binder 的读写操作，绝大多数的命令都是它，此时 arg 对应的是 binder_write_read 结构体实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">case</span> BINDER_WRITE_READ: </span><br><span class="line">		ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_MAX_THREADS: &#123; <span class="comment">// 设置binder最大支持的线程数</span></span><br><span class="line">		<span class="type">int</span> max_threads;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;max_threads, ubuf,</span><br><span class="line">				   <span class="keyword">sizeof</span>(max_threads))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		proc-&gt;max_threads = max_threads;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123; <span class="comment">// 成为binder的上下文管理者，也就是ServiceManager成为守护进程</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> <span class="title">fbo</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 将 service manager 传来的 flat_binder_object 对象从 ubuf 中复制到 fbo 中</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;fbo, ubuf, <span class="keyword">sizeof</span>(fbo))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = binder_ioctl_set_ctx_mgr(filp, &amp;fbo);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_CONTEXT_MGR: <span class="comment">// 成为binder的上下文管理者，也就是ServiceManager成为守护进程</span></span><br><span class="line">		ret = binder_ioctl_set_ctx_mgr(filp, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_THREAD_EXIT: <span class="comment">// 当binder线程退出，释放binder线程</span></span><br><span class="line">		binder_debug(BINDER_DEBUG_THREADS, <span class="string">&quot;%d:%d exit\n&quot;</span>,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		binder_thread_release(proc, thread);</span><br><span class="line">		thread = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_VERSION: &#123; <span class="comment">// 获取binder的版本号</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_version</span> __<span class="title">user</span> *<span class="title">ver</span> =</span> ubuf;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (put_user(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">			     &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> BINDER_GET_NODE_INFO_FOR_REF: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_node_info_for_ref</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;info, ubuf, <span class="keyword">sizeof</span>(info))) &#123;</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = binder_ioctl_get_node_info_for_ref(proc, &amp;info);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(ubuf, &amp;info, <span class="keyword">sizeof</span>(info))) &#123;</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> BINDER_GET_NODE_DEBUG_INFO: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_node_debug_info</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;info, ubuf, <span class="keyword">sizeof</span>(info))) &#123;</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = binder_ioctl_get_node_debug_info(proc, &amp;info);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(ubuf, &amp;info, <span class="keyword">sizeof</span>(info))) &#123;</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (thread)</span><br><span class="line">		thread-&gt;looper_need_return = <span class="literal">false</span>;</span><br><span class="line">	wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; ret != -ERESTARTSYS)</span><br><span class="line">		pr_info(<span class="string">&quot;%d:%d ioctl %x %lx returned %d\n&quot;</span>, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line">	trace_binder_ioctl_done(ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 binder_ioctl() 中，会做一些做一些准备工作。比如还是先从入参 filp-&gt;private_data 中取出之前保存的调用方进程信息 binder_proc 实例，然后在通过它来获取当前调用方所在的线程信息，即通过 binder_get_thread() 方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 proc.thread 中查找当前线程是否存在,</span></span><br><span class="line"><span class="comment"> * 存在的话则直接返回，</span></span><br><span class="line"><span class="comment"> * 不存在的话则新建一个放入到 proc.thread 中并返回出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_thread *<span class="title function_">binder_get_thread</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">new_thread</span>;</span></span><br><span class="line"></span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这里第二个参数传的是 NULL </span></span><br><span class="line"><span class="comment">	 * 通过该方法去查找判断当前线程是否已经加入到 proc-&gt;threads 中了，是的话则返回非空，否则返回 null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thread = binder_get_thread_ilocked(proc, <span class="literal">NULL</span>);</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果没找到，即当前线程还没有加入到 proc-&gt;threads.rb_node 中</span></span><br><span class="line"><span class="comment">	 * 那么此时新创建一个 binder_thread 实例，然后传入到 binder_get_thread_ilocked 方法中</span></span><br><span class="line"><span class="comment">	 * 此时内部会初始化该 binder_thread 中的属性，并且将其插入到 proc-&gt;threads 红黑树中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!thread) &#123;</span><br><span class="line">		new_thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (new_thread == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 初始化 new_thread 中的属性并且将其插入到 proc-&gt;threads 红黑树中</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		thread = binder_get_thread_ilocked(proc, new_thread);</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		<span class="keyword">if</span> (thread != new_thread)</span><br><span class="line">			kfree(new_thread);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 proc-&gt;threads 中查找 current.pid 所对应的 binder_thread 实例，</span></span><br><span class="line"><span class="comment"> * 如果之前有的话直接返回找到的实例</span></span><br><span class="line"><span class="comment"> * 如果之前没有的话，则根据入参 new_thread 是否等于 NULL 来：</span></span><br><span class="line"><span class="comment"> * -- new_thread == NULL ：返回 null</span></span><br><span class="line"><span class="comment"> * -- new_thread != NULL ：初始化该 new_thread 中的属性字段，并将其插入到  proc-&gt;threads 红黑树中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_thread *<span class="title function_">binder_get_thread_ilocked</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *new_thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 从 proc-&gt;threads 中查找</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;proc-&gt;threads.rb_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * current-&gt;pid : 当前线程id(这里很奇怪，为啥叫 pid ？)</span></span><br><span class="line"><span class="comment">	 * 根据当前进程的 pid，从 proc-&gt;threads 中查找相应的 binder_thread</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		thread = rb_entry(parent, <span class="keyword">struct</span> binder_thread, rb_node);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> thread; <span class="comment">// 找到了就直接返回</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果入参 new_thread 为空，则直接返回null</span></span><br><span class="line">	<span class="keyword">if</span> (!new_thread)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将入参 new_thread 赋值给返回值 thread ，然后初始化 thread 中的属性</span></span><br><span class="line"><span class="comment">	 * 并且将其加入到 proc-&gt;threads 中，后续通过本方法就能查到了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thread = new_thread;</span><br><span class="line">	binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">	thread-&gt;proc = proc;</span><br><span class="line">	thread-&gt;pid = current-&gt;pid;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	thread-&gt;task = current;</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;thread-&gt;tmp_ref, <span class="number">0</span>);</span><br><span class="line">	init_waitqueue_head(&amp;thread-&gt;wait);</span><br><span class="line">	INIT_LIST_HEAD(&amp;thread-&gt;todo);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将新的 thread 插入到 parent 的 p 节点上(p 表示了是左子树还是右子树)</span></span><br><span class="line"><span class="comment">	 * 也就是将新的 thread 插入到 proc-&gt;threads 中了</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * rb_link_node 是先插入红黑树，rb_insert_color 是执行一次红黑树平衡</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rb_link_node(&amp;thread-&gt;rb_node, parent, p);</span><br><span class="line">	rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line"></span><br><span class="line">	thread-&gt;looper_need_return = <span class="literal">true</span>;</span><br><span class="line">	thread-&gt;return_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">	thread-&gt;return_error.cmd = BR_OK;</span><br><span class="line">	thread-&gt;reply_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">	thread-&gt;reply_error.cmd = BR_OK;</span><br><span class="line">	INIT_LIST_HEAD(&amp;new_thread-&gt;waiting_thread_node);</span><br><span class="line">	<span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 binder_get_thread() 方法内，会通过 binder_get_thread_ilocked() 方法来从 binder_proc.threads 中查找是否已经存在当前线程所对应的 binder_thread 实例了，存在的话就返回；不存在的话则会创建一个 binder_thread 实例并初始化赋值，同时将其插入到 binder_proc.threads 中。</p>
<p>这里用到的 proc-&gt;threads ，它的定义是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * binder_thread 红黑树，进程内使用 binder driver 的线程都会被保存在这颗红黑树中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 rb_root 、 rb_node 或者 rb_entry 这些都是红黑树相关的结构。</p>
<p>可以将这里的 proc.threads 当做是红黑树的根节点，其内部存储着若干个节点，每个节点可以认为是 binder_thread 实例。后续查找时只需要从 proc.threads 开始寻找，每次二分查找其中一个子树。关于红黑树相关这里不介绍，可以单独查阅资料。</p>
<p>因此，在binder驱动中，一个个的 binder_proc 表示的是对应的发起方进程信息；一个个的 binder_thread 表示的是发起方进程中调用 ioctl() 等方法时的线程信息。并且这些 binder_thread 会存储在 binder_proc 中的 threads 红黑树中，后续可以很快的查找使用。</p>
<p>回到 binder_ioctl() 中，获取到当前发起方线程信息binder_thread 实例后，接着往下就是一个大的 switch case 体，其内部根据 binder_ioctl() 入参 cmd 来执行不同的逻辑。而这个cmd 对应着发起方调用 ioctl() 方法时传入的第二个参数。</p>
<p>下面则挑几个重要的cmd命令来进行分析：</p>
<h4 id="BINDER-WRITE-READ"><a href="#BINDER-WRITE-READ" class="headerlink" title="BINDER_WRITE_READ"></a>BINDER_WRITE_READ</h4><p>比如在前面提及的 IPCThreadState 的 talkWithDriver() 方法中，内部调用 ioctl() 时传入的cmd&#x3D;BINDER_WRITE_READ ，并且同时传入了一个 binder_write_read 结构体实例。</p>
<p>从而到了Binder驱动中的 binder_ioctl() 方法内，进而走到 binder_ioctl_write_read() 方法中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * binder_ioctl 方法中，cmd = BINDER_WRITE_READ 时，会调用当前方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param filp </span></span><br><span class="line"><span class="comment"> * @param cmd BINDER_WRITE_READ</span></span><br><span class="line"><span class="comment"> * @param arg binder_write_read 结构体实例</span></span><br><span class="line"><span class="comment"> * @param thread 当前线程实例</span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_ioctl_write_read</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 拿到当前调用 ioctl 的用户进程信息。因为在该用户进程中，肯定先执行过 open 操作，返回了一个 int 的fd</span></span><br><span class="line"><span class="comment">	 * 详见 binder_open</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * cmd = BINDER_WRITE_READ 时，其对应的 data 就是一个 binder_write_read 实例</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 取出 arg 的 size ，如果不是 binder_write_read 的话，则不合法</span></span><br><span class="line"><span class="comment">	 * 从外部传递过来的，一定是 binder_write_read 结构体实例,</span></span><br><span class="line"><span class="comment">	 * 因为 cmd = BINDER_WRITE_READ 时 arg 应该是 binder_write_read</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ubuf : 就是用户空间传递过来的数据</span></span><br><span class="line"><span class="comment">	 * bwr  : 上面新建的  binder_write_read 实例，用来保存从 用户空间 复制过来的 ubuf 入参数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 比如从 main_mediaserver.cpp#main -&gt; MediaPlayerService.cpp#instantiate 中调用过来时</span></span><br><span class="line"><span class="comment">	 * 最终经由 IPCThreadState::transact 、 IPCThreadState::writeTransactionData 一直到 IPCThreadState::talkWithDriver</span></span><br><span class="line"><span class="comment">	 * 这个过程的话，会封装 binder_write_read ，此时 binder_write_read 中的 write_buffer 中存储的数据为：</span></span><br><span class="line"><span class="comment">	 * cmd  binder_transaction_data </span></span><br><span class="line"><span class="comment">	 * 其中                   cmd = BC_TRANSACTION </span></span><br><span class="line"><span class="comment">	 * - binder_transaction_data = 详见 IPCThreadState::writeTransactionData</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 到这里的话，bwr 中就存储着来自用户空间传递过来的 binder_write_read 数据了</span></span><br><span class="line"><span class="comment">	 * 这里先检查其 write_size 是否大于0 ，是的话先执行 binder 写操作</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 内部会从 write_buffer 开始往后偏移 write_consumed 长度的情况下，往后读取</span></span><br><span class="line"><span class="comment">	 * 读取处理完成之后，会修改 bwr.write_consumed 的值为内部已读取消耗的长度</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 实际逻辑交由 binder_thread_write 方法来实现</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ret = binder_thread_write(proc, thread,</span><br><span class="line">					  bwr.write_buffer,</span><br><span class="line">					  bwr.write_size,</span><br><span class="line">					  &amp;bwr.write_consumed);</span><br><span class="line">		trace_binder_write_done(ret);</span><br><span class="line">		<span class="comment">// 当写操作失败时，再将 bwr 数据写回用户空间，并返回</span></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果其 read_size 不等于 0，则表示开始处理 binder读操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">					 bwr.read_size,</span><br><span class="line">					 &amp;bwr.read_consumed,</span><br><span class="line">					 filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">		trace_binder_read_done(ret);</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 唤醒</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))</span><br><span class="line">			binder_wakeup_proc_ilocked(proc);</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		<span class="comment">// 同样的，如果 读操作 失败，则将其写回用户空间，并返回</span></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将处理完的 bwr 数据赋值到 ubuf ，也就是从内核空间赋值到 用户空间去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进入binder_ioctl_write_read()方法后，首先会从用户空间传来的地址中将 binder_write_read 结构体实例赋值到内核中来，也就是通过  copy_from_user() 方法来复制。</p>
<p>而这个 binder_write_read 实例此时就可以想象它是从 IPCThreadState 的 talkWithDriver() 方法传过来的。</p>
<p>在binder_write_read 中属性分为两组： write 和 read，即分别用户进程要给Binder内核发送的数据和要从Binder内核读取的数据。而到了Binder内核中处理时是优先先处理 write 部分，再处理 read 部分。</p>
<p>在读取 binder_write_read 到内核之后，会首先判断其 write_size 是否大于0，是的话则表示其内部有要传输给Binder内核的数据，会去执行 binder_thread_write()，执行完之后会再判断其 read_size 是否大于0，是的话则会执行 binder_thread_read() 方法来处理数据的读取。</p>
<p>这些write 、read 执行完毕之后，binder_write_read 中会存储着读取数据之后的信息，最后会调用 copy_to_user() 方法来将该结构体实例复制到用户空间去。</p>
<blockquote>
<p>诶？不是说Binder只会复制一次数据嘛？咋这里都有两次了?</p>
<p>Binder中说的复制一次不是说这些固定结构体只会复制一次。这些结构体是固定的，长度因此也是固定的，所以复制他们的话消耗时间是固定的，但是它其中存储的内存地址和数据长度是可变的，可能会对应很大的数据量。所以Binder说的只复制一次是针对这些大批量数据的。</p>
</blockquote>
<p>所以下面按照 write 和 read 分开分析：</p>
<h5 id="binder-thread-write"><a href="#binder-thread-write" class="headerlink" title="binder_thread_write()"></a>binder_thread_write()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 binder_ioctl 方法中，如果 cmd = BINDER_WRITE_READ ，</span></span><br><span class="line"><span class="comment"> * 则会调用 binder_ioctl_write_read 方法来处理来自用户空间的读写数据</span></span><br><span class="line"><span class="comment"> * 判断到来自用户空间的 bwr.write_size &gt; 0 的话，进而会调用到当前方法来</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param proc </span></span><br><span class="line"><span class="comment"> * @param thread </span></span><br><span class="line"><span class="comment"> * @param binder_buffer 通过 binder_write_read.write_buffer 从用户态传递到内核空间的参数数据</span></span><br><span class="line"><span class="comment"> * @param size 通过 binder_write_read.write_buffer 从用户态传递到内核空间的参数数据的长度，即：binder_write_read.write_size</span></span><br><span class="line"><span class="comment"> * @param consumed binder_write_read.write_consumed,即 write_buffer 中已经被消耗的数据，可以认为是 offset</span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_thread_write</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params">			<span class="type">binder_uintptr_t</span> binder_buffer, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">			<span class="type">binder_size_t</span> *consumed)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> cmd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> =</span> proc-&gt;context;</span><br><span class="line">	<span class="type">void</span> __user *buffer = (<span class="type">void</span> __user *)(<span class="type">uintptr_t</span>)binder_buffer;</span><br><span class="line">	<span class="comment">// start</span></span><br><span class="line">	<span class="type">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">	<span class="comment">// end，所以 write_buffer 中可用的是： [consumed,size) zheg </span></span><br><span class="line">	<span class="type">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ptr : 当前处理 write_buffer 数据的指针</span></span><br><span class="line"><span class="comment">	 * end : 处理 write_buffer 数据的末尾</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 可能会存在多个 cmd+data 组合，所以这里是 while 一直读取</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 先从 binder_write_read.write_buffer 中读取出 cmd 具体命令</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 1、比如在 service_manager#main binder_loop 中先发送的： BC_ENTER_LOOPER</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 2、比如在 IServiceManager 中 addService 过来的情况下，会在 IPCThreadState::writeTransactionData 方法中</span></span><br><span class="line"><span class="comment">		 * -  先写入 cmd = BC_TRANSACTION ，然后再写入了一个 binder_transaction_data 结构体实例，</span></span><br><span class="line"><span class="comment">		 * -  该实例内部会存储 handle ，具体的 code 等值</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (get_user(cmd, (<span class="type">uint32_t</span> __user *)ptr))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="comment">// 因为读取了 cmd， 所以将指针后移</span></span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">		trace_binder_command(cmd);</span><br><span class="line">		<span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">			<span class="type">atomic_inc</span>(&amp;binder_stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">			<span class="type">atomic_inc</span>(&amp;proc-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">			<span class="type">atomic_inc</span>(&amp;thread-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 开始处理具体的 cmd</span></span><br><span class="line">		<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">		<span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * BC_TRANSACTION 和 BC_REPLY 都会执行到这里来</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * BC_TRANSACTION 时： </span></span><br><span class="line"><span class="comment">			 * - 比如从 main_mediaserver.cpp#main -&gt; MediaPlayerService.cpp#instantiate 中调用过来时</span></span><br><span class="line"><span class="comment">	 		 * - 最终经由 IPCThreadState::transact 、 IPCThreadState::writeTransactionData 一直到 IPCThreadState::talkWithDriver</span></span><br><span class="line"><span class="comment">	 		 * - 这个过程的话，会封装 binder_write_read ，此时 binder_write_read 中的 write_buffer 中存储的数据为：</span></span><br><span class="line"><span class="comment">	 		 * - cmd  binder_transaction_data </span></span><br><span class="line"><span class="comment">	 		 * - 其中                   cmd = BC_TRANSACTION </span></span><br><span class="line"><span class="comment">	 		 * - -  binder_transaction_data = 详见 IPCThreadState::writeTransactionData</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 这里将 ptr 中用户空间传递过来的数据赋值到内核 tr 中</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 从 ptr 位置开始往后开始读取一个 binder_transaction_data 类型实例到 tr 中</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line">			ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 开始处理从用户空间传递过来的 binder_transaction_data 实例数据</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			binder_transaction(proc, thread, &amp;tr,</span><br><span class="line">					   cmd == BC_REPLY, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			pr_err(<span class="string">&quot;%d:%d unknown command %d\n&quot;</span>,</span><br><span class="line">			       proc-&gt;pid, thread-&gt;pid, cmd);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 最后一步，修改 binder_write_read.write_consumed 的值为当前已消耗的长度</span></span><br><span class="line"><span class="comment">		 * 即当前已经读取过的长度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		*consumed = ptr - buffer;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意这里调用 binder_thread_write() 方法时的入参：</p>
<ol>
<li>proc : 发起方进程信息，是 binder_proc 实例。</li>
<li>thread : 发起方线程信息，是 binder_thread 实例。</li>
<li>binder_buffer : 从用户空间发送过来的 binder_write_read.write_buffer ，也就是要发送的数据起始地址。</li>
<li>size : 从用户空间发送过来的 binder_write_read.write_size ，也就是要发送的数据长度。</li>
<li>consumed :  从用户空间发送过来的 binder_write_read.write_consumed ，它表示当前 write_buffer 中已消耗的数据长度。</li>
</ol>
<p>考虑上 consumed的话，那么在write_buffer 中读取数据时，起始位置就是 write_buffer + write_consumed , 结束位置就是：write_buffer+ size 。</p>
<p>并且在当前 binder_thread_write() 方法内只要从 write_buffer 中读取了数据的话，会同步修改 write_consumed 的值，修改后的值实际是 binder_ioctl_write_read() 中的那个 binder_write_read结构体内的 write_consumed 属性。因为传入时是传入的它的地址。</p>
<p>所以在这里刚进入本方法时，会计算出用户发送过来数据的开始地址 ptr 和结束地址 end。</p>
<p>接着 while(ptr &lt; end) 来遍历用户发送的数据内容，进行挨个的处理。</p>
<p>在实际处理时，遵循的顺序是先读取 cmd ，然后将 ptr 后移执行长度来表示消耗掉一个 cmd 长度的数据了(uint32_t) 。然后再次进入一个 switch case来分类处理该cmd。</p>
<blockquote>
<p>注意这里读取的是 binder_write_read.write_buffer 中的数据。而前面分析 SM 发送数据时，在 IPTThreadState::writeTransactionData() 方法中会给Pacel mOut 中写入待传输的数据，格式是按序写入：cmd+ binder_transaction_data 组合（并会存在多个这种组合，因此这里读取时是 while (ptr&lt;end)一直读取）。而这些最终会存入 binder_write_read.write_buffer 中，也就是这里读取到的数据。</p>
</blockquote>
<p>因此按照之前的 SM 发送数据的例子，那么这里 cmd &#x3D; BC_TRANSACTION 。接着会先读取出一个 binder_transaction_data 实例对象，并将 ptr 后移。最后将读取出来的 binder_transaction_data 实例传入到 binder_transaction() 方法内去处理。</p>
<p>因为 binder_transaction() 方法代码太长了，因此下面分块来分析，我将其逻辑分为4步来分析，所以下面贴代码时也是只按顺序贴对应的代码：</p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h6 id="1-寻找目标进程-线程信息"><a href="#1-寻找目标进程-线程信息" class="headerlink" title="1. 寻找目标进程\线程信息"></a>1. 寻找目标进程\线程信息</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> binder_transaction_data *tr, <span class="type">int</span> reply,</span></span><br><span class="line"><span class="params">			       <span class="type">binder_size_t</span> extra_buffers_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">	<span class="type">binder_size_t</span> buffer_offset = <span class="number">0</span>;</span><br><span class="line">	<span class="type">binder_size_t</span> off_start_offset, off_end_offset;</span><br><span class="line">	<span class="type">binder_size_t</span> off_min;</span><br><span class="line">	<span class="type">binder_size_t</span> sg_buf_offset, sg_buf_end_offset;</span><br><span class="line">	<span class="comment">// 目标进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 目标线程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line">	<span class="comment">// 目标binder节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span> return_error = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> return_error_param = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> return_error_line = <span class="number">0</span>;</span><br><span class="line">	<span class="type">binder_size_t</span> last_fixup_obj_off = <span class="number">0</span>;</span><br><span class="line">	<span class="type">binder_size_t</span> last_fixup_min_off = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> =</span> proc-&gt;context;</span><br><span class="line">	<span class="type">int</span> t_debug_id = atomic_inc_return(&amp;binder_last_id);</span><br><span class="line">	<span class="type">char</span> *secctx = <span class="literal">NULL</span>;</span><br><span class="line">	u32 secctx_sz = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	e = binder_transaction_log_add(&amp;binder_transaction_log);</span><br><span class="line">	e-&gt;debug_id = t_debug_id;</span><br><span class="line">	e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">	e-&gt;from_proc = proc-&gt;pid;</span><br><span class="line">	e-&gt;from_thread = thread-&gt;pid;</span><br><span class="line">	e-&gt;target_handle = tr-&gt;target.handle;</span><br><span class="line">	e-&gt;data_size = tr-&gt;data_size;</span><br><span class="line">	e-&gt;offsets_size = tr-&gt;offsets_size;</span><br><span class="line">	e-&gt;context_name = proc-&gt;context-&gt;name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果对应的 cmd 是 BC_REPLY 时，reply 才会是 true ，才会执行到内部去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (reply) &#123;</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 假设之前是 A 线程发送事务 t 到B线程，此时 thread =B，</span></span><br><span class="line"><span class="comment">		 * transaction_stack 之前保存了该 thread 当前在处理的事务</span></span><br><span class="line"><span class="comment">		 * 所以此时 A-&gt;transaction_stack = t</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">		<span class="keyword">if</span> (in_reply_to == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			binder_user_error(<span class="string">&quot;%d:%d got reply transaction with no transaction stack\n&quot;</span>,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EPROTO;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_empty_call_stack;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 假设之前是 A线程发送事务 t 到B线程，那么 t-&gt;to_thread = B </span></span><br><span class="line"><span class="comment">		 * 而此时是 B返回数据给A，此时 thread =B，</span></span><br><span class="line"><span class="comment">		 * 所以这里的判断就是保证必须是 B 返回的数据给 A 才行。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) &#123;</span><br><span class="line">			spin_lock(&amp;in_reply_to-&gt;lock);</span><br><span class="line">			binder_user_error(<span class="string">&quot;%d:%d got reply transaction with bad transaction stack, transaction %d has target %d:%d\n&quot;</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid, in_reply_to-&gt;debug_id,</span><br><span class="line">				in_reply_to-&gt;to_proc ?</span><br><span class="line">				in_reply_to-&gt;to_proc-&gt;pid : <span class="number">0</span>,</span><br><span class="line">				in_reply_to-&gt;to_thread ?</span><br><span class="line">				in_reply_to-&gt;to_thread-&gt;pid : <span class="number">0</span>);</span><br><span class="line">			spin_unlock(&amp;in_reply_to-&gt;lock);</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EPROTO;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			in_reply_to = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">goto</span> err_bad_call_stack;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 此时 thread = B，</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		<span class="comment">// 找到其 </span></span><br><span class="line">		target_thread = binder_get_txn_from_and_acq_inner(in_reply_to);</span><br><span class="line">		<span class="keyword">if</span> (target_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			return_error = BR_DEAD_REPLY;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) &#123;</span><br><span class="line">			binder_user_error(<span class="string">&quot;%d:%d got reply transaction with bad target transaction stack %d, expected %d\n&quot;</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">				target_thread-&gt;transaction_stack ?</span><br><span class="line">				target_thread-&gt;transaction_stack-&gt;debug_id : <span class="number">0</span>,</span><br><span class="line">				in_reply_to-&gt;debug_id);</span><br><span class="line">			binder_inner_proc_unlock(target_thread-&gt;proc);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EPROTO;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			in_reply_to = <span class="literal">NULL</span>;</span><br><span class="line">			target_thread = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">		&#125;</span><br><span class="line">		target_proc = target_thread-&gt;proc;</span><br><span class="line">		target_proc-&gt;tmp_ref++;</span><br><span class="line">		binder_inner_proc_unlock(target_thread-&gt;proc);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 比如从 main_mediaserver.cpp#main -&gt; MediaPlayerService.cpp#instantiate 中调用过来时</span></span><br><span class="line"><span class="comment">	 	 * 最终经由 IPCThreadState::transact 、 IPCThreadState::writeTransactionData 一直到 IPCThreadState::talkWithDriver</span></span><br><span class="line"><span class="comment">	 	 * 这个过程的话，会封装 binder_write_read ，此时 binder_write_read 中的 write_buffer 中存储的数据为：</span></span><br><span class="line"><span class="comment">	 	 * cmd  binder_transaction_data </span></span><br><span class="line"><span class="comment">	 	 * 其中                   cmd = BC_TRANSACTION </span></span><br><span class="line"><span class="comment">	 	 * -  binder_transaction_data = 详见 IPCThreadState::writeTransactionData</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 所以可以对照着 IPCThreadState.cpp#writeTransactionData 方法来看</span></span><br><span class="line"><span class="comment">		 * tr.target.handle 对应的就是目的 handle，比如从 ServiceManager 的 BpBinder 发起的transact</span></span><br><span class="line"><span class="comment">		 * 那么该 handle 就是 ServierManager 的，也就是 0</span></span><br><span class="line"><span class="comment">		 * 而这里判断如果 tr-&gt;target.handle 不为 0 则走if ，否则走下面else ，就是在判断是不是 SM </span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 这里是先找到目标 service 其对应的 binder_node 。当前是处于 内核态 的</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">			<span class="keyword">struct</span> binder_ref *ref;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * There must already be a strong ref</span></span><br><span class="line"><span class="comment">			 * on this node. If so, do a strong</span></span><br><span class="line"><span class="comment">			 * increment on the node to ensure it</span></span><br><span class="line"><span class="comment">			 * stays alive until the transaction is</span></span><br><span class="line"><span class="comment">			 * done.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			binder_proc_lock(proc);</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 遍历 proc-&gt;refs_by_desc 树，从中查找每个节点的 ref-&gt;data.desc 是否等于入参 tr-&gt;target.handle</span></span><br><span class="line"><span class="comment">			 * 是的话则表示已找到，则返回，没找到则返回 NULL</span></span><br><span class="line"><span class="comment">			 * 这也就是说 ref-&gt;data.desc 其实就是对应的 id ，比如 0 对应 service manager</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 第一步：确定 binder_node （其中分为两小步）和 target_proc （目标进程信息）</span></span><br><span class="line"><span class="comment">			 *  1.通过 handle 找到该进程中对应的 binder_ref</span></span><br><span class="line"><span class="comment">			 *  2.通过 binder_ref 来找其对应 binder_node （其实就是 ref-&gt;node ）</span></span><br><span class="line"><span class="comment">			 *  -- 来作为  target_node ，而同时会给 target_proc 赋值为：target_node-&gt;proc</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			ref = binder_get_ref_olocked(proc, tr-&gt;target.handle,</span><br><span class="line">						     <span class="literal">true</span>);</span><br><span class="line">			<span class="comment">// 找到了</span></span><br><span class="line">			<span class="keyword">if</span> (ref) &#123;</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 到这里，ref 代表的就是该 handle 对应的 binder_ref 实例</span></span><br><span class="line"><span class="comment">				 * 在 binder_get_node_refs_for_txn 方法中，将查找到的 binder_ref 实例传入进去，内部</span></span><br><span class="line"><span class="comment">				 * 会通过 ref-&gt;node-&gt;proc 来判断目标是否已经死亡，没有的话则自增其引用数并返回它，</span></span><br><span class="line"><span class="comment">				 * 否则 return_error = BR_DEAD_REPLY</span></span><br><span class="line"><span class="comment">				 * </span></span><br><span class="line"><span class="comment">				 * 注意如果目标进程没有死亡，则同时会将入参 target_proc 赋值给 ref-&gt;node.proc </span></span><br><span class="line"><span class="comment">				 * 所以正常的话，该方法返回后:</span></span><br><span class="line"><span class="comment">				 * target_node 表示 handle 对应的 binder_ref 实例</span></span><br><span class="line"><span class="comment">				 * target_proc 表示 handle 对应的 进程 信息</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				target_node = binder_get_node_refs_for_txn(</span><br><span class="line">						ref-&gt;node, &amp;target_proc,</span><br><span class="line">						&amp;return_error);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				binder_user_error(<span class="string">&quot;%d:%d got transaction to invalid handle\n&quot;</span>,</span><br><span class="line">						  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">			&#125;</span><br><span class="line">			binder_proc_unlock(proc);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 目的地调用是往 SM 去的，因为 SM 的handle 是 0</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 这里取的是 context-&gt;binder_context_mgr_node </span></span><br><span class="line"><span class="comment">			 * 而在 service_manager.c#main 中，会调用 binder_become_context_manager 方法</span></span><br><span class="line"><span class="comment">			 * 然后在该方法中，会发送一个 BINDER_SET_CONTEXT_MGR_EXT 消息给 binder，然后执行其</span></span><br><span class="line"><span class="comment">			 * binder_ioctl_set_ctx_mgr 方法，在该方法中就会给 context-&gt;binder_context_mgr_node 赋值</span></span><br><span class="line"><span class="comment">			 * 赋值为 SM 对应的信息，所以此时就可以通过它直接拿到之前设置的 SM 的</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			target_node = context-&gt;binder_context_mgr_node;</span><br><span class="line">			<span class="keyword">if</span> (target_node)</span><br><span class="line">				target_node = binder_get_node_refs_for_txn(</span><br><span class="line">						target_node, &amp;target_proc,</span><br><span class="line">						&amp;return_error);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				return_error = BR_DEAD_REPLY;</span><br><span class="line">			mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">			<span class="keyword">if</span> (target_node &amp;&amp; target_proc-&gt;pid == proc-&gt;pid) &#123;</span><br><span class="line">				binder_user_error(<span class="string">&quot;%d:%d got transaction to context manager from process owning it\n&quot;</span>,</span><br><span class="line">						  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = -EINVAL;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 上面先根据 handle 来通过 binder_get_ref_olocked 去 proc-&gt;refs_by_desc 树中查找到对应的 binder_ref</span></span><br><span class="line"><span class="comment">		 * 然后通过 binder_get_node_refs_for_txn 来将找到的 binder_ref.node 传入进去，内部会判断该 node 对应的进程是否还存活</span></span><br><span class="line"><span class="comment">		 * 存活的话自增其引用数并返回出来给 target_node ，此时 target_node 不等于null，否则返回 null 给 target_node</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 再写一遍：</span></span><br><span class="line"><span class="comment">		 * 所以正常的话，到这里:</span></span><br><span class="line"><span class="comment">		 * target_node 表示 handle 对应的 binder_ref 实例</span></span><br><span class="line"><span class="comment">		 * target_proc 表示 handle 对应的 进程 信息</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!target_node) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * return_error is set above</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		e-&gt;to_node = target_node-&gt;debug_id;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(proc == target_proc)) &#123;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Client进程是否有权限向Server进程发送请求，也就是Client是否有权限调用Server的功能</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (security_binder_transaction(proc-&gt;cred,</span><br><span class="line">						target_proc-&gt;cred) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EPERM;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">		&#125;</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * list_first_entry_or_null 三个入参分别是 ：指向链表结点指针ptr，用户数据类型，用户数据结构中成员变量名</span></span><br><span class="line"><span class="comment">		 * 即找到 thread-&gt;todo 链表中的第一个元素，如果 thread-&gt;todo 为空则返回 NULL</span></span><br><span class="line"><span class="comment">		 * thread-&gt;todo 链表中存储的都是 binder_work 实例</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * thread 是一个 binder_thread 实例(一个线程对应一个binder_thread实例)，是当前方法的入参，</span></span><br><span class="line"><span class="comment">		 * 其代表的是【当前进程】的信息，所以这里也就是取出【当前进程的 todo 列表】中第一个元素</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		w = list_first_entry_or_null(&amp;thread-&gt;todo,</span><br><span class="line">					     <span class="keyword">struct</span> binder_work, entry);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * tr 是入参，是用户空间传递过来的 binder_transaction_data 实例</span></span><br><span class="line"><span class="comment">		 * w 是上面刚从 thread-&gt;todo 中读取出来的当前进程 todo 链表内第一个元素</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 当前线程目前中已经有一个 binder事务 在等待处理了，然后又来了一个同步binder 事务</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; w &amp;&amp;</span><br><span class="line">		    w-&gt;type == BINDER_WORK_TRANSACTION) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Do not allow new outgoing transaction from a</span></span><br><span class="line"><span class="comment">			 * thread that has a transaction at the head of</span></span><br><span class="line"><span class="comment">			 * its todo list. Only need to check the head</span></span><br><span class="line"><span class="comment">			 * because binder_select_thread_ilocked picks a</span></span><br><span class="line"><span class="comment">			 * thread from proc-&gt;waiting_threads to enqueue</span></span><br><span class="line"><span class="comment">			 * the transaction, and nothing is queued to the</span></span><br><span class="line"><span class="comment">			 * todo list while the thread is on waiting_threads.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			binder_user_error(<span class="string">&quot;%d:%d new transaction not allowed when there is a transaction on thread todo\n&quot;</span>,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EPROTO;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_bad_todo_list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 查找出 target_thread </span></span><br><span class="line"><span class="comment">		 * 通常情况下，Client 并不在乎由Service的哪个线程来处理请求，即 target_thread = null。但是，考虑一个特殊的复杂情况：</span></span><br><span class="line"><span class="comment">		 * 进程A是一个Service，它提供了多个线程A1，A2，A3等多个线程来服务Client</span></span><br><span class="line"><span class="comment">		 * 进程B是一个Client，它向A发送了请求（即binder_transaction）T1。</span></span><br><span class="line"><span class="comment">		 * A1接收到了来自B的请求T1。</span></span><br><span class="line"><span class="comment">		 * A1处理T1的过程中，发现为了处理T1的请求，需要 Serivce C 协助。</span></span><br><span class="line"><span class="comment">		 * A1向 C 发送了请求，并等待 C回复请求T2</span></span><br><span class="line"><span class="comment">		 * C的C1线程接收到请求，但是，处理T2的过程中，发现也需要A协助</span></span><br><span class="line"><span class="comment">		 * C1 向A发送请求 T3</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 这种情况下，因为A1处于等待状态，比起A2和A3来，由A1来处理T3请求会是一个提高性能的解决方案。也就是说，我们希望target_thread=A1。</span></span><br><span class="line"><span class="comment">		 * 但是，通过什么样的逻辑来实现呢？首先，明确当前的情况：</span></span><br><span class="line"><span class="comment">		 * thread = C1;  // 当前</span></span><br><span class="line"><span class="comment">		 * target_porc = A;</span></span><br><span class="line"><span class="comment">		 * T3-&gt;from = C1;</span></span><br><span class="line"><span class="comment">		 * T3-&gt;from_parent = T2; // 关于from_parent大致，可以理解为，T3是由T2的处理触发的</span></span><br><span class="line"><span class="comment">		 * C1-&gt;transaction_stack = T2;  // transaction_stack 表示当前thread 正在处理的事务</span></span><br><span class="line"><span class="comment">		 * T2-&gt;from = A1;</span></span><br><span class="line"><span class="comment">		 * T2-&gt;from_parent=T1;</span></span><br><span class="line"><span class="comment">		 * A1-&gt;proc=A;</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 遍历当前线程的事务栈,查找是否存在可以复用的线程</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 同步 binder ，并且【当前binder_thread】 中还有正在处理的事务</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			tmp = thread-&gt;transaction_stack;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * tmp 此时表示的是：【当前binder_thread】 中还有正在处理的事务</span></span><br><span class="line"><span class="comment">			 * 所以其 to_thread 表示的是它的目的 thread，那它一定是当前 thread </span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 查找事务栈中的事务，是否有来自目标进程的线程在等待，如果有即可作为目标线程</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (tmp-&gt;to_thread != thread) &#123;</span><br><span class="line">				spin_lock(&amp;tmp-&gt;lock);</span><br><span class="line">				binder_user_error(<span class="string">&quot;%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d\n&quot;</span>,</span><br><span class="line">					proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,</span><br><span class="line">					tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : <span class="number">0</span>,</span><br><span class="line">					tmp-&gt;to_thread ?</span><br><span class="line">					tmp-&gt;to_thread-&gt;pid : <span class="number">0</span>);</span><br><span class="line">				spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">				binder_inner_proc_unlock(proc);</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = -EPROTO;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_bad_call_stack;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 遍历 tmp ，判断它的 from 是否等于 target_proc</span></span><br><span class="line"><span class="comment">			 * 也就是判断该 tmp 事务它是从哪个线程调用发起的</span></span><br><span class="line"><span class="comment">			 * 可能如上存在循环的调用，这里就是逆着调用顺序往回找，找到一个和【本次目标进程】 target_proc  一样的话</span></span><br><span class="line"><span class="comment">			 * 则表示存在循环的情况，则此时将其 binder_thread 保存到 target_thread 中作为目标线程</span></span><br><span class="line"><span class="comment">			 * 此时表示指定目标进程 target_proc 中的 target_thread 线程中去执行该事务。</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 如果不存在上述情况的话，target_thread = null，则不指定目标线程，只是指定目标进程 target_proc</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line"></span><br><span class="line">				spin_lock(&amp;tmp-&gt;lock);</span><br><span class="line">				from = tmp-&gt;from;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (from &amp;&amp; from-&gt;proc == target_proc) &#123;</span><br><span class="line">					<span class="type">atomic_inc</span>(&amp;from-&gt;tmp_ref);</span><br><span class="line">					target_thread = from;</span><br><span class="line">					spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">				tmp = tmp-&gt;from_parent;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (target_thread)</span><br><span class="line">		e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">	e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略剩下的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是binder_transaction() 方法中的第一步，主要作用是：根据Client传来的binder_transaction_data 来找到其对应的目的方进程&#x2F;线程信息。</p>
<blockquote>
<p>比如我们前面分析的：在某个Client进程通过SM 代理来请求 SM添加指定Service，也就是Client发送一个addService的请求到SM 进程中。而对于这个过程来说，发起方进程是Client，而目的方进程为SM进程。</p>
</blockquote>
<p>在分析第一步之前，先看看定义的参数含义：</p>
<p>1、binder_proc *proc ： 入参，表示发起方进程信息。</p>
<p>2、binder_thread *thread ： 入参，表示发起方线程信息</p>
<p>3、binder_transaction_data *tr ： 入参，从发起方binder_write_read.write_buffer 中读取出来要处理的 binder_transaction_data 实例</p>
<p>4、int reply ： 入参，表示当前 cmd 是否是 BC_REPLY 。这个cmd 和上面的 tr 是一组。如果cmd &#x3D; BC_TRANSACTION 则这里是 0，也就是false；如果cmd &#x3D; BC_REPLY 则这里也就是true。</p>
<p>5、binder_transaction *t ： 当前函数内定义的。用来在后面第二步保存这次binder请求信息。</p>
<p>6、binder_proc *target_proc ：当前函数内定义的。 表示找到的目的进程信息，也就是当前这一步(第一步)要查找并赋值的。</p>
<p>7、binder_thread *target_thread ： 当前函数内定义的。表示找到的目的线程信息，也就是当前这一步(第一步)要查找并赋值的。</p>
<p>8、binder_node *target_node ： 当前函数内定义的。表示找到的目的Binder信息。binder_node简单理解是每一个BBinder 在内核中的对应。而每个BBinder表示一个Binder 实体。比如 SM 的话，它对应一个BBinder 实例，那么它在内核中也对应一个 binder_node 实例。</p>
<blockquote>
<p>与binder_node对应的在内核中还存在 binder_ref 实例，他俩分别对应着用户进程的 BBinder 实例和 BpBinder 实例。</p>
<p>在 binder_node 中，有 ptr 和 cookie，这俩保存着Server 进程中 BBinder 实例的地址。因此内核中可以拿到对应 binder_node 实例，通过它来执行到 Server 进程中 BBinder 实例中的 transact() 方法去。</p>
<p>而在 binder_ref 中，有一个node 表示其所指向的 binder_node 实例。在每个Client进程所对应的binder_proc 实例中的红黑树中，都会存储着该Client进程访问过的binder_ref 实例。通过handle值拿到对应的binder_ref 之后，就可以通过它拿到对应的 binder_node 了。</p>
<p>关于这俩的关系简单可以按照如上解释来理解。后续会有较多地方用到他俩，到时候会再做解释。</p>
</blockquote>
<p>因此在这一步查找目的进程信息时，其最终目的是要给上面： target_proc 、 target_thread 和 target_node 赋值。</p>
<p>在实际查找时，首先会判断 tr-&gt;target.handle ，也就是目标Binder 在当前进程的唯一handle 值。比如发送给 SM 的话，handle值都是0。然后通过该 handle 值在当前进程 binder_proc 实例中查找其对应的 binder_ref 实例，查找 binder_ref 是通过 binder_get_ref_olocked() 方法来实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_ref *<span class="title function_">binder_get_ref_olocked</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">						 u32 desc, <span class="type">bool</span> need_strong_ref)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> =</span> proc-&gt;refs_by_desc.rb_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		ref = rb_entry(n, <span class="keyword">struct</span> binder_ref, rb_node_desc);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (desc &lt; ref-&gt;data.desc) &#123;</span><br><span class="line">			n = n-&gt;rb_left;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc &gt; ref-&gt;data.desc) &#123;</span><br><span class="line">			n = n-&gt;rb_right;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (need_strong_ref &amp;&amp; !ref-&gt;data.strong) &#123;</span><br><span class="line">			binder_user_error(<span class="string">&quot;tried to use weak ref as strong ref\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ref;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里是从：”当前发起方进程binder_proc” 中查找的，更确切的是从其 refs_by_desc 中查找的。refs_by_desc 是一个红黑树根节点，其内部通过 handle 值来放置对应的 binder_ref，使用红黑树保证了其查找效率。如果找到的话则返回；没找到则返回NULL。</p>
<p>从该方法也可以知道，binder_ref.data.desc 它表示的就是 handle 值，也就是说desc是handle 的另外一种叫法而已。</p>
<p>如果通过 binder_get_ref_olocked()方法找到了该handle 对应的 binder_ref 实例的话，则将其赋值给 ref 供后续使用；如果没找的话则 ref &#x3D;&#x3D; NULL ，那么后续会直接失败，表示 handle 不合法，即在当前进程binder_proc 中没有该 handle 存在。而至于怎么样才能让该进程存在该handle 呢？等后面再说。</p>
<p>因此当找到了目标 handle 在当前进程binder_proc 中所对应的 binder_ref 实例的话，那么就可以从这个 binder_ref 实例中取出其对应的 binder_node 等信息了，这些是通过 binder_get_node_refs_for_txn() 方法来实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_node *<span class="title function_">binder_get_node_refs_for_txn</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> binder_node *node,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> binder_proc **procp,</span></span><br><span class="line"><span class="params">		<span class="type">uint32_t</span> *error)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	binder_node_inner_lock(node);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果 node 的 proc 不为 null，则自增其 tmp_refs 等属性，表示其引用数增加了，然后原封不动将入参 node 返回出去</span></span><br><span class="line"><span class="comment">	 * 否则则将 error 置为 BR_DEAD_REPLY ，返回 null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (node-&gt;proc) &#123;</span><br><span class="line">		target_node = node;</span><br><span class="line">		binder_inc_node_nilocked(node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">		binder_inc_node_tmpref_ilocked(node);</span><br><span class="line">		node-&gt;proc-&gt;tmp_ref++;</span><br><span class="line">		*procp = node-&gt;proc;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		*error = BR_DEAD_REPLY;</span><br><span class="line">	binder_node_inner_unlock(node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> target_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中的 node 入参就是刚获取到的 binder_ref 中的 binder_node 实例。</p>
<p>而 procp 入参是对应的 target_proc 。</p>
<p>该方法体内通过该 binder_node 实例取出其中的 proc 将其赋值给入参 procp 也就是 target_proc 。</p>
<blockquote>
<p>binder_node 结构体中不仅如上面所说存储着代表Server进程BBinder 内存地址的 ptr 和 cookie ，额外其proc属性还存储着Server进程对应的 binder_proc 实例。</p>
</blockquote>
<p>因此说，当binder_get_node_refs_for_txn() 方法执行完毕之后，target_proc 就会被赋值，指向目标进程信息；其返回值会赋值给 target_node ，也就是指向 binder_ref-&gt;node。</p>
<p>以上这些是当 tr-&gt;target.handle !&#x3D;0 时的操作。而当其等于0 时，也就是handle&#x3D;0表示是指向的 SM 。此时只需要取固定的 SM 对应的 binder_node 即可。</p>
<p>SM 对应的 binder_node 在Binder 内核中有一个专门的属性来存储它：binder_proc-&gt;context-&gt;binder_context_mgr_node 。</p>
<blockquote>
<p>binder_context_mgr_node 这个属性在 service_manager 进程启动后，会将自身的BBinder 实例注册进来的。将其存储在 binder_context_mgr_node 中供后续直接使用。这个后续会在 SM 注册的时候讲</p>
</blockquote>
<p>因此此时 binder_node 就可以直接取binder_context_mgr_node 作为 target_node 即可。然后同样的再调用 binder_get_node_refs_for_txn() 方法来为 target_proc 赋值。</p>
<p>至此，就确定好了 target_node 和 target_proc 。当然主要是确认前者，前者确定后后者自然就确定了。</p>
<p>接着往下就会进行一些合法性判断，比如 target_node 是否找到了？当前发起方进程binder_proc和目标进程binder_proc是一样的？等等。</p>
<p>接下来就是确定 target_thread 的值了。按常理来将，Client 进程端发送一个请求到Server进程去让它来处理逻辑，然后拿到返回结果。这个过程中Client端并不关心Server端哪个线程来执行该逻辑，怎么执行该逻辑是你Server端的事儿，你是开线程池或者就一个单线程在排队跑逻辑，这些都是Server自己应该关注的。而这里为什么会需要 target_thread 呢？</p>
<p>这里获取 target_thread 的逻辑比较绕，等后续分析完 write &amp; read 逻辑之后再来分析。【埋坑点】</p>
<p>计算出 target_thread 之后，如果它为空表示不需要指定目标进程中的线程信息，即只要是目标进程就行了，不管它内部哪个线程来执行；而如果不为空则表示该任务要到目标进程中的目标线程内来执行的。</p>
<p>至此第一步执行完毕，此时计算出来的 target_node 、target_proc，甚至target_thread 就都会有值了。后面就可以使用他们了。</p>
<h6 id="2-创建binder-transaction等实例来保存本次请求"><a href="#2-创建binder-transaction等实例来保存本次请求" class="headerlink" title="2.创建binder_transaction等实例来保存本次请求"></a>2.创建binder_transaction等实例来保存本次请求</h6><p>第二步的逻辑主要是创建对应的实例来保存本次Binder请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> binder_transaction_data *tr, <span class="type">int</span> reply,</span></span><br><span class="line"><span class="params">			       <span class="type">binder_size_t</span> extra_buffers_size)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略第一步的代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> reuse incoming transaction for reply */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 上面是一些合法性判断，这里开始赋值</span></span><br><span class="line"><span class="comment">	 * 先创建 binder_transaction *t 对象，后续下面会给他赋值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -ENOMEM;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_t_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_lock_init(&amp;t-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 为 binder_work tcomplete 分配内存</span></span><br><span class="line"><span class="comment">	 * tcomplete 则发送给当前线程的 todo 队列，向发送者返回 BR_TRANSACTION_COMPLETE</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (tcomplete == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -ENOMEM;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_tcomplete_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t-&gt;debug_id = t_debug_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * reply: cmd = BC_TRANSACTION 时为 false</span></span><br><span class="line"><span class="comment">	 * !(tr-&gt;flags &amp; TF_ONE_WAY) : 同步binder方式时</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 1、所以说 【cmd = BC_TRANSACTION 时的同步请求方式】时，会将当前 thread 线程信息(也就是client发起方线程)保存到 t-&gt;from</span></span><br><span class="line"><span class="comment">	 * 表示该事务 t 的发起方线程信息为 thread</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 2、而如果是 【BC_REPLY 或者是 BC_TRANSACTION 的异步请求方式】时，t-&gt;from 为空，因为不需要返回值，就不用保存了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">		t-&gt;from = thread;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录发送者的有效用户id，是Binder机制安全保障的一环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	t-&gt;sender_euid = task_euid(proc-&gt;tsk);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * target_proc 是上面通过 handle 查找到的【目标进程信息】</span></span><br><span class="line"><span class="comment">	 * 这里将其保存到 t-&gt;to_proc 中，表示该事务 t 应该到 target_proc 中去执行处理</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	t-&gt;to_proc = target_proc;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 目标进程中的指定线程</span></span><br><span class="line"><span class="comment">	 * 如上面分析，存在循环调用时，会指定 target_thread 为具体的线程，否则 target_thread 一般都是 null </span></span><br><span class="line"><span class="comment">	 * 即只指定到指定进程 target_proc 中去处理，而不指定指定线程</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	t-&gt;to_thread = target_thread;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 可以对照着 IPCThreadState.cpp#writeTransactionData 方法来看</span></span><br><span class="line"><span class="comment">	 * 这里的code 就是对应的操作码，比如从 IServiceManager#addService 方法过来的 ADD_SERVICE_TRANSACTION</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	t-&gt;code = tr-&gt;code;</span><br><span class="line">	t-&gt;flags = tr-&gt;flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 保存进程调度信息</span></span><br><span class="line"><span class="comment">	 * 如果是同步binder事务调用的话，即发起方线程和执行方线程设置相同的优先级</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) &amp;&amp;</span><br><span class="line">	    binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">		<span class="comment">/* Inherit supported policies for synchronous transactions */</span></span><br><span class="line">		t-&gt;priority.sched_policy = current-&gt;policy;</span><br><span class="line">		t-&gt;priority.prio = current-&gt;normal_prio;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="comment">/* Otherwise, fall back to the default priority */</span></span><br><span class="line">		t-&gt;priority = target_proc-&gt;default_priority;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (target_node &amp;&amp; target_node-&gt;txn_security_ctx) &#123;</span><br><span class="line">		u32 secid;</span><br><span class="line">		<span class="type">size_t</span> added_size;</span><br><span class="line"></span><br><span class="line">		security_cred_getsecid(proc-&gt;cred, &amp;secid);</span><br><span class="line">		ret = security_secid_to_secctx(secid, &amp;secctx, &amp;secctx_sz);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = ret;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_get_secctx_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		added_size = ALIGN(secctx_sz, <span class="keyword">sizeof</span>(u64));</span><br><span class="line">		extra_buffers_size += added_size;</span><br><span class="line">		<span class="keyword">if</span> (extra_buffers_size &lt; added_size) &#123;</span><br><span class="line">			<span class="comment">/* integer overflow of extra_buffers_size */</span></span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_bad_extra_size;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从 target_proc 为 t-&gt;buffer 分配一块 buffer</span></span><br><span class="line"><span class="comment">	 * 第一个参数：target_proc-&gt;alloc，即使用的是【目标进程的信息】</span></span><br><span class="line"><span class="comment">	 * 第二个参数：tr-&gt;data_size，tr 是入参表示的是来自发送方用户空间的信息，其 data_size 表示其tr内部数据的大小</span></span><br><span class="line"><span class="comment">	 * 第二个参数：tr-&gt;offsets_size， 同上，不过这是数据偏移量</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 所以在 binder_alloc_new_buf 方法内部申请内存，并做物理页的内存映射 等操作的话，都是在目标进程地址中操作的</span></span><br><span class="line"><span class="comment">	 * 也就是在 目标进程内开启一片内存，并做物理页的映射</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size,</span><br><span class="line">		tr-&gt;offsets_size, extra_buffers_size,</span><br><span class="line">		!reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(t-&gt;buffer)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * -ESRCH indicates VMA cleared. The target is dying.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		return_error_param = PTR_ERR(t-&gt;buffer);</span><br><span class="line">		return_error = return_error_param == -ESRCH ?</span><br><span class="line">			BR_DEAD_REPLY : BR_FAILED_REPLY;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		t-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_binder_alloc_buf_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (secctx) &#123;</span><br><span class="line">		<span class="type">size_t</span> buf_offset = ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="type">void</span> *)) +</span><br><span class="line">				    ALIGN(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="type">void</span> *)) +</span><br><span class="line">				    ALIGN(extra_buffers_size, <span class="keyword">sizeof</span>(<span class="type">void</span> *)) -</span><br><span class="line">				    ALIGN(secctx_sz, <span class="keyword">sizeof</span>(u64));</span><br><span class="line"></span><br><span class="line">		t-&gt;security_ctx = (<span class="type">uintptr_t</span>)t-&gt;buffer-&gt;user_data + buf_offset;</span><br><span class="line">		binder_alloc_copy_to_buffer(&amp;target_proc-&gt;alloc,</span><br><span class="line">					    t-&gt;buffer, buf_offset,</span><br><span class="line">					    secctx, secctx_sz);</span><br><span class="line">		security_release_secctx(secctx, secctx_sz);</span><br><span class="line">		secctx = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 保存 binder_transaction 和对应的 binder_node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">	t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将从 tr-&gt;data.ptr.buffer 开始的数据赋值到 t-&gt;buffer 中所对应的物理页内，</span></span><br><span class="line"><span class="comment">	 * 一共需要复制 tr-&gt;data_size 长度的数据，也就是将 tr 用户空间来的数据通过 copy_from_user 方法</span></span><br><span class="line"><span class="comment">	 * 复制到内核空间中去，而内核物理页和目标进程在前面已经做好内存映射了</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 值得注意的是，虽然我们之前已经多次看到 copy_from_user 函数，但是之前copy的都是Binder指令，或者结构体（binder_transaction_data),</span></span><br><span class="line"><span class="comment">	 * 而binder_transaction_data.ptr.buffer&amp;binder_transaction_data.ptr.offsets也仅仅是保存了数据和偏移量数组在user space的首地址，</span></span><br><span class="line"><span class="comment">	 * 而非数据本身。所以，这里才是真正的数据copy，而Binder通信中唯一一次数据copy指的这里</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * binder_alloc_copy_user_to_buffer : binder_alloc.c </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (binder_alloc_copy_user_to_buffer(</span><br><span class="line">				&amp;target_proc-&gt;alloc,</span><br><span class="line">				t-&gt;buffer, <span class="number">0</span>,</span><br><span class="line">				(<span class="type">const</span> <span class="type">void</span> __user *)</span><br><span class="line">					(<span class="type">uintptr_t</span>)tr-&gt;data.ptr.buffer,</span><br><span class="line">				tr-&gt;data_size)) &#123;</span><br><span class="line">		binder_user_error(<span class="string">&quot;%d:%d got transaction with invalid data ptr\n&quot;</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EFAULT;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 同上，不同的是这里复制的是 tr-&gt;data.ptr.offsets 开始的数据，一共 tr-&gt;offsets_size 长度。</span></span><br><span class="line"><span class="comment">	 * 赋值到 t-&gt;buffer 中也是从其 tr-&gt;data_size 位置开始往后的，因为前面已经赋值了 tr-&gt;data_size 这么多的数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (binder_alloc_copy_user_to_buffer(</span><br><span class="line">				&amp;target_proc-&gt;alloc,</span><br><span class="line">				t-&gt;buffer,</span><br><span class="line">				ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="type">void</span> *)),</span><br><span class="line">				(<span class="type">const</span> <span class="type">void</span> __user *)</span><br><span class="line">					(<span class="type">uintptr_t</span>)tr-&gt;data.ptr.offsets,</span><br><span class="line">				tr-&gt;offsets_size)) &#123;</span><br><span class="line">		binder_user_error(<span class="string">&quot;%d:%d got transaction with invalid offsets ptr\n&quot;</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EFAULT;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="type">binder_size_t</span>))) &#123;</span><br><span class="line">		binder_user_error(<span class="string">&quot;%d:%d got transaction with invalid offsets size, %lld\n&quot;</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid, (u64)tr-&gt;offsets_size);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EINVAL;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!IS_ALIGNED(extra_buffers_size, <span class="keyword">sizeof</span>(u64))) &#123;</span><br><span class="line">		binder_user_error(<span class="string">&quot;%d:%d got transaction with unaligned buffers size, %lld\n&quot;</span>,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">				  (u64)extra_buffers_size);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EINVAL;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略后续第三步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，首先是为  binder_transaction *t 来分配内存空间，接着就是给它内部的属性赋值，即挨个如下：</p>
<p>1、binder_transaction.from ：from属性表示当前 binder_transaction 所对应的发起方线程信息。因为 binder_transaction 是一个binder请求信息在Binder内核中的实例代表，其内部自然会存储这个binder请求的发起方、接收方等信息。</p>
<p>当 cmd &#x3D; BC_TRANSACTION 并且是同步Binder请求方式时，会给其 from 赋值为 thread ，也就是当前发起方线程 binder_thread 信息。存储这个主要是为了后续返回数据时方便些。</p>
<p>而平时接触的的Binder请求基本都是同步方式的，即发起方线程要阻塞住等待返回结果再接着执行。因为后续分析时基本可以认为都是同步方式。</p>
<p>而如果 cmd &#x3D; BC_REPLY 时，那么其 from 就会被置为 NULL。</p>
<p>2、binder_transaction.sender_euid ：表示发送方uid信息，这是Binder机制来保障安全的其中一个环节。</p>
<p>3、binder_transaction.to_proc ：接收方进程binder_proc 信息，也就是上面计算出来的 target_proc 实例。这个肯定不会为空。</p>
<p>4、binder_transaction.to_thread ：接收方进程中用来执行该事务的线程信息，即前面计算出来的 target_thread 。如果它不为空，则该binder 事务要在执行进程内的该线程中执行。</p>
<p>5、binder_transaction.code ：对应发送给binder server 端的code。比如在调用 SM 的 addService 时，会传送code&#x3D;ADD_SERVICE_TRANSACTION 到 IPCThreadState::writeTransactionData 中，然后将该 code 写入到binder_transaction_data 中然后发送到Binder内核中来，也就是这里的入参 tr 。</p>
<blockquote>
<p>这个code和前面讲的cmd比较容易混淆：</p>
<p>code 是 BpBinder 方调用指定方法时所指定的，用来唯一标识当前调用的是server端BBinder的哪个方法。比如对于SM来说，ADD_SERVICE_TRANSACTION 对应着其 addService() 方法；CHECK_SERVICE_TRANSACTION 对应着 checkService() 方法；</p>
<p>cmd 是针对于 Binder 内核来说的，比如常见的 BC_TRANSACTION ，BC_REPLY 等 BC_XXX 开头的，还有一些表达binder内核操作返回值的 BR_XXX 开头的cmd。</p>
</blockquote>
<p>6、binder_transaction.flags ：同上code。</p>
<p>7、binder_transaction.priority：线程配置信息，比如其优先级。</p>
<p>如果当前Binder请求是同步方式时，即发起方线程会等待目的进程执行完毕返回结果之后再接着执行，因此这种情况时会将其线程优先级等信息设置成跟当前发起方线程一样的，保证两个线程调度配置是一样的。</p>
<blockquote>
<p>为什么这样设置呢？看看如下的解释：</p>
<p>Binder 通信，归根结底是位于不同进程中的线程之间的通信。假如进程 S 是 Server 端，提供 Binder 实体，线程 T1 从 Client 进程 C 中通过 Binder 的引用向进程 S 发送请求。S 为了处理这个请求需要启动线程 T2，而此时线程 T1 处于接收返回数据的等待状态。T2 处理完请求就会将处理结果返回给 T1，T1 被唤醒得到处理结果。在这过程中，T2 仿佛 T1 在进程 S 中的代理，代表 T1 执行远程任务，而给 T1 的感觉就像是穿越到 S 中执行一段代码又回到了 C。为了使这种穿越更加真实，驱动会将 T1 的一些属性赋给 T2，特别是 T1 的优先级，这样 T2 会使用和 T1 类似的时间完成任务。很多资料用＂线程迁移＂来形容这种现象，容易让人产生误解。一来线程根本不可能在进程之间跳来跳去，二来 T2 除了和 T1 优先级一样，其它没有相同之处，包括身份，打开文件，栈大小，信号处理，私有数据等。<br>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwg1226/article/details/107893816">https://blog.csdn.net/liuwg1226/article/details/107893816</a></p>
</blockquote>
<p>而如果当前Binder请求不是同步方式时，那么目标线程的优先级就无所谓了，这里设置成默认的。</p>
<p>8、binder_transaction.buffer：这是一个binder_buffer 结构体实例，代表了一块【Server端和Binder内核内存映射之后的】缓冲区域，该区域内可以用来存放来自发送方的数据，后面将发送方数据复制到这块儿区域之后，由于Server进程已经进行过内存映射，那么自然会在 Server侧直接访问到。这便是Binder 中所说的”一次复制”。</p>
<p>而这里给 buffer 赋值是通过 binder_alloc_new_buf() 方法来完成的，这里先关注下调用该方法时传入的参数：</p>
<ol>
<li>target_proc-&gt;alloc ：即这里传入的是目标进程信息binder_proc 中的 binder_alloc alloc ，即后续的内存块分配是在目标进程基础上操作的。简单说就是在目标进程内寻找内存来存放发送过来的数据。</li>
<li>tr-&gt;data_size ：发送方发送的数据大小。因为只有知道了数据大小，才好为其分配合适的内存空间来存储。</li>
<li>tr-&gt;offsets_size ： 和上面的data_size类似</li>
</ol>
<p>然后看看其代码逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> binder_buffer *<span class="title function_">binder_alloc_new_buf</span><span class="params">(<span class="keyword">struct</span> binder_alloc *alloc,</span></span><br><span class="line"><span class="params">					   <span class="type">size_t</span> data_size,</span></span><br><span class="line"><span class="params">					   <span class="type">size_t</span> offsets_size,</span></span><br><span class="line"><span class="params">					   <span class="type">size_t</span> extra_buffers_size,</span></span><br><span class="line"><span class="params">					   <span class="type">int</span> is_async)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;alloc-&gt;mutex);</span><br><span class="line">	buffer = binder_alloc_new_buf_locked(alloc, data_size, offsets_size,</span><br><span class="line">					     extra_buffers_size, is_async);</span><br><span class="line">	mutex_unlock(&amp;alloc-&gt;mutex);</span><br><span class="line">	<span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_buffer *<span class="title function_">binder_alloc_new_buf_locked</span><span class="params">(</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> binder_alloc *alloc,</span></span><br><span class="line"><span class="params">				<span class="type">size_t</span> data_size,</span></span><br><span class="line"><span class="params">				<span class="type">size_t</span> offsets_size,</span></span><br><span class="line"><span class="params">				<span class="type">size_t</span> extra_buffers_size,</span></span><br><span class="line"><span class="params">				<span class="type">int</span> is_async)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> =</span> alloc-&gt;free_buffers.rb_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">	<span class="type">size_t</span> buffer_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">best_fit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">void</span> __user *has_page_addr;</span><br><span class="line">	<span class="type">void</span> __user *end_page_addr;</span><br><span class="line">	<span class="type">size_t</span> size, data_offsets_size;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 下面首先是做入参的合法性判断</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!binder_alloc_get_vma(alloc)) &#123;</span><br><span class="line">		binder_alloc_debug(BINDER_DEBUG_USER_ERROR,</span><br><span class="line">				   <span class="string">&quot;%d: binder_alloc_buf, no vma\n&quot;</span>,</span><br><span class="line">				   alloc-&gt;pid);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ESRCH);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data_offsets_size = ALIGN(data_size, <span class="keyword">sizeof</span>(<span class="type">void</span> *)) +</span><br><span class="line">		ALIGN(offsets_size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data_offsets_size &lt; data_size || data_offsets_size &lt; offsets_size) &#123;</span><br><span class="line">		binder_alloc_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">				<span class="string">&quot;%d: got transaction with invalid size %zd-%zd\n&quot;</span>,</span><br><span class="line">				alloc-&gt;pid, data_size, offsets_size);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line">	size = data_offsets_size + ALIGN(extra_buffers_size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">	<span class="keyword">if</span> (size &lt; data_offsets_size || size &lt; extra_buffers_size) &#123;</span><br><span class="line">		binder_alloc_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">				<span class="string">&quot;%d: got transaction with invalid extra_buffers_size %zd\n&quot;</span>,</span><br><span class="line">				alloc-&gt;pid, extra_buffers_size);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (is_async &amp;&amp;</span><br><span class="line">	    alloc-&gt;free_async_space &lt; size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer)) &#123;</span><br><span class="line">		binder_alloc_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">			     <span class="string">&quot;%d: binder_alloc_buf size %zd failed, no async space left\n&quot;</span>,</span><br><span class="line">			      alloc-&gt;pid, size);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOSPC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Pad 0-size buffers so they get assigned unique addresses */</span></span><br><span class="line">	size = max(size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * n 是 alloc-&gt;free_buffers ，也就是之前在 binder_mmap 中分配的 buffer</span></span><br><span class="line"><span class="comment">	 * 遍历 free_buffers 中的内容，找到一个最合适大小的 buffer 来使用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		buffer = rb_entry(n, <span class="keyword">struct</span> binder_buffer, rb_node);</span><br><span class="line">		BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</span><br><span class="line">		<span class="comment">// 计算该 buffer 的大小</span></span><br><span class="line">		buffer_size = binder_alloc_buffer_size(alloc, buffer);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果需要的大小 size 小于当前遍历到的 buffer 的 size</span></span><br><span class="line"><span class="comment">		 * 那么这个 buffer 可能可以用，先将其存在 best_fit 中然后接着遍历</span></span><br><span class="line"><span class="comment">		 * 找不到更合适的话就用它，找到更合适的就用更合适的那个</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (size &lt; buffer_size) &#123;</span><br><span class="line">			best_fit = n;</span><br><span class="line">			n = n-&gt;rb_left;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; buffer_size) <span class="comment">// buffer 大小不足以 size 来使用</span></span><br><span class="line">			n = n-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span> &#123; </span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 如果 bufferSize 和 size 相等，则直接使用它</span></span><br><span class="line"><span class="comment">			 * 此时 n ！=NULL ， best_fit 也不等于NULL ，也就是说找到一模一样的size 时， 这俩都不是null</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			best_fit = n;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * best_fit == null 表示没有找到合适的 buffer 来存在 size 大小的数据</span></span><br><span class="line"><span class="comment">	 * 则直接返回吧，也就是当前内存不足以存下 size 大小的数据了</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 这里主要是打印日志，可以忽略</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (best_fit == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="type">size_t</span> allocated_buffers = <span class="number">0</span>;</span><br><span class="line">		<span class="type">size_t</span> largest_alloc_size = <span class="number">0</span>;</span><br><span class="line">		<span class="type">size_t</span> total_alloc_size = <span class="number">0</span>;</span><br><span class="line">		<span class="type">size_t</span> free_buffers = <span class="number">0</span>;</span><br><span class="line">		<span class="type">size_t</span> largest_free_size = <span class="number">0</span>;</span><br><span class="line">		<span class="type">size_t</span> total_free_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (n = rb_first(&amp;alloc-&gt;allocated_buffers); n != <span class="literal">NULL</span>;</span><br><span class="line">		     n = rb_next(n)) &#123;</span><br><span class="line">			buffer = rb_entry(n, <span class="keyword">struct</span> binder_buffer, rb_node);</span><br><span class="line">			buffer_size = binder_alloc_buffer_size(alloc, buffer);</span><br><span class="line">			allocated_buffers++;</span><br><span class="line">			total_alloc_size += buffer_size;</span><br><span class="line">			<span class="keyword">if</span> (buffer_size &gt; largest_alloc_size)</span><br><span class="line">				largest_alloc_size = buffer_size;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (n = rb_first(&amp;alloc-&gt;free_buffers); n != <span class="literal">NULL</span>;</span><br><span class="line">		     n = rb_next(n)) &#123;</span><br><span class="line">			buffer = rb_entry(n, <span class="keyword">struct</span> binder_buffer, rb_node);</span><br><span class="line">			buffer_size = binder_alloc_buffer_size(alloc, buffer);</span><br><span class="line">			free_buffers++;</span><br><span class="line">			total_free_size += buffer_size;</span><br><span class="line">			<span class="keyword">if</span> (buffer_size &gt; largest_free_size)</span><br><span class="line">				largest_free_size = buffer_size;</span><br><span class="line">		&#125;</span><br><span class="line">		binder_alloc_debug(BINDER_DEBUG_USER_ERROR,</span><br><span class="line">				   <span class="string">&quot;%d: binder_alloc_buf size %zd failed, no address space\n&quot;</span>,</span><br><span class="line">				   alloc-&gt;pid, size);</span><br><span class="line">		binder_alloc_debug(BINDER_DEBUG_USER_ERROR,</span><br><span class="line">				   <span class="string">&quot;allocated: %zd (num: %zd largest: %zd), free: %zd (num: %zd largest: %zd)\n&quot;</span>,</span><br><span class="line">				   total_alloc_size, allocated_buffers,</span><br><span class="line">				   largest_alloc_size, total_free_size,</span><br><span class="line">				   free_buffers, largest_free_size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOSPC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 到这里的话，best_fit肯定就不是 NULL 了。</span></span><br><span class="line"><span class="comment">	 * 而此时 n=null，表示 alloc-&gt;free_buffers 树遍历完了</span></span><br><span class="line"><span class="comment">	 * 所以如果进入到if条件体内的话表示：此时是 n==null &amp;&amp; best_fit!=null</span></span><br><span class="line"><span class="comment">	 * 此时 best_fit 对应的 buffer 的 size 肯定是大于要求的 size 的。</span></span><br><span class="line"><span class="comment">	 * （因为如果是等于的话在上面遍历时可知 n肯定不等于null，即会是：  best_fit = n != null）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		buffer = rb_entry(best_fit, <span class="keyword">struct</span> binder_buffer, rb_node);</span><br><span class="line">		buffer_size = binder_alloc_buffer_size(alloc, buffer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 由上面可知： buffer_size 是大于等于 size 的。</span></span><br><span class="line"><span class="comment">	 * 如果上面遍历 alloc-&gt;free_buffers 时找到了一模一样大小的buffer 时，则两者相等</span></span><br><span class="line"><span class="comment">	 * 否则就是 buffer_size 大于 size</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	has_page_addr = (<span class="type">void</span> __user *)</span><br><span class="line">		(((<span class="type">uintptr_t</span>)buffer-&gt;user_data + buffer_size) &amp; PAGE_MASK);</span><br><span class="line">	WARN_ON(n &amp;&amp; buffer_size != size);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * https://blog.csdn.net/prike/article/details/73369063</span></span><br><span class="line"><span class="comment">	 * PAGE_ALIGN 页对齐</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	end_page_addr =</span><br><span class="line">		(<span class="type">void</span> __user *)PAGE_ALIGN((<span class="type">uintptr_t</span>)buffer-&gt;user_data + size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end_page_addr &gt; has_page_addr)</span><br><span class="line">		end_page_addr = has_page_addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 内部申请物理内存，并做内存映射</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = binder_update_page_range(alloc, <span class="number">1</span>, (<span class="type">void</span> __user *)</span><br><span class="line">		PAGE_ALIGN((<span class="type">uintptr_t</span>)buffer-&gt;user_data), end_page_addr);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (buffer_size != size) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">new_buffer</span>;</span></span><br><span class="line"></span><br><span class="line">		new_buffer = kzalloc(<span class="keyword">sizeof</span>(*buffer), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!new_buffer) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;%s: %d failed to alloc new buffer struct\n&quot;</span>,</span><br><span class="line">			       __func__, alloc-&gt;pid);</span><br><span class="line">			<span class="keyword">goto</span> err_alloc_buf_struct_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		new_buffer-&gt;user_data = (u8 __user *)buffer-&gt;user_data + size;</span><br><span class="line">		list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);</span><br><span class="line">		new_buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 将 new_buffer 插入到 alloc-&gt;free_buffers 树中</span></span><br><span class="line">		binder_insert_free_buffer(alloc, new_buffer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rb_erase(best_fit, &amp;alloc-&gt;free_buffers);</span><br><span class="line">	buffer-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">	buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将 new_buffer 作为一个节点插入到 alloc-&gt;allocated_buffers 树中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	binder_insert_allocated_buffer_locked(alloc, buffer);</span><br><span class="line">	binder_alloc_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">		     <span class="string">&quot;%d: binder_alloc_buf size %zd got %pK\n&quot;</span>,</span><br><span class="line">		      alloc-&gt;pid, size, buffer);</span><br><span class="line">	buffer-&gt;data_size = data_size;</span><br><span class="line">	buffer-&gt;offsets_size = offsets_size;</span><br><span class="line">	buffer-&gt;async_transaction = is_async;</span><br><span class="line">	buffer-&gt;extra_buffers_size = extra_buffers_size;</span><br><span class="line">	<span class="keyword">if</span> (is_async) &#123;</span><br><span class="line">		alloc-&gt;free_async_space -= size + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_buffer);</span><br><span class="line">		binder_alloc_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</span><br><span class="line">			     <span class="string">&quot;%d: binder_alloc_buf size %zd async free %zd\n&quot;</span>,</span><br><span class="line">			      alloc-&gt;pid, size, alloc-&gt;free_async_space);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buffer;</span><br><span class="line"></span><br><span class="line">err_alloc_buf_struct_failed:</span><br><span class="line">	binder_update_page_range(alloc, <span class="number">0</span>, (<span class="type">void</span> __user *)</span><br><span class="line">				 PAGE_ALIGN((<span class="type">uintptr_t</span>)buffer-&gt;user_data),</span><br><span class="line">				 end_page_addr);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_update_page_range</span><span class="params">(<span class="keyword">struct</span> binder_alloc *alloc, <span class="type">int</span> allocate,</span></span><br><span class="line"><span class="params">				    <span class="type">void</span> __user *start, <span class="type">void</span> __user *end)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> __user *page_addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> user_page_addr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_lru_page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> need_mm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 合法性判断</span></span><br><span class="line">	<span class="keyword">if</span> (end &lt;= start)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (allocate == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_range;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从之前 binder_mmap 时申请的物理内存页数组中寻找一个页来存储数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">		page = &amp;alloc-&gt;pages[(page_addr - alloc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line">		<span class="keyword">if</span> (!page-&gt;page_ptr) &#123;</span><br><span class="line">			need_mm = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (need_mm &amp;&amp; mmget_not_zero(alloc-&gt;vma_vm_mm))</span><br><span class="line">		mm = alloc-&gt;vma_vm_mm;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		vma = alloc-&gt;vma;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!vma &amp;&amp; need_mm) &#123;</span><br><span class="line">		binder_alloc_debug(BINDER_DEBUG_USER_ERROR,</span><br><span class="line">				   <span class="string">&quot;%d: binder_alloc_buf failed to map pages in userspace, no vma\n&quot;</span>,</span><br><span class="line">				   alloc-&gt;pid);</span><br><span class="line">		<span class="keyword">goto</span> err_no_vma;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 再重新开始一次</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line">		<span class="type">bool</span> on_lru;</span><br><span class="line">		<span class="type">size_t</span> index;</span><br><span class="line">		<span class="comment">// 求出当前遍历到的页索引</span></span><br><span class="line">		index = (page_addr - alloc-&gt;buffer) / PAGE_SIZE;</span><br><span class="line">		page = &amp;alloc-&gt;pages[index];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 遇到一个 已经分配过内存 的页时，就将其从全局 binder_alloc_lru 列表中删除</span></span><br><span class="line"><span class="comment">		 * 然后接着循环下一个页</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (page-&gt;page_ptr) &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * binder_alloc_lru 是全局定义的</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			on_lru = list_lru_del(&amp;binder_alloc_lru, &amp;page-&gt;lru);</span><br><span class="line">			WARN_ON(!on_lru);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(!vma))</span><br><span class="line">			<span class="keyword">goto</span> err_page_ptr_cleared;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 分配一个物理页内存，然后使用 page-&gt;page_ptr 指向它</span></span><br><span class="line"><span class="comment">		 * https://deepinout.com/linux-kernel-api/linux-kernel-api-memory-management/linux-kernel-api-alloc_pages.html</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		page-&gt;page_ptr = alloc_page(GFP_KERNEL |</span><br><span class="line">					    __GFP_HIGHMEM |</span><br><span class="line">					    __GFP_ZERO);</span><br><span class="line">		<span class="keyword">if</span> (!page-&gt;page_ptr) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;%d: binder_alloc_buf failed for page at %pK\n&quot;</span>,</span><br><span class="line">				alloc-&gt;pid, page_addr);</span><br><span class="line">			<span class="keyword">goto</span> err_alloc_page_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		page-&gt;alloc = alloc;</span><br><span class="line">		INIT_LIST_HEAD(&amp;page-&gt;lru);</span><br><span class="line"></span><br><span class="line">		user_page_addr = (<span class="type">uintptr_t</span>)page_addr;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 将 vma 内存映射到该 page 对应的物理内存上去</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * https://blog.csdn.net/hexiaolong2009/article/details/107592704 : 中的示例二</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>].page_ptr);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;%d: binder_alloc_buf failed to map page at %lx in userspace\n&quot;</span>,</span><br><span class="line">			       alloc-&gt;pid, user_page_addr);</span><br><span class="line">			<span class="keyword">goto</span> err_vm_insert_page_failed;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (index + <span class="number">1</span> &gt; alloc-&gt;pages_high)</span><br><span class="line">			alloc-&gt;pages_high = index + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		mmput(mm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">free_range:</span><br><span class="line">	<span class="keyword">for</span> (page_addr = end - PAGE_SIZE; <span class="number">1</span>; page_addr -= PAGE_SIZE) &#123;</span><br><span class="line">		<span class="type">bool</span> ret;</span><br><span class="line">		<span class="type">size_t</span> index;</span><br><span class="line"></span><br><span class="line">		index = (page_addr - alloc-&gt;buffer) / PAGE_SIZE;</span><br><span class="line">		page = &amp;alloc-&gt;pages[index];</span><br><span class="line"></span><br><span class="line">		trace_binder_free_lru_start(alloc, index);</span><br><span class="line"></span><br><span class="line">		ret = list_lru_add(&amp;binder_alloc_lru, &amp;page-&gt;lru);</span><br><span class="line">		WARN_ON(!ret);</span><br><span class="line"></span><br><span class="line">		trace_binder_free_lru_end(alloc, index);</span><br><span class="line">		<span class="keyword">if</span> (page_addr == start)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">err_vm_insert_page_failed:</span><br><span class="line">		__free_page(page-&gt;page_ptr);</span><br><span class="line">		page-&gt;page_ptr = <span class="literal">NULL</span>;</span><br><span class="line">err_alloc_page_failed:</span><br><span class="line">err_page_ptr_cleared:</span><br><span class="line">		<span class="keyword">if</span> (page_addr == start)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">err_no_vma:</span><br><span class="line">	<span class="keyword">if</span> (mm) &#123;</span><br><span class="line">		up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		mmput(mm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vma ? -ENOMEM : -ESRCH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，首先根据传入的数据大小，来从 target_proc-&gt;alloc-&gt;free_buffers 红黑树中查找出一个合适大小的 binder_buffer 来使用，所谓合适的其实就是找到一个大于等于dataSize 的最小 buffer 来使用。</p>
<p>然后再调用 binder_update_page_range() 方法来从物理内存页中找到一个页来进行内存映射工作，即此时才完成：接收方进程和Binder内核的内存映射工作。</p>
<p>而之前的binder_mmap 只是记录下来内存地址而已，实际的映射工作是在这里完成的。</p>
<blockquote>
<p>有点类似这篇文章中的示例二：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hexiaolong2009/article/details/107592704">https://blog.csdn.net/hexiaolong2009/article/details/107592704</a></p>
</blockquote>
<p>至此，就会完成：目标进程和Binder 内核的内存映射工作，并且是只映射了一块儿够存储当前发送数据的空间。后续就可以将发送端的数据从用户空间复制到内核空间的该buffer区域内，然后自然映射到接收方进程中去访问。</p>
<p>接着给 buffer-&gt;transaction 赋值为当前 t，给 buffer-&gt;target_node 赋值为当前 target_node 以供后续使用。</p>
<p>最后一步就是完成发送方数据的赋值了，因为上面的buffer已经准备好了，可以存放来自发送方进程的数据了，因此此时调用了两次 binder_alloc_copy_user_to_buffer() 方法来将 tr-&gt;data.ptr.buffer 和 tr-&gt;data.ptr.offets 中的数据赋值到上面刚分配好的buffer 中去。</p>
<p>这一步便完成了Binder 中所说的“一次复制”的逻辑。之前 tr 中存储的都是数据的地址，这里才真正完成了数据复制。</p>
<p>而由于 buffer 对应的地址是接收方进程和 Binder 内核内存映射之后的，所以此时相当于数据直接从发送方进程复制到了接收方进程。接收方进程此时可以读取到这些数据了。</p>
<h6 id="3-处理发送数据中的flat-binder-object"><a href="#3-处理发送数据中的flat-binder-object" class="headerlink" title="3.处理发送数据中的flat_binder_object"></a>3.处理发送数据中的flat_binder_object</h6><p>前面讲过，在 BpServiceManager 中调用 addService() 方法添加一个服务实体 BBinder 时，会调用 Parcel::writeStrongBinder() 方法来将这个BBinder 实例写入到Parcel中然后通过ioctl()方法传送到Binder内核中。在BBinder写入Parcel时，是将其转换为 flat_binder_object 结构体实例之后再写入的。</p>
<blockquote>
<p>详见：Parcel.cpp # flatten_binder() ，当然这里不止是写入 BBinder ，还会写入 BpBinder 。</p>
<p>写入BBinder 时，flat_binder_object.hdr.type&#x3D;BINDER_TYPE_BINDER ，并且额外的其 flat_binder_object.binder 和 flat_binder_object.cookie 会保存记录BBinder 的内存地址值。后续通过它来访问到这个 BBinder 实例，从而调用其 transact() 方法</p>
<p>写入BpBinder时，flat_binder_object.hdr.type&#x3D;BINDER_TYPE_HANDLE ，并且额外的其 flat_binder_object.handle 会保存对应发起请求的BpBinder 中的handle值，比如BpServiceManager其内部BpBinder的handle值是0；</p>
<p>具体代码分析详见前面文章</p>
</blockquote>
<p>接下来先看看第三步是怎么读取处理这些flat_binder_object的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> binder_transaction_data *tr, <span class="type">int</span> reply,</span></span><br><span class="line"><span class="params">			       <span class="type">binder_size_t</span> extra_buffers_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 省略第一、二步的代码</span></span><br><span class="line"></span><br><span class="line">	off_start_offset = ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">	buffer_offset = off_start_offset;</span><br><span class="line"></span><br><span class="line">	off_end_offset = off_start_offset + tr-&gt;offsets_size;</span><br><span class="line">	sg_buf_offset = ALIGN(off_end_offset, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">	sg_buf_end_offset = sg_buf_offset + extra_buffers_size -</span><br><span class="line">		ALIGN(secctx_sz, <span class="keyword">sizeof</span>(u64));</span><br><span class="line">	off_min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理 flat_binder_object 结构体</span></span><br><span class="line"><span class="comment">	 * 遍历偏移数组区间，找出其中的每一个flat_binder_object对象（Binder在传输数据中的表现形式）并生成相</span></span><br><span class="line"><span class="comment">	 * 应的binder_ref 或 binder_node，然后分别添加到引用树（refs）或者节点树(nodes)中．</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (buffer_offset = off_start_offset; buffer_offset &lt; off_end_offset;</span><br><span class="line">	     buffer_offset += <span class="keyword">sizeof</span>(<span class="type">binder_size_t</span>)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> *<span class="title">hdr</span>;</span></span><br><span class="line">		<span class="type">size_t</span> object_size;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> <span class="title">object</span>;</span></span><br><span class="line">		<span class="type">binder_size_t</span> object_offset;</span><br><span class="line"></span><br><span class="line">		binder_alloc_copy_from_buffer(&amp;target_proc-&gt;alloc,</span><br><span class="line">					      &amp;object_offset,</span><br><span class="line">					      t-&gt;buffer,</span><br><span class="line">					      buffer_offset,</span><br><span class="line">					      <span class="keyword">sizeof</span>(object_offset));</span><br><span class="line"></span><br><span class="line">		object_size = binder_get_object(target_proc, t-&gt;buffer,</span><br><span class="line">						object_offset, &amp;object);</span><br><span class="line">		<span class="keyword">if</span> (object_size == <span class="number">0</span> || object_offset &lt; off_min) &#123;</span><br><span class="line">			binder_user_error(<span class="string">&quot;%d:%d got transaction with invalid offset (%lld, min %lld max %lld) or object.\n&quot;</span>,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">					  (u64)object_offset,</span><br><span class="line">					  (u64)off_min,</span><br><span class="line">					  (u64)t-&gt;buffer-&gt;data_size);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		hdr = &amp;object.hdr;</span><br><span class="line">		off_min = object_offset + object_size;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 读取 Parcel 传递过来的 binder 类型</span></span><br><span class="line"><span class="comment">		 * 比如 BINDER_TYPE_WEAK_BINDER 或者  BINDER_TYPE_WEAK_HANDLE、</span></span><br><span class="line"><span class="comment">		 * 这俩分别表示内部存储的是啥类型的数据，</span></span><br><span class="line"><span class="comment">		 * 如果是 BINDER_TYPE_WEAK_BINDER ： obj.binder 和 obj.cookie 存储着对应的值</span></span><br><span class="line"><span class="comment">		 * 如果是 BINDER_TYPE_WEAK_HANDLE、 ： obj.binder 和 obj.cookie 都是0 ，</span></span><br><span class="line"><span class="comment">		 * - 而 obj.handle 存储着对应的 handle 值，比如 handle =0 表示的是 SM</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 比如从 main_mediaserver.cpp#main -&gt; MediaPlayerService.cpp#instantiate 中过来的</span></span><br><span class="line"><span class="comment">		 * 其添加的 MediaPlayerService ，它的继承关系如下：</span></span><br><span class="line"><span class="comment">		 * BnMediaPlayerService -&gt; BnInterface&lt;IMediaPlayerService&gt; -&gt; BBinder -&gt; IBinder</span></span><br><span class="line"><span class="comment">		 * 在 IServiceManager.cpp#addService 方法中调用 Parcel.writeStrongBinder 方法时，</span></span><br><span class="line"><span class="comment">		 * 会最终写入 hdr.type</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 通过 hdr 的地址，而 hdr 是 flat_binder_object 中的一个属性</span></span><br><span class="line"><span class="comment">			 * 所以可以通过 hdr 来拿到其对应的 flat_binder_object 实例</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 也就是写入的 binder 实例，比如从 main_mediaserver.cpp#main -&gt; MediaPlayerService.cpp#instantiate 中过来的</span></span><br><span class="line"><span class="comment">			 * 这里写入的 binder 实例 flat_binder_object 对象，也就是存储着 MediaPlayerService 的信息</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 而此时 binder_translate_binder 方法内部会通过 fp-&gt;binder 也就是 MediaPlayerService 的信息</span></span><br><span class="line"><span class="comment">			 * 来查找此时是否存在对应的node，没有的话则创建，并为其在 service manager 中创建一个 binder_ref</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			fp = to_flat_binder_object(hdr);</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 第一次时，在当前进程创建 binder_node 和目标进程创建 binder_ref </span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			ret = binder_translate_binder(fp, t, thread);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = ret;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 上面 binder_translate_binder 方法内部会修改 fp 的类型，以及内部的 handle 、binder、cookie</span></span><br><span class="line"><span class="comment">			 * 所以这里将新的 fp 数据赋值到 t-&gt;buffer 中去</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			binder_alloc_copy_to_buffer(&amp;target_proc-&gt;alloc,</span><br><span class="line">						    t-&gt;buffer, object_offset,</span><br><span class="line">						    fp, <span class="keyword">sizeof</span>(*fp));</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">			fp = to_flat_binder_object(hdr);</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 通过传递过来的 handle 值来查找其对应的 node 信息</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			ret = binder_translate_handle(fp, t, thread);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = ret;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 面 binder_translate_handle 方法内部会修改 fp 的类型，以及内部的 handle 、binder、cookie</span></span><br><span class="line"><span class="comment">			 * 所以这里将新的 fp 数据赋值到 t-&gt;buffer 中去</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			binder_alloc_copy_to_buffer(&amp;target_proc-&gt;alloc,</span><br><span class="line">						    t-&gt;buffer, object_offset,</span><br><span class="line">						    fp, <span class="keyword">sizeof</span>(*fp));</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_FD: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_fd_object</span> *<span class="title">fp</span> =</span> to_binder_fd_object(hdr);</span><br><span class="line">			<span class="type">int</span> target_fd = binder_translate_fd(fp-&gt;fd, t, thread,</span><br><span class="line">							    in_reply_to);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (target_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = target_fd;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">			&#125;</span><br><span class="line">			fp-&gt;pad_binder = <span class="number">0</span>;</span><br><span class="line">			fp-&gt;fd = target_fd;</span><br><span class="line">			binder_alloc_copy_to_buffer(&amp;target_proc-&gt;alloc,</span><br><span class="line">						    t-&gt;buffer, object_offset,</span><br><span class="line">						    fp, <span class="keyword">sizeof</span>(*fp));</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_FDA: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> <span class="title">ptr_object</span>;</span></span><br><span class="line">			<span class="type">binder_size_t</span> parent_offset;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_fd_array_object</span> *<span class="title">fda</span> =</span></span><br><span class="line">				to_binder_fd_array_object(hdr);</span><br><span class="line">			<span class="type">size_t</span> num_valid = (buffer_offset - off_start_offset) /</span><br><span class="line">						<span class="keyword">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer_object</span> *<span class="title">parent</span> =</span></span><br><span class="line">				binder_validate_ptr(target_proc, t-&gt;buffer,</span><br><span class="line">						    &amp;ptr_object, fda-&gt;parent,</span><br><span class="line">						    off_start_offset,</span><br><span class="line">						    &amp;parent_offset,</span><br><span class="line">						    num_valid);</span><br><span class="line">			<span class="keyword">if</span> (!parent) &#123;</span><br><span class="line">				binder_user_error(<span class="string">&quot;%d:%d got transaction with invalid parent offset or type\n&quot;</span>,</span><br><span class="line">						  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = -EINVAL;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_bad_parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!binder_validate_fixup(target_proc, t-&gt;buffer,</span><br><span class="line">						   off_start_offset,</span><br><span class="line">						   parent_offset,</span><br><span class="line">						   fda-&gt;parent_offset,</span><br><span class="line">						   last_fixup_obj_off,</span><br><span class="line">						   last_fixup_min_off)) &#123;</span><br><span class="line">				binder_user_error(<span class="string">&quot;%d:%d got transaction with out-of-order buffer fixup\n&quot;</span>,</span><br><span class="line">						  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = -EINVAL;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_bad_parent;</span><br><span class="line">			&#125;</span><br><span class="line">			ret = binder_translate_fd_array(fda, parent, t, thread,</span><br><span class="line">							in_reply_to);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = ret;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">			&#125;</span><br><span class="line">			last_fixup_obj_off = parent_offset;</span><br><span class="line">			last_fixup_min_off =</span><br><span class="line">				fda-&gt;parent_offset + <span class="keyword">sizeof</span>(u32) * fda-&gt;num_fds;</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_PTR: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer_object</span> *<span class="title">bp</span> =</span></span><br><span class="line">				to_binder_buffer_object(hdr);</span><br><span class="line">			<span class="type">size_t</span> buf_left = sg_buf_end_offset - sg_buf_offset;</span><br><span class="line">			<span class="type">size_t</span> num_valid;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (bp-&gt;length &gt; buf_left) &#123;</span><br><span class="line">				binder_user_error(<span class="string">&quot;%d:%d got transaction with too large buffer\n&quot;</span>,</span><br><span class="line">						  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = -EINVAL;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (binder_alloc_copy_user_to_buffer(</span><br><span class="line">						&amp;target_proc-&gt;alloc,</span><br><span class="line">						t-&gt;buffer,</span><br><span class="line">						sg_buf_offset,</span><br><span class="line">						(<span class="type">const</span> <span class="type">void</span> __user *)</span><br><span class="line">							(<span class="type">uintptr_t</span>)bp-&gt;buffer,</span><br><span class="line">						bp-&gt;length)) &#123;</span><br><span class="line">				binder_user_error(<span class="string">&quot;%d:%d got transaction with invalid offsets ptr\n&quot;</span>,</span><br><span class="line">						  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">				return_error_param = -EFAULT;</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* Fixup buffer pointer to target proc address space */</span></span><br><span class="line">			bp-&gt;buffer = (<span class="type">uintptr_t</span>)</span><br><span class="line">				t-&gt;buffer-&gt;user_data + sg_buf_offset;</span><br><span class="line">			sg_buf_offset += ALIGN(bp-&gt;length, <span class="keyword">sizeof</span>(u64));</span><br><span class="line"></span><br><span class="line">			num_valid = (buffer_offset - off_start_offset) /</span><br><span class="line">					<span class="keyword">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">			ret = binder_fixup_parent(t, thread, bp,</span><br><span class="line">						  off_start_offset,</span><br><span class="line">						  num_valid,</span><br><span class="line">						  last_fixup_obj_off,</span><br><span class="line">						  last_fixup_min_off);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				return_error = BR_FAILED_REPLY;</span><br><span class="line">				return_error_param = ret;</span><br><span class="line">				return_error_line = __LINE__;</span><br><span class="line">				<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">			&#125;</span><br><span class="line">			binder_alloc_copy_to_buffer(&amp;target_proc-&gt;alloc,</span><br><span class="line">						    t-&gt;buffer, object_offset,</span><br><span class="line">						    bp, <span class="keyword">sizeof</span>(*bp));</span><br><span class="line">			last_fixup_obj_off = object_offset;</span><br><span class="line">			last_fixup_min_off = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			binder_user_error(<span class="string">&quot;%d:%d got transaction with invalid object type, %x\n&quot;</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid, hdr-&gt;type);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_bad_object_type;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * tcomplete 是上面创建出来的 binder_work 实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * t 是上面新创建出来的 binder_transaction 实例</span></span><br><span class="line"><span class="comment">	 * 这里则是修改其 work.type 为 BINDER_WORK_TRANSACTION </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略后续第四步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，主要是在一个for循环内进行 flat_binder_object 的读取和处理。</p>
<p>而在正式读取 flat_binder_object 之前，先读取出 binder_object_header ，这样的话就从这个 binder_object_header.type 知道这个flat_binder_object 是什么类型了，是Binder 实体BBinder 还是Binder代理BpBinder ? 这俩分别对应 type&#x3D;BINDER_TYPE_BINDER 和 type&#x3D;BINDER_TYPE_HANDLE 。</p>
<p>接着就是根据type值来进行switch case 操作了。</p>
<p>而 type 的取值较多，这里只分析最常见的 BINDER_TYPE_BINDER 和 BINDER_TYPE_HANDLE。</p>
<p>1、BINDER_TYPE_BINDER：首先都是通过 to_flat_binder_object(hdr) 方法来获得 flat_binder_object实例 fp。然后调用 binder_translate_binder() 方法来进行 binder_node 和binder_ref 的创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_translate_binder</span><span class="params">(<span class="keyword">struct</span> flat_binder_object *fp,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> binder_transaction *t,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当前进程信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> thread-&gt;proc;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 在前面  t-&gt;to_proc 中就已经保存了 target_proc ,即目标进程信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> =</span> t-&gt;to_proc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> <span class="title">rdata</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从【当前进程】中查找 fp-&gt;binder ，也就是从 proc-&gt;nodes 中查找 ptr 对应的 node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">	<span class="keyword">if</span> (!node) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 没找着的话，则新建一个并插入到【当前进程】 proc-&gt;nodes 中</span></span><br><span class="line"><span class="comment">		 * 表示这是第一次在 Binder 通信中传输 Binder，所以为 BBinder 创建 binder_node 实例</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		node = binder_new_node(proc, fp);</span><br><span class="line">		<span class="keyword">if</span> (!node)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) &#123;</span><br><span class="line">		binder_user_error(<span class="string">&quot;%d:%d sending u%016llx node %d, cookie mismatch %016llx != %016llx\n&quot;</span>,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid, (u64)fp-&gt;binder,</span><br><span class="line">				  node-&gt;debug_id, (u64)fp-&gt;cookie,</span><br><span class="line">				  (u64)node-&gt;cookie);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 安全检查</span></span><br><span class="line">	<span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;cred, target_proc-&gt;cred)) &#123;</span><br><span class="line">		ret = -EPERM;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 内部自增 proc-&gt;refs_by_node 中该 node 对应的 binder_ref 上的引用数</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 【注意：此时传入的是 target_proc 哦！！！】</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 比如从 main_mediaserver.cpp#main -&gt; MediaPlayerService.cpp#instantiate 中过来的</span></span><br><span class="line"><span class="comment">	 * 那么此时 target_proc 代表的就是 service manager 的进程信息，也就是在 sm 进程中为该 binder </span></span><br><span class="line"><span class="comment">	 * 创建一个 binder_ref 。也就是说对于同一个 binder_node，每个进程只会创建一个binder_ref对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 在目标进程内找到binder_node对应的binder_ref,如果未找到，则在目标进程内创建binder_ref，并返回</span></span><br><span class="line"><span class="comment">	 * 所以说对比上面的创建 binder_node 的操作： binder_new_node(proc, fp)</span></span><br><span class="line"><span class="comment">	 * 可以理解：在binder实体自身的进程存在 binder_node 来代表一个binder 实体，而在其他进程都是存在 binder_ref 实例</span></span><br><span class="line"><span class="comment">	 * 来指向这个 binder_node</span></span><br><span class="line"><span class="comment">	 * 在 binder_inc_ref_for_node 内部，会在创建 binder_ref 时，将当前进程的 binder_node 赋值给 binder_ref.node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">			fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">			&amp;thread-&gt;todo, &amp;rdata);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 此时将 BINDER_TYPE_BINDER 类型统一转成 BINDER_TYPE_HANDLE</span></span><br><span class="line"><span class="comment">	 * 因为对于 BINDER_TYPE_BINDER 类型时，内部会创建 binder_node ，并且保存其 binder 和 cookie</span></span><br><span class="line"><span class="comment">	 * 并创建对应的 binder_ref ，为其分配 desc 值(handle)并且插入到对应的红黑树中</span></span><br><span class="line"><span class="comment">	 * 那么后续就可以通过 handle 来查找对应的 binder_ref 了，只需要保存 handle 就可以了</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 把 binder 地址保存在当前进程红黑树中就行了，这个地址传给目标进程没啥意义，因为地址都不能直接用</span></span><br><span class="line"><span class="comment">	 * 所以就只传递 handle 值就行了，后面通过handle 值在当前进程红黑树中查找就行了</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * A 进程的binder 地址只会保存在 A进程的 node 树中，发给B进程的就只是 handle 值，</span></span><br><span class="line"><span class="comment">	 * 通过该handle 值可以后续在 B 进程的 binder_ref 树中找到对应的 binder_ref ,</span></span><br><span class="line"><span class="comment">	 * 然后通过 binder_ref 的 node 找到对应的 binder_node ,也就是A进程中的binder 地址</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">		fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">	<span class="comment">// 将 binder 和 cookie 置为 0 ，因为 BINDER_TYPE_BINDER 类型时，binder 和 cookie 不为null</span></span><br><span class="line">	fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">	fp-&gt;handle = rdata.desc;</span><br><span class="line">	fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	binder_put_node(node);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看看入参的含义：</p>
<ol>
<li>flat_binder_object *fp ：刚从发送方数据中读取出来的flat_binder_object实例，此时其type&#x3D;BINDER_TYPE_BINDER。</li>
<li>binder_transaction *t ：上面第二步刚创建出来的实例，内部的绝大多数属性都已经被赋值了。</li>
<li>binder_thread *thread：当前发起方线程信息binder_thread 实例。</li>
</ol>
<p>接着看当前方法，进入当前方法后，首先通过入参拿到当前发起方进程信息proc 和 接收方进程信息 target_proc。</p>
<p>然后调用 binder_get_node() 方法来获取当前进程中指定handle值的binder_node 实例。因为传入的两个参数分别是：1）proc表示当前进程信息；2）fp-&gt;binder表示当前BBinder实例(内部引用计数类实例的地址)。因为当前fp 的type&#x3D;BINDER_TYPE_BINDER，所以其 binder 和 cookie 字段存储了BBindder对象实例的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_node *<span class="title function_">binder_get_node</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">					   <span class="type">binder_uintptr_t</span> ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	node = binder_get_node_ilocked(proc, ptr);</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_node *<span class="title function_">binder_get_node_ilocked</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">						   <span class="type">binder_uintptr_t</span> ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> =</span> proc-&gt;nodes.rb_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">	assert_spin_locked(&amp;proc-&gt;inner_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		node = rb_entry(n, <span class="keyword">struct</span> binder_node, rb_node);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ptr &lt; node-&gt;ptr)</span><br><span class="line">			n = n-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)</span><br><span class="line">			n = n-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * take an implicit weak reference</span></span><br><span class="line"><span class="comment">			 * to ensure node stays alive until</span></span><br><span class="line"><span class="comment">			 * call to binder_put_node()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			binder_inc_node_tmpref_ilocked(node);</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，binder_get_node() 方法中实际是从 binder_proc.nodes 红黑树中查找 fp-&gt;binder 对应的binder_node 实例，如果找到表示其之前就在当前进程存在，那么自增下引用数即可；没找到则返回NULL。如果是第一次的话，则一般是返回NULL。</p>
<p>如果binder_get_node()没找到该fp-&gt;binder 对应的binder_node 时，表示其BBinder在当前进程中是第一次传输，此时需要为其增加一个binder_node 实例，即调用binder_new_node() 方法来创建一个binder_node实例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_node *<span class="title function_">binder_new_node</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">					   <span class="keyword">struct</span> flat_binder_object *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="comment">// 创建一个 new_node </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">new_node</span> =</span> kzalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!new_node)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将上面创建出来的 new_node 插入到 proc-&gt;nodes 树中合适的位置上去，</span></span><br><span class="line"><span class="comment">	 * 并且初始化 new_node 中的其他属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	node = binder_init_node_ilocked(proc, new_node, fp);</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">	<span class="keyword">if</span> (node != new_node)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The node was already added by another thread</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		kfree(new_node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_node *<span class="title function_">binder_init_node_ilocked</span><span class="params">(</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> binder_node *new_node,</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> flat_binder_object *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;proc-&gt;nodes.rb_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将 flat_binder_object 中的 binder 和 cookie 后续会保存到 new_node 中</span></span><br><span class="line"><span class="comment">	 * 而这里的 flat_binder_object 中存储的就是binder 发起方设置的信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">binder_uintptr_t</span> ptr = fp ? fp-&gt;binder : <span class="number">0</span>;</span><br><span class="line">	<span class="type">binder_uintptr_t</span> cookie = fp ? fp-&gt;cookie : <span class="number">0</span>;</span><br><span class="line">	__u32 flags = fp ? fp-&gt;flags : <span class="number">0</span>;</span><br><span class="line">	s8 priority;</span><br><span class="line"></span><br><span class="line">	assert_spin_locked(&amp;proc-&gt;inner_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 先找一遍看是否存在该 node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (*p) &#123;</span><br><span class="line"></span><br><span class="line">		parent = *p;</span><br><span class="line">		node = rb_entry(parent, <span class="keyword">struct</span> binder_node, rb_node);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ptr &lt; node-&gt;ptr)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * A matching node is already in</span></span><br><span class="line"><span class="comment">			 * the rb tree. Abandon the init</span></span><br><span class="line"><span class="comment">			 * and return it.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			binder_inc_node_tmpref_ilocked(node);</span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 不存在的话才使用 new_node ,也就是要插入 proc-&gt;nodes 的 binder_node 实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	node = new_node;</span><br><span class="line">	binder_stats_created(BINDER_STAT_NODE);</span><br><span class="line">	node-&gt;tmp_refs++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将新的 node 插入到 proc-&gt;nodes.rb_node 树中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rb_link_node(&amp;node-&gt;rb_node, parent, p);</span><br><span class="line">	rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 node 中的属性</span></span><br><span class="line">	node-&gt;debug_id = atomic_inc_return(&amp;binder_last_id);</span><br><span class="line">	node-&gt;proc = proc;</span><br><span class="line">	node-&gt;ptr = ptr;</span><br><span class="line">	node-&gt;cookie = cookie;</span><br><span class="line">	node-&gt;work.type = BINDER_WORK_NODE;</span><br><span class="line">	priority = flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</span><br><span class="line">	node-&gt;sched_policy = (flags &amp; FLAT_BINDER_FLAG_SCHED_POLICY_MASK) &gt;&gt;</span><br><span class="line">		FLAT_BINDER_FLAG_SCHED_POLICY_SHIFT;</span><br><span class="line">	node-&gt;min_priority = to_kernel_prio(node-&gt;sched_policy, priority);</span><br><span class="line">	node-&gt;accept_fds = !!(flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</span><br><span class="line">	node-&gt;inherit_rt = !!(flags &amp; FLAT_BINDER_FLAG_INHERIT_RT);</span><br><span class="line">	node-&gt;txn_security_ctx = !!(flags &amp; FLAT_BINDER_FLAG_TXN_SECURITY_CTX);</span><br><span class="line">	spin_lock_init(&amp;node-&gt;lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;node-&gt;work.entry);</span><br><span class="line">	INIT_LIST_HEAD(&amp;node-&gt;async_todo);</span><br><span class="line">	binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">		     <span class="string">&quot;%d:%d node %d u%016llx c%016llx created\n&quot;</span>,</span><br><span class="line">		     proc-&gt;pid, current-&gt;pid, node-&gt;debug_id,</span><br><span class="line">		     (u64)node-&gt;ptr, (u64)node-&gt;cookie);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，会创建一个binder_node 并尝试将其插入到【当前进程】 proc-&gt;nodes 红黑树中，</p>
<p>在创建 binder_node 实例时，会为 binder_node.ptr 和 binder_node.cookie 赋值，分别赋值成 flat_binder_object.binder 和 flat_binder_object.cookie。</p>
<p>这样的话，从发起方用户空间传输的BBinder实例，经由flat_binder_object实例暂存，最终存储到了Binder内核空间中对应的一个binder_node实例中。而这个binder_node 实例会保存在【发起方进程binder_proc.nodes】红黑树中。</p>
<p>至此，binder_node就告一段落了，接着就是调用：binder_inc_ref_for_node()来为目标进程binder_proc 中添加该binder_node 对应的binder_ref 实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_inc_ref_for_node</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> binder_node *node,</span></span><br><span class="line"><span class="params">			<span class="type">bool</span> strong,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> list_head *target_list,  <span class="comment">//  thread-&gt;todo</span></span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> binder_ref_data *rdata)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">new_ref</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	binder_proc_lock(proc);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注意此时外部传入的是 target_proc 哦！！也就是在目标进程中查找该 node 对应的 binder_ref 实例</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 从 proc-&gt;refs_by_node 中查找该 node 对应的 binder_ref</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ref = binder_get_ref_for_node_olocked(proc, node, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 没找着的话则针对该 binder_node 新建一个 binder_ref 存入到目标进程中去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ref) &#123;</span><br><span class="line">		binder_proc_unlock(proc);</span><br><span class="line">		new_ref = kzalloc(<span class="keyword">sizeof</span>(*ref), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!new_ref)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		binder_proc_lock(proc);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 此时新建一个 binder_ref ，指向该 node ，然后将其插入到 proc 中</span></span><br><span class="line"><span class="comment">		 * 也就是在目标进程中新建插入一个 binder_ref ，来指向当前 binder_node </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ref = binder_get_ref_for_node_olocked(proc, node, new_ref);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据 strong 来决定递增 ref-&gt;data.strong 还是 ref-&gt;data.weak</span></span><br><span class="line"><span class="comment">	 * 而 strong = hdr.type == BINDER_TYPE_BINDER</span></span><br><span class="line"><span class="comment">	 * 即 BINDER_TYPE_BINDER 类型时是强引用，handle 类型时是弱引用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = binder_inc_ref_olocked(ref, strong, target_list);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将 ref-&gt;data 作为返回值返回出去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	*rdata = ref-&gt;data;</span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; ref == new_ref) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Cleanup the failed reference here as the target</span></span><br><span class="line"><span class="comment">		 * could now be dead and have already released its</span></span><br><span class="line"><span class="comment">		 * references by now. Calling on the new reference</span></span><br><span class="line"><span class="comment">		 * with strong=0 and a tmp_refs will not decrement</span></span><br><span class="line"><span class="comment">		 * the node. The new_ref gets kfree&#x27;d below.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		binder_cleanup_ref_olocked(new_ref);</span><br><span class="line">		ref = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binder_proc_unlock(proc);</span><br><span class="line">	<span class="keyword">if</span> (new_ref &amp;&amp; ref != new_ref)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Another thread created the ref first so</span></span><br><span class="line"><span class="comment">		 * free the one we allocated</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		kfree(new_ref);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_ref *<span class="title function_">binder_get_ref_for_node_olocked</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> binder_node *node,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> binder_ref *new_ref)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> =</span> proc-&gt;context;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;proc-&gt;refs_by_node.rb_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 还是先从 proc-&gt;refs_by_node 中查找下对应的 binder_ref 是否存在</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		ref = rb_entry(parent, <span class="keyword">struct</span> binder_ref, rb_node_node);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (node &lt; ref-&gt;node)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (node &gt; ref-&gt;node)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> ref;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 没找着的话，则判断入参 new_ref 是否为null，不为null 则初始化它并将其插入到 proc-&gt;refs_by_node 中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!new_ref)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_REF);</span><br><span class="line">	new_ref-&gt;data.debug_id = atomic_inc_return(&amp;binder_last_id);</span><br><span class="line">	<span class="comment">// 该 binder_ref 所处的进程</span></span><br><span class="line">	new_ref-&gt;proc = proc;</span><br><span class="line">	<span class="comment">// 该 binder_ref 所对应的 binder_node</span></span><br><span class="line">	<span class="comment">// 因为 binder_ref 就是在其他进程中对另外一个进程 binder_node 的引用代表</span></span><br><span class="line">	new_ref-&gt;node = node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入到 proc-&gt;refs_by_node 中</span></span><br><span class="line">	rb_link_node(&amp;new_ref-&gt;rb_node_node, parent, p);</span><br><span class="line">	rb_insert_color(&amp;new_ref-&gt;rb_node_node, &amp;proc-&gt;refs_by_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * data.desc 其实就是存储的 handle 值。如果当前 node 是 sm 对应的 node ，则这里将其赋值为 0，否则为 1。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 也就是说：每个进程 binder_proc 所记录的 binder_ref 的 handle 值是从1开始递增的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	new_ref-&gt;data.desc = (node == context-&gt;binder_context_mgr_node) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 然后通过赋值的 new_ref-&gt;data.desc (0 或者 1) 去 proc-&gt;refs_by_desc 红黑树中查找</span></span><br><span class="line"><span class="comment">	 * 找到一个 node 的 data.desc 也就是 handle 值小于等于 new_ref-&gt;data.desc 的，就表示该 handle 被占用了</span></span><br><span class="line"><span class="comment">	 * 此时将其自增1 ，也就是 new_ref-&gt;data.desc = ref-&gt;data.desc + 1;</span></span><br><span class="line"><span class="comment">	 * 一直找到遇到一个 node 的 handle 大于 new_ref-&gt;data.desc ，表示 new_ref 此时的 handle 值可以用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (n = rb_first(&amp;proc-&gt;refs_by_desc); n != <span class="literal">NULL</span>; n = rb_next(n)) &#123;</span><br><span class="line">		ref = rb_entry(n, <span class="keyword">struct</span> binder_ref, rb_node_desc);</span><br><span class="line">		<span class="keyword">if</span> (ref-&gt;data.desc &gt; new_ref-&gt;data.desc)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		new_ref-&gt;data.desc = ref-&gt;data.desc + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 接下来开始使用 new_ref 正确的 handle 值去插入到 proc-&gt;refs_by_desc 树中合适的位置上去</span></span><br><span class="line"><span class="comment">	 * 而这里的 proc 是对应的【目标进程】</span></span><br><span class="line"><span class="comment">	 * 所以说：</span></span><br><span class="line"><span class="comment">	 * 每个进程 binder_proc的 refs_by_desc 树中所记录的 binder_ref 的 handle 值是从1开始递增的；</span></span><br><span class="line"><span class="comment">	 * 所有进程 binder_proc的 refs_by_desc 树中所记录的 handle=0 的 binder_ref 都指向 service manager</span></span><br><span class="line"><span class="comment">	 * 同一个服务的 binder_node 在不同进程的 binder_ref 的 handle 值可以不同</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	p = &amp;proc-&gt;refs_by_desc.rb_node;</span><br><span class="line">	<span class="keyword">while</span> (*p) &#123;</span><br><span class="line">		parent = *p;</span><br><span class="line">		ref = rb_entry(parent, <span class="keyword">struct</span> binder_ref, rb_node_desc);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (new_ref-&gt;data.desc &lt; ref-&gt;data.desc)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (new_ref-&gt;data.desc &gt; ref-&gt;data.desc)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			BUG();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将其插入到 proc-&gt;refs_by_desc 中</span></span><br><span class="line">	rb_link_node(&amp;new_ref-&gt;rb_node_desc, parent, p);</span><br><span class="line">	rb_insert_color(&amp;new_ref-&gt;rb_node_desc, &amp;proc-&gt;refs_by_desc);</span><br><span class="line"></span><br><span class="line">	binder_node_lock(node);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 最后一步，将 new_ref 插入到 node-&gt;refs 中去，表示又多了一个引用当前 node 的 binder_ref 实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	hlist_add_head(&amp;new_ref-&gt;node_entry, &amp;node-&gt;refs);</span><br><span class="line"></span><br><span class="line">	binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">		     <span class="string">&quot;%d new ref %d desc %d for node %d\n&quot;</span>,</span><br><span class="line">		      proc-&gt;pid, new_ref-&gt;data.debug_id, new_ref-&gt;data.desc,</span><br><span class="line">		      node-&gt;debug_id);</span><br><span class="line">	binder_node_unlock(node);</span><br><span class="line">	<span class="keyword">return</span> new_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建 binder_ref 时，比较重要的有几个点：</p>
<ol>
<li>这是在目标进程binder_proc 中操作的。而上面的 binder_node 是保存在发起方进程binder_proc 中的。这是这俩的区别。对应到用户空间的话就是：1) binder_node 对应 BBinder ，表示Server 中的Binder实体。2)binder_ref 对应 BpBinder ，表示Client 中的Binder代理对象。<br>而binder_node 只会存在一个，存在于Binder实体的那个进程中；binder_ref会存在多个，每个相关Client进程都会存在一份实例，并且这些binder_ref 中的 node 都指向同一个binder_node实例。binder_ref 相当于是散落在其他各个进程中的binder_node 的代理，通过他们可以访问到binder_node。</li>
<li>binder_ref 中的 desc 就是前面所说的handle 值，这个值的分配有一定规则的，即：<blockquote>
<p>每个进程 binder_proc的 refs_by_desc 树中所记录的 binder_ref 的 handle 值是从1开始递增的；</p>
<p>所有进程 binder_proc的 refs_by_desc 树中所记录的 handle&#x3D;0 的 binder_ref 都指向 service manager</p>
<p>同一个服务的 binder_node 在不同进程的 binder_ref 的 handle 值可以不同</p>
</blockquote>
</li>
<li>新创建的 binder_ref 会分别存在目标进程中的 refs_by_node 和 refs_by_desc 两个红黑树中。前者通过binder_node 来查找，后者通过 desc也就是handle值来查找，这样算是空间换时间吧。</li>
</ol>
<p>完成 binder_node 和 binder_ref 的工作之后，回到binder_translate_binder() 方法中，最后会将入参 flat_binder_object fp 的type从 BINDER_TYPE_BINDER修改为BINDER_TYPE_HANDLE，并且将其存储BBinder内存地址的 cookie、binder 置0，然后将其 handle 置成为新创建的binder_ref所分配的desc，也就是handle值。</p>
<p>因为将这个cookie、binder内存地址值传递到另外一个进程也没用，还不如转成handle传送。而这个地址值只需要存在当前进程 binder_node 中即可，后续通过binder_ref 来查binder_node 就知道地址了。</p>
<p>至此，就完成了 binder_translate_binder() 中的工作。这种是分析的flat_binder_object.hdr.type &#x3D; BINDER_TYPE_BINDER 的情况，即发送的是BBinder的情况。</p>
<p>2、BINDER_TYPE_HANDLE：与上面不同的是这里调用的是 binder_translate_handle() 方法。该方法内就不在赘述了，分析都写在代码注释中了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_translate_handle</span><span class="params">(<span class="keyword">struct</span> flat_binder_object *fp,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> binder_transaction *t,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> thread-&gt;proc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> =</span> t-&gt;to_proc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> <span class="title">src_rdata</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过传递过来的 handle 来在当前进程中查找对应的 node 。 比如 service manager 的 handle = 0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	node = binder_get_node_from_ref(proc, fp-&gt;handle,</span><br><span class="line">			fp-&gt;hdr.type == BINDER_TYPE_HANDLE, &amp;src_rdata);</span><br><span class="line">	<span class="keyword">if</span> (!node) &#123;</span><br><span class="line">		binder_user_error(<span class="string">&quot;%d:%d got transaction with invalid handle, %d\n&quot;</span>,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;cred, target_proc-&gt;cred)) &#123;</span><br><span class="line">		ret = -EPERM;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binder_node_lock(node);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 找到的目标 binder_node 和目标进程 target_proc 是位于同一个进程的话</span></span><br><span class="line"><span class="comment">	 * 直接复用之前保存的binder 地址就行了，将其 type 从 Handle 改为 Binder</span></span><br><span class="line"><span class="comment">	 * 因为位于同一个进程空间中，直接用之前保存的binder 地址就可以访问到对应的node了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (node-&gt;proc == target_proc) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_HANDLE)</span><br><span class="line">			fp-&gt;hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			fp-&gt;hdr.type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">		<span class="comment">// 将 binder 和 cookie 赋值为当前进程对应对象的地址</span></span><br><span class="line">		fp-&gt;binder = node-&gt;ptr;</span><br><span class="line">		fp-&gt;cookie = node-&gt;cookie;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;proc)</span><br><span class="line">			binder_inner_proc_lock(node-&gt;proc);</span><br><span class="line">		binder_inc_node_nilocked(node,</span><br><span class="line">					 fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">					 <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;proc)</span><br><span class="line">			binder_inner_proc_unlock(node-&gt;proc);</span><br><span class="line">		trace_binder_transaction_ref_to_node(t, node, &amp;src_rdata);</span><br><span class="line">		binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">			     <span class="string">&quot;        ref %d desc %d -&gt; node %d u%016llx\n&quot;</span>,</span><br><span class="line">			     src_rdata.debug_id, src_rdata.desc, node-&gt;debug_id,</span><br><span class="line">			     (u64)node-&gt;ptr);</span><br><span class="line">		binder_node_unlock(node);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 找到的目标 binder_node 和目标进程 target_proc 是两个不同的进程</span></span><br><span class="line"><span class="comment">		 * 那么就只保存 handle 值即可，因为不是同一个进程，所以不能像上面那样保存 binder 地址</span></span><br><span class="line"><span class="comment">		 * 进程都不是同一个，另外一个进程的 binder 地址在当前进程没有任何意义。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">struct</span> binder_ref_data dest_rdata;</span><br><span class="line"></span><br><span class="line">		binder_node_unlock(node);</span><br><span class="line">		<span class="comment">// 将 目标进程中的 binder_ref 引用数自增，没有的话会在目标进程创建 binder_ref</span></span><br><span class="line">		ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">				fp-&gt;hdr.type == BINDER_TYPE_HANDLE,</span><br><span class="line">				<span class="literal">NULL</span>, &amp;dest_rdata);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">		fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 不是同一个进程的话，则保存 handle 值即可</span></span><br><span class="line">		fp-&gt;handle = dest_rdata.desc;</span><br><span class="line">		fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">		trace_binder_transaction_ref_to_ref(t, node, &amp;src_rdata,</span><br><span class="line">						    &amp;dest_rdata);</span><br><span class="line">		binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">			     <span class="string">&quot;        ref %d desc %d -&gt; ref %d desc %d (node %d)\n&quot;</span>,</span><br><span class="line">			     src_rdata.debug_id, src_rdata.desc,</span><br><span class="line">			     dest_rdata.debug_id, dest_rdata.desc,</span><br><span class="line">			     node-&gt;debug_id);</span><br><span class="line">	&#125;</span><br><span class="line">done:</span><br><span class="line">	binder_put_node(node);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> binder_node *<span class="title function_">binder_get_node_from_ref</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">		u32 desc, <span class="type">bool</span> need_strong_ref,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> binder_ref_data *rdata)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line"></span><br><span class="line">	binder_proc_lock(proc);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这里的 desc 其实就是 handle ，比如 SM 的 handle = 0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ref = binder_get_ref_olocked(proc, desc, need_strong_ref);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这里没找到就直接返回了</span></span><br><span class="line"><span class="comment">	 * 如果使用蒙猜法，ref就会为null，通信就会终止</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ref)</span><br><span class="line">		<span class="keyword">goto</span> err_no_ref;</span><br><span class="line">	node = ref-&gt;node;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Take an implicit reference on the node to ensure</span></span><br><span class="line"><span class="comment">	 * it stays alive until the call to binder_put_node()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	binder_inc_node_tmpref(node);</span><br><span class="line">	<span class="keyword">if</span> (rdata)</span><br><span class="line">		*rdata = ref-&gt;data;</span><br><span class="line">	binder_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">err_no_ref:</span><br><span class="line">	binder_proc_unlock(proc);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中可能会将传递过来的 handle 值转变为对应的BBinder内存地址，从而直接调用。这也就完成了handle 值到 cookie 值的转换，也就是到真正BBinder内存地址的转换。</p>
<p>最后会再完成 tcomplete-&gt;type &#x3D; BINDER_WORK_TRANSACTION_COMPLETE 和 t-&gt;work.type &#x3D; BINDER_WORK_TRANSACTION 的赋值。</p>
<p>第三步执行完毕，总结来说就是发送方要发送的数据，会经由Binder内核，而Binder 内核会过滤处理这些数据中的 flat_binder_object 实例，判断其类型，如果是BINDER_TYPE_BINDER 类型则表示是发送了 BBinder实体，此时会在发送方进程中创建binder_node 实例保存起来，并创建和分配binder_ref实例并将其保存到接收方进程binder_proc中，这一步相当于完成了BBinder内存地址cookie到handle值的转换；如果 BINDER_TYPE_HANDLE ,则会判断当前如果传送到了接收方进程那么会将该handle 对应的 binder_ref 中的 binder_node 中的 cookie 内存地址查询出来并保存供后续调用使用，相当于完成了 handle值到cookie内存地址的转换。</p>
<h6 id="4-将-binder-transaction-保存到对应队列中等待处理"><a href="#4-将-binder-transaction-保存到对应队列中等待处理" class="headerlink" title="4.将 binder_transaction 保存到对应队列中等待处理"></a>4.将 binder_transaction 保存到对应队列中等待处理</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> binder_transaction_data *tr, <span class="type">int</span> reply,</span></span><br><span class="line"><span class="params">			       <span class="type">binder_size_t</span> extra_buffers_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 省略第一、二、三步的代码</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (reply) &#123;</span><br><span class="line">		binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">		binder_inner_proc_lock(target_proc);</span><br><span class="line">		<span class="keyword">if</span> (target_thread-&gt;is_dead) &#123;</span><br><span class="line">			binder_inner_proc_unlock(target_proc);</span><br><span class="line">			<span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">		&#125;</span><br><span class="line">		BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">		binder_pop_transaction_ilocked(target_thread, in_reply_to);</span><br><span class="line">		binder_enqueue_thread_work_ilocked(target_thread, &amp;t-&gt;work);</span><br><span class="line">		binder_inner_proc_unlock(target_proc);</span><br><span class="line">		wake_up_interruptible_sync(&amp;target_thread-&gt;wait);</span><br><span class="line">		binder_restore_priority(current, in_reply_to-&gt;saved_priority);</span><br><span class="line">		binder_free_transaction(in_reply_to);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; <span class="comment">// sync 同步 binder</span></span><br><span class="line">		BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Defer the TRANSACTION_COMPLETE, so we don&#x27;t return to</span></span><br><span class="line"><span class="comment">		 * userspace immediately; this allows the target process to</span></span><br><span class="line"><span class="comment">		 * immediately start processing this transaction, reducing</span></span><br><span class="line"><span class="comment">		 * latency. We will then return the TRANSACTION_COMPLETE when</span></span><br><span class="line"><span class="comment">		 * the target replies (or there is an error).</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 将 binder_work tcomplete 实例放入到【请求方线程】 thread-&gt;todo 列表中</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		binder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);</span><br><span class="line">		<span class="comment">// 标记为同步binder,需要有返回值答复</span></span><br><span class="line">		t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里是想要修改 thread-&gt;transaction_stack 的值为 t ，表示当前线程正在处理的事务是t</span></span><br><span class="line"><span class="comment">		 * 但是 thread-&gt;transaction_stack 中可能有未处理的binder_transaction，</span></span><br><span class="line"><span class="comment">		 * 所以这里先通过 t-&gt;from_parent 将其保存起来。</span></span><br><span class="line"><span class="comment">		 * 然后再修改 thread-&gt;transaction_stack 的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">		thread-&gt;transaction_stack = t;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 把 t-&gt;work 插入到【接收方线程】 target_thread-&gt;todo 中</span></span><br><span class="line"><span class="comment">		 * 而 todo 队列，到 binder_thread_read 函数中会有解释</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 比如从 main_mediaserver.cpp#main -&gt; MediaPlayerService.cpp#instantiate 中过来的</span></span><br><span class="line"><span class="comment">		 * 其目的进程是 service manager ，那么此时会执行到 service manager 中去</span></span><br><span class="line"><span class="comment">		 * 也就是：  servicemanager.c#main -&gt; binder.c#binder_loop 中的 binder_parse 内去</span></span><br><span class="line"><span class="comment">		 * 而上面已经将数据复制到了 buffer 中，且目标进程+内核 是内存映射的，所以目标进程 sm 中可以访问到该数据</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, target_thread)) &#123;</span><br><span class="line">			binder_inner_proc_lock(proc);</span><br><span class="line">			binder_pop_transaction_ilocked(thread, t);</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			<span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		BUG_ON(target_node == <span class="literal">NULL</span>);</span><br><span class="line">		BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">1</span>);</span><br><span class="line">		binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">		<span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (target_thread)</span><br><span class="line">		binder_thread_dec_tmpref(target_thread);</span><br><span class="line">	binder_proc_dec_tmpref(target_proc);</span><br><span class="line">	<span class="keyword">if</span> (target_node)</span><br><span class="line">		binder_dec_node_tmpref(target_node);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * write barrier to synchronize with initialization</span></span><br><span class="line"><span class="comment">	 * of log entry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_wmb();</span><br><span class="line">	WRITE_ONCE(e-&gt;debug_id_done, t_debug_id);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步中在当前条件下走的是<code>else if (!(t-&gt;flags &amp; TF_ONE_WAY))</code> 分支，即当当前是Binder同步请求方式时。</p>
<p>首先会调用binder_enqueue_deferred_thread_work_ilocked() 方法来将上面创建的 binder_work *tcomplete 插入到当前发起方线程 binder_thread-&gt;todo 列表中。</p>
<blockquote>
<p>tcomplete 是一个 binder_work实例，它在上面第二步中被创建，在第三步中给其 type 属性赋值为BINDER_WORK_TRANSACTION_COMPLETE 。关于它的作用后续会再讲，这里只需要暂时记住这个type即可。</p>
</blockquote>
<p>其次是修改 t-&gt;from_parent 和 thread-&gt;transaction_stack 的值。还记得上面 第一步中寻找target_thread的逻辑嘛？这俩值的修改就会影响到它，这里先有个印象，等后面一起再讲。埋坑点</p>
<p>最后就是调用 binder_proc_transaction() 方法来将 binder_transaction t 加入到对应的目标线程或者目标进程中去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">binder_proc_transaction</span><span class="params">(<span class="keyword">struct</span> binder_transaction *t,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> =</span> t-&gt;buffer-&gt;target_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">node_prio</span>;</span></span><br><span class="line">	<span class="comment">// 是否是异步请求</span></span><br><span class="line">	<span class="type">bool</span> oneway = !!(t-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">	<span class="comment">// 默认是 false</span></span><br><span class="line">	<span class="type">bool</span> pending_async = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!node);</span><br><span class="line">	binder_node_lock(node);</span><br><span class="line">	node_prio.prio = node-&gt;min_priority;</span><br><span class="line">	node_prio.sched_policy = node-&gt;sched_policy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是 异步请求 的话</span></span><br><span class="line">	<span class="keyword">if</span> (oneway) &#123;</span><br><span class="line">		BUG_ON(thread);</span><br><span class="line">		<span class="comment">// 如果目标节点里边已经有异步事务要处理，则设置pending_async为true</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;has_async_transaction) &#123;</span><br><span class="line">			pending_async = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			node-&gt;has_async_transaction = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;is_dead || (thread &amp;&amp; thread-&gt;is_dead)) &#123;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		binder_node_unlock(node);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 外部没有传入目标线程 target_thread, 那么这里去</span></span><br><span class="line"><span class="comment">	 * 目标进程中的 waiting_threads 列表中找一个线程来作为 目标线程 target_thread</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!thread &amp;&amp; !pending_async)</span><br><span class="line">		thread = binder_select_thread_ilocked(proc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果现在有了目标线程 target_thread ，就将该 binder_transaction *t 加入到该 binder_thread 中的 todo 列表中去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (thread) &#123;</span><br><span class="line">		binder_transaction_priority(thread-&gt;task, t, node_prio,</span><br><span class="line">					    node-&gt;inherit_rt);</span><br><span class="line">		<span class="comment">// 把事务添加的目标线程的todo中处理</span></span><br><span class="line">		binder_enqueue_thread_work_ilocked(thread, &amp;t-&gt;work);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_async) &#123; <span class="comment">// 没有找到目标线程，则只能添加到目标进程的todo中</span></span><br><span class="line">		binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;proc-&gt;todo);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// node中已经有异步任务了，则把事务添加的node的async_todo中排队待处理</span></span><br><span class="line">		binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;node-&gt;async_todo);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是同步或者第一次执行异步操作，则唤醒目标进程或目标线程</span></span><br><span class="line">	<span class="keyword">if</span> (!pending_async)</span><br><span class="line">		binder_wakeup_thread_ilocked(proc, thread, !oneway <span class="comment">/* sync */</span>);</span><br><span class="line"></span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">	binder_node_unlock(node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里调用 binder_proc_transaction() 方法时传入的是 target_proc 和 target_thread ，其中target_proc目标进程信息此时肯定不为空，而target_thread目标线程可能为空。因此在binder_proc_transaction() 方法中是将 t-&gt;work 优先加入到目标线程 target_thread-&gt;todo 中去，否则就加入到目标进程 target_proc-&gt;todo 中去。将 t-&gt;work 加进去就相当于把t加进去了。后续接收方进程中就可以查询这个 todo队列来处理待处理的事务了。</p>
<blockquote>
<p>注意这里的 tcomplete 和 t-&gt;work ，他俩一个加入到发送方todo队列中，另一个加入到接收方todo队列中。</p>
</blockquote>
<h5 id="binder-thread-read"><a href="#binder-thread-read" class="headerlink" title="binder_thread_read()"></a>binder_thread_read()</h5><p>上面完成了对 Binder 内核写入数据的操作，接下来就是完成数据的读取处理了。</p>
<p>对于数据的读取是从 binder_ioctl_write_read()中调用 binder_thread_read() 方法来实现数据的读取，注意此时传入的 proc 和 thread 是表示的当前发起方进程、线程信息。即在该方法中读取的是当前进程&#x2F;线程中待处理的事务，比如别的发起方发送了数据到了当前进程中，此时当前进程就作为Server端来使用的。明确了这一点那么就可以接着往下看代码了，而关于该方法，我分为下面两步来分析：</p>
<h6 id="1、判断当前线程是否有待处理的事务"><a href="#1、判断当前线程是否有待处理的事务" class="headerlink" title="1、判断当前线程是否有待处理的事务"></a>1、判断当前线程是否有待处理的事务</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_thread_read</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params">			      <span class="type">binder_uintptr_t</span> binder_buffer, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">			      <span class="type">binder_size_t</span> *consumed, <span class="type">int</span> non_block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> __user *buffer = (<span class="type">void</span> __user *)(<span class="type">uintptr_t</span>)binder_buffer;</span><br><span class="line">	<span class="type">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">	<span class="type">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果 consumed = 0，也就是 binder_write_read.read_consumed 为0</span></span><br><span class="line"><span class="comment">	 * 则将 BR_NOOP 赋值回 用户空间的 ptr ，也就是写入到入参  binder_write_read.read_buffer 中去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果入参 consumed = 0 的话，则直接先写入 BR_NOOP 作为 cmd</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (put_user(BR_NOOP, (<span class="type">uint32_t</span> __user *)ptr))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断当前 thread 中是否有待处理的任务，即当前线程是否是空闲状态呢？会看当前 thread 的 transaction_stack 和 todo 列表</span></span><br><span class="line"><span class="comment">	 * 如果其 transaction_stack 为空并且todo列表中没有值，则返回 wait_for_proc_work = true </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	wait_for_proc_work = binder_available_for_proc_work_ilocked(thread);</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 此时改变线程的状态为 BINDER_LOOPER_STATE_WAITING</span></span><br><span class="line"><span class="comment">	 * 表示当前线程可能要进入等待状态了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">	trace_binder_wait_for_work(wait_for_proc_work,</span><br><span class="line">				   !!thread-&gt;transaction_stack,</span><br><span class="line">				   !binder_worklist_empty(proc, &amp;thread-&gt;todo));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">					BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">			binder_user_error(<span class="string">&quot;%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)\n&quot;</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</span><br><span class="line">			wait_event_interruptible(binder_user_error_wait,</span><br><span class="line">						 binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		binder_restore_priority(current, proc-&gt;default_priority);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!binder_has_work(thread, wait_for_proc_work))</span><br><span class="line">			ret = -EAGAIN;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * binder_wait_for_work 调用 prepare_to_wait 将自身加入 wait 队列</span></span><br><span class="line"><span class="comment">		 * 紧接着调用 schedule , 读取数据的 thread 开始休眠等待唤醒</span></span><br><span class="line"><span class="comment">		 * 后续被唤醒之后，接着从当前位置往后开始执行</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ret = binder_wait_for_work(thread, wait_for_proc_work);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行到这里的时候表示已经被唤醒了，去掉 BINDER_LOOPER_STATE_WAITING 标记</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略第二步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法刚进来，会通过binder_available_for_proc_work_ilocked() 方法来判断当前线程中是否存在待处理的事务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">binder_available_for_proc_work_ilocked</span><span class="params">(<span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * thread-&gt;transaction_stack!=null : 说明当前线程曾发送同步请求，而未得到回复</span></span><br><span class="line"><span class="comment">	 * thread-&gt;todo非空 : 说明有binder_work等待本线程处理</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 这两个的赋值在 binder_thread_write -&gt; binder_transaction 中最后会有</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 因此如果 transaction_stack 有值则返回false；如果todo列表中有值则返回false；</span></span><br><span class="line"><span class="comment">	 * 因此当前方法返回true时表示transaction_stack没有值并且todo列表为空</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> !thread-&gt;transaction_stack &amp;&amp;  </span><br><span class="line">		binder_worklist_empty_ilocked(&amp;thread-&gt;todo) &amp;&amp;</span><br><span class="line">		(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_ENTERED |</span><br><span class="line">				   BINDER_LOOPER_STATE_REGISTERED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此该方法的返回值 wait_for_proc_work &#x3D; true 时表示当前线程中没有待处理的事务。因此此时该线程会被标记为休眠状态，因为没有事务待处理那就得阻塞住等待新的事务过来然后再唤醒它去处理。</p>
<p>标记为休眠状态时，首先会修改标识：thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_WAITING，表示该线程进入休眠等待状态，接着调用 binder_wait_for_work() 方法来执行休眠逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_wait_for_work</span><span class="params">(<span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params">				<span class="type">bool</span> do_proc_work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 建立并初始化一个等待队列项wait</span></span><br><span class="line">	DEFINE_WAIT(wait);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> thread-&gt;proc;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	freezer_do_not_count();</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	<span class="comment">// 循环的作用是让线程被唤醒后再一次去检查一下condition是否满足</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 将wait添加到等待队列头中，并设置进程的状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		prepare_to_wait(&amp;thread-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">		<span class="comment">// 唤醒条件condition,如果满足则跳出循环，否则一直循环等待</span></span><br><span class="line">		<span class="keyword">if</span> (binder_has_work_ilocked(thread, do_proc_work))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果是在等待处理本进程的todo队列的任务</span></span><br><span class="line"><span class="comment">		 * 把本线程的waiting_thread_node添加到所属进程的waiting_threads中</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (do_proc_work)</span><br><span class="line">			list_add(&amp;thread-&gt;waiting_thread_node,</span><br><span class="line">				 &amp;proc-&gt;waiting_threads);</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		<span class="comment">// 调用schedule()，让出cpu资源，开始休眠</span></span><br><span class="line">		schedule();</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		list_del_init(&amp;thread-&gt;waiting_thread_node);</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			ret = -ERESTARTSYS;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行清理工作</span></span><br><span class="line">	finish_wait(&amp;thread-&gt;wait, &amp;wait);</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">	freezer_count();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时该线程会被插入到 binder_proc-&gt;waiting_threads 等待队列中，然后陷入休眠等待，等待后续被唤醒。</p>
<p>等后续被唤醒之后，接着往下执行会修改标识：thread-&gt;looper &amp;&#x3D; ~BINDER_LOOPER_STATE_WAITING 表示休眠结束。</p>
<p>而如果 wait_for_proc_work&#x3D; false 即当前线程有待处理的事务，那么不会陷入休眠，而是直接往下接着执行。</p>
<p>读取数据的操作必须是 binder_write_read.read_size &gt; 0。而对于读取操作，SM 和其他的BBinder 实体提供方进程的实现策略是不一样的：</p>
<p>SM 方是单独提供的实现，开启一个线程一直从Binder 内核中通过ioctl读取数据来处理；</p>
<p>其他BBinder提供方进程则是起一个指定的线程池，线程池内的线程会去 Binder 驱动中读取数据，读取到了就会在该线程池中某个线程内执行处理，没读取到则陷入阻塞。</p>
<p>这些后续都会分析到。</p>
<h6 id="2、处理事务"><a href="#2、处理事务" class="headerlink" title="2、处理事务"></a>2、处理事务</h6><p>第一步执行完毕，到了第二步时，表示当前线程是有待处理的事务的，因此这一步就可以开始事务的处理了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_thread_read</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> binder_thread *thread,</span></span><br><span class="line"><span class="params">			      <span class="type">binder_uintptr_t</span> binder_buffer, <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">			      <span class="type">binder_size_t</span> *consumed, <span class="type">int</span> non_block)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 省略第一步代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 开始处理数据，即 binder_thread_read 执行一次，允许执行多个 binder_work</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> cmd;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data_secctx</span> <span class="title">tr</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">trd</span> =</span> &amp;tr.transaction_data;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">t_from</span>;</span></span><br><span class="line">		<span class="type">size_t</span> trsize = <span class="keyword">sizeof</span>(*trd);</span><br><span class="line"></span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 优先处理本线程内部的 todo 队列，如果为空，则处理进程的 todo 队列</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">			<span class="built_in">list</span> = &amp;thread-&gt;todo;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo) &amp;&amp;</span><br><span class="line">			   wait_for_proc_work)</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * thread-&gt;todo 为空的话，则使用 proc-&gt;todo</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">list</span> = &amp;proc-&gt;todo;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* no data added */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 *  ptr - buffer == 4 意为着 binder driver仅向用户态接收缓冲区写入了一个BR_NOOP，即当前还未处理过binder_work</span></span><br><span class="line"><span class="comment">             * !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN) 意为着当前线程并不急着返回，可以继续工作</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 若无数据且当前线程 looper_need_return 为 false, 则重试</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !thread-&gt;looper_need_return)</span><br><span class="line">				<span class="keyword">goto</span> retry; <span class="comment">// 继续等待下一个binder_work</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 用户接收缓存区快被写满了，返回，等待下次调用ioctl</span></span><br><span class="line">		<span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>) &#123;</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 选取好 todo 队列后，开始从 todo 队列中摘除待处理的 binder_transaction 事务</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		w = binder_dequeue_work_head_ilocked(<span class="built_in">list</span>);</span><br><span class="line">		<span class="comment">// 取出一个之后 list 为空了</span></span><br><span class="line">		<span class="keyword">if</span> (binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">			thread-&gt;process_todo = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * @brief </span></span><br><span class="line"><span class="comment">		 * 开始处理这个 binder_work </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 说明收到了一个来自其他进程的 binder_transaction</span></span><br><span class="line"><span class="comment">		 * 在前面处理 write 数据时，在 binder_transaction() 函数中将 transaction-&gt;work 保存到了 todo 队列中</span></span><br><span class="line"><span class="comment">		 * 而这里通过 container_of 拿到之前保存的 transaction</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * https://zhuanlan.zhihu.com/p/54932270</span></span><br><span class="line"><span class="comment">			 * w 是 binder_transaction 结构体内的 work 属性，</span></span><br><span class="line"><span class="comment">			 * 然后通过 w ，以及它是 binder_transaction.work 这两个条件来获取其对应的 binder_transaction 实例</span></span><br><span class="line"><span class="comment">			 * 因为外部也是通过 binder_transaction.work 来将 w 传入的</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			t = container_of(w, <span class="keyword">struct</span> binder_transaction, work);</span><br><span class="line">		&#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略其他 case</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 没有读取到 t transaction ，或者读取失败就都是再试</span></span><br><span class="line">		<span class="keyword">if</span> (!t)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		BUG_ON(t-&gt;buffer == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * t 是由 BC_TRANSACTION 发送过来的，当前线程为 Serivce 的处理线程</span></span><br><span class="line"><span class="comment">		 * 以上我们已经拿到从请求端发送过来的binder_transaction事务，接下来解析这个事务</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 是否存在目标节点，这里为存在</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> =</span> t-&gt;buffer-&gt;target_node;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">node_prio</span>;</span></span><br><span class="line">			<span class="comment">// 把Binder实体的地址赋值给tr的target.ptr</span></span><br><span class="line">			trd-&gt;target.ptr = target_node-&gt;ptr;</span><br><span class="line">			<span class="comment">// 把 Binder实体的地址赋值给tr的target.cookie</span></span><br><span class="line">			trd-&gt;cookie =  target_node-&gt;cookie;</span><br><span class="line">			<span class="comment">// 保存处理线程当前的优先级</span></span><br><span class="line">			node_prio.sched_policy = target_node-&gt;sched_policy;</span><br><span class="line">			node_prio.prio = target_node-&gt;min_priority;</span><br><span class="line">			binder_transaction_priority(current, t, node_prio,</span><br><span class="line">						    target_node-&gt;inherit_rt);</span><br><span class="line">			<span class="comment">// 构建BR_TRANSACTION命令把tr数据返回到用户空间</span></span><br><span class="line">			cmd = BR_TRANSACTION;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// t是由BC_REPLY指令发送过来的，当前线程为Client的请求线程</span></span><br><span class="line">			trd-&gt;target.ptr = <span class="number">0</span>;</span><br><span class="line">			trd-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">			cmd = BR_REPLY;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 事务的信息全部赋值给tr这个binder_transaction_data结构，用来返回到用户空间</span></span><br><span class="line">		trd-&gt;code = t-&gt;code;</span><br><span class="line">		trd-&gt;flags = t-&gt;flags;</span><br><span class="line">		trd-&gt;sender_euid = from_kuid(current_user_ns(), t-&gt;sender_euid);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 该事务的请求方线程为  t_from</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		t_from = binder_get_txn_from(t);</span><br><span class="line">		<span class="keyword">if</span> (t_from) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> =</span> t_from-&gt;proc-&gt;tsk;</span><br><span class="line"></span><br><span class="line">			trd-&gt;sender_pid =</span><br><span class="line">				task_tgid_nr_ns(sender,</span><br><span class="line">						task_active_pid_ns(current));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 因为读取回复不需要安全验证，安全验证总是在通过BC_TRANSACTION发送请求时进行</span></span><br><span class="line">			trd-&gt;sender_pid = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里不需要copy数据实体到用户态，因为内核态和用户态已经共享物理内存</span></span><br><span class="line"><span class="comment">		 * 所以，这里只需要在 tr 中返回数据在内核态的起始地址和偏移量数组在内核态的首地址</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		trd-&gt;data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">		trd-&gt;offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">		trd-&gt;data.ptr.buffer = (<span class="type">uintptr_t</span>)t-&gt;buffer-&gt;user_data;</span><br><span class="line">		trd-&gt;data.ptr.offsets = trd-&gt;data.ptr.buffer +</span><br><span class="line">					ALIGN(t-&gt;buffer-&gt;data_size,</span><br><span class="line">					    <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"></span><br><span class="line">		tr.secctx = t-&gt;security_ctx;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * trsize 默认是 trd 结构体，也就是 binder_transaction_data 的大小</span></span><br><span class="line"><span class="comment">		 * 而如果 t-&gt;security_ctx 不为空则 cmd 修改为 BR_TRANSACTION_SEC_CTX </span></span><br><span class="line"><span class="comment">		 * trsize 也修改为 tr 也就是 binder_transaction_data_secctx 的大小</span></span><br><span class="line"><span class="comment">		 * 后面在 copy_to_user 时会用到这俩参数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (t-&gt;security_ctx) &#123;</span><br><span class="line">			cmd = BR_TRANSACTION_SEC_CTX;</span><br><span class="line">			trsize = <span class="keyword">sizeof</span>(tr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * put_user 类似于 copy_to_user，不过 put_user 只能操作一些简单基础变量</span></span><br><span class="line"><span class="comment">		 * 对于结构体等对象不行。</span></span><br><span class="line"><span class="comment">		 * https://blog.csdn.net/ce123_zhouwei/article/details/8457822</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 这里则是将 cmd 复制到 ptr 对应的用户空间，</span></span><br><span class="line"><span class="comment">		 * 而 ptr 则是对应的 binder_write_read.read_buffer 当前读取的位置</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (put_user(cmd, (<span class="type">uint32_t</span> __user *)ptr)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (t_from)</span><br><span class="line">				binder_thread_dec_tmpref(t_from);</span><br><span class="line"></span><br><span class="line">			binder_cleanup_transaction(t, <span class="string">&quot;put_user failed&quot;</span>,</span><br><span class="line">						   BR_FAILED_REPLY);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 上面复制了 cmd ，这里则将其指针后移</span></span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 接着将 tr 复制到 用户空间 ptr 中</span></span><br><span class="line"><span class="comment">		 * 这里只是将 tr 结构体复制过去，其内部指针指向的数据已经是内存共享的了，不需要额外复制</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, trsize)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (t_from)</span><br><span class="line">				binder_thread_dec_tmpref(t_from);</span><br><span class="line"></span><br><span class="line">			binder_cleanup_transaction(t, <span class="string">&quot;copy_to_user failed&quot;</span>,</span><br><span class="line">						   BR_FAILED_REPLY);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 同样还是后移指针</span></span><br><span class="line">		ptr += trsize;</span><br><span class="line"></span><br><span class="line">		trace_binder_transaction_received(t);</span><br><span class="line">		binder_stat_br(proc, thread, cmd);</span><br><span class="line">		binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">			     <span class="string">&quot;%d:%d %s %d %d:%d, cmd %d size %zd-%zd ptr %016llx-%016llx\n&quot;</span>,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">			     (cmd == BR_TRANSACTION) ? <span class="string">&quot;BR_TRANSACTION&quot;</span> :</span><br><span class="line">				(cmd == BR_TRANSACTION_SEC_CTX) ?</span><br><span class="line">				     <span class="string">&quot;BR_TRANSACTION_SEC_CTX&quot;</span> : <span class="string">&quot;BR_REPLY&quot;</span>,</span><br><span class="line">			     t-&gt;debug_id, t_from ? t_from-&gt;proc-&gt;pid : <span class="number">0</span>,</span><br><span class="line">			     t_from ? t_from-&gt;pid : <span class="number">0</span>, cmd,</span><br><span class="line">			     t-&gt;buffer-&gt;data_size, t-&gt;buffer-&gt;offsets_size,</span><br><span class="line">			     (u64)trd-&gt;data.ptr.buffer,</span><br><span class="line">			     (u64)trd-&gt;data.ptr.offsets);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (t_from)</span><br><span class="line">			binder_thread_dec_tmpref(t_from);</span><br><span class="line">		<span class="comment">// 表示事务t的buffer允许目标线程在用户空间发出BC_FREE_BUFFER命令协议来释放</span></span><br><span class="line">		t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 当前线程为Service的处理线程，把 t 保存到 thread-&gt;transaction_stack</span></span><br><span class="line"><span class="comment">		 * 处理完成以后，回复请求时，会用到它</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (cmd != BR_REPLY &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * thread-&gt;transaction_stack 修改为当前事务 t ，</span></span><br><span class="line"><span class="comment">			 * 修改之前将其原来的值保存到 t-&gt;to_parent</span></span><br><span class="line"><span class="comment">			 * 同步操作，要等事务t处理完, 才释放缓存空间</span></span><br><span class="line"><span class="comment">			 * 同时需要对事务栈transaction_stack进行处理</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			binder_inner_proc_lock(thread-&gt;proc);</span><br><span class="line">			t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">			t-&gt;to_thread = thread;</span><br><span class="line">			thread-&gt;transaction_stack = t;</span><br><span class="line">			binder_inner_proc_unlock(thread-&gt;proc);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 异步操作可以直接free这个事务t了</span></span><br><span class="line">			binder_free_transaction(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="comment">// while(1) finish</span></span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 更新入参 consumed ，表示往 buffer 开头的内存中写入了多少数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	*consumed = ptr - buffer;</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 每次读取完事务后，都需要检查进程中的 Binder 线程是否够用，如果不够用需要通知新增线程</span></span><br><span class="line"><span class="comment">	 * 新增条件是:请求线程数为0，并且等待线程数也为0，并且已启动线程数不超过最大线程数</span></span><br><span class="line"><span class="comment">	 * 并且线程的状态为已经注册或已经进程循环，满足以上条件则向用户空间发送 BR_SPAWN_LOOPER命令，</span></span><br><span class="line"><span class="comment">	 * 告诉用户空间创建一个新的 Binder 线程</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;requested_threads == <span class="number">0</span> &amp;&amp;</span><br><span class="line">	    list_empty(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp;</span><br><span class="line">	    proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">	    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">	     BINDER_LOOPER_STATE_ENTERED)) <span class="comment">/* the user-space code fails to */</span></span><br><span class="line">	     <span class="comment">/*spawn a new thread if we leave this out */</span>) &#123;</span><br><span class="line">		<span class="comment">// 正在请求还没有启动的线程数量加 1</span></span><br><span class="line">		proc-&gt;requested_threads++;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		binder_debug(BINDER_DEBUG_THREADS,</span><br><span class="line">			     <span class="string">&quot;%d:%d BR_SPAWN_LOOPER\n&quot;</span>,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		<span class="comment">// 向用户空间发送命令 BR_SPAWN_LOOPER, 创建新线程</span></span><br><span class="line">		<span class="keyword">if</span> (put_user(BR_SPAWN_LOOPER, (<span class="type">uint32_t</span> __user *)buffer))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		binder_stat_br(proc, thread, BR_SPAWN_LOOPER);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务的处理是放在一个 while(1) 死循环中的，可以将todo队列中的任务一次性处理完。</p>
<p>首先是确定要处理事务的任务队列，优先从 binder_thread -&gt; todo ，也就是当前发起方线程内部的todo队列中查找有无待处理的事务，有的话则用它的；否则从 binder_proc -&gt; todo ，也就是当前发起方进程中的todo队列内。</p>
<p>接着就是调用 binder_dequeue_work_head_ilocked() 方法从todo队列中取出任务来处理了。取出任务 binder_work 之后，根据其 type 类型来处理。</p>
<p>还记得前面 binder_transaction() 方法中第三步中给新创建的 binder_transaction 中的 work.type 赋值的是什么类型嘛？正是 BINDER_WORK_TRANSACTION 。该类型表示该 binder_work 的拥有方是 binder_transaction ,也就是可以通过这个 binder_work 拿到对应的 binder_transaction实例。</p>
<p>因此这里通过 container_of() 方法获取到了对应的binder_transaction实例。</p>
<blockquote>
<p>可以再翻看上去，看上面 binder_transaction() 方法中第三步的逻辑</p>
</blockquote>
<p>取到binder_transaction实例之后，就可以拿到其内部存储的target_node 属性，从而从中取出对应的 cookie 、ptr 等内存地址值了。</p>
<blockquote>
<p>注意，此时能从 todo队列中取出待处理的事务，那肯定当前线程或者进程是作为Server方的。</p>
<p>比如从A进程发送数据到 SM 中，先执行了 write操作将A进程发送的数据包装成 binder_transaction 实例保存到 SM 进程中的 todo 队列中；接着执行 read 操作，此时当前进程还是A，也就是此时是获取A进程todo队列中的事务的，也就是别的进程发送给A进程的数据。假设此时没有别的发送过数据给A进程，所以A进程中当前线程会陷入等待状态。</p>
<p>此时SM进程中读取数据时，发现其todo队列中有待处理的事务了(因为上面A 发送了数据插入到了SM进程todo队列中了)，此时SM进程会执行到这里，那么此时SM进程肯定是 target_node 对应的进程，因此可以直接使用其之前保存的内存地址 cookie 和 ptr 那些。通过这些内存地址就可以调用到对应的BBinder实体。</p>
</blockquote>
<p>因此这里会将 target_node 中的 cookie 等地址值保存到 binder_transaction_data *trd 中，也就是binder_transaction_data_secctx.transaction_data 中。同时保存的还有 code、flag 、data_size 、data.ptr.buffer 那些。</p>
<blockquote>
<p>code 和 cmd 的区别前面讲过了，请翻看前面。</p>
<p>ptr.buffer 这些就是要传输的数据地址</p>
</blockquote>
<p>最后准备将这些数据写回到用户空间去，先调用put_user() 方法来将 cmd&#x3D;BR_TRANSACTION 写回去，再通过 copy_to_user() 把binder_transaction_data_secctx tr 写回去。</p>
<blockquote>
<p>注意这里只是将 tr 结构体复制过去，其内部指针指向的数据已经是内存共享的了，也就是在当前进程中可以直接访问了的，不需要额外复制。</p>
<p>后续可以通过这个 tr 实例中的内存地址值来访问对应的数据。</p>
<p>正是因为前面write时的内存映射工作，才让这里少了一次数据的复制，只需要要将数据从发送方进程复制到内核中即可，会自动内存映射到接收方进程，接收方进程只需要知道映射之后的内存地址即可直接访问了。</p>
</blockquote>
<p>然后会修改 thread-&gt;transaction_stack 的值为 t，也就是说当前线程binder_thread 中正在处理该事务。</p>
<p>最后会判断用户空间线程池线程数是否够用，不够用则会通知它来扩充线程数。这些后续单独讲。</p>
<p>至此 binder_thread_read() 方法执行完毕，在该方法中会将当前线程待处理的事务包装成对应的结构体实例，内部存储该事务对应的BBinder对象地址，然后发送给该线程用户空间去让它处理。</p>
<h5 id="target-thread补充"><a href="#target-thread补充" class="headerlink" title="target_thread补充"></a>target_thread补充</h5><p>埋坑点</p>
<h4 id="BINDER-SET-MAX-THREADS"><a href="#BINDER-SET-MAX-THREADS" class="headerlink" title="BINDER_SET_MAX_THREADS"></a>BINDER_SET_MAX_THREADS</h4><p>回到 binder_ioctl() 方法中，如果读取到的cmd &#x3D; BINDER_SET_MAX_THREADS 时，此时会从用户空间复制int过来，然后将其作为新的 max_thread 值设置给当前进程 binder_proc.max_threads 。</p>
<h4 id="BINDER-SET-CONTEXT-MGR-EXT-amp-BINDER-SET-CONTEXT-MGR"><a href="#BINDER-SET-CONTEXT-MGR-EXT-amp-BINDER-SET-CONTEXT-MGR" class="headerlink" title="BINDER_SET_CONTEXT_MGR_EXT &amp; BINDER_SET_CONTEXT_MGR"></a>BINDER_SET_CONTEXT_MGR_EXT &amp; BINDER_SET_CONTEXT_MGR</h4><p>这两种类型的cmd是类似的，都是用来设置SM binder_node 的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// binder.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">binder_ioctl_set_ctx_mgr</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> flat_binder_object *fbo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> =</span> proc-&gt;context;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">new_node</span>;</span></span><br><span class="line">	<span class="type">kuid_t</span> curr_euid = current_euid();</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果其已经被赋值过，则直接结束</span></span><br><span class="line">	<span class="keyword">if</span> (context-&gt;binder_context_mgr_node) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;BINDER_SET_CONTEXT_MGR already set\n&quot;</span>);</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = security_binder_set_context_mgr(proc-&gt;cred);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> (uid_valid(context-&gt;binder_context_mgr_uid)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!uid_eq(context-&gt;binder_context_mgr_uid, curr_euid)) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;BINDER_SET_CONTEXT_MGR bad uid %d != %d\n&quot;</span>,</span><br><span class="line">			       from_kuid(&amp;init_user_ns, curr_euid),</span><br><span class="line">			       from_kuid(&amp;init_user_ns,</span><br><span class="line">					 context-&gt;binder_context_mgr_uid));</span><br><span class="line">			ret = -EPERM;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 设置当前线程euid作为Service Manager的uid</span></span><br><span class="line">		context-&gt;binder_context_mgr_uid = curr_euid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建 ServiceManager 实体</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建一个 binder_node node 插入到 proc-&gt;nodes.rb_node 树中合适的位置上去，</span></span><br><span class="line"><span class="comment">	 * 并且初始化 node 中的其他属性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	new_node = binder_new_node(proc, fbo);</span><br><span class="line">	<span class="keyword">if</span> (!new_node) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_node_lock(new_node);</span><br><span class="line">	new_node-&gt;local_weak_refs++;</span><br><span class="line">	new_node-&gt;local_strong_refs++;</span><br><span class="line">	new_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">	new_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 把这个binder_node节点保存到进程的binder_context中,这个binder_context是全局共享的</span></span><br><span class="line"><span class="comment">	 * 其它进程也可以通过自己的binder_context来获取这个binder_context_mgr_node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	context-&gt;binder_context_mgr_node = new_node;</span><br><span class="line">	binder_node_unlock(new_node);</span><br><span class="line">	binder_put_node(new_node);</span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实最主要的逻辑就是创建 binder_node 实例，然后将其保存到 binder_context_mgr_node 属性中。后期直接使用它就可以了。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Binder/">Binder</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/1d5df811.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Binder - Server数据处理</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/5b9837b1.html">
        <span class="next-text nav-default">Binder - Client数据发送</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2022
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
