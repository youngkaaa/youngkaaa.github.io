<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Kotlin协程 - 拦截器原理"/>




  <meta name="keywords" content="Kotlin Coroutine," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/ff74222f.html"/>


<meta name="description" content="正如前面所说，CorontineContext 是作为协程上下文基础类，它提供了get、fold、plus、minusKey方法，基本就像是把它当做集合来使用了，提供了增删查和迭代的操作。而另外又存在 Element 接口继承自 CoroutineContext。所以说在协程中，CoroutineContext中的元素都实现了CoroutineContext.Element接口，而键类型都实现了C">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin协程 - 拦截器原理">
<meta property="og:url" content="https://youngkaaa.github.io/ff74222f.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="正如前面所说，CorontineContext 是作为协程上下文基础类，它提供了get、fold、plus、minusKey方法，基本就像是把它当做集合来使用了，提供了增删查和迭代的操作。而另外又存在 Element 接口继承自 CoroutineContext。所以说在协程中，CoroutineContext中的元素都实现了CoroutineContext.Element接口，而键类型都实现了C">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/ff74222f/pic_01.png">
<meta property="og:image" content="https://youngkaaa.github.io/ff74222f/pic_02.png">
<meta property="article:published_time" content="2022-05-05T12:48:56.000Z">
<meta property="article:modified_time" content="2022-11-02T13:23:06.413Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Kotlin Coroutine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/ff74222f/pic_01.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Kotlin协程 - 拦截器原理 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Kotlin协程 - 拦截器原理
        
      </h1>

      <time class="post-time">
          5月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>正如前面所说，CorontineContext 是作为协程上下文基础类，它提供了get、fold、plus、minusKey方法，基本就像是把它当做集合来使用了，提供了增删查和迭代的操作。而另外又存在 Element 接口继承自 CoroutineContext。所以说在协程中，CoroutineContext中的<code>元素</code>都实现了CoroutineContext.Element接口，而<code>键类型</code>都实现了CoroutineContext.Key接口，且每种键类型只存在一个元素。</p>
<p>其中一个很重要的就是 <code>ContinuationInterceptor</code>,它的作用简单来说就是拦截原始 Continuation 从而改变其原有性质，实际一般都是用来将协程逻辑切换线程来执行。</p>
<h3 id="ContinuationInterceptor"><a href="#ContinuationInterceptor" class="headerlink" title="ContinuationInterceptor"></a>ContinuationInterceptor</h3><p>先看看 <code>ContinuationInterceptor</code> 的真面目：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The key that defines *the* context interceptor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.</span></span><br><span class="line"><span class="comment">     * This function is invoked by coroutines framework when needed and the resulting continuations are</span></span><br><span class="line"><span class="comment">     * cached internally per each instance of the original [continuation].</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]</span></span><br><span class="line"><span class="comment">     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously</span></span><br><span class="line"><span class="comment">     * returned a different continuation instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked for the continuation instance returned by [interceptContinuation] when the original</span></span><br><span class="line"><span class="comment">     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]</span></span><br><span class="line"><span class="comment">     * had returned a different continuation instance from the one it was invoked with.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Default implementation does nothing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> continuation Continuation instance returned by this interceptor&#x27;s [interceptContinuation] invocation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">releaseInterceptedContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">/* do nothing by default */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : CoroutineContext.Element&gt;</span> <span class="title">get</span><span class="params">(key: <span class="type">CoroutineContext</span>.<span class="type">Key</span>&lt;<span class="type">E</span>&gt;)</span></span>: E? &#123;</span><br><span class="line">        <span class="comment">// getPolymorphicKey specialized for ContinuationInterceptor key</span></span><br><span class="line">        <span class="meta">@OptIn(ExperimentalStdlibApi::class)</span></span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">is</span> AbstractCoroutineContextKey&lt;*, *&gt;) &#123;</span><br><span class="line">            <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (key.isSubKey(<span class="keyword">this</span>.key)) key.tryCast(<span class="keyword">this</span>) <span class="keyword">as</span>? E <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (ContinuationInterceptor === key) <span class="keyword">this</span> <span class="keyword">as</span> E <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">minusKey</span><span class="params">(key: <span class="type">CoroutineContext</span>.<span class="type">Key</span>&lt;*&gt;)</span></span>: CoroutineContext &#123;</span><br><span class="line">        <span class="comment">// minusPolymorphicKey specialized for ContinuationInterceptor key</span></span><br><span class="line">        <span class="meta">@OptIn(ExperimentalStdlibApi::class)</span></span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">is</span> AbstractCoroutineContextKey&lt;*, *&gt;) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (key.isSubKey(<span class="keyword">this</span>.key) &amp;&amp; key.tryCast(<span class="keyword">this</span>) != <span class="literal">null</span>) EmptyCoroutineContext <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (ContinuationInterceptor === key) EmptyCoroutineContext <span class="keyword">else</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它继承自 <code>CoroutineContext.Element</code>,那么它就可以被当做一个<code>元素</code>放入到 CorontineContext 中了，并且可以使用 Key ：ContinuationInterceptor.Key 来查询或者判断指定context 是否是包括（或者本身就是）ContinuationInterceptor 。</p>
<p>注意额外的在 ContinuationInterceptor 中增加了:interceptContinuation() 方法，它接收一个 Continuation 对象，并返回一个 Continuation ，这个方法也就是 ContinuationInterceptor 的核心了：拦截。</p>
<p>ContinuationInterceptor 的实现类比较多，这里先只贴出来其部分实现的类图：</p>
<p><img src="/ff74222f/pic_01.png" alt="pic_01.png"></p>
<p>从上往下看其实有好多分支，所以可以从子类往父类去看。即从 Dispatchers 中开始分析:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatchers.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">object</span> Dispatchers &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default [CoroutineDispatcher] that is used by all standard builders like</span></span><br><span class="line"><span class="comment">     * [launch][CoroutineScope.launch], [async][CoroutineScope.async], etc.</span></span><br><span class="line"><span class="comment">     * if no dispatcher nor any other [ContinuationInterceptor] is specified in their context.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is backed by a shared pool of threads on JVM. By default, the maximal level of parallelism used</span></span><br><span class="line"><span class="comment">     * by this dispatcher is equal to the number of CPU cores, but is at least two.</span></span><br><span class="line"><span class="comment">     * Level of parallelism X guarantees that no more than X tasks can be executed in this dispatcher in parallel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Default: CoroutineDispatcher = DefaultScheduler</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A coroutine dispatcher that is confined to the Main thread operating with UI objects.</span></span><br><span class="line"><span class="comment">     * This dispatcher can be used either directly or via [MainScope] factory.</span></span><br><span class="line"><span class="comment">     * Usually such dispatcher is single-threaded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Access to this property may throw [IllegalStateException] if no main thread dispatchers are present in the classpath.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Depending on platform and classpath it can be mapped to different dispatchers:</span></span><br><span class="line"><span class="comment">     * - On JS and Native it is equivalent of [Default] dispatcher.</span></span><br><span class="line"><span class="comment">     * - On JVM it is either Android main thread dispatcher, JavaFx or Swing EDT dispatcher. It is chosen by</span></span><br><span class="line"><span class="comment">     *   [`ServiceLoader`](https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In order to work with `Main` dispatcher, the following artifacts should be added to project runtime dependencies:</span></span><br><span class="line"><span class="comment">     *  - `kotlinx-coroutines-android` for Android Main thread dispatcher</span></span><br><span class="line"><span class="comment">     *  - `kotlinx-coroutines-javafx` for JavaFx Application thread dispatcher</span></span><br><span class="line"><span class="comment">     *  - `kotlinx-coroutines-swing` for Swing EDT dispatcher</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In order to set a custom `Main` dispatcher for testing purposes, add the `kotlinx-coroutines-test` artifact to </span></span><br><span class="line"><span class="comment">     * project test dependencies.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Implementation note: [MainCoroutineDispatcher.immediate] is not supported on Native and JS platforms.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Main: MainCoroutineDispatcher <span class="keyword">get</span>() = MainDispatcherLoader.dispatcher</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A coroutine dispatcher that is not confined to any specific thread.</span></span><br><span class="line"><span class="comment">     * It executes initial continuation of the coroutine in the current call-frame</span></span><br><span class="line"><span class="comment">     * and lets the coroutine resume in whatever thread that is used by the corresponding suspending function, without</span></span><br><span class="line"><span class="comment">     * mandating any specific threading policy. Nested coroutines launched in this dispatcher form an event-loop to avoid</span></span><br><span class="line"><span class="comment">     * stack overflows.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ### Event loop</span></span><br><span class="line"><span class="comment">     * Event loop semantics is a purely internal concept and have no guarantees on the order of execution</span></span><br><span class="line"><span class="comment">     * except that all queued coroutines will be executed on the current thread in the lexical scope of the outermost</span></span><br><span class="line"><span class="comment">     * unconfined coroutine.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, the following code:</span></span><br><span class="line"><span class="comment">     * ```</span></span><br><span class="line"><span class="comment">     * withContext(Dispatchers.Unconfined) &#123;</span></span><br><span class="line"><span class="comment">     *    println(1)</span></span><br><span class="line"><span class="comment">     *    withContext(Dispatchers.Unconfined) &#123; // Nested unconfined</span></span><br><span class="line"><span class="comment">     *        println(2)</span></span><br><span class="line"><span class="comment">     *    &#125;</span></span><br><span class="line"><span class="comment">     *    println(3)</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * println(&quot;Done&quot;)</span></span><br><span class="line"><span class="comment">     * ```</span></span><br><span class="line"><span class="comment">     * Can print both &quot;1 2 3&quot; and &quot;1 3 2&quot;, this is an implementation detail that can be changed.</span></span><br><span class="line"><span class="comment">     * But it is guaranteed that &quot;Done&quot; will be printed only when both `withContext` are completed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that if you need your coroutine to be confined to a particular thread or a thread-pool after resumption,</span></span><br><span class="line"><span class="comment">     * but still want to execute it in the current call-frame until its first suspension, then you can use</span></span><br><span class="line"><span class="comment">     * an optional [CoroutineStart] parameter in coroutine builders like</span></span><br><span class="line"><span class="comment">     * [launch][CoroutineScope.launch] and [async][CoroutineScope.async] setting it to</span></span><br><span class="line"><span class="comment">     * the value of [CoroutineStart.UNDISPATCHED].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">actual</span> <span class="keyword">val</span> Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The [CoroutineDispatcher] that is designed for offloading blocking IO tasks to a shared pool of threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Additional threads in this pool are created and are shutdown on demand.</span></span><br><span class="line"><span class="comment">     * The number of threads used by tasks in this dispatcher is limited by the value of</span></span><br><span class="line"><span class="comment">     * &quot;`kotlinx.coroutines.io.parallelism`&quot; ([IO_PARALLELISM_PROPERTY_NAME]) system property.</span></span><br><span class="line"><span class="comment">     * It defaults to the limit of 64 threads or the number of cores (whichever is larger).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ### Elasticity for limited parallelism</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * `Dispatchers.IO` has a unique property of elasticity: its views</span></span><br><span class="line"><span class="comment">     * obtained with [CoroutineDispatcher.limitedParallelism] are</span></span><br><span class="line"><span class="comment">     * not restricted by the `Dispatchers.IO` parallelism. Conceptually, there is</span></span><br><span class="line"><span class="comment">     * a dispatcher backed by an unlimited pool of threads, and both `Dispatchers.IO`</span></span><br><span class="line"><span class="comment">     * and views of `Dispatchers.IO` are actually views of that dispatcher. In practice</span></span><br><span class="line"><span class="comment">     * this means that, despite not abiding by `Dispatchers.IO`&#x27;s parallelism</span></span><br><span class="line"><span class="comment">     * restrictions, its views share threads and resources with it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In the following example</span></span><br><span class="line"><span class="comment">     * ```</span></span><br><span class="line"><span class="comment">     * // 100 threads for MySQL connection</span></span><br><span class="line"><span class="comment">     * val myMysqlDbDispatcher = Dispatchers.IO.limitedParallelism(100)</span></span><br><span class="line"><span class="comment">     * // 60 threads for MongoDB connection</span></span><br><span class="line"><span class="comment">     * val myMongoDbDispatcher = Dispatchers.IO.limitedParallelism(60)</span></span><br><span class="line"><span class="comment">     * ```</span></span><br><span class="line"><span class="comment">     * the system may have up to `64 + 100 + 60` threads dedicated to blocking tasks during peak loads,</span></span><br><span class="line"><span class="comment">     * but during its steady state there is only a small number of threads shared</span></span><br><span class="line"><span class="comment">     * among `Dispatchers.IO`, `myMysqlDbDispatcher` and `myMongoDbDispatcher`.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ### Implementation note</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This dispatcher and its views share threads with the [Default][Dispatchers.Default] dispatcher, so using</span></span><br><span class="line"><span class="comment">     * `withContext(Dispatchers.IO) &#123; ... &#125;` when already running on the [Default][Dispatchers.Default]</span></span><br><span class="line"><span class="comment">     * dispatcher typically does not lead to an actual switching to another thread. In such scenarios,</span></span><br><span class="line"><span class="comment">     * the underlying implementation attempts to keep the execution on the same thread on a best-effort basis.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * As a result of thread sharing, more than 64 (default parallelism) threads can be created (but not used)</span></span><br><span class="line"><span class="comment">     * during operations over IO dispatcher.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> IO: CoroutineDispatcher = DefaultIoScheduler</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shuts down built-in dispatchers, such as [Default] and [IO],</span></span><br><span class="line"><span class="comment">     * stopping all the threads associated with them and making them reject all new tasks.</span></span><br><span class="line"><span class="comment">     * Dispatcher used as a fallback for time-related operations (`delay`, `withTimeout`)</span></span><br><span class="line"><span class="comment">     * and to handle rejected tasks from other dispatchers is also shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is a **delicate** API. It is not supposed to be called from a general</span></span><br><span class="line"><span class="comment">     * application-level code and its invocation is irreversible.</span></span><br><span class="line"><span class="comment">     * The invocation of shutdown affects most of the coroutines machinery and</span></span><br><span class="line"><span class="comment">     * leaves the coroutines framework in an inoperable state.</span></span><br><span class="line"><span class="comment">     * The shutdown method should only be invoked when there are no pending tasks or active coroutines.</span></span><br><span class="line"><span class="comment">     * Otherwise, the behavior is unspecified: the call to `shutdown` may throw an exception without completing</span></span><br><span class="line"><span class="comment">     * the shutdown, or it may finish successfully, but the remaining jobs will be in a permanent dormant state,</span></span><br><span class="line"><span class="comment">     * never completing nor executing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The main goal of the shutdown is to stop all background threads associated with the coroutines</span></span><br><span class="line"><span class="comment">     * framework in order to make kotlinx.coroutines classes unloadable by Java Virtual Machine.</span></span><br><span class="line"><span class="comment">     * It is only recommended to be used in containerized environments (OSGi, Gradle plugins system,</span></span><br><span class="line"><span class="comment">     * IDEA plugins) at the end of the container lifecycle.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        DefaultExecutor.shutdown()</span><br><span class="line">        <span class="comment">// Also shuts down Dispatchers.IO</span></span><br><span class="line">        DefaultScheduler.shutdown()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 Dispatchers 中共四种调度器，他们都是 <code>CoroutineDispatcher</code>的子类。其中常用的是有三种：<code>Default</code>、<code>Main</code>和<code>IO</code> 。</p>
<h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h3><p><code>Dispatchers.Default</code>是默认的调度器类型，在前面讲过的 launch 方法中，如果没有显式传入 context 的话， 或者传入的context 中不存在拦截器的话，也会默认使用 Dispatchers.Default。</p>
<p>这里<code>Dispatchers.Default</code>实际返回的是：<code>DefaultScheduler</code>实例，该实例是一个 单例object 对象实例。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> DefaultScheduler : SchedulerCoroutineDispatcher(</span><br><span class="line">    CORE_POOL_SIZE, MAX_POOL_SIZE,</span><br><span class="line">    IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// Shuts down the dispatcher, used only by Dispatchers.shutdown()</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overridden in case anyone writes (Dispatchers.Default as ExecutorCoroutineDispatcher).close()</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> UnsupportedOperationException(<span class="string">&quot;Dispatchers.Default cannot be closed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;Dispatchers.Default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这一层实现中，它继承自 <code>SchedulerCoroutineDispatcher</code>类，此时指定了一些参数：</p>
<p>1、CORE_POOL_SIZE：</p>
<p>核心线程数，它的取值一般是把 可用核心数作为核心线程数的，但是会额外确保最终的最小值不能小于2</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> CORE_POOL_SIZE = systemProp(</span><br><span class="line">    <span class="string">&quot;kotlinx.coroutines.scheduler.core.pool.size&quot;</span>,</span><br><span class="line">    AVAILABLE_PROCESSORS.coerceAtLeast(<span class="number">2</span>), <span class="comment">// 把可用核心数作为核心线程数，但是确保其最小值不能小于2</span></span><br><span class="line">    minValue = CoroutineScheduler.MIN_SUPPORTED_POOL_SIZE</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>2、MAX_POOL_SIZE：</p>
<p>最大线程数。即 1^21-2 个线程，即最多两百万多个线程，可以近视认为它是无限的了。这里的 BLOCKING_SHIFT &#x3D; 21 后续会一直看到它。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">const</span> <span class="keyword">val</span> MAX_SUPPORTED_POOL_SIZE = (<span class="number">1</span> shl BLOCKING_SHIFT) - <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>3、IDLE_WORKER_KEEP_ALIVE_NS：</p>
<p>默认空闲线程存活时间</p>
<p>4、DEFAULT_SCHEDULER_NAME：</p>
<p>默认线程名</p>
<p>这些很容易就想到线程池，即这里配置的是线程池的核心线程数、最大线程数、线程存活时间、默认线程名等。而内部究竟是不是线程池还需要再接着往下看。</p>
<p>再往上继承自：<code>SchedulerCoroutineDispatcher</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">SchedulerCoroutineDispatcher</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> corePoolSize: <span class="built_in">Int</span> = CORE_POOL_SIZE,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> maxPoolSize: <span class="built_in">Int</span> = MAX_POOL_SIZE,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> idleWorkerKeepAliveNs: <span class="built_in">Long</span> = IDLE_WORKER_KEEP_ALIVE_NS,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> schedulerName: String = <span class="string">&quot;CoroutineScheduler&quot;</span>,</span><br><span class="line">) : ExecutorCoroutineDispatcher() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> executor: Executor</span><br><span class="line">        <span class="keyword">get</span>() = coroutineScheduler</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is variable for test purposes, so that we can reinitialize from clean state</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> coroutineScheduler = createScheduler()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个 CoroutineScheduler 实例，它同时实现了 Executor 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createScheduler</span><span class="params">()</span></span> =</span><br><span class="line">        CoroutineScheduler(corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际是分发到 CoroutineScheduler 中去处理</span></span><br><span class="line"><span class="comment">     * 注意这里只传入了 block ，所以其 dispatch 方法后面的两个参数都是默认值：即：</span></span><br><span class="line"><span class="comment">     * taskContext = NonBlockingContext,</span></span><br><span class="line"><span class="comment">     * tailDispatch = false</span></span><br><span class="line"><span class="comment">     * 即默认的实现是把 block 当做非阻塞task 来处理的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一般Default调度器调度的任务就是TASK_NON_BLOCKING，而IO调度器调度的任务就是TASK_PROBABLY_BLOCKING</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Unit</span> = coroutineScheduler.dispatch(block)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchYield</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Unit</span> =</span><br><span class="line">        coroutineScheduler.dispatch(block, tailDispatch = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchWithContext</span><span class="params">(block: <span class="type">Runnable</span>, context: <span class="type">TaskContext</span>, tailDispatch: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        coroutineScheduler.dispatch(block, context, tailDispatch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineScheduler.close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fot tests only</span></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">usePrivateScheduler</span><span class="params">()</span></span> &#123;</span><br><span class="line">        coroutineScheduler.shutdown(<span class="number">1_000L</span>)</span><br><span class="line">        coroutineScheduler = createScheduler()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for tests only</span></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">shutdown</span><span class="params">(timeout: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">        coroutineScheduler.shutdown(timeout)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for tests only</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">restore</span><span class="params">()</span></span> = usePrivateScheduler() <span class="comment">// recreate scheduler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，内部会先创建一个 <code>CoroutineScheduler</code> 实例，然后将入参核心线程数那些设置进去，并且内部的 exectuor 、coroutineScheduler属性使用的也是该 CoroutineScheduler 实例 。并且同时实现了 dispatch 方法，并将调度逻辑委托给<code>CoroutineScheduler</code> 实例去实现，所以说：<code>CoroutineScheduler</code> 是真正的逻辑承担者，主要逻辑也都在它内部实现。<code>CoroutineScheduler</code> 的话先按住不表，暂且把这个继承关系捋完。</p>
<p>再往后它实现的类是：<code>ExecutorCoroutineDispatcher</code>，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ExecutorCoroutineDispatcher</span>: <span class="type">CoroutineDispatcher</span>(), Closeable &#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@suppress</span> */</span></span><br><span class="line">    <span class="meta">@ExperimentalStdlibApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : AbstractCoroutineContextKey&lt;CoroutineDispatcher, ExecutorCoroutineDispatcher&gt;(</span><br><span class="line">        CoroutineDispatcher,</span><br><span class="line">        &#123; it <span class="keyword">as</span>? ExecutorCoroutineDispatcher &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Underlying executor of current [CoroutineDispatcher].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">val</span> executor: Executor</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this coroutine dispatcher and shuts down its executor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It may throw an exception if this dispatcher is global and cannot be closed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一层的实现可以保证其可以当做传统用的Java <code>Executor</code>来使用的，相当于是协程和Java异步api之间的桥梁了。</p>
<p>其中额外在 <code>ExecutorCoroutineDispatcher</code>中增加了 executor 属性供外部使用。而上面其父类<code>SchedulerCoroutineDispatcher</code>中对其做了实现，即统一使用<code>CoroutineScheduler</code> 实例。</p>
<p>再往后，就是 <code>CoroutineDispatcher</code> 了，该类直接实现了<code>ContinuationInterceptor</code>接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineDispatcher.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoroutineDispatcher</span> :</span><br><span class="line">    <span class="type">AbstractCoroutineContextElement</span>(ContinuationInterceptor), ContinuationInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@suppress</span> */</span></span><br><span class="line">    <span class="meta">@ExperimentalStdlibApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">companion</span> <span class="keyword">object</span> Key : AbstractCoroutineContextKey&lt;ContinuationInterceptor, CoroutineDispatcher&gt;(</span><br><span class="line">        ContinuationInterceptor,</span><br><span class="line">        &#123; it <span class="keyword">as</span>? CoroutineDispatcher &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns `true` if the execution of the coroutine should be performed with [dispatch] method.</span></span><br><span class="line"><span class="comment">     * The default behavior for most dispatchers is to return `true`.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If this method returns `false`, the coroutine is resumed immediately in the current thread,</span></span><br><span class="line"><span class="comment">     * potentially forming an event-loop to prevent stack overflows.</span></span><br><span class="line"><span class="comment">     * The event loop is an advanced topic and its implications can be found in [Dispatchers.Unconfined] documentation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The [context] parameter represents the context of the coroutine that is being dispatched,</span></span><br><span class="line"><span class="comment">     * or [EmptyCoroutineContext] if a non-coroutine-specific [Runnable] is dispatched instead.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A dispatcher can override this method to provide a performance optimization and avoid paying a cost of an unnecessary dispatch.</span></span><br><span class="line"><span class="comment">     * E.g. [MainCoroutineDispatcher.immediate] checks whether we are already in the required UI thread in this method and avoids</span></span><br><span class="line"><span class="comment">     * an additional dispatch when it is not required.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * While this approach can be more efficient, it is not chosen by default to provide a consistent dispatching behaviour</span></span><br><span class="line"><span class="comment">     * so that users won&#x27;t observe unexpected and non-consistent order of events by default.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Coroutine builders like [launch][CoroutineScope.launch] and [async][CoroutineScope.async] accept an optional [CoroutineStart]</span></span><br><span class="line"><span class="comment">     * parameter that allows one to optionally choose the [undispatched][CoroutineStart.UNDISPATCHED] behavior to start coroutine immediately,</span></span><br><span class="line"><span class="comment">     * but to be resumed only in the provided dispatcher.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method should generally be exception-safe. An exception thrown from this method</span></span><br><span class="line"><span class="comment">     * may leave the coroutines that use this dispatcher in the inconsistent and hard to debug state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> dispatch</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Dispatchers.Unconfined</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意默认这是返回 true 的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">isDispatchNeeded</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a view of the current dispatcher that limits the parallelism to the given [value][parallelism].</span></span><br><span class="line"><span class="comment">     * The resulting view uses the original dispatcher for execution, but with the guarantee that</span></span><br><span class="line"><span class="comment">     * no more than [parallelism] coroutines are executed at the same time.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method does not impose restrictions on the number of views or the total sum of parallelism values,</span></span><br><span class="line"><span class="comment">     * each view controls its own parallelism independently with the guarantee that the effective parallelism</span></span><br><span class="line"><span class="comment">     * of all views cannot exceed the actual parallelism of the original dispatcher.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ### Limitations</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The default implementation of `limitedParallelism` does not support direct dispatchers,</span></span><br><span class="line"><span class="comment">     * such as executing the given runnable in place during [dispatch] calls.</span></span><br><span class="line"><span class="comment">     * Any dispatcher that may return `false` from [isDispatchNeeded] is considered direct.</span></span><br><span class="line"><span class="comment">     * For direct dispatchers, it is recommended to override this method</span></span><br><span class="line"><span class="comment">     * and provide a domain-specific implementation or to throw an [UnsupportedOperationException].</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ### Example of usage</span></span><br><span class="line"><span class="comment">     * ```</span></span><br><span class="line"><span class="comment">     * private val backgroundDispatcher = newFixedThreadPoolContext(4, &quot;App Background&quot;)</span></span><br><span class="line"><span class="comment">     * // At most 2 threads will be processing images as it is really slow and CPU-intensive</span></span><br><span class="line"><span class="comment">     * private val imageProcessingDispatcher = backgroundDispatcher.limitedParallelism(2)</span></span><br><span class="line"><span class="comment">     * // At most 3 threads will be processing JSON to avoid image processing starvation</span></span><br><span class="line"><span class="comment">     * private val jsonProcessingDispatcher = backgroundDispatcher.limitedParallelism(3)</span></span><br><span class="line"><span class="comment">     * // At most 1 thread will be doing IO</span></span><br><span class="line"><span class="comment">     * private val fileWriterDispatcher = backgroundDispatcher.limitedParallelism(1)</span></span><br><span class="line"><span class="comment">     * ```</span></span><br><span class="line"><span class="comment">     * Note how in this example the application has an executor with 4 threads, but the total sum of all limits</span></span><br><span class="line"><span class="comment">     * is 6. Still, at most 4 coroutines can be executed simultaneously as each view limits only its own parallelism.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that this example was structured in such a way that it illustrates the parallelism guarantees.</span></span><br><span class="line"><span class="comment">     * In practice, it is usually better to use [Dispatchers.IO] or [Dispatchers.Default] instead of creating a</span></span><br><span class="line"><span class="comment">     * `backgroundDispatcher`. It is both possible and advised to call `limitedParallelism` on them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExperimentalCoroutinesApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">limitedParallelism</span><span class="params">(parallelism: <span class="type">Int</span>)</span></span>: CoroutineDispatcher &#123;</span><br><span class="line">        parallelism.checkParallelism()</span><br><span class="line">        <span class="keyword">return</span> LimitedDispatcher(<span class="keyword">this</span>, parallelism)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Requests execution of a runnable [block].</span></span><br><span class="line"><span class="comment">     * The dispatcher guarantees that [block] will eventually execute, typically by dispatching it to a thread pool,</span></span><br><span class="line"><span class="comment">     * using a dedicated thread, or just executing the block in place.</span></span><br><span class="line"><span class="comment">     * The [context] parameter represents the context of the coroutine that is being dispatched,</span></span><br><span class="line"><span class="comment">     * or [EmptyCoroutineContext] if a non-coroutine-specific [Runnable] is dispatched instead.</span></span><br><span class="line"><span class="comment">     * Implementations may use [context] for additional context-specific information,</span></span><br><span class="line"><span class="comment">     * such as priority, whether the dispatched coroutine can be invoked in place,</span></span><br><span class="line"><span class="comment">     * coroutine name, and additional diagnostic elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method should guarantee that the given [block] will be eventually invoked,</span></span><br><span class="line"><span class="comment">     * otherwise the system may reach a deadlock state and never leave it.</span></span><br><span class="line"><span class="comment">     * The cancellation mechanism is transparent for [CoroutineDispatcher] and is managed by [block] internals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method should generally be exception-safe. An exception thrown from this method</span></span><br><span class="line"><span class="comment">     * may leave the coroutines that use this dispatcher in an inconsistent and hard-to-debug state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method must not immediately call [block]. Doing so may result in `StackOverflowError`</span></span><br><span class="line"><span class="comment">     * when `dispatch` is invoked repeatedly, for example when [yield] is called in a loop.</span></span><br><span class="line"><span class="comment">     * In order to execute a block in place, it is required to return `false` from [isDispatchNeeded]</span></span><br><span class="line"><span class="comment">     * and delegate the `dispatch` implementation to `Dispatchers.Unconfined.dispatch` in such cases.</span></span><br><span class="line"><span class="comment">     * To support this, the coroutines machinery ensures in-place execution and forms an event-loop to</span></span><br><span class="line"><span class="comment">     * avoid unbound recursion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> isDispatchNeeded</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Dispatchers.Unconfined</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dispatches execution of a runnable `block` onto another thread in the given `context`</span></span><br><span class="line"><span class="comment">     * with a hint for the dispatcher that the current dispatch is triggered by a [yield] call, so that the execution of this</span></span><br><span class="line"><span class="comment">     * continuation may be delayed in favor of already dispatched coroutines.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Though the `yield` marker may be passed as a part of [context], this</span></span><br><span class="line"><span class="comment">     * is a separate method for performance reasons.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@suppress</span> **This an internal API and should not be used from general code.**</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InternalCoroutinesApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchYield</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Unit</span> = dispatch(context, block)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a continuation that wraps the provided [continuation], thus intercepting all resumptions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method should generally be exception-safe. An exception thrown from this method</span></span><br><span class="line"><span class="comment">     * may leave the coroutines that use this dispatcher in the inconsistent and hard to debug state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">        DispatchedContinuation(<span class="keyword">this</span>, continuation)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">releaseInterceptedContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;*&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Unconditional cast is safe here: we only return DispatchedContinuation from `interceptContinuation`,</span></span><br><span class="line"><span class="comment">         * any ClassCastException can only indicate compiler bug</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> dispatched = continuation <span class="keyword">as</span> DispatchedContinuation&lt;*&gt;</span><br><span class="line">        dispatched.release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@suppress</span> **Error**: Operator &#x27;+&#x27; on two CoroutineDispatcher objects is meaningless.</span></span><br><span class="line"><span class="comment">     * CoroutineDispatcher is a coroutine context element and `+` is a set-sum operator for coroutine contexts.</span></span><br><span class="line"><span class="comment">     * The dispatcher to the right of `+` just replaces the dispatcher to the left.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;DeprecatedCallableAddReplaceWith&quot;</span>)</span></span><br><span class="line">    <span class="meta">@Deprecated(</span></span><br><span class="line"><span class="meta">        message = <span class="string">&quot;Operator &#x27;+&#x27; on two CoroutineDispatcher objects is meaningless. &quot;</span> +</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;CoroutineDispatcher is a coroutine context element and `+` is a set-sum operator for coroutine contexts. &quot;</span> +</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;The dispatcher to the right of `+` just replaces the dispatcher to the left.&quot;</span>,</span></span><br><span class="line"><span class="meta">        level = DeprecationLevel.ERROR</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">CoroutineDispatcher</span>)</span></span>: CoroutineDispatcher = other</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@suppress</span> for nicer debugging */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String = <span class="string">&quot;<span class="variable">$classSimpleName</span>@<span class="variable">$hexAddress</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部有如下需要关注的点：</p>
<p>1、实现了来自父接口<code>ContinuationInterceptor</code>接口的<code>interceptContinuation</code>方法，并且将其标记为final：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    DispatchedContinuation(<span class="keyword">this</span>, continuation)</span><br></pre></td></tr></table></figure>

<p>即统一将原协程Continuation对象实例包装成<code>interceptContinuation</code> 实例返回。这里只需要记住这里返回的统一是：DispatchedContinuation 实例，而且该实例在内部把：Dispatchers.Default和原continuation保存在其内部了。这里使用 Dispatchers.Default 表示的其实就是 this，因为当前是以 Dispatchers.Default 为具体示例在分析的。</p>
<p>2、新增了 dispatch 方法，接收两个入参：</p>
<p>CoroutineContext：该协程代码逻辑对应的上下文，比如当启动协程时会指定一个协程上下文。可以通过这个拿到这个即将被调度的协程相关的信息。</p>
<p>Runnable ：即将要被调度的协程逻辑包装实例。这里是Runnbale ，其实一般都是 DispatchedTask ，它间接实现了 Runnbale 接口。</p>
<p>这个方法是抽象的，等待子类来实现，比如上面<code>SchedulerCoroutineDispatcher</code>子类中就实现了该方法，并将其实际逻辑都扔给了 <code>CoroutineScheduler</code> 去做。</p>
<p>3、新增了 isDispatchNeeded() 方法，并且提供了默认实现返回 true 。即默认需要 dispatch 调度。</p>
<p>这里再往下就是<code>ContinuationInterceptor</code>了，上面讲过了。</p>
<p>看完这一系列的继承关系之后，接下来看之前讲过的启动协程中的一部分：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatcherContinuation.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Unit</span> = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是 DispatchedContinuation 则单独走 resumeCancellableWith 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意第二个参数其默认值是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">is</span> DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)</span><br><span class="line">    <span class="keyword">else</span> -&gt; resumeWith(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面讲到协程启动时，在 startCoroutineCancellable 方法内会执行三步：</p>
<p>1、二次创建SuspendLambda子类实例</p>
<p>2、调用其 intercepted 方法返回一个 DispatchedContinuation 实例，该实例内部包装了此时通过上下文设置的具体的一个 Dispatcher（比如 Dispatchers.Default）和上面第一步创建的SuspendLambda子类实例(此时是将其当做 Continuation 类型的)。</p>
<p>3、调用其 resumeCancellableWith 方法来启动协程。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatcherContinuation.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Unit</span> = <span class="keyword">when</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是 DispatchedContinuation 则单独走 resumeCancellableWith 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意第二个参数其默认值是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">is</span> DispatchedContinuation -&gt; resumeCancellableWith(result, onCancellation)</span><br><span class="line">    <span class="keyword">else</span> -&gt; resumeWith(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行到这里</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如上，这里的 dispatcher就是创建 DispatchedContinuation 实例时保存的调度器实例，比如 Dispatchers.Default(后续都以Dispatchers.Default 为例)。这里的 isDispatchNeeded &#x3D; true，然后将当前 this 作为 Runnbale 扔到 Dispatchers.Default 中去 dispatch 调度。在看接下来的逻辑之前，先看看：DispatchedContinuation ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatchedContinuation.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">DispatchedContinuation</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> dispatcher: CoroutineDispatcher,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;</span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;PropertyName&quot;</span>)</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _state: Any? = UNDEFINED</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现自父类 DispatchedTask ，父类在run方法内会使用到它来获取到当前类</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> delegate: Continuation&lt;T&gt;</span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> context = continuation.context</span><br><span class="line">        <span class="keyword">val</span> state = result.toState()</span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_ATOMIC</span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeUnconfined(state, MODE_ATOMIC) &#123;</span><br><span class="line">                withCoroutineContext(<span class="keyword">this</span>.context, countOrElement) &#123;</span><br><span class="line">                    continuation.resumeWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We inline it to save an entry on the stack in cases where it shows (unconfined dispatcher)</span></span><br><span class="line">    <span class="comment">// It is used only in Continuation&lt;T&gt;.resumeCancellableWith</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;NOTHING_TO_INLINE&quot;</span>)</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeCancellableWith</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">noinline</span> onCancellation: ((<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> state = result.toState(onCancellation)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否需要调度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_CANCELLABLE</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将当前 DispatchedContinuation 当做 task 来进行分发</span></span><br><span class="line"><span class="comment">             * 这个 dispatcher 可能是 Dispatchers.Default 之类的</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resumeCancelled(state)) &#123;</span><br><span class="line">                    resumeUndispatchedWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// DispatchedTask.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DispatchedTask</span>&lt;<span class="type">in T</span>&gt;(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">public</span> <span class="keyword">var</span> resumeMode: <span class="built_in">Int</span></span><br><span class="line">) : SchedulerTask() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存该 task 代理的  Continuation ,</span></span><br><span class="line"><span class="comment">     * 后期在当前 task run 方法中会执行它的 resumeWith 方法来将其内部代码逻辑恢复执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">val</span> delegate: Continuation&lt;T&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">takeState</span><span class="params">()</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承自 Task 接口的 run 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        assert &#123; resumeMode != MODE_UNINITIALIZED &#125; <span class="comment">// should have been set before dispatching</span></span><br><span class="line">        <span class="keyword">val</span> taskContext = <span class="keyword">this</span>.taskContext</span><br><span class="line">        <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> delegate = delegate <span class="keyword">as</span> DispatchedContinuation&lt;T&gt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 拿到之前在 intercept 方法中创建 DispatchedContinuation 实例保存的那个  continuation 实例</span></span><br><span class="line"><span class="comment">             * 可以理解为是编译器生成的中间类，比如是 Demo01Kt$main$1 实例</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">val</span> continuation = delegate.continuation</span><br><span class="line"></span><br><span class="line">            withContinuationContext(continuation, delegate.countOrElement) &#123;</span><br><span class="line">                <span class="keyword">val</span> context = continuation.context</span><br><span class="line">                <span class="keyword">val</span> state = takeState() <span class="comment">// <span class="doctag">NOTE:</span> Must take state in any case, even if cancelled</span></span><br><span class="line">                <span class="keyword">val</span> exception = getExceptionalResult(state)</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Check whether continuation was originally resumed with an exception.</span></span><br><span class="line"><span class="comment">                 * If so, it dominates cancellation, otherwise the original exception</span></span><br><span class="line"><span class="comment">                 * will be silently lost.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">val</span> job = <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 此时如果该任务已经被取消了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (job != <span class="literal">null</span> &amp;&amp; !job.isActive) &#123;</span><br><span class="line">                    <span class="keyword">val</span> cause = job.getCancellationException()</span><br><span class="line">                    cancelCompletedResult(state, cause)</span><br><span class="line">                    continuation.resumeWithStackTrace(cause)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                        continuation.resumeWithException(exception)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 接着执行该 continuation 。这里会执行到 BaseContinuationImpl 中去</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        continuation.resume(getSuccessfulResult(state))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            <span class="comment">// This instead of runCatching to have nicer stacktrace and debug experience</span></span><br><span class="line">            fatalException = e</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;</span><br><span class="line">            handleFatalException(fatalException, result.exceptionOrNull())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SchedulerTask.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">actual</span> <span class="keyword">typealias</span> SchedulerTask = Task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tasks.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Task</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> submissionTime: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">var</span> taskContext: TaskContext</span><br><span class="line">) : Runnable &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="number">0</span>, NonBlockingContext)</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">val</span> mode: <span class="built_in">Int</span> <span class="keyword">get</span>() = taskContext.taskMode <span class="comment">// TASK_XXX</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以看出，这里的 DispatchedContinuation 类实际是包装了原 continuation，然后通过内部Dispatcher调度之后，最终执行到其父类(也可以算是它自己的)run方法内，在其run方法内会执行原continuation的 resume 方法，从而恢复对原continuation中剩余代码逻辑的执行。</p>
<p>接着来看 Dispatchers.Default 中是怎么调度这个 Runnable 的，上面的 dispatch() 方法最终会调用到<code>SchedulerCoroutineDispatcher</code>中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher.kt 中的 SchedulerCoroutineDispatcher 类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span>: <span class="built_in">Unit</span> = coroutineScheduler.dispatch(block)</span><br></pre></td></tr></table></figure>

<h3 id="dispatch调度任务"><a href="#dispatch调度任务" class="headerlink" title="dispatch调度任务"></a>dispatch调度任务</h3><p>也就是到其内部的 <code>CoroutineScheduler</code>内：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineScheduler.kt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(block: <span class="type">Runnable</span>, taskContext: <span class="type">TaskContext</span> = NonBlockingContext, tailDispatch: <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">    trackTask() <span class="comment">// this is needed for virtual time support</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> task = createTask(block, taskContext)</span><br><span class="line">    <span class="comment">// try to submit the task to the local queue and act depending on the result</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、第一步先尝试将该任务添加到当前线程 Worker 中</span></span><br><span class="line"><span class="comment">     * 如果当前 thread 是 Worker(Worker 继承自 Thread),那么 currentWorker 不为 null</span></span><br><span class="line"><span class="comment">     * 如果 currentWorker 不为空，则将其加入到该 Worker 内部的 localQueue 队列中</span></span><br><span class="line"><span class="comment">     * 如果 currentWorker 为空的话，则 notAdded 不为空，后续会将其加入到全局队列中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> currentWorker = currentWorker()</span><br><span class="line">    <span class="keyword">val</span> notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、如果第一步添加失败的话，则需要将其加入到全局队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (notAdded != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!addToGlobalQueue(notAdded)) &#123;</span><br><span class="line">            <span class="comment">// Global queue is closed in the last step of close/shutdown -- no more tasks should be accepted</span></span><br><span class="line">            <span class="keyword">throw</span> RejectedExecutionException(<span class="string">&quot;<span class="variable">$schedulerName</span> was terminated&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> skipUnpark = tailDispatch &amp;&amp; currentWorker != <span class="literal">null</span></span><br><span class="line">    <span class="comment">// Checking &#x27;task&#x27; instead of &#x27;notAdded&#x27; is completely okay</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mode == TASK_NON_BLOCKING 表示其 taskContext 是 NonBlockingContext ，即：非阻塞CPU密集型任务</span></span><br><span class="line"><span class="comment">     * 则执行 signalCpuWork</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 否则如果是阻塞型任务，会执行 signalBlockingWork</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (task.mode == TASK_NON_BLOCKING) &#123;</span><br><span class="line">        <span class="keyword">if</span> (skipUnpark) <span class="keyword">return</span></span><br><span class="line">        signalCpuWork()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Increment blocking tasks anyway</span></span><br><span class="line">        signalBlockingWork(skipUnpark = skipUnpark)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createTask</span><span class="params">(block: <span class="type">Runnable</span>, taskContext: <span class="type">TaskContext</span>)</span></span>: Task &#123;</span><br><span class="line">    <span class="keyword">val</span> nanoTime = schedulerTimeSource.nanoTime() </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 block 是 DispatchedContinuation 时，它自然是继承自 Task 的。</span></span><br><span class="line"><span class="comment">     * 那么此时只需要修改其内部的属性即可。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (block <span class="keyword">is</span> Task) &#123;</span><br><span class="line">        block.submissionTime = nanoTime</span><br><span class="line">        block.taskContext = taskContext</span><br><span class="line">        <span class="keyword">return</span> block</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TaskImpl(block, nanoTime, taskContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">currentWorker</span><span class="params">()</span></span>: Worker? = (Thread.currentThread() <span class="keyword">as</span>? Worker)?.takeIf &#123; it.scheduler == <span class="keyword">this</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Worker?.<span class="title">submitToLocalQueue</span><span class="params">(task: <span class="type">Task</span>, tailDispatch: <span class="type">Boolean</span>)</span></span>: Task? &#123;</span><br><span class="line">    <span class="comment">// 如果当前线程不是 Worker 那么则不能添加进去，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> task</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This worker could have been already terminated from this thread by close/shutdown and it should not</span></span><br><span class="line"><span class="comment">     * accept any more tasks into its local queue.</span></span><br><span class="line"><span class="comment">     * 该 Worker 已被终止，不能使用了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (state === WorkerState.TERMINATED) <span class="keyword">return</span> task</span><br><span class="line">    <span class="comment">// Do not add CPU tasks in local queue if we are not able to execute it</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞型 worker 不可添加非阻塞型任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (task.mode == TASK_NON_BLOCKING &amp;&amp; state === WorkerState.BLOCKING) &#123;</span><br><span class="line">        <span class="keyword">return</span> task</span><br><span class="line">    &#125;</span><br><span class="line">    mayHaveLocalTasks = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> localQueue.add(task, fair = tailDispatch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">addToGlobalQueue</span><span class="params">(task: <span class="type">Task</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * task.isBlocking = true 即 taskContext=BlockingContext 时，加入到 globalBlockingQueue</span></span><br><span class="line"><span class="comment">     * 即阻塞型任务添加到 globalBlockingQueue</span></span><br><span class="line"><span class="comment">     * 非阻塞CPU密集型任务添加到 globalCpuQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (task.isBlocking) &#123;</span><br><span class="line">        globalBlockingQueue.addLast(task)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        globalCpuQueue.addLast(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到dispatch方法时，首先需要注意其入参 taskContext , 其默认值是NonBlockingContext 。</p>
<blockquote>
<p>从 Dispatchers.Default 调度过来的时候 taskContext 是默认值；而从Dispatchers.IO 调度过来的 taskContext 是 BlockingContext(详见：UnlimitedIoScheduler中dispatch方法) 。</p>
<p>也就是说，使用Default调度器调度的协程，其默认认为它是非阻塞型任务，即CPU密集型；而IO调度的默认认为它是阻塞型。</p>
</blockquote>
<p>所以dispatch()方法内部的逻辑主要分为如下几步：</p>
<p>1、调用 createTask 方法来创建一个Task实例，而此时 block 其实对应的是DispatchedContinuation 实例，它继承自Task，所以在 createTask 中只会修改 block 其内部的 taskContext 等属性为：NonBlockingContext 。</p>
<blockquote>
<p>这个属性设置之后，后续就可以通过 task.isBlocking 来判断该task 类型了。</p>
<p>如果是阻塞型任务(即其isBlocking&#x3D;true，也就是其taskContext&#x3D;BlockingContext)，则将其加入到 globalBlockingQueue 队列中；否则将其加入到 globalCpuQueue 中</p>
</blockquote>
<p>2、通过 currentWorker() 方法判断当前线程是否是 Worker 类型的，如果是普通线程则不满足，如果是 Worker 类型的线程则将其转换为 Worker 类型赋值给currentWorker变量。</p>
<blockquote>
<p>Worker类继承自 Thread 。这点和 JUC 线程池有点类似，它内部也存在一个 Worker，但是不同的是它并没有继承 Thread ，而是实现了 Runnable，内部包装了thread变量指向一个 Thread线程实例。</p>
</blockquote>
<p>所以说currentWorker可能为空。那么接下来调用 submitToLocalQueue 方法来尝试将该 Task 放入到该Worker内部队列 localQueue 中去。</p>
<p>该方法内部会额外有判断：如果该 Worker 当前是阻塞BLOCKING状态，但是Task是</p>
<p>TASK_NON_BLOCKING(即非阻塞CPU密集型任务)时，会直接返回。所以说 Worker 内部任务队列 localQueue 中存放的 Task，可能是TASK_NON_BLOCKING(即非阻塞CPU密集型任务)，也可能是TASK_PROBABLY_BLOCKING(阻塞型任务),即任何类型的Task都可以放入进去。</p>
<p>当然这一步可能添加失败，比如Worker为null，或者上面具体条件不满足等。那么会将要添加的task原封不动返回，即 submitToLocalQueue() 返回不为空。</p>
<p>3、判断前面将task添加到Worker内部队列失败的话，则调用 addToGlobalQueue() 方法将其添加到全局队列中去。因为全局队列有两个：globalBlockingQueue 和 globalCpuQueue ,到底添加到哪一个里面是根据Task.isBlocking 来决定的，而前面入参传入进来的 TaskContext 又决定了Task.isBlocking 的值。所以说如果是阻塞型任务则添加到 globalBlockingQueue 队列中，否则就是非阻塞CPU密集型任务，那么添加到 globalCpuQueue 中。他俩都是 GlobalQueue 类型，其内部会保证其操作时的线程安全。</p>
<p>4、根据Task类型是阻塞型还是非阻塞型来执行最后一步：唤醒(或创建)线程来执行这些任务。具体是非阻塞型任务通过 signalCpuWork() 方法，而阻塞型任务通过signalBlockingWork()。</p>
<p>先看signalCpuWork() 方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// CoroutineScheduler.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">signalCpuWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先尝试唤醒一个当前正处于空闲状态的 Worker 线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tryUnpark()) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面尝试唤醒一个休眠Worker失败了，有可能是没有处于park休眠状态的 Worker ，</span></span><br><span class="line"><span class="comment">     * 所以此时尝试创建一个新的 Worker ，创建成功了的话，则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tryCreateWorker()) <span class="keyword">return</span></span><br><span class="line">    tryUnpark()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 signalCpuWork() 方法中主要分为以下几步：</p>
<p>1、首先会调用 tryUnpark() 方法来尝试 Unpark 即唤醒一个处于Park状态的Worker线程：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineScheduler.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryUnpark</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是 while true 会一直尝试找一个可用的Worker 线程来进行unpark唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从当前休眠的线程 Worker 栈parkedWorkersStack中弹出栈顶worker</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> worker = parkedWorkersStackPop() ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上面 parkedWorkersStackPop 中弹出 Worker 之后并没有修改其状态，</span></span><br><span class="line"><span class="comment">         * 只是修改了其 nextParkedWorker = NOT_IN_STACK</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 所以这里接着将其 Worker 状态从 PARKED 改为 CLAIMED ，然后将其 unpark 掉</span></span><br><span class="line"><span class="comment">         * 也就是将当前 Worker 线程唤醒</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (worker.workerCtl.compareAndSet(PARKED, CLAIMED)) &#123;</span><br><span class="line">            LockSupport.unpark(worker)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parkedWorkersStackPop</span><span class="params">()</span></span>: Worker? &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * parkedWorkersStack 中存储着已经 park 的 Worker 索引等信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    parkedWorkersStack.loop &#123; top -&gt;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 详见 [parkedWorkersStackPush]</span></span><br><span class="line"><span class="comment">         * 这里取出栈顶的worker 索引，该索引是栈顶worker位于workers数组的索引</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> index = (top and PARKED_INDEX_MASK).toInt()</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 所以从workers数组中查到该 worker</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> worker = workers[index] ?: <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// stack is empty</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将其版本号自增1</span></span><br><span class="line"><span class="comment">         * 详见 [parkedWorkersStackPush]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> updVersion = (top + PARKED_VERSION_INC) and PARKED_VERSION_MASK</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拿到栈顶 worker 中存储的下一个worker 的索引（在workers数组中的索引）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> updIndex = parkedWorkersStackNextIndex(worker)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重试，返回索引不合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (updIndex &lt; <span class="number">0</span>) <span class="keyword">return</span><span class="symbol">@loop</span> <span class="comment">// retry</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Other thread can be changing this worker&#x27;s index at this point, but it</span></span><br><span class="line"><span class="comment">         * also invokes parkedWorkersStackTopUpdate which updates version to make next CAS fail.</span></span><br><span class="line"><span class="comment">         * Successful CAS of the stack top completes successful pop.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * updVersion 是自增完version之后的值</span></span><br><span class="line"><span class="comment">         * updIndex 是栈顶worker 中存储的下一个worker 的索引，也就是新的栈顶worker的索引</span></span><br><span class="line"><span class="comment">         * 将这俩值拼接成Long 之后设置给 top 也就是 parkedWorkersStack</span></span><br><span class="line"><span class="comment">         * 这里是自旋cas，设置失败的话会再次尝试</span></span><br><span class="line"><span class="comment">         * 设置成功的话则会将栈顶worker的  nextParkedWorker 置为 NOT_IN_STACK 表示其已经出栈了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (parkedWorkersStack.compareAndSet(top, updVersion or updIndex.toLong())) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * We&#x27;ve just took worker out of the stack, but nextParkerWorker is not reset yet, so if a worker is</span></span><br><span class="line"><span class="comment">             * currently invoking parkedWorkersStackPush it would think it is in the stack and bail out without</span></span><br><span class="line"><span class="comment">             * adding itself again. It does not matter, since we are going it invoke unpark on the thread</span></span><br><span class="line"><span class="comment">             * that was popped out of parkedWorkersStack anyway.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            worker.nextParkedWorker = NOT_IN_STACK</span><br><span class="line">            <span class="keyword">return</span> worker</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryUnpark 内部会一直自旋通过 parkedWorkersStackPop() 方法来找出一个当前处于Park状态的线程，然后将其状态从 PARKED 改为 CLAIMED 。</p>
<p>可以把休眠的 Worker 线程列表看做一个栈结构，栈顶 Worker 存储在parkedWorkersStack 属性内，更准确的来说是：栈顶Woker在workers数组中的索引会存储在parkedWorkersStack 属性内。</p>
<blockquote>
<p>workers：可以认为是一个数组，内部存储着当前创建的所有 Worker 实例，包括休眠中、运行中的。</p>
</blockquote>
<p>parkedWorkersStack ：可以认为是一个Long，不同的是它使用 atomic 包装着，可以认为是一个具有原子性操作特性的Long，可以执行无锁CAS操作。详见<a target="_blank" rel="noopener" href="https://github.com/Kotlin/kotlinx-atomicfu">https://github.com/Kotlin/kotlinx-atomicfu</a> 。</p>
<p>它作为一个Long来使用的话，内部会将其拆分为两部分来使用：1)低21位用来存储休眠Worker线程在workers数组中的索引值；</p>
<blockquote>
<p>PARKED_INDEX_MASK &#x3D; CREATED_MASK &#x3D; (1L shl BLOCKING_SHIFT) - 1 ；</p>
<p>并且：BLOCKING_SHIFT &#x3D; 21 ；</p>
<p>所以后续可以将parkedWorkersStack和PARKED_INDEX_MASK求与操作，求出parkedWorkersStack 低21位中存储的栈顶休眠Worker在workers数组中的索引值。</p>
<p>而这里使用的是 CREATED_MASK ，正好是可创建的最大 Worker线程数。</p>
</blockquote>
<p>2)剩余高位存储版本号。这是用来避免CAS中的ABA问题。即后续每次parkedWorkersStack 进行 pop(parkedWorkersStackPop方法)、push(parkedWorkersStackPop()方法)以及更新操作update(parkedWorkersStackTopUpdate()方法)时，也就是对其进行增删改操作时都会自增版本。</p>
<p>所以回到 tryUnpark() 方法，它内部找到一个Park线程时会将其unpark唤醒，此时会返回true，否则都是返回false。</p>
<p>执行完 tryUnpark() 方法，如果其内部成功唤醒了一个Worker，那么signalCpuWork()会直接返回，表示完事儿了，有线程去执行刚才的Task了；如果返回false时，表示唤醒Worker线程失败，则此时需要调用 tryCreateWorker</p>
<p>2、调用 tryCreateWorker()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryCreateWorker</span><span class="params">(state: <span class="type">Long</span> = controlState.value)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拿到当前已创建的 Worker 数和阻塞中 Task 数</span></span><br><span class="line"><span class="comment">     * 这里是从 controlState 内取的值，所以说 controlState 中对应位会存储这些数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> created = createdWorkers(state)</span><br><span class="line">    <span class="keyword">val</span> blocking = blockingTasks(state)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用当前已存在的 Worker线程数 减去阻塞中Task的数得到 cpuWorkers</span></span><br><span class="line"><span class="comment">     * 下面判断 cpuWorkers 是小于设置的核心线程数时，就会尝试一个新的 Worker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果阻塞的Task增多那么最终的cpuWorkers 就会减少，一直增多的话就可能会小于corePoolSize 此时会创建新的 Worker 来处理这些Task</span></span><br><span class="line"><span class="comment">     * 如果阻塞的Task减少了，那么会有Worker空闲等待，超过一定时间就会被终止掉，从而 created 数量会降下来</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * cpuWorkers 大于0 的话表示当前已创建的Worker线程数 大于 当前阻塞的Task 数</span></span><br><span class="line"><span class="comment">     * cpuWorkers 等于0 的话表示当前已创建的Worker线程数 小于等于 当前阻塞的Task 数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> cpuWorkers = (created - blocking).coerceAtLeast(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We check how many threads are there to handle non-blocking work,</span></span><br><span class="line"><span class="comment">     * and create one more if we have not enough of them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (cpuWorkers &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要创建新的Worker线程来处理这些过多的 Task 了</span></span><br><span class="line"><span class="comment">         * 返回的值 newCpuWorkers 就是创建Worker线程之后的 created - blocking 的值</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 比如原来： created = 2，blocking = 2 ，corePoolSize = 1，此时 cpuWorkers=0</span></span><br><span class="line"><span class="comment">         * 那么createNewWorker 创建成功之后返回的值就是：newCpuWorkers = 3-2 = 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> newCpuWorkers = createNewWorker()</span><br><span class="line">        <span class="comment">// If we&#x27;ve created the first cpu worker and corePoolSize &gt; 1 then create</span></span><br><span class="line">        <span class="comment">// one more (second) cpu worker, so that stealing between them is operational</span></span><br><span class="line">        <span class="keyword">if</span> (newCpuWorkers == <span class="number">1</span> &amp;&amp; corePoolSize &gt; <span class="number">1</span>) createNewWorker()</span><br><span class="line">        <span class="keyword">if</span> (newCpuWorkers &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CREATED_MASK 是一个 Long ，其中它的低21为都是1 ,其他位都是 0</span></span><br><span class="line"><span class="comment"> * 所以此时是取 state 中的低21 位的值，然后将其作为一个 int 返回，来代表当前已创建 Worker 线程数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">createdWorkers</span><span class="params">(state: <span class="type">Long</span>)</span></span>: <span class="built_in">Int</span> = (state and CREATED_MASK).toInt()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BLOCKING_MASK 是一个Long，它的低21位都是0 ，紧接着中间21位都是1，剩下的高位都是0 ，即：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0000 0000 0000 0000 0000 0011 1111 1111 1111 1111 1110 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以此时是取 state 中间21位的值，然后将结果 shr 右移BLOCKING_SHIFT(21位)，也就是取出中间21位的值作为int返回</span></span><br><span class="line"><span class="comment"> * 代表了当前阻塞中的 task 数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">blockingTasks</span><span class="params">(state: <span class="type">Long</span>)</span></span>: <span class="built_in">Int</span> = (state and BLOCKING_MASK shr BLOCKING_SHIFT).toInt()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createNewWorker</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    synchronized(workers) &#123;</span><br><span class="line">        <span class="comment">// Make sure we&#x27;re not trying to resurrect terminated scheduler</span></span><br><span class="line">        <span class="keyword">if</span> (isTerminated) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> state = controlState.value</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同样还是先获取已创建 Worker 线程数以及当前阻塞Task数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> created = createdWorkers(state)</span><br><span class="line">        <span class="keyword">val</span> blocking = blockingTasks(state)</span><br><span class="line">        <span class="comment">// 还是计算出两者的差值</span></span><br><span class="line">        <span class="keyword">val</span> cpuWorkers = (created - blocking).coerceAtLeast(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// Double check for overprovision</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里再次检查下其差值是否小于核心线程数，此时不满足条件的话就不创建Worker了</span></span><br><span class="line"><span class="comment">         * 同时大于最大线程数时当然也是不创建的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (cpuWorkers &gt;= corePoolSize) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (created &gt;= maxPoolSize) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">// start &amp; register new worker, commit index only after successful creation</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此时可以创建Worker了，那么先为该 Worker 计算出来它在 workers 数组中的索引</span></span><br><span class="line"><span class="comment">         * 即在当前 Worker线程数基础上加一，作为新 Worker 的索引</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> newIndex = createdWorkers + <span class="number">1</span></span><br><span class="line">        require(newIndex &gt; <span class="number">0</span> &amp;&amp; workers[newIndex] == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1) Claim the slot (under a lock) by the newly created worker</span></span><br><span class="line"><span class="comment">         * 2) Make it observable by increment created workers count</span></span><br><span class="line"><span class="comment">         * 3) Only then start the worker, otherwise it may miss its own creation</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.创建 Worker 对象，实际是创建一个 Thread ，因为 Worker 它继承自 Thread</span></span><br><span class="line"><span class="comment">         * 2.然后将其放入到 workers 数组中 newIndex 位置去</span></span><br><span class="line"><span class="comment">         * 3.调用 Thread.start 方法来启动该线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> worker = Worker(newIndex)</span><br><span class="line">        workers.setSynchronized(newIndex, worker)</span><br><span class="line">        <span class="comment">// 自增 controlState 中 createWork 数量</span></span><br><span class="line">        require(newIndex == incrementCreatedWorkers())</span><br><span class="line">        worker.start()</span><br><span class="line">        <span class="keyword">return</span> cpuWorkers + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析之前，先分析下<code>CoroutineScheduler</code>中的一些关键属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BLOCKING_SHIFT = <span class="number">21</span> <span class="comment">// 2M threads max</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shl 等价于java中的有符号左移操作： &lt;&lt; .</span></span><br><span class="line"><span class="comment"> * 1 shl 21 --&gt; 0000 0000 0010 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment"> * 然后减一之后的结果： 0000 0000 0001 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当然这里使用的是int 来举例的，即最多只用到了 4个字节(32 位) 但是这里的其实是 Long，也就是8个字节(64位)</span></span><br><span class="line"><span class="comment"> * 但是可以知道，这里的 CREATED_MASK 是低21位都是1，也就是Long 的低21位全部用来存储当前创建Worker线程数</span></span><br><span class="line"><span class="comment"> * 也就是做多可以有：2^21-1 = 2097151 个线程(也就是差不多两百万个)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以说 CREATED_MASK 其实就是一个 Long ，其中它的低21为都是1 而已。</span></span><br><span class="line"><span class="comment"> * 使用其他 Long 和他做与操作时，会剔除掉低21位之外的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> CREATED_MASK: <span class="built_in">Long</span> = (<span class="number">1L</span> shl BLOCKING_SHIFT) - <span class="number">1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shl 等价于java中的有符号左移操作： &lt;&lt;</span></span><br><span class="line"><span class="comment"> * 所以说这里是在 CREATED_MASK 基础上再左移21 位，</span></span><br><span class="line"><span class="comment"> * 那么此时最终结果是：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0000 0000 0000 0000 0000 0011 1111 1111 1111 1111 1110 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即 低21位是0 ，紧接着中间21位都是1，剩下的高位都是0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BLOCKING_MASK: <span class="built_in">Long</span> = CREATED_MASK shl BLOCKING_SHIFT</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 21 * 2 = 42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> CPU_PERMITS_SHIFT = BLOCKING_SHIFT * <span class="number">2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CREATED_MASK 其实就是一个 Long ，其中它的低21为都是1</span></span><br><span class="line"><span class="comment"> * 那么将其 左移 42 位的话，也就是：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0111 1111 1111 1111 1111 1100 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即低42位都是0，然后往左21位的高位都是1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以说 CREATED_MASK 、 BLOCKING_MASK 以及CPU_PERMITS_MASK 是将 Long(64位) 每21位一分割，分成三份</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> CPU_PERMITS_MASK = CREATED_MASK shl CPU_PERMITS_SHIFT</span><br></pre></td></tr></table></figure>

<p>1)workers: 可以简单认为是一个数组，内部存储着当前创建的所有 Worker 实例，包括休眠中、运行中的。</p>
<p>2)controlState:可以认为是一个线程安全的 Long 。这里会将其64位拆分为三部分来使用，如下图：</p>
<p><img src="/ff74222f/pic_02.png" alt="image.png"></p>
<p>这点和JUC 线程池中的 ctl 属性类似，这种位操作很常见。上述贴出来的CREATED_MASK、CPU_PERMITS_MASK那些都是为了操作不同 位段 的。</p>
<p>而其初始化值为：</p>
<p><code>corePoolSize.toLong() shl CPU_PERMITS_SHIFT</code> 。即将外部设置进来的核心线程数保存到 <code>CPU_PERMITS</code>区域内，等到后续调用 tryAcquireCpuPermit() 去获取CPU执行权时，会将其<code>对应区域内的值</code>自减1；tryReleaseCpu() 时会释放指定 Worker线程当前所拥有的CPU执行权，会将其<code>对应区域内的值</code>自增1。</p>
<blockquote>
<p>所以说，最多只会有 corePoolSize 个线程同时拥有CPU执行权。而 corePoolSize 外部设置的是CPU总核心数，多个核心可以通知运行多个同等数量的线程。</p>
<p>而获取到CPU执行权的线程在运行时，会优先执行非阻塞的CPU密集型任务，以提高CPU利用率，实际在kotlin协程中，如果一个线程获取到CPU执行权的话，会从随机的一个队列中弹出任务来执行，后续在执行的任务的时候判断如果它是阻塞型任务会先释放掉当前线程的CPU执行权再执行该阻塞任务，在释放CPU执行权之后会尝试再次唤醒一个线程。因为当前线程刚释放了CPU执行权那么就需要有一个新线程来获取该执行权名额。详见：beforeTask()方法</p>
<p>CPU密集型任务会重度使用CPU，比如一些复杂的计算工作。可以减少操作系统调度线程而产生的额外损耗，在操作系统分配给指定线程的时间片内尽可能让CPU满负荷运行。</p>
<p>而IO文件操作等阻塞型任务会让CPU一直等待耗时任务完成，这样CPU在其时间片内存在浪费的时间，从而CPU利用率低。</p>
</blockquote>
<p>回到tryCreateWorker()中，首先会从 controlState 中指定位段 读取出当前已创建的Worker线程总数created 和 当前的阻塞型任务数blocking。</p>
<p>然后使用 created 减去 blocking 就可以知道当前所有Worker中剩余的用来CPU密集型任务的Worker数了，叫做cpuWorkers。</p>
<blockquote>
<p>可以这样理解：所有执行CPU密集型任务的Worker + 所有执行阻塞型任务的Worker &#x3D; created 所有的Worker数。因为一个阻塞的Task可以认为是要占用一个线程去一直执行的。</p>
</blockquote>
<p>如果cpuWorkers数小于设置的核心线程数，那么则需要创建一个新的Worker，也就是优先填充新线程。</p>
<blockquote>
<p>该策略在JUC 线程池中也是一样的逻辑，当核心线程数不够时，优先创建新线程。</p>
</blockquote>
<p>接着就是执行 createNewWorker() 方法来进行实际的 Worker 创建流程。在创建新 Worker 时会加锁，保证线程安全。并且实际创建时会再次检查cpuWorkers数是否正确。然后创建一个新的Worker实例，并会执行如下三步：</p>
<p>1)将其放入到全局workers数组中，这里额外会将其在workers数组中的索引值保存到自身内部的indexInArray属性中供后续使用，</p>
<p>2)调用 incrementCreatedWorkers() 方法来自增 controlState 中固定位段 的值，表示新增了一个Worker。</p>
<p>3)启动该Worker线程</p>
<p>这就完成了Worker 的创建工作。如果内部成功创建Worker的话，那么 tryCreateWorker() 方法最终会返回 true 而终止掉 signalCpuWork() 方法；否则返回false 而接着去执行 tryUnpark()唤醒休眠线程 。</p>
<p>3、再次调用 tryUnpark() 来唤醒</p>
<p>当然这一步的调用前提是前面第2步 tryCreateWorker() 方法返回了false。那么此时没办法了，只能再试一次，看有没有此时处于休眠的Worker了，有的话就唤醒去处理任务。没有的话表示当前线程数很多，但是都没有休眠的，那么就等着吧，等他们哪个有空了就会去指定队列中找任务来执行的。反正现在要调度的任务Task已经成功的放到指定队列中了，就等消费者去消费就行了。</p>
<h3 id="run执行任务"><a href="#run执行任务" class="headerlink" title="run执行任务"></a>run执行任务</h3><p>由于Worker 继承自 Thread，所以当操作系统调度到该线程时，最终会执行其 run 方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineScheduler.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> = runWorker()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> rescanned = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 是否调用过 shutdown 方法</span></span><br><span class="line"><span class="comment">     * 2. 当前 Worker 是否已处于终止状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从对应的队列中查找拿出来一个 Task 来处理</span></span><br><span class="line"><span class="comment">         * mayHaveLocalTasks :默认是false，当dispatch 中成功将task提交到Worker内部时会将该Worker内部的该值置为true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">val</span> task = findTask(mayHaveLocalTasks)</span><br><span class="line">        <span class="comment">// Task found. Execute and repeat</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 找到一个可用的 Task 的话，则执行他</span></span><br><span class="line"><span class="comment">         * 执行完成之后，接着continue 循环处理下一个task</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">            rescanned = <span class="literal">false</span></span><br><span class="line">            minDelayUntilStealableTaskNs = <span class="number">0L</span></span><br><span class="line">            executeTask(task)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mayHaveLocalTasks = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No tasks were found:</span></span><br><span class="line"><span class="comment">         * 1) Either at least one of the workers has stealable task in its FIFO-buffer with a stealing deadline.</span></span><br><span class="line"><span class="comment">         *    Then its deadline is stored in [minDelayUntilStealableTask]</span></span><br><span class="line"><span class="comment">         * // &#x27;2)&#x27; can be found below</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Then just park for that duration (ditto re-scanning).</span></span><br><span class="line"><span class="comment">         * While it could potentially lead to short (up to WORK_STEALING_TIME_RESOLUTION_NS ns) starvations,</span></span><br><span class="line"><span class="comment">         * excess unparks and managing &quot;one unpark per signalling&quot; invariant become unfeasible, instead we are going to resolve</span></span><br><span class="line"><span class="comment">         * it with &quot;spinning via scans&quot; mechanism.</span></span><br><span class="line"><span class="comment">         * NB: this short potential parking does not interfere with `tryUnpark`</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (minDelayUntilStealableTaskNs != <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rescanned) &#123;</span><br><span class="line">                rescanned = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rescanned = <span class="literal">false</span></span><br><span class="line">                tryReleaseCpu(WorkerState.PARKING)</span><br><span class="line">                interrupted()</span><br><span class="line">                LockSupport.parkNanos(minDelayUntilStealableTaskNs)</span><br><span class="line">                minDelayUntilStealableTaskNs = <span class="number">0L</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2) Or no tasks available, time to park and, potentially, shut down the thread.</span></span><br><span class="line"><span class="comment">         * Add itself to the stack of parked workers, re-scans all the queues</span></span><br><span class="line"><span class="comment">         * to avoid missing wake-up (requestCpuWorker) and either starts executing discovered tasks or parks itself awaiting for new tasks.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 没有找到待处理的 Task 了，那么尝试 park 当前 Worker</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tryPark()</span><br><span class="line">    &#125;</span><br><span class="line">    tryReleaseCpu(WorkerState.TERMINATED)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际逻辑都在 runWorker() 中，其中主要分为如下几步：</p>
<p>1、while 一直循环，除非外部调用过 shutdown() 方法。</p>
<p>2、while 条件不满足时，调用 tryReleaseCpu() 方法，并将该 Worker 中表示其状态的属性 state 改为 WorkerState.TERMINATED 。从而该线程  runWorker() -&gt; run() 方法执行完毕，该线程终止掉。</p>
<p>其中第1步为主要逻辑，所以以下主要针对第1步展开解释。</p>
<p>执行 findTask() 去队列中取出任务来处理。这里传入的mayHaveLocalTasks 属性默认是 false ，然而当 dispatch() 时成功调用 submitToLocalQueue() 方法将任务添加到该Worker内部队列中时，会将其置为 true。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineScheduler.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findTask</span><span class="params">(scanLocalQueue: <span class="type">Boolean</span>)</span></span>: Task? &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试为当前 Worker 来获取 CPU的执行权，如果已经有执行权的话则直接返回 true。</span></span><br><span class="line"><span class="comment">     * cpu密集型任务需要长时间使用cpu，对上下文切换比较敏感，过多的线程争用反而导致性能下降。</span></span><br><span class="line"><span class="comment">     * 所以对于这类任务，scheduler 将执行线程的数量控制在了核心线程数之下，</span></span><br><span class="line"><span class="comment">     * 每次获取 CpuPermit 的过程就是一次可用核心线程数的自减，直至为0</span></span><br><span class="line"><span class="comment">     * 如果获取到了执行权的话，则从队列中随机取 task 来处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireCpuPermit()) <span class="keyword">return</span> findAnyTask(scanLocalQueue)</span><br><span class="line">    <span class="comment">// If we can&#x27;t acquire a CPU permit -- attempt to find blocking task</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有获取到执行权的话，则按顺序从队列中取</span></span><br><span class="line"><span class="comment">     * 是否优先使用 Worker 内部的队列，内部队列没有的话则从全局的 globalBlockingQueue 队列中找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> task = <span class="keyword">if</span> (scanLocalQueue) &#123;</span><br><span class="line">        localQueue.poll() ?: globalBlockingQueue.removeFirstOrNull()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        globalBlockingQueue.removeFirstOrNull()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果取出失败的话，则尝试从其他 Worker 内部队列中取出 Task 来处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> task ?: trySteal(blockingOnly = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryAcquireCpuPermit</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = <span class="keyword">when</span> &#123;</span><br><span class="line">    state == WorkerState.CPU_ACQUIRED -&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span><span class="symbol">@CoroutineScheduler</span>.tryAcquireCpuPermit() -&gt; &#123;</span><br><span class="line">        state = WorkerState.CPU_ACQUIRED</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findAnyTask</span><span class="params">(scanLocalQueue: <span class="type">Boolean</span>)</span></span>: Task? &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Anti-starvation mechanism: probabilistically poll either local</span></span><br><span class="line"><span class="comment">     * or global queue to ensure progress for both external and internal tasks.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 Worker 内部队列中有任务的话，则会随机从 全局队列+内部队列 中取</span></span><br><span class="line"><span class="comment">     * 否则只是从随机从全局队列中取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (scanLocalQueue) &#123;</span><br><span class="line">        <span class="keyword">val</span> globalFirst = nextInt(<span class="number">2</span> * corePoolSize) == <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (globalFirst) pollGlobalQueues()?.let &#123; <span class="keyword">return</span> it &#125;</span><br><span class="line">        localQueue.poll()?.let &#123; <span class="keyword">return</span> it &#125;</span><br><span class="line">        <span class="keyword">if</span> (!globalFirst) pollGlobalQueues()?.let &#123; <span class="keyword">return</span> it &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pollGlobalQzueues()?.let &#123; <span class="keyword">return</span> it &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trySteal(blockingOnly = <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">trySteal</span><span class="params">(blockingOnly: <span class="type">Boolean</span>)</span></span>: Task? &#123;</span><br><span class="line">    assert &#123; localQueue.size == <span class="number">0</span> &#125;</span><br><span class="line">    <span class="comment">// 当前已创建的 Worker 线程数</span></span><br><span class="line">    <span class="keyword">val</span> created = createdWorkers</span><br><span class="line">    <span class="comment">// 0 to await an initialization and 1 to avoid excess stealing on single-core machines</span></span><br><span class="line">    <span class="keyword">if</span> (created &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从随机的一个 Worker 中窃取其内部任务队列中的 Task 来处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> currentIndex = nextInt(created)</span><br><span class="line">    <span class="keyword">var</span> minDelay = <span class="built_in">Long</span>.MAX_VALUE</span><br><span class="line">    repeat(created) &#123;</span><br><span class="line">        ++currentIndex</span><br><span class="line">        <span class="keyword">if</span> (currentIndex &gt; created) currentIndex = <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> worker = workers[currentIndex]</span><br><span class="line">        <span class="keyword">if</span> (worker !== <span class="literal">null</span> &amp;&amp; worker !== <span class="keyword">this</span>) &#123;</span><br><span class="line">            assert &#123; localQueue.size == <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">val</span> stealResult = <span class="keyword">if</span> (blockingOnly) &#123;</span><br><span class="line">                localQueue.tryStealBlockingFrom(victim = worker.localQueue)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                localQueue.tryStealFrom(victim = worker.localQueue)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stealResult == TASK_STOLEN) &#123;</span><br><span class="line">                <span class="keyword">return</span> localQueue.poll()</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stealResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                minDelay = min(minDelay, stealResult)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    minDelayUntilStealableTaskNs = <span class="keyword">if</span> (minDelay != <span class="built_in">Long</span>.MAX_VALUE) minDelay <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 findTask 时，首先会去尝试为当前Work线程获取CPU使用权，而关于CPU权限前面讲过了，是保证最多只会有 核心线程数 个线程来同时执行。</p>
<p>获取到CPU使用权的这些线程会随机抽取一个队列来<code>优先</code>从中取出任务处理。即通过<code>findAnyTask</code>方法。这种被成为防饿死机制。当全局队列和内部队列都没有任务待处理时，就会调用 trySteal() 方法去随机找一个 Worker 然后将其内部任务“偷过来“处理。这样也是为了让当前Worker更充分的利用其时间片，提升CPU利用率。</p>
<p>回到 runWorker() 方法，拿到一个待处理的 task 任务之后，就会尝试去通过 executeTask() 方法来执行他，执行完后会接着 continue 循环开始读取下一个任务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineScheduler.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeTask</span><span class="params">(task: <span class="type">Task</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时task可能是 TASK_PROBABLY_BLOCKING 即阻塞型任务</span></span><br><span class="line"><span class="comment">     * 也可能是 TASK_NON_BLOCKING 非阻塞CPU密集型任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> taskMode = task.mode</span><br><span class="line">    idleReset(taskMode)</span><br><span class="line">    beforeTask(taskMode)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行该 task ,该Task 一般是 DispatchedContinuation 实例</span></span><br><span class="line"><span class="comment">     * 而它继承自 DispatchedTask ,所以实际是调用到 [DispatchedTask.run]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    runSafely(task)</span><br><span class="line">    afterTask(taskMode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">idleReset</span><span class="params">(mode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    terminationDeadline = <span class="number">0L</span> <span class="comment">// reset deadline for termination</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前 Worker 是休眠 PARKING 状态的话，就将其状态先改为 BLOCKING</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (state == WorkerState.PARKING) &#123;</span><br><span class="line">        assert &#123; mode == TASK_PROBABLY_BLOCKING &#125;</span><br><span class="line">        state = WorkerState.BLOCKING</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runSafely</span><span class="params">(task: <span class="type">Task</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        <span class="keyword">val</span> thread = Thread.currentThread()</span><br><span class="line">        thread.uncaughtExceptionHandler.uncaughtException(thread, e)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unTrackTask()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTask</span><span class="params">(taskMode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 刚执行完的是非阻塞型任务。所以不需要做额外操作</span></span><br><span class="line">    <span class="keyword">if</span> (taskMode == TASK_NON_BLOCKING) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 执行到这里，表示刚执行完的是阻塞型任务，所以需要将 blocking task 数减一</span></span><br><span class="line">    decrementBlockingTasks()</span><br><span class="line">    <span class="comment">// 然后将当前 Work 线程置为 DORMANT 状态，即执行完任务之后的休眠状态</span></span><br><span class="line">    <span class="keyword">val</span> currentState = state</span><br><span class="line">    <span class="comment">// Shutdown sequence of blocking dispatcher</span></span><br><span class="line">    <span class="keyword">if</span> (currentState !== WorkerState.TERMINATED) &#123;</span><br><span class="line">        assert &#123; currentState == WorkerState.BLOCKING &#125; <span class="comment">// &quot;Expected BLOCKING state, but has $currentState&quot;</span></span><br><span class="line">        state = WorkerState.DORMANT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结这里在执行任务之前会做如下操作：</p>
<p>1、beforTask 中，会在执行任务之前判断其类型，如果是阻塞型任务的话，那么在执行其之前需要先释放掉 CPU 执行权。因为如果这个任务是阻塞的，那么当前线程不能占用CPU执行权，不然就是对CPU资源的浪费。所以也就是说获取到了CPU执行权的线程应该是要执行CPU密集型任务的。</p>
<p>而如果此时当前Worker确实是拥有CPU执行权的，那么tryReleaseCpu()方法释放掉CPU执行权会返回true，此时会再次调用 signalCpuWork() 方法去唤醒其他休眠的线程去争夺这个刚空闲出来的席位，以达到CPU充分利用的目的。</p>
<p>2、afterTask 中，会判断如果刚执行完的任务是阻塞型，那么需要将 Blocking Task 计数减去1，并修改当前线程状态为 DORMANT 休眠状态。</p>
<p>再次回到 runWork() 中，剩余逻辑的执行前提就是 findTask() 没有返回可用任务。那么分为两种情况：</p>
<p>1、minDelayUntilStealableTaskNs 不等于 0，表示等待一会儿之后再去别的worker 偷取任务就可能会成功，那么这里 park 当前线程指定时长，等其park完成之后接着continue去窃取任务</p>
<p>2、minDelayUntilStealableTaskNs 等于 0，那就调用 tryPark() 方法来休眠当前线程。在 tryPark 中会先将该线程通过 parkedWorkersStackPush()方法来加入到 parkedWorkersStack 栈中。并且一直循环挂起它。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoroutineScheduler.kt</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryPark</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 没入栈把当前worker放入挂起栈，然后返回外面while再扫描一次task</span></span><br><span class="line">    <span class="keyword">if</span> (!inStack()) &#123;</span><br><span class="line">        parkedWorkersStackPush(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert &#123; localQueue.size == <span class="number">0</span> &#125;</span><br><span class="line">    workerCtl.value = PARKED <span class="comment">// Update value once</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * inStack() prevents spurious wakeups, while workerCtl.value == PARKED</span></span><br><span class="line"><span class="comment">     * prevents the following race:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - T2 scans the queue, adds itself to the stack, goes to rescan</span></span><br><span class="line"><span class="comment">     * - T2 suspends in &#x27;workerCtl.value = PARKED&#x27; line</span></span><br><span class="line"><span class="comment">     * - T1 pops T2 from the stack, claims workerCtl, suspends</span></span><br><span class="line"><span class="comment">     * - T2 fails &#x27;while (inStack())&#x27; check, goes to full rescan</span></span><br><span class="line"><span class="comment">     * - T2 adds itself to the stack, parks</span></span><br><span class="line"><span class="comment">     * - T1 unparks T2, bails out with success</span></span><br><span class="line"><span class="comment">     * - T2 unparks and loops in &#x27;while (inStack())&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果已经入栈了就设置挂起状态让出cpu执行权，并在当前循环中不断挂起恢复，直到别的worker唤醒或超时终止</span></span><br><span class="line"><span class="comment">     * 也就是当前worker 不再栈中了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (inStack() &amp;&amp; workerCtl.value == PARKED) &#123; <span class="comment">// Prevent spurious wakeups</span></span><br><span class="line">        <span class="keyword">if</span> (isTerminated || state == WorkerState.TERMINATED) <span class="keyword">break</span></span><br><span class="line">        tryReleaseCpu(WorkerState.PARKING)</span><br><span class="line">        interrupted() <span class="comment">// Cleanup interruptions</span></span><br><span class="line">        park()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>到这里就完成了协程拦截器，以及其中核心逻辑的讲解了。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Kotlin-Coroutine/">Kotlin Coroutine</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/692c4604.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">02-AOSP-OPENGL_ES</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/e2cf098c.html">
        <span class="next-text nav-default">Kotlin协程 - 协程挂起原理</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2022
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
