<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="SurfaceFlinger|Vsync - SurfaceFlinger(一)"/>




  <meta name="keywords" content="AndroidFrameworks,SurfaceFlinger," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/2fa835ad.html"/>


<meta name="description" content="关于 SurfaceFlinger的启动，可以从 frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Android.bp 文件中看出个大概。在该文件中，有如下代码： 12345678910111213141516171819....filegroup &amp;#123;    name: &quot;surfaceflinger_">
<meta property="og:type" content="article">
<meta property="og:title" content="SurfaceFlinger|Vsync - SurfaceFlinger(一)">
<meta property="og:url" content="https://youngkaaa.github.io/2fa835ad.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="关于 SurfaceFlinger的启动，可以从 frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Android.bp 文件中看出个大概。在该文件中，有如下代码： 12345678910111213141516171819....filegroup &amp;#123;    name: &quot;surfaceflinger_">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/2fa835ad/surface_flinger_01.png">
<meta property="article:published_time" content="2022-08-05T11:48:56.000Z">
<meta property="article:modified_time" content="2022-11-02T13:05:47.876Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="SurfaceFlinger">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/2fa835ad/surface_flinger_01.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> SurfaceFlinger|Vsync - SurfaceFlinger(一) - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          SurfaceFlinger|Vsync - SurfaceFlinger(一)
        
      </h1>

      <time class="post-time">
          8月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>关于 SurfaceFlinger的启动，可以从 <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/Android.bp">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Android.bp</a> 文件中看出个大概。在该文件中，有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line">filegroup &#123;</span><br><span class="line">    name: &quot;surfaceflinger_binary_sources&quot;,</span><br><span class="line">    srcs: [&quot;main_surfaceflinger.cpp&quot;],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;surfaceflinger&quot;,</span><br><span class="line">    defaults: [&quot;libsurfaceflinger_binary&quot;],</span><br><span class="line">    init_rc: [&quot;surfaceflinger.rc&quot;],</span><br><span class="line">    srcs: [&quot;:surfaceflinger_binary_sources&quot;],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;libsurfaceflinger&quot;,</span><br><span class="line">        &quot;libSurfaceFlingerProp&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>其中配置了 SurfaceFlinger 在Android启动初期需要加载的init.rc文件：surfaceflinger.rc ,以及 SurfaceFlinger 主函数入口 main_surfaceflinger.cpp。</p>
<p>关于这里的 bp 文件，以及 rc 文件的解析和使用，这里不再赘述，详见：<a href="3c031a43.html">Android bp</a> 、<a href="de9ff6b8.html">Android rc</a>。这里直接从 main_surfaceflinger.cpp 开始。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp">main_surfaceflinger.cpp</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span> &#123;</span><br><span class="line">		<span class="comment">// 省略部分代码</span></span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 1.创建 SurfaceFlinger 实例</span></span><br><span class="line">    <span class="comment">// instantiate surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::createSurfaceFlinger();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略部分代码	</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 2.调用其 init 方法</span></span><br><span class="line">    <span class="comment">// initialize before clients can connect</span></span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// publish surface flinger</span></span><br><span class="line">    sp&lt;IServiceManager&gt; <span class="title function_">sm</span><span class="params">(defaultServiceManager())</span>;</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>,</span><br><span class="line">                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);</span><br><span class="line"></span><br><span class="line">    startDisplayService(); <span class="comment">// dependency on SF getting registered above</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (sched_setscheduler(<span class="number">0</span>, SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// </span></span><br><span class="line">    <span class="comment">// run surface flinger in this thread</span></span><br><span class="line">		<span class="comment">// 3.调用其 run 方法</span></span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如上，省略掉了一些暂时可以不考虑的点之外(其实是我还没搞懂，囧)，剩余主要分为三步：</p>
<ol>
<li>创建出 SurfaceFlinger 对象实例</li>
<li>调用其 init() 方法</li>
<li>调用其 run()方法</li>
</ol>
<p>下面就按照这三步来进行分析：</p>
<h3 id="创建-SurfaceFlinger-对象实例"><a href="#创建-SurfaceFlinger-对象实例" class="headerlink" title="创建 SurfaceFlinger 对象实例"></a>创建 SurfaceFlinger 对象实例</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.cpp">SurfaceFlingerFactory.cpp</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceFlinger&gt; <span class="title function_">createSurfaceFlinger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">final</span> :</span> public surfaceflinger::Factory &#123;</span><br><span class="line">    public:</span><br><span class="line">        Factory() = <span class="keyword">default</span>;</span><br><span class="line">        ~Factory() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DispSync&gt; <span class="title function_">createDispSync</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">bool</span> hasSyncFramework,</span></span><br><span class="line"><span class="params">                                                 <span class="type">int64_t</span> dispSyncPresentTimeOffset)</span> override &#123;</span><br><span class="line">            <span class="comment">// Note: We create a local temporary with the real DispSync implementation</span></span><br><span class="line">            <span class="comment">// type temporarily so we can initialize it with the configured values,</span></span><br><span class="line">            <span class="comment">// before storing it for more generic use using the interface type.</span></span><br><span class="line">            <span class="keyword">auto</span> primaryDispSync = <span class="built_in">std</span>::make_unique&lt;android::impl::DispSync&gt;(name);</span><br><span class="line">            primaryDispSync-&gt;init(hasSyncFramework, dispSyncPresentTimeOffset);</span><br><span class="line">            <span class="keyword">return</span> primaryDispSync;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventControlThread&gt; <span class="title function_">createEventControlThread</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="built_in">std</span>::function&lt;<span class="type">void</span>(<span class="type">bool</span>)&gt; setVSyncEnabled)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;android::impl::EventControlThread&gt;(setVSyncEnabled);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Factory factory;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">return</span> new SurfaceFlinger(factory);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，在createSurfaceFlinger() 方法中创建 SurfaceFlinger 时，会先创建一个Factory内部类，它继承自 surfaceflinger::Factory (在 <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.h">SurfaceFlingerFactory.h</a> 中定义)， 然后将该 Factory 类实例传入到 SurfaceFlinger 构造方法中去：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp">SurfaceFlinger.cpp</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法1</span></span><br><span class="line">SurfaceFlinger::SurfaceFlinger(Factory&amp; factory) : SurfaceFlinger(factory, SkipInitialization) &#123;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 构造方法2</span></span><br><span class="line">   SurfaceFlinger::SurfaceFlinger(Factory&amp; factory, SkipInitializationTag)</span><br><span class="line">      : mFactory(factory),</span><br><span class="line">     mPhaseOffsets(mFactory.createPhaseOffsets()),</span><br><span class="line">     mInterceptor(mFactory.createSurfaceInterceptor(this)),</span><br><span class="line">     mTimeStats(mFactory.createTimeStats()),</span><br><span class="line">        mEventQueue(mFactory.createMessageQueue()),</span><br><span class="line">         mCompositionEngine(mFactory.createCompositionEngine()) &#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，调用了 SurfaceFlinger 中 构造方法1 ，而构造方法1 中又调用到了构造方法2。对于构造方法1来说，其内部主要是初始化一些属性变量，包括从全局配置中读取一些属性设置。这里需要关注的是构造方法1，其中会将上面创建出来的Factory 保存到了 mFactory 中；同时会通过这个 Factory 来创建其他属性，比如其中给 mEventQueue  创建一个 MessageQueue 实例，用于处理 SurfaceFlinger 中的消息；为 mCompositionEngine 创建一个  CompositionEngine 对象实例，用于合成 Layer。</p>
<p>额外我们需要看一下 SurfaceFlinger 类的一个继承关系：</p>
<p><img src="/2fa835ad/surface_flinger_01.png" alt="ssss"></p>
<p>可以看到，它实现了  HWC2::ComposerCallback 接口，用于接收来自HWC上层的事件通知，比如 vsync 事件和 hotplug 事件；以及实现了BnSurfaceComposer接口，而BnSurfaceComposer接口又是继承自BnInterface<ISurfaceComposer> 的，也就是作为 ISurfaceComposer 的服务端实现；DeathRecipient 是为了当Binder服务端程序挂掉后，可以通知给绑定的Binder客户端程序；</p>
<p>到这里，就完成了 SurfaceFlinger 对象的创建工作，简单总结下：就是创建出其实例，并且为其中一些关键变量或者模块初始化赋值，方便后续的使用。</p>
<h3 id="执行-init-方法"><a href="#执行-init-方法" class="headerlink" title="执行 init 方法"></a>执行 init 方法</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp">SurfaceFlinger.cpp</a>::init</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ALOGI</span>(<span class="string">&quot;SurfaceFlinger&#x27;s main thread ready to run. &quot;</span></span><br><span class="line">        <span class="string">&quot;Initializing graphics H/W...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ALOGI</span>(<span class="string">&quot;Phase offset NS: %&quot;</span>PRId64<span class="string">&quot;&quot;</span>, mPhaseOffsets-&gt;<span class="built_in">getCurrentAppOffset</span>());</span><br><span class="line"></span><br><span class="line">  Mutex::Autolock _l(mStateLock);</span><br><span class="line">  <span class="comment">// start the EventThread</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建 Scheduler 对象实例,后续通过 Scheduler 对象来创建 EventThread 等对象</span></span><br><span class="line"><span class="comment">   * 并且传入一个 callback 回调给内部，用于给 EventControlThread 线程来调用关闭 hardware vsync ，也就是关闭硬件层面的vsync信号</span></span><br><span class="line"><span class="comment">   * 也就是通过 SurfaceFlinger::setPrimaryVsyncEnabled 方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mScheduler = <span class="built_in">getFactory</span>().<span class="built_in">createScheduler</span>([<span class="keyword">this</span>](<span class="type">bool</span> enabled) &#123; <span class="built_in">setPrimaryVsyncEnabled</span>(enabled); &#125;,</span><br><span class="line">                                            mRefreshRateConfigs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * std::bind(&amp;SurfaceFlinger::getVsyncPeriod, this) ： 绑定当前 this 对象的 getVsyncPeriod</span></span><br><span class="line"><span class="comment">   * 使用Scheduler::makeResyncCallback函数构造一个回调函数，回调的是 SurfaceFlinger 实例对象的 getVsyncPeriod 函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">auto</span> resyncCallback = mScheduler-&gt;<span class="built_in">makeResyncCallback</span>(std::<span class="built_in">bind</span>(&amp;SurfaceFlinger::getVsyncPeriod, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler.cpp # Scheduler::createConnection</span></span><br><span class="line"><span class="comment">   * 1、创建 DispSyncSource 、 EventThread 等对象实例，其中 EventThread 中包装存储了 DispSyncSource</span></span><br><span class="line"><span class="comment">   * 2、创建一个 EventThreadConnection 对象实例，该实例内部包装了存储了 EventThread 和 入参 resyncCallback</span></span><br><span class="line"><span class="comment">   * 3、创建一个 Connection 对象实例，里面保存了 EventThreadConnection 实例 、 EventThread 实例，以及一个唯一标识ConnectionHandle对象实例</span></span><br><span class="line"><span class="comment">   *    这个 ConnectionHandle 类中有一个字段是int，保存了id，可以理解为该connection 的key。</span></span><br><span class="line"><span class="comment">   * 4、将 Connection 对象实例保存到  mConnections 中，key是id(这个id是每次自增1的int)。上面的ConnectionHandle 内部也包装了这个int id</span></span><br><span class="line"><span class="comment">   * 5、返回  ConnectionHandle 对象实例，后面使用这个  ConnectionHandle 中的 id 字段就可以从 mConnections 中查询 Connection 那些了。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * ------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">   * 主要参数解释：</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 1、const char *connectionName :</span></span><br><span class="line"><span class="comment">   * - 作为内部创建 DispSyncSource 和 EventThread 时的名称，详见 DispSyncSource.h # mName 和 EventThread.h # mThreadName</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 2、nsecs_t phaseOffsetNs :</span></span><br><span class="line"><span class="comment">   * - 待补充</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 3、nsecs_t offsetThresholdForNextVsync :</span></span><br><span class="line"><span class="comment">   * - 待补充</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 4、ResyncCallback resyncCallback :</span></span><br><span class="line"><span class="comment">   * - 上面使用 Scheduler::makeResyncCallback 函数构造一个回调函数，回调的是 SurfaceFlinger 实例对象的 getVsyncPeriod 函数</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 5、impl::EventThread::InterceptVSyncsCallback interceptCallback :</span></span><br><span class="line"><span class="comment">   * - 内部创建 EventThread 时传入的。详见 EventThead.h # mInterceptVSyncsCallback</span></span><br><span class="line"><span class="comment">   * - 对于 app 的，传入的是一个新建的 InterceptVSyncsCallback，表示不处理。</span></span><br><span class="line"><span class="comment">   * - 而对于 sf 用的是 mInterceptor-&gt;saveVSyncEvent(timestamp) ，所以走的是 SurfaceInterceptorc.cpp # saveVSyncEvent 方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 分别创建 sf 和 app 对应的 EventThread &amp; DispSyncSource 对象实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mAppConnectionHandle =</span><br><span class="line">      mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;app&quot;</span>, mVsyncModulator.<span class="built_in">getOffsets</span>().app,</span><br><span class="line">                                   mPhaseOffsets-&gt;<span class="built_in">getOffsetThresholdForNextVsync</span>(),</span><br><span class="line">                                   resyncCallback,</span><br><span class="line">                                   impl::EventThread::<span class="built_in">InterceptVSyncsCallback</span>());</span><br><span class="line"></span><br><span class="line">  mSfConnectionHandle =</span><br><span class="line">      mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;sf&quot;</span>, mVsyncModulator.<span class="built_in">getOffsets</span>().sf,</span><br><span class="line">                                   mPhaseOffsets-&gt;<span class="built_in">getOffsetThresholdForNextVsync</span>(),</span><br><span class="line">                                   resyncCallback, [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">            mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 上面 createConnection 创建了相关的对象，比如 ConnectionHandle 、EventThreadConnection 等，并保存起来了</span></span><br><span class="line"><span class="comment">   * 而这里就是通过 getEventConnection() 传入 ConnectionHandle 来查询对应的 EventThreadConnection 对象实例</span></span><br><span class="line"><span class="comment">   * 而 EventThreadConnection 中保存了 EventThread 、 resyncCallback 那些</span></span><br><span class="line"><span class="comment">   * 内部会创建BitTube并监听其文件描述符</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 注意：这里只是将 sf 对应的 EventThreadConnection 对象拿出来设置进去，而sf对应的 EventThreadConnection 对象实例的创建在上面createConnection中的</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 在上面创建 EventThreadConnection 时，会调用其 onFirstRef 的方法，然后内部会给 EventThread 中注册connection，</span></span><br><span class="line"><span class="comment">   * 这样在EventThread 线程中的 mDisplayEventConnections 中就会有一个connection了，在后续event到来时就会被回调</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * MessageQueue.cpp # MessageQueue::setEventConnection</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mEventQueue-&gt;<span class="built_in">setEventConnection</span>(mScheduler-&gt;<span class="built_in">getEventConnection</span>(mSfConnectionHandle));</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 保存 Scheduler 等</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mVsyncModulator.<span class="built_in">setSchedulerAndHandles</span>(mScheduler.<span class="built_in">get</span>(), mAppConnectionHandle.<span class="built_in">get</span>(), mSfConnectionHandle.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  mRegionSamplingThread =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">RegionSamplingThread</span>(*<span class="keyword">this</span>, *mScheduler, RegionSamplingThread::<span class="built_in">EnvironmentTimingTunables</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a RenderEngine for the given display / config (can&#x27;t fail)</span></span><br><span class="line">  <span class="type">int32_t</span> renderEngineFeature = <span class="number">0</span>;</span><br><span class="line">  renderEngineFeature |= (useColorManagement ?</span><br><span class="line">                          renderengine::RenderEngine::USE_COLOR_MANAGEMENT : <span class="number">0</span>);</span><br><span class="line">  renderEngineFeature |= (useContextPriority ?</span><br><span class="line">                          renderengine::RenderEngine::USE_HIGH_PRIORITY_CONTEXT : <span class="number">0</span>);</span><br><span class="line">  renderEngineFeature |=</span><br><span class="line">      (<span class="built_in">enable_protected_contents</span>(<span class="literal">false</span>) ? renderengine::RenderEngine::ENABLE_PROTECTED_CONTEXT : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建渲染引擎，主要是选择EGL配置，选择OpenGL版本，创建OpenGL上下文</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 1、renderengine::RenderEngine::create() : RenderEngine.cpp # create</span></span><br><span class="line"><span class="comment">   *    返回一个 GLESRenderEngine 对象实例，而 GLESRenderEngine 继承自 RenderEngine</span></span><br><span class="line"><span class="comment">   *o</span></span><br><span class="line"><span class="comment">   * 2、mCompositionEngine-&gt;setRenderEngine() : CompositionEngine.cpp # setRenderEngine</span></span><br><span class="line"><span class="comment">   *    将新创建的 GLESRenderEngine 对象实例设置保存到 mCompositionEngine 中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 而 mCompositionEngine 是在 SurfaceFlinger 构造方法中被初始化的，其实就是new了一个 CompositionEngine 对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// TODO(b/77156734): We need to stop casting and use HAL types when possible.</span></span><br><span class="line">  <span class="comment">// Sending maxFrameBufferAcquiredBuffers as the cache size is tightly tuned to single-display.</span></span><br><span class="line">  mCompositionEngine-&gt;<span class="built_in">setRenderEngine</span>(</span><br><span class="line">      renderengine::RenderEngine::<span class="built_in">create</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(defaultCompositionPixelFormat),</span><br><span class="line">                                         renderEngineFeature, maxFrameBufferAcquiredBuffers));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mVrFlingerRequestsDisplay,</span><br><span class="line">                      <span class="string">&quot;Starting with vr flinger active is not currently supported.&quot;</span>);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1、 getFactory().createHWComposer  :  SurfaceflingerFactory.cpp # createHWComposer</span></span><br><span class="line"><span class="comment">   *     内部就是创建一个 HWComposer 对象实例，然后返回 ( HWComposer.cpp # HWComposer::HWComposer )</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 2、 mCompositionEngine-&gt;setHwComposer() : CompositionEngine.cpp # setHwComposer()</span></span><br><span class="line"><span class="comment">   *     将新创建的 HWComposer 对象实例设置保存到 mCompositionEngine 中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * mHwcServiceName ： 默认就是 default  了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mCompositionEngine-&gt;<span class="built_in">setHwComposer</span>(<span class="built_in">getFactory</span>().<span class="built_in">createHWComposer</span>(<span class="built_in">getBE</span>().mHwcServiceName));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1、CompositionEngine.cpp # getHwComposer()</span></span><br><span class="line"><span class="comment">   *    其实就是拿到刚才设置的 HWComposer 对象实例 ( HWComposer.cpp # HWComposer::HWComposer )</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 2、HWComposer # registerCallback  ： ComposerHal.cpp # HWComposer::registerCallback</span></span><br><span class="line"><span class="comment">   *    而 SurfaceFlinger 是继承自 HWC2::ComposerCallback 的，（在 SurfaceFlinger.h 中可以看到）</span></span><br><span class="line"><span class="comment">   *    而 HWC2::ComposerCallback 位于 HWC2.h 中，该 Callback 中的方法在当前类中都有实现</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 注册这个Callback的话，就可以接受来自 HWC 的事件了。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 所以说此时 SF 就通过了这个方法联通了hal层</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 而我们从常识推断，一个手机通电，屏幕驱动一定是最早那几个启动的常用服务(除了Linux内核这些之外)。因此当SF启动之后，在底层一定会准备好一个通知，</span></span><br><span class="line"><span class="comment">   * 所以说我们这里：一旦SF注册了监听一定会立马回调！！！</span></span><br><span class="line"><span class="comment">   * 还记得 ComposerCallbackBridge 中回调，实际上应对上的是SF对应的，屏幕热插拔最终回调 。 到当前类 SurfaceFlinger::onHotplugReceived 中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 所以这里 registerCallback 之后立马应该执行 SurfaceFlinger::onHotplugReceive 来准备显示屏相关数据结构</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mCompositionEngine-&gt;<span class="built_in">getHwComposer</span>().<span class="built_in">registerCallback</span>(<span class="keyword">this</span>, <span class="built_in">getBE</span>().mComposerSequenceId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process any initial hotplug and resulting display changes.</span></span><br><span class="line">  <span class="comment">// 处理 任何初始热插拔和显示更改的结果 SurfaceFlinger::processDisplayHotplugEventsLocked</span></span><br><span class="line">  <span class="comment">// 该方法第一次进来无效，这是SF重启发现有屏幕插进来，一般不会走进来</span></span><br><span class="line">  <span class="built_in">processDisplayHotplugEventsLocked</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">  <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!display, <span class="string">&quot;Missing internal display after registering composer callback.&quot;</span>);</span><br><span class="line">  <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!<span class="built_in">getHwComposer</span>().<span class="built_in">isConnected</span>(*display-&gt;<span class="built_in">getId</span>()),</span><br><span class="line">                      <span class="string">&quot;Internal display is disconnected.&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (useVrFlinger) &#123;</span><br><span class="line">    <span class="keyword">auto</span> vrFlingerRequestDisplayCallback = [<span class="keyword">this</span>](<span class="type">bool</span> requestDisplay) &#123;</span><br><span class="line">      <span class="comment">// This callback is called from the vr flinger dispatch thread. We</span></span><br><span class="line">      <span class="comment">// need to call signalTransaction(), which requires holding</span></span><br><span class="line">      <span class="comment">// mStateLock when we&#x27;re not on the main thread. Acquiring</span></span><br><span class="line">      <span class="comment">// mStateLock from the vr flinger dispatch thread might trigger a</span></span><br><span class="line">      <span class="comment">// deadlock in surface flinger (see b/66916578), so post a message</span></span><br><span class="line">      <span class="comment">// to be handled on the main thread instead.</span></span><br><span class="line">      <span class="built_in">postMessageAsync</span>(<span class="keyword">new</span> <span class="built_in">LambdaMessage</span>([=] &#123;</span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;VR request display mode: requestDisplay=%d&quot;</span>, requestDisplay);</span><br><span class="line">        mVrFlingerRequestsDisplay = requestDisplay;</span><br><span class="line">        <span class="built_in">signalTransaction</span>();</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">    mVrFlinger = dvr::VrFlinger::<span class="built_in">Create</span>(<span class="built_in">getHwComposer</span>().<span class="built_in">getComposer</span>(),</span><br><span class="line">                                        <span class="built_in">getHwComposer</span>()</span><br><span class="line">                                            .<span class="built_in">fromPhysicalDisplayId</span>(*display-&gt;<span class="built_in">getId</span>())</span><br><span class="line">                                            .<span class="built_in">value_or</span>(<span class="number">0</span>),</span><br><span class="line">                                        vrFlingerRequestDisplayCallback);</span><br><span class="line">    <span class="keyword">if</span> (!mVrFlinger) &#123;</span><br><span class="line">      <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to start vrflinger&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize our drawing state</span></span><br><span class="line">  mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该方法是 SurfaceFlinger 启动逻辑中最重要的部分，代码行数不多，但是执行的逻辑不少，且错综复杂。主要分为以下几步：</p>
<h4 id="1、创建Scheduler"><a href="#1、创建Scheduler" class="headerlink" title="1、创建Scheduler"></a>1、创建Scheduler</h4><p>这里创建的Scheduler是全局唯一的实例，后续很多工作都会交给Scheduler来做的，比如创建DispSync、EventControlThread以及EventThread 等。</p>
<p>比如先看 Scheduler 的构造方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Scheduler::<span class="built_in">Scheduler</span>(impl::EventControlThread::SetVSyncEnabledFunction function,</span><br><span class="line">                     <span class="type">const</span> scheduler::RefreshRateConfigs &amp;refreshRateConfig)</span><br><span class="line">    : <span class="built_in">mHasSyncFramework</span>(<span class="built_in">running_without_sync_framework</span>(<span class="literal">true</span>)),</span><br><span class="line">      <span class="built_in">mDispSyncPresentTimeOffset</span>(<span class="built_in">present_time_offset_from_vsync_ns</span>(<span class="number">0</span>)),</span><br><span class="line">      <span class="built_in">mPrimaryHWVsyncEnabled</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mHWVsyncAvailable</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mRefreshRateConfigs</span>(refreshRateConfig) &#123;</span><br><span class="line">  <span class="comment">// Note: We create a local temporary with the real DispSync implementation</span></span><br><span class="line">  <span class="comment">// type temporarily so we can initialize it with the configured values,</span></span><br><span class="line">  <span class="comment">// before storing it for more generic use using the interface type.</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建一个 DispSync 对象实例.然后调用其 init 方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">auto</span> primaryDispSync = std::<span class="built_in">make_unique</span>&lt;impl::DispSync&gt;(<span class="string">&quot;SchedulerDispSync&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用其 init 方法将内部线程启动起来</span></span><br><span class="line">  primaryDispSync-&gt;<span class="built_in">init</span>(mHasSyncFramework, mDispSyncPresentTimeOffset);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存到全局 mPrimaryDispSync 中去</span></span><br><span class="line">  mPrimaryDispSync = std::<span class="built_in">move</span>(primaryDispSync);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建 EventControlThread 实例，其内部会启动线程,其实就是对整个HWC的EventThread的控制</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mEventControlThread = std::<span class="built_in">make_unique</span>&lt;impl::EventControlThread&gt;(function);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Scheduler构造方法中也做了挺多逻辑，其中最重要的就是创建了唯一的 DispSync 和 EventControlThread 实例并启动器内部的线程。虽然说是在这里启动了这俩线程，但是其内部执行刚开始不久就会被阻塞住，DispSync的话是因为其内部 mPeriod &#x3D; 0 而阻塞休眠，EventControlThread 是因为其内部的开关 currentVsyncEnabled 没有发生变化，所以一直阻塞休眠。所以说到现在一共出来了两个线程，并且都是会处于阻塞休眠状态。</p>
<p>关于这俩可以的分析可以分别看：<a href="6caea16d.html">DispSync</a> 和 <a href="5e3d97eb.html">EventControlThread</a>。</p>
<h4 id="2、创建EventThread"><a href="#2、创建EventThread" class="headerlink" title="2、创建EventThread"></a>2、创建EventThread</h4><p>通过刚刚创建好的 Scheduler 对象来创建 app EventThread 和 sf EventThread，其内部的创建逻辑详见：<a href="7b339bd2.html">EventThread</a>。需要注意的是在这里创建了app 和sf 的EventThread 之后，其内部的线程就开始执行了，但是执行之后是立马又处于阻塞休眠，因为其内部还有没待处理的 Event 。所以结合上面第1点，到现在一共有四个线程，分别是：DispSync 、 EventControlThread 、app EventThread 和 sf EventThread ，这四个线程的共同点都是处于休眠状态，等待某种时机来唤醒他们接着执行。关于更多分析详见 <a href="7b339bd2.html">EventThread</a> 。</p>
<h4 id="3、绑定-sf-EventThread-和-MessageQueue"><a href="#3、绑定-sf-EventThread-和-MessageQueue" class="headerlink" title="3、绑定 sf EventThread 和 MessageQueue"></a>3、绑定 sf EventThread 和 MessageQueue</h4><p>接下来就是将创建好的 sf EventThread 和 SurfaceFlinger 中的 MessageQueue 消息队列绑定起来，即通过mEventQueue-&gt;setEventConnection 来将其绑定起来，mEventQueue 是 MessageQueue  类型，它在 SurfaceFlinger 构造方法中通过入参 mFactory.createMessageQueue() 创建赋值:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlingerFactory.cpp</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;MessageQueue&gt; <span class="title">createMessageQueue</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;android::impl::MessageQueue&gt;();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实就是new了一个 MessageQueue 的实例保存给 mEventQueue 。然后在 SurfaceFlinger 的 onFirstRef 方法内被初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SurfaceFlinger::onFirstRef</span><span class="params">()</span> &#123;</span><br><span class="line">  mEventQueue-&gt;init(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageQueue.cpp</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MessageQueue::init</span><span class="params">(<span class="type">const</span> sp&lt;SurfaceFlinger&gt; &amp;flinger)</span> &#123;</span><br><span class="line">  mFlinger = flinger;</span><br><span class="line">  mLooper = new Looper(<span class="literal">true</span>);</span><br><span class="line">  mHandler = new Handler(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的MessageQueue在上层也有类似的对应类，这是有些微的设计上的差异但是用途都差不多。这里的MessageQueue就可以按照上层的Handler消息队列那些来理解。</p>
<p>然后在这里调用mEventQueue-&gt;setEventConnection方法来将 sf EventThread 和 MessageQueue 进行绑定:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MessageQueue.cpp</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MessageQueue::setEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt; &amp;connection)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果当前 mEventTube 中的 mReceiveFd 已经设置过了，就清掉</span></span><br><span class="line">  <span class="keyword">if</span> (mEventTube.getFd() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    mLooper-&gt;removeFd(mEventTube.getFd());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mEvents = connection;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mEvents ： EventThreadConnection ，内部包括了 EventThread 和一个 BitTube 对象实例</span></span><br><span class="line"><span class="comment">   * 该 BitTube 对象实例是经过了init 等初始化操作的，所以内部有两个fd，一个send、一个 receive，通过send发送的数据 receive 就能收到</span></span><br><span class="line"><span class="comment">   * 而这里的 stealReceiveChannel 呢，就是将 mEvents 内部的这个 BitTube 实例的 receiveFd 赋值给这里的  mEventTube 中的 receiveFd</span></span><br><span class="line"><span class="comment">   * 这样的话，在该 mEvents 内部的EventThread线程 通过其 BitTube 对象实例的 sendFd 是发送消息时，这里的 mEventTube 就能收到消息了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mEvents-&gt;stealReceiveChannel(&amp;mEventTube);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * BitTube::getFd 返回的是其 mReceiveFd ，所以上面 stealReceiveChannel 是将 mEventTube的 mReceiveFd 赋值</span></span><br><span class="line"><span class="comment">   * 当 EventThread 发送消息时这里的 mReceiveFd 就能收到消息了。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 注意这里传入的 Callback 是： MessageQueue::cb_eventReceiver ,所以最终在Looper中处理消息时，会通知到这个方法里面来</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mLooper-&gt;addFd(mEventTube.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个里面用到了 BitTube ,它内部封装了 socket，可以使用它来进行数据发送，这里通过它来将 sf EventThread 和 MessageQueue 进行了绑定，这样后续在 sf EventThread 中发送的vsync等事件，就会到 MessageQueue 中然后到MessageQueue::cb_eventReceiver方法中 ，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MessageQueue.cpp</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">  MessageQueue *<span class="built_in">queue</span> = reinterpret_cast&lt;MessageQueue *&gt;(data);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> &#123;</span><br><span class="line">  <span class="type">ssize_t</span> n;</span><br><span class="line">  DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">  <span class="comment">// 先读取出来消息</span></span><br><span class="line">  <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// 遍历每个消息，只处理 vsync 的</span></span><br><span class="line">      <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">        <span class="comment">// 调用到当前类中的  MessageQueue::Handler::dispatchInvalidate</span></span><br><span class="line">        mHandler-&gt;dispatchInvalidate();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;</span><br><span class="line">  <span class="keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里将 MessageQueue::INVALIDATE 插入到消息队列中去，最终在当前类  MessageQueue::Handler::handleMessage 中回调</span></span><br><span class="line">    mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::INVALIDATE));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::handleMessage(<span class="type">const</span> Message &amp;message) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">    <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 最终将消息通过 onMessageReceived 传递给 SurfaceFlinger</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">      mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> REFRESH:</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 处理 REFRESH 消息，最终是到 SurfaceFlinger.cpp # onMessageReceived</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      android_atomic_and(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">      mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以一步步传的将vsync包装成 MessageQueue::INVALIDATE 消息，然后最后传递给 SurfaceFlinger中onMessageReceived 方法内来处理。而关于 EventThread 事件发送的逻辑详见：<a href="7b339bd2.html">EventThread</a>中的解释，而onMessageReceived 的具体逻辑详见后面文章分析。</p>
<p>注意这里是将 sf EventThread和 MessageQueue 绑定的，后续 SurfaceFlinger 也只会接收到来自 sf EventThread 的 vsync 信号，相当于SurfaceFlinger就是sf EventThread的监听观察者，它接收到vsync信号后会进行Layer叠加绘制操作。而app EventThread 的观察者呢？它的观察者主要是各个app进程，用来接收vsync信号以完成ViewRootImpl 的遍历计算、动画的计算等。而app和sf的vsync信号会有一些偏移差，也叫相位差。比如在创建 EventThread 时分别传入的mVsyncModulator.getOffsets().app 和 mVsyncModulator.getOffsets().sf 。存在偏移量是为了避免CPU繁忙将这俩部分的逻辑岔开执行，即可以先处理让app端收到vsync信号然后开始页面刷新的计算操作并更新给自身对应的layer中，然后再让surfaceFlinger端收到vsync信号新的layer属性进行叠加绘制渲染等操作。</p>
<h4 id="4、创建-RenderEngine"><a href="#4、创建-RenderEngine" class="headerlink" title="4、创建 RenderEngine"></a>4、创建 RenderEngine</h4><p> 创建 RenderEngine 并将其都保存到 mCompositionEngine 中。后面可以使用它来完成Layer的合成。 【待补充】</p>
<h4 id="5、创建-HWComposer-并注册监听"><a href="#5、创建-HWComposer-并注册监听" class="headerlink" title="5、创建 HWComposer 并注册监听"></a>5、创建 HWComposer 并注册监听</h4><p>创建 HWComposer 实例，同样将其先保存到 mCompositionEngine  中，然后再给它设置HWC2::ComposerCallback，用来监听来自hal硬件层的vsync、hotplug事件通知。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlingerFactory.cpp</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;HWComposer&gt; <span class="title function_">createHWComposer</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName)</span> override &#123;</span><br><span class="line">   <span class="comment">// 再将创建出来的 Composer 对象实例传入 HWComposer 构造方法中来创建一个 HWComposer 对象实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;android::impl::HWComposer&gt;(</span><br><span class="line">      <span class="comment">// 先创建出来 Composer 对象实例。具体在  ComposerHal.cpp 中</span></span><br><span class="line">      <span class="built_in">std</span>::make_unique&lt;Hwc2::impl::Composer&gt;(serviceName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建 HWComposer 实例时，先创建了 Composer实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComposerHal.cpp</span></span><br><span class="line">Composer::<span class="built_in">Composer</span>(<span class="type">const</span> std::string &amp;serviceName)</span><br><span class="line">    : <span class="built_in">mWriter</span>(kWriterInitialSize),</span><br><span class="line">      <span class="built_in">mIsUsingVrComposer</span>(serviceName == std::<span class="built_in">string</span>(<span class="string">&quot;vr&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建一个 IComposer 对象实例，这个可以理解为 Binder，从抽象层(hal)服务端传送过来的 IComposer 接口对象。</span></span><br><span class="line"><span class="comment">   * 之后所有要和硬件层进行交互，只需要操作这个 IComposer 对象即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mComposer = V2_1::IComposer::<span class="built_in">getService</span>(serviceName);</span><br><span class="line">  <span class="keyword">if</span> (mComposer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to get hwcomposer service&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sp &lt; IComposer &gt; composer_2_3 = IComposer::<span class="built_in">castFrom</span>(mComposer)) &#123;</span><br><span class="line">    composer_2_3-&gt;<span class="built_in">createClient_2_3</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span> &amp;tmpError, <span class="type">const</span> <span class="keyword">auto</span> &amp;tmpClient) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tmpError == Error::NONE) &#123;</span><br><span class="line">        mClient = tmpClient;</span><br><span class="line">        mClient_2_2 = tmpClient;</span><br><span class="line">        mClient_2_3 = tmpClient;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    mComposer-&gt;<span class="built_in">createClient</span>([&amp;](<span class="type">const</span> <span class="keyword">auto</span> &amp;tmpError, <span class="type">const</span> <span class="keyword">auto</span> &amp;tmpClient) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tmpError != Error::NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mClient = tmpClient;</span><br><span class="line">      <span class="keyword">if</span> (sp &lt; V2_2::IComposer &gt; composer_2_2 = V2_2::IComposer::<span class="built_in">castFrom</span>(mComposer)) &#123;</span><br><span class="line">        mClient_2_2 = V2_2::IComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mClient_2_2 == <span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="string">&quot;IComposer 2.2 did not return IComposerClient 2.2&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create composer client&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mIsUsingVrComposer) &#123;</span><br><span class="line">    sp&lt;IVrComposerClient&gt; vrClient = IVrComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">    <span class="keyword">if</span> (vrClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create vr composer client&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 Composer 内部会连通到硬件hal层，然后通过其内部的 mClient_XXX 来访问操纵硬件设备。到这里就可以先打住，hal层后面再分析，这里先记住这里的Composer 实例连通hal层可以使用它来操作hal层就行了。</p>
<p>然后将该 Composer传入到 HWCompser 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HWComposer.cpp</span></span><br><span class="line">HWComposer::HWComposer(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Hwc2::Composer&gt; composer)</span><br><span class="line">    : mHwcDevice(<span class="built_in">std</span>::make_unique&lt;HWC2::Device&gt;(<span class="built_in">std</span>::move(composer))) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>HWComposer构造方法就很简单了，其内部又创建了一个 Device 对象实例来将入参 Composer 包装起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HWC2.cpp</span></span><br><span class="line">Device::<span class="built_in">Device</span>(std::unique_ptr&lt;android::Hwc2::Composer&gt; composer) : <span class="built_in">mComposer</span>(std::<span class="built_in">move</span>(composer)) &#123;</span><br><span class="line">  <span class="built_in">loadCapabilities</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载 capability ，并且将其放入到 mCapabilities 中</span></span><br><span class="line"><span class="comment"> * 该方法在 Device 构造方法中就被调用了，所以只要 Device实例创建出来后 mCapabilities 一般就有值了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Device::loadCapabilities</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(Capability) == <span class="built_in">sizeof</span>(<span class="type">int32_t</span>),</span><br><span class="line">                <span class="string">&quot;Capability size has changed&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> capabilities = mComposer-&gt;<span class="built_in">getCapabilities</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> capability: capabilities) &#123;</span><br><span class="line">    mCapabilities.<span class="built_in">emplace</span>(<span class="built_in">static_cast</span>&lt;Capability&gt;(capability));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就完成了对 HWComposer 的创建。</p>
<p>接下来会给他注册回调：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HWComposer.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::registerCallback</span><span class="params">(HWC2::ComposerCallback *callback, <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// mHwcDevice 在上面 HWComposer 构造方法中被初始化为一个 Device 对象实例</span></span><br><span class="line">  mHwcDevice-&gt;<span class="built_in">registerCallback</span>(callback, sequenceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HWC2.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Device::registerCallback</span><span class="params">(ComposerCallback *callback, <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 避免重复注册</span></span><br><span class="line">  <span class="keyword">if</span> (mRegisteredCallback) &#123;</span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;Callback already registered. Ignored extra registration attempt.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mRegisteredCallback = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将 callback 和 sequenceId 包装成 ComposerCallbackBridge 对象实例</span></span><br><span class="line"><span class="comment">   * callback 传入的一般就是 SurfaceFlinger 对象自身，因为它实现了 ComposerCallback </span></span><br><span class="line"><span class="comment">   * 所以说此时 SF 就通过了 ComposerBridge 联通了hal层</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">sp&lt;ComposerCallbackBridge&gt; <span class="title">callbackBridge</span><span class="params">(<span class="keyword">new</span> ComposerCallbackBridge(callback, sequenceId))</span></span>;</span><br><span class="line">  mComposer-&gt;<span class="built_in">registerCallback</span>(callbackBridge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ComposerHal.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Composer::registerCallback</span><span class="params">(<span class="type">const</span> sp&lt;IComposerCallback&gt; &amp;callback)</span> </span>&#123;</span><br><span class="line">  android::hardware::<span class="built_in">setMinSchedulerPolicy</span>(callback, SCHED_FIFO, <span class="number">2</span>);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mClient 在 Composer::Composer 构造方法中被调用初始化</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">auto</span> ret = mClient-&gt;<span class="built_in">registerCallback</span>(callback);</span><br><span class="line">  <span class="keyword">if</span> (!ret.<span class="built_in">isOk</span>()) &#123;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;failed to register IComposerCallback&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// // HWC2.cpp</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每当hal层发生回调的时候，如刷新请求等时候，就会调用callback对应的onRefreshReceived，</span></span><br><span class="line"><span class="comment"> * onVsyncReceived，onHotplugReceived三个方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * ComposerCallbackBridge 相当于将 SF 注册的回调包装了一层，额外还扩充了一个 mSequenceId 字段</span></span><br><span class="line"><span class="comment"> * 而这个 mSequenceId 来源是 SF 中的 mComposerSequenceId ，它是用来区分给 HWComposer 注册的不同 Callback 。</span></span><br><span class="line"><span class="comment"> * 比如在 SF::init 中会往 HWComposer 中注册回调，此时 sequenceId=0，然后有可能是 VR 模式时</span></span><br><span class="line"><span class="comment"> * 有会注册一次回调，此时sequence 就是 1了。所以说使用这个 mComposerSequenceId 来区分不同的 Callback</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个类的使用在下面 Device::registerCallback 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComposerCallbackBridge</span> : <span class="keyword">public</span> Hwc2::IComposerCallback &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ComposerCallbackBridge</span>(ComposerCallback *callback, <span class="type">int32_t</span> sequenceId)</span><br><span class="line">      : <span class="built_in">mCallback</span>(callback), <span class="built_in">mSequenceId</span>(sequenceId) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onHotplug</span><span class="params">(Hwc2::Display display, IComposerCallback::Connection conn)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    HWC2::Connection connection = <span class="built_in">static_cast</span>&lt;HWC2::Connection&gt;(conn);</span><br><span class="line">    mCallback-&gt;<span class="built_in">onHotplugReceived</span>(mSequenceId, display, connection);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onRefresh</span><span class="params">(Hwc2::Display display)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    mCallback-&gt;<span class="built_in">onRefreshReceived</span>(mSequenceId, display);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onVsync</span><span class="params">(Hwc2::Display display, <span class="type">int64_t</span> timestamp)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    mCallback-&gt;<span class="built_in">onVsyncReceived</span>(mSequenceId, display, timestamp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ComposerCallback *mCallback;</span><br><span class="line">  <span class="type">int32_t</span> mSequenceId;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意这里是从 SurfaceFlinger::init 中调用的，传入的是 this 也就是 SurfaceFlinger 自身，因为它实现了HWC2::ComposerCallback接口。那么就这样一步步注册到hal 中去，当hal中有vsync、hotplug 事件时，就会一步步回调到SurfaceFlinger中，它实现了其中的onHotplugReceived、onVsyncReceived等方法，当这些方法会被回调时，SurfaceFlinger就会开始对应的逻辑处理，比如：</p>
<ol>
<li><p>onHotplugReceived表示硬件屏幕插拔事件回调，当SurfaceFlinger收到该事件之后，会创建相应的对象比如DisplayDeviceState，然后将其保存到指定地方比如mCurrentState.displays中，后期就可以用来操作屏幕了；</p>
<p>另外这里设置了HWC2::ComposerCallback 之后，一般立马就会有onHotplugReceived方法的回调，因为Android系统启动时，屏幕相关驱动一定是最早启动的，这样等到后面SurfaceFlinger启动时，屏幕一定是启动好了，所以立马会有一个屏幕插入的hotplug事件进来。</p>
</li>
<li><p>onVsyncReceived表示有硬件vsync事件发生，此时SurfaceFlinger收到该事件之后将其加入到全局唯一的<a href="6caea16d.html">DispSync</a>实例中，作为一个采样数据，而在<a href="6caea16d.html">DispSync</a>内部会将使用很多个这样的硬件采样数据来计算出软件层面的vsync再发送给对应的EventThread，然后对应的EventThread再发送到外部的监听者，比如app或者surfaceFlinger 。这些都可以详见<a href="6caea16d.html">DispSync</a>。</p>
</li>
</ol>
<p>这里主要先列举这5点，后续的比如开机动画之类的，等分析到对应的部分时，再做单独补充。</p>
<h3 id="3、执行-run-方法"><a href="#3、执行-run-方法" class="headerlink" title="3、执行 run 方法"></a>3、执行 run 方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// waitForEvent 其实就只是 ：mEventQueue-&gt;waitMessage();</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">waitForEvent</span>();</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::waitForEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mEventQueue-&gt;<span class="built_in">waitMessage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageQueue.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::waitMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 不断去调用mLooper-&gt;pollOnce(-1)，检查Looper中是否有消息需要处理，如果有，则调用该消息对应的MessageHandler去处理。</span></span><br><span class="line"><span class="comment">   * 而当前方法是在 SurfaceFlinger.cpp # run 方法中调用的，也是在一个while(true) 中不断调用当前 waitMessage 方法的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">flushCommands</span>();</span><br><span class="line">    <span class="comment">// 注意这里调用的是一个参数的 pollOnce，实际是在 Looper.h 中定义的，它最终会调用到四个参数的 pollOnce 方法</span></span><br><span class="line">    <span class="comment">// 也就是调用 Looper.cpp # pollOnce (四个参数的)方法来检测是否有消息要处理</span></span><br><span class="line">    <span class="type">int32_t</span> ret = mLooper-&gt;<span class="built_in">pollOnce</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">      <span class="keyword">case</span> Looper::POLL_WAKE:</span><br><span class="line">      <span class="keyword">case</span> Looper::POLL_CALLBACK:<span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> Looper::POLL_ERROR:<span class="built_in">ALOGE</span>(<span class="string">&quot;Looper::POLL_ERROR&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> Looper::POLL_TIMEOUT:</span><br><span class="line">        <span class="comment">// timeout (should not happen)</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// should not happen</span></span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Looper::pollOnce() returned unknown status %d&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了run 方法中就简单多了，启动消息队列的死循环一直从中获取消息来执行，至此 SurfaceFlinger 就能收到来自 sf EventThread 的消息了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在 SurfaceFlinger 中，主要逻辑还是在其init 方法中，该方法中会初始化最重要的四个线程相关类：DispSync、EventControlThread、sf EventThread以及app EventThread ，这四个再加上 MessageQueue消息队列的话，基本上就代表了Vsync 的主要部分。当SurfaceFlinger 收到来自 hal 的vsync 事件后，发送给 DispSync 再兜兜转转回来回到 SurfaceFlinger 中，此时就会遍历内部的 Layer 来进行Layer 的绘制等操作了，这些扔到后面的文章来讲吧。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/SurfaceFlinger/">SurfaceFlinger</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/b9b33037.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">SurfaceFlinger|Vsync - SurfaceFlinger(二)</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/3c031a43.html">
        <span class="next-text nav-default">AOSP-BP-File</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
