<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="SurfaceFlinger（一）-- 启动篇"/>




  <meta name="keywords" content="AndroidFrameworks,SurfaceFlinger," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/2fa835ad.html"/>


<meta name="description" content="关于 SurfaceFlinger的启动，可以从 frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Android.bp 文件中看出个大概。在该文件中，有如下代码： 12345678910111213141516171819....filegroup &amp;#123;    name: &quot;surfaceflinger_">
<meta property="og:type" content="article">
<meta property="og:title" content="SurfaceFlinger（一）-- 启动篇">
<meta property="og:url" content="https://youngkaaa.github.io/2fa835ad.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="关于 SurfaceFlinger的启动，可以从 frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Android.bp 文件中看出个大概。在该文件中，有如下代码： 12345678910111213141516171819....filegroup &amp;#123;    name: &quot;surfaceflinger_">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/2fa835ad/surface_flinger_01.png">
<meta property="article:published_time" content="2022-08-02T11:48:56.000Z">
<meta property="article:modified_time" content="2022-08-06T01:48:48.896Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="SurfaceFlinger">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/2fa835ad/surface_flinger_01.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> SurfaceFlinger（一）-- 启动篇 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          SurfaceFlinger（一）-- 启动篇
        
      </h1>

      <time class="post-time">
          8月 02 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>关于 SurfaceFlinger的启动，可以从 <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/Android.bp">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Android.bp</a> 文件中看出个大概。在该文件中，有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line">filegroup &#123;</span><br><span class="line">    name: &quot;surfaceflinger_binary_sources&quot;,</span><br><span class="line">    srcs: [&quot;main_surfaceflinger.cpp&quot;],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;surfaceflinger&quot;,</span><br><span class="line">    defaults: [&quot;libsurfaceflinger_binary&quot;],</span><br><span class="line">    init_rc: [&quot;surfaceflinger.rc&quot;],</span><br><span class="line">    srcs: [&quot;:surfaceflinger_binary_sources&quot;],</span><br><span class="line">    shared_libs: [</span><br><span class="line">        &quot;libsurfaceflinger&quot;,</span><br><span class="line">        &quot;libSurfaceFlingerProp&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>其中配置了 SurfaceFlinger 在Android启动初期需要加载的init.rc文件：surfaceflinger.rc ,以及 SurfaceFlinger 主函数入口 main_surfaceflinger.cpp。</p>
<p>关于这里的 bp 文件，以及 rc 文件的解析和使用，这里不再赘述，详见：<a href="3c031a43.html">Android bp</a> 、<a href="de9ff6b8.html">Android rc</a>。这里直接从 main_surfaceflinger.cpp 开始。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp">main_surfaceflinger.cpp</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span> &#123;</span><br><span class="line">		<span class="comment">// 省略部分代码</span></span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 1.创建 SurfaceFlinger 实例</span></span><br><span class="line">    <span class="comment">// instantiate surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::createSurfaceFlinger();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 省略部分代码	</span></span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 2.调用其 init 方法</span></span><br><span class="line">    <span class="comment">// initialize before clients can connect</span></span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// publish surface flinger</span></span><br><span class="line">    sp&lt;IServiceManager&gt; <span class="title function_">sm</span><span class="params">(defaultServiceManager())</span>;</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>,</span><br><span class="line">                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);</span><br><span class="line"></span><br><span class="line">    startDisplayService(); <span class="comment">// dependency on SF getting registered above</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (sched_setscheduler(<span class="number">0</span>, SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// </span></span><br><span class="line">    <span class="comment">// run surface flinger in this thread</span></span><br><span class="line">		<span class="comment">// 3.调用其 run 方法</span></span><br><span class="line">    flinger-&gt;run();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如上，省略掉了一些暂时可以不考虑的点之外(其实是我还没搞懂，囧)，剩余主要分为三步：</p>
<ol>
<li>创建出 SurfaceFlinger 对象实例</li>
<li>调用其 init() 方法</li>
<li>调用其 run()方法</li>
</ol>
<p>下面就按照这三步来进行分析：</p>
<h3 id="创建-SurfaceFlinger-对象实例"><a href="#创建-SurfaceFlinger-对象实例" class="headerlink" title="创建 SurfaceFlinger 对象实例"></a>创建 SurfaceFlinger 对象实例</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.cpp">SurfaceFlingerFactory.cpp</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceFlinger&gt; <span class="title function_">createSurfaceFlinger</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">final</span> :</span> public surfaceflinger::Factory &#123;</span><br><span class="line">    public:</span><br><span class="line">        Factory() = <span class="keyword">default</span>;</span><br><span class="line">        ~Factory() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DispSync&gt; <span class="title function_">createDispSync</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">bool</span> hasSyncFramework,</span></span><br><span class="line"><span class="params">                                                 <span class="type">int64_t</span> dispSyncPresentTimeOffset)</span> override &#123;</span><br><span class="line">            <span class="comment">// Note: We create a local temporary with the real DispSync implementation</span></span><br><span class="line">            <span class="comment">// type temporarily so we can initialize it with the configured values,</span></span><br><span class="line">            <span class="comment">// before storing it for more generic use using the interface type.</span></span><br><span class="line">            <span class="keyword">auto</span> primaryDispSync = <span class="built_in">std</span>::make_unique&lt;android::impl::DispSync&gt;(name);</span><br><span class="line">            primaryDispSync-&gt;init(hasSyncFramework, dispSyncPresentTimeOffset);</span><br><span class="line">            <span class="keyword">return</span> primaryDispSync;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventControlThread&gt; <span class="title function_">createEventControlThread</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="built_in">std</span>::function&lt;<span class="type">void</span>(<span class="type">bool</span>)&gt; setVSyncEnabled)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;android::impl::EventControlThread&gt;(setVSyncEnabled);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;HWComposer&gt; <span class="title function_">createHWComposer</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; serviceName)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;android::impl::HWComposer&gt;(</span><br><span class="line">                    <span class="built_in">std</span>::make_unique&lt;Hwc2::impl::Composer&gt;(serviceName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageQueue&gt; <span class="title function_">createMessageQueue</span><span class="params">()</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;android::impl::MessageQueue&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;scheduler::PhaseOffsets&gt; <span class="title function_">createPhaseOffsets</span><span class="params">()</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;scheduler::impl::PhaseOffsets&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Scheduler&gt; <span class="title function_">createScheduler</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="built_in">std</span>::function&lt;<span class="type">void</span>(<span class="type">bool</span>)&gt; callback,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> scheduler::RefreshRateConfigs&amp; refreshRateConfig)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;Scheduler&gt;(callback, refreshRateConfig);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SurfaceInterceptor&gt; <span class="title function_">createSurfaceInterceptor</span><span class="params">(</span></span><br><span class="line"><span class="params">                SurfaceFlinger* flinger)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;android::impl::SurfaceInterceptor&gt;(flinger);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;StartPropertySetThread&gt; <span class="title function_">createStartPropertySetThread</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="type">bool</span> timestampPropertyValue)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> new StartPropertySetThread(timestampPropertyValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;DisplayDevice&gt; <span class="title function_">createDisplayDevice</span><span class="params">(DisplayDeviceCreationArgs&amp;&amp; creationArgs)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> new DisplayDevice(<span class="built_in">std</span>::move(creationArgs));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;GraphicBuffer&gt; <span class="title function_">createGraphicBuffer</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, PixelFormat format,</span></span><br><span class="line"><span class="params">                                              <span class="type">uint32_t</span> layerCount, <span class="type">uint64_t</span> usage,</span></span><br><span class="line"><span class="params">                                              <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> new GraphicBuffer(width, height, format, layerCount, usage, requestorName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">createBufferQueue</span><span class="params">(sp&lt;IGraphicBufferProducer&gt;* outProducer,</span></span><br><span class="line"><span class="params">                               sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span></span><br><span class="line"><span class="params">                               <span class="type">bool</span> consumerIsSurfaceFlinger)</span> override &#123;</span><br><span class="line">            BufferQueue::createBufferQueue(outProducer, outConsumer, consumerIsSurfaceFlinger);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;surfaceflinger::NativeWindowSurface&gt; <span class="title function_">createNativeWindowSurface</span><span class="params">(</span></span><br><span class="line"><span class="params">                <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; producer)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> surfaceflinger::impl::createNativeWindowSurface(producer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;compositionengine::CompositionEngine&gt; <span class="title function_">createCompositionEngine</span><span class="params">()</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> compositionengine::impl::createCompositionEngine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;ContainerLayer&gt; <span class="title function_">createContainerLayer</span><span class="params">(<span class="type">const</span> LayerCreationArgs&amp; args)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> new ContainerLayer(args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;BufferQueueLayer&gt; <span class="title function_">createBufferQueueLayer</span><span class="params">(<span class="type">const</span> LayerCreationArgs&amp; args)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> new BufferQueueLayer(args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;BufferStateLayer&gt; <span class="title function_">createBufferStateLayer</span><span class="params">(<span class="type">const</span> LayerCreationArgs&amp; args)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> new BufferStateLayer(args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;ColorLayer&gt; <span class="title function_">createColorLayer</span><span class="params">(<span class="type">const</span> LayerCreationArgs&amp; args)</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> new ColorLayer(args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;TimeStats&gt; <span class="title function_">createTimeStats</span><span class="params">()</span> override &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;android::impl::TimeStats&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Factory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new SurfaceFlinger(factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，在createSurfaceFlinger() 方法中创建 SurfaceFlinger 时，会先创建一个Factory内部类，它继承自 surfaceflinger::Factory (在 <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.h">SurfaceFlingerFactory.h</a> 中定义)， 然后将该 Factory 类实例传入到 SurfaceFlinger 构造方法中去：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp">SurfaceFlinger.cpp</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法1</span></span><br><span class="line">SurfaceFlinger::SurfaceFlinger(Factory&amp; factory, SkipInitializationTag)</span><br><span class="line">      : mFactory(factory),</span><br><span class="line">        mPhaseOffsets(mFactory.createPhaseOffsets()),</span><br><span class="line">        mInterceptor(mFactory.createSurfaceInterceptor(this)),</span><br><span class="line">        mTimeStats(mFactory.createTimeStats()),</span><br><span class="line">        mEventQueue(mFactory.createMessageQueue()),</span><br><span class="line">        mCompositionEngine(mFactory.createCompositionEngine()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法1</span></span><br><span class="line">SurfaceFlinger::SurfaceFlinger(Factory&amp; factory) : SurfaceFlinger(factory, SkipInitialization) &#123;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，调用了 SurfaceFlinger 中 构造方法1 ，而构造方法1 中又调用到了构造方法2。对于构造方法1来说，其内部主要是初始化一些属性变量，包括从全局配置中读取一些属性设置，可以先不考虑，等后面用到时再挨个分析。这里需要关注的是构造方法1，其中会将上面创建出来的Factory 保存到了 mFactory 中；同时会通过这个 Factory 来创建其他属性，比如其中给 mEventQueue  创建一个 MessageQueue 实例，用于处理 SurfaceFlinger 中的消息；为 mCompositionEngine 创建一个  CompositionEngine 对象实例，用于合成 Layer。</p>
<p>额外我们需要看一下 SurfaceFlinger 类的一个继承关系：</p>
<p><img src="/2fa835ad/surface_flinger_01.png" alt="ssss"></p>
<p>可以看到，它实现了  HWC2::ComposerCallback 接口，用于接收来自HWC上层的事件通知，比如 vsync 事件和 hotplug 事件；以及实现了BnSurfaceComposer接口，而BnSurfaceComposer接口又是继承自BnInterface<ISurfaceComposer> 的，也就是作为 ISurfaceComposer 的服务端实现；DeathRecipient 是为了当Binder服务端程序挂掉后，可以通知给绑定的Binder客户端程序；</p>
<p>到这里，就完成了 SurfaceFlinger 对象的创建工作，简单总结下：就是创建出其实例，并且为其中一些关键变量或者模块初始化赋值，方便后续的使用。</p>
<h3 id="执行-init-方法"><a href="#执行-init-方法" class="headerlink" title="执行 init 方法"></a>执行 init 方法</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp">SurfaceFlinger.cpp</a>::init</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGI</span>(  <span class="string">&quot;SurfaceFlinger&#x27;s main thread ready to run. &quot;</span></span><br><span class="line">            <span class="string">&quot;Initializing graphics H/W...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;Phase offset NS: %&quot;</span> PRId64 <span class="string">&quot;&quot;</span>, mPhaseOffsets-&gt;<span class="built_in">getCurrentAppOffset</span>());</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    mScheduler =</span><br><span class="line">            <span class="built_in">getFactory</span>().<span class="built_in">createScheduler</span>([<span class="keyword">this</span>](<span class="type">bool</span> enabled) &#123; <span class="built_in">setPrimaryVsyncEnabled</span>(enabled); &#125;,</span><br><span class="line">                                         mRefreshRateConfigs);</span><br><span class="line">    <span class="keyword">auto</span> resyncCallback =</span><br><span class="line">            mScheduler-&gt;<span class="built_in">makeResyncCallback</span>(std::<span class="built_in">bind</span>(&amp;SurfaceFlinger::getVsyncPeriod, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    mAppConnectionHandle =</span><br><span class="line">            mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;app&quot;</span>, mVsyncModulator.<span class="built_in">getOffsets</span>().app,</span><br><span class="line">                                         mPhaseOffsets-&gt;<span class="built_in">getOffsetThresholdForNextVsync</span>(),</span><br><span class="line">                                         resyncCallback,</span><br><span class="line">                                         impl::EventThread::<span class="built_in">InterceptVSyncsCallback</span>());</span><br><span class="line">    mSfConnectionHandle =</span><br><span class="line">            mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;sf&quot;</span>, mVsyncModulator.<span class="built_in">getOffsets</span>().sf,</span><br><span class="line">                                         mPhaseOffsets-&gt;<span class="built_in">getOffsetThresholdForNextVsync</span>(),</span><br><span class="line">                                         resyncCallback, [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                             mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                         &#125;);</span><br><span class="line"></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventConnection</span>(mScheduler-&gt;<span class="built_in">getEventConnection</span>(mSfConnectionHandle));</span><br><span class="line">    mVsyncModulator.<span class="built_in">setSchedulerAndHandles</span>(mScheduler.<span class="built_in">get</span>(), mAppConnectionHandle.<span class="built_in">get</span>(),</span><br><span class="line">                                           mSfConnectionHandle.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    mRegionSamplingThread =</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">RegionSamplingThread</span>(*<span class="keyword">this</span>, *mScheduler,</span><br><span class="line">                                     RegionSamplingThread::<span class="built_in">EnvironmentTimingTunables</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a RenderEngine for the given display / config (can&#x27;t fail)</span></span><br><span class="line">    <span class="type">int32_t</span> renderEngineFeature = <span class="number">0</span>;</span><br><span class="line">    renderEngineFeature |= (useColorManagement ?</span><br><span class="line">                            renderengine::RenderEngine::USE_COLOR_MANAGEMENT : <span class="number">0</span>);</span><br><span class="line">    renderEngineFeature |= (useContextPriority ?</span><br><span class="line">                            renderengine::RenderEngine::USE_HIGH_PRIORITY_CONTEXT : <span class="number">0</span>);</span><br><span class="line">    renderEngineFeature |=</span><br><span class="line">            (<span class="built_in">enable_protected_contents</span>(<span class="literal">false</span>) ? renderengine::RenderEngine::ENABLE_PROTECTED_CONTEXT</span><br><span class="line">                                              : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(b/77156734): We need to stop casting and use HAL types when possible.</span></span><br><span class="line">    <span class="comment">// Sending maxFrameBufferAcquiredBuffers as the cache size is tightly tuned to single-display.</span></span><br><span class="line">    mCompositionEngine-&gt;<span class="built_in">setRenderEngine</span>(</span><br><span class="line">            renderengine::RenderEngine::<span class="built_in">create</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(defaultCompositionPixelFormat),</span><br><span class="line">                                               renderEngineFeature, maxFrameBufferAcquiredBuffers));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mVrFlingerRequestsDisplay,</span><br><span class="line">            <span class="string">&quot;Starting with vr flinger active is not currently supported.&quot;</span>);</span><br><span class="line">    mCompositionEngine-&gt;<span class="built_in">setHwComposer</span>(<span class="built_in">getFactory</span>().<span class="built_in">createHWComposer</span>(<span class="built_in">getBE</span>().mHwcServiceName));</span><br><span class="line">    mCompositionEngine-&gt;<span class="built_in">getHwComposer</span>().<span class="built_in">registerCallback</span>(<span class="keyword">this</span>, <span class="built_in">getBE</span>().mComposerSequenceId);</span><br><span class="line">    <span class="comment">// Process any initial hotplug and resulting display changes.</span></span><br><span class="line">    <span class="built_in">processDisplayHotplugEventsLocked</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!display, <span class="string">&quot;Missing internal display after registering composer callback.&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!<span class="built_in">getHwComposer</span>().<span class="built_in">isConnected</span>(*display-&gt;<span class="built_in">getId</span>()),</span><br><span class="line">                        <span class="string">&quot;Internal display is disconnected.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useVrFlinger) &#123;</span><br><span class="line">        <span class="keyword">auto</span> vrFlingerRequestDisplayCallback = [<span class="keyword">this</span>](<span class="type">bool</span> requestDisplay) &#123;</span><br><span class="line">            <span class="comment">// This callback is called from the vr flinger dispatch thread. We</span></span><br><span class="line">            <span class="comment">// need to call signalTransaction(), which requires holding</span></span><br><span class="line">            <span class="comment">// mStateLock when we&#x27;re not on the main thread. Acquiring</span></span><br><span class="line">            <span class="comment">// mStateLock from the vr flinger dispatch thread might trigger a</span></span><br><span class="line">            <span class="comment">// deadlock in surface flinger (see b/66916578), so post a message</span></span><br><span class="line">            <span class="comment">// to be handled on the main thread instead.</span></span><br><span class="line">            <span class="built_in">postMessageAsync</span>(<span class="keyword">new</span> <span class="built_in">LambdaMessage</span>([=] &#123;</span><br><span class="line">                <span class="built_in">ALOGI</span>(<span class="string">&quot;VR request display mode: requestDisplay=%d&quot;</span>, requestDisplay);</span><br><span class="line">                mVrFlingerRequestsDisplay = requestDisplay;</span><br><span class="line">                <span class="built_in">signalTransaction</span>();</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;;</span><br><span class="line">        mVrFlinger = dvr::VrFlinger::<span class="built_in">Create</span>(<span class="built_in">getHwComposer</span>().<span class="built_in">getComposer</span>(),</span><br><span class="line">                                            <span class="built_in">getHwComposer</span>()</span><br><span class="line">                                                    .<span class="built_in">fromPhysicalDisplayId</span>(*display-&gt;<span class="built_in">getId</span>())</span><br><span class="line">                                                    .<span class="built_in">value_or</span>(<span class="number">0</span>),</span><br><span class="line">                                            vrFlingerRequestDisplayCallback);</span><br><span class="line">        <span class="keyword">if</span> (!mVrFlinger) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to start vrflinger&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize our drawing state</span></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set initial conditions (e.g. unblank default device)</span></span><br><span class="line">    <span class="built_in">initializeDisplays</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getRenderEngine</span>().<span class="built_in">primeCache</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inform native graphics APIs whether the present timestamp is supported:</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> presentFenceReliable =</span><br><span class="line">            !<span class="built_in">getHwComposer</span>().<span class="built_in">hasCapability</span>(HWC2::Capability::PresentFenceIsNotReliable);</span><br><span class="line">    mStartPropertySetThread = <span class="built_in">getFactory</span>().<span class="built_in">createStartPropertySetThread</span>(presentFenceReliable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStartPropertySetThread-&gt;<span class="built_in">Start</span>() != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Run StartPropertySetThread failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mScheduler-&gt;<span class="built_in">setChangeRefreshRateCallback</span>(</span><br><span class="line">            [<span class="keyword">this</span>](RefreshRateType type, Scheduler::ConfigEvent event) &#123;</span><br><span class="line">                Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">                <span class="built_in">setRefreshRateTo</span>(type, event);</span><br><span class="line">            &#125;);</span><br><span class="line">    mScheduler-&gt;<span class="built_in">setGetCurrentRefreshRateTypeCallback</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">        Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">        <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">            <span class="comment">// If we don&#x27;t have a default display the fallback to the default</span></span><br><span class="line">            <span class="comment">// refresh rate type</span></span><br><span class="line">            <span class="keyword">return</span> RefreshRateType::DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> configId = display-&gt;<span class="built_in">getActiveConfig</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [type, refresh] : mRefreshRateConfigs.<span class="built_in">getRefreshRates</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (refresh &amp;&amp; refresh-&gt;configId == configId) &#123;</span><br><span class="line">                <span class="keyword">return</span> type;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This should never happen, but just gracefully fallback to default.</span></span><br><span class="line">        <span class="keyword">return</span> RefreshRateType::DEFAULT;</span><br><span class="line">    &#125;);</span><br><span class="line">    mScheduler-&gt;<span class="built_in">setGetVsyncPeriodCallback</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">        Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mRefreshRateConfigs.<span class="built_in">populate</span>(<span class="built_in">getHwComposer</span>().<span class="built_in">getConfigs</span>(*display-&gt;<span class="built_in">getId</span>()));</span><br><span class="line">    mRefreshRateStats.<span class="built_in">setConfigMode</span>(<span class="built_in">getHwComposer</span>().<span class="built_in">getActiveConfigIndex</span>(*display-&gt;<span class="built_in">getId</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Done initializing&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该方法是 SurfaceFlinger 启动逻辑中最重要的部分，代码行数不多，但是执行的逻辑不少，且错综复杂。下面分块来介绍：</p>
<h4 id="1、创建并启动DispSyncThread、sf-EventThread-和-app-EventThread"><a href="#1、创建并启动DispSyncThread、sf-EventThread-和-app-EventThread" class="headerlink" title="1、创建并启动DispSyncThread、sf EventThread 和 app EventThread"></a>1、创建并启动DispSyncThread、sf EventThread 和 app EventThread</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start the EventThread</span></span><br><span class="line">   mScheduler =</span><br><span class="line">           <span class="built_in">getFactory</span>().<span class="built_in">createScheduler</span>([<span class="keyword">this</span>](<span class="type">bool</span> enabled) &#123; <span class="built_in">setPrimaryVsyncEnabled</span>(enabled); &#125;,</span><br><span class="line">                                        mRefreshRateConfigs);</span><br><span class="line">   <span class="keyword">auto</span> resyncCallback =</span><br><span class="line">           mScheduler-&gt;<span class="built_in">makeResyncCallback</span>(std::<span class="built_in">bind</span>(&amp;SurfaceFlinger::getVsyncPeriod, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   mAppConnectionHandle =</span><br><span class="line">           mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;app&quot;</span>, mVsyncModulator.<span class="built_in">getOffsets</span>().app,</span><br><span class="line">                                        mPhaseOffsets-&gt;<span class="built_in">getOffsetThresholdForNextVsync</span>(),</span><br><span class="line">                                        resyncCallback,</span><br><span class="line">                                        impl::EventThread::<span class="built_in">InterceptVSyncsCallback</span>());</span><br><span class="line">   mSfConnectionHandle =</span><br><span class="line">           mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;sf&quot;</span>, mVsyncModulator.<span class="built_in">getOffsets</span>().sf,</span><br><span class="line">                                        mPhaseOffsets-&gt;<span class="built_in">getOffsetThresholdForNextVsync</span>(),</span><br><span class="line">                                        resyncCallback, [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                            mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                        &#125;);</span><br><span class="line">   mEventQueue-&gt;<span class="built_in">setEventConnection</span>(mScheduler-&gt;<span class="built_in">getEventConnection</span>(mSfConnectionHandle));</span><br><span class="line">   mVsyncModulator.<span class="built_in">setSchedulerAndHandles</span>(mScheduler.<span class="built_in">get</span>(), mAppConnectionHandle.<span class="built_in">get</span>(),</span><br><span class="line">                                          mSfConnectionHandle.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">   mRegionSamplingThread =</span><br><span class="line">           <span class="keyword">new</span> <span class="built_in">RegionSamplingThread</span>(*<span class="keyword">this</span>, *mScheduler,</span><br><span class="line">                                    RegionSamplingThread::<span class="built_in">EnvironmentTimingTunables</span>());</span><br></pre></td></tr></table></figure>

<p>通过 getFactory() 拿到全局的 mFactory 实例，它就是在前面 SurfaceFlinger 构造方法时传入的。调用其 createScheduler 方法来创建一个 Scheduler 实例。</p>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/SurfaceFlingerFactory.cpp">SurfaceFlingerFactory::createScheduler</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Scheduler&gt; <span class="title">createScheduler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                std::function&lt;<span class="type">void</span>(<span class="type">bool</span>)&gt; callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> scheduler::RefreshRateConfigs&amp; refreshRateConfig)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Scheduler&gt;(callback, refreshRateConfig);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在 createScheduler 方法中，接收两个参数，最重要的是第一个参数 callback。它传入进来的值是：[ this] (bool enabled) { setPrimaryVsyncEnabled(enabled); }  ,他是一个lambda语句，可以按照Java 中的lambda来理解，只是写法不一样而已，内部持有这个callback 之后，在需要的时候可以调用: callback(bool) 来执行其中的语句，也就是执行 SurfaceFlinger::setPrimaryVsyncEnabled(enabled); 。</p>
<blockquote>
<p>PS : 这个 callback 后面又在内部被重命名为： SetVSyncEnabledFunction (详见 <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/Scheduler/EventControlThread.h">EventControlThread</a>) 。</p>
</blockquote>
<p>这里创建Scheduler 对象时，会执行到 Scheduler 构造方法中去：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r25:frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp">Scheduler</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Scheduler::<span class="built_in">Scheduler</span>(impl::EventControlThread::SetVSyncEnabledFunction function,</span><br><span class="line">                     <span class="type">const</span> scheduler::RefreshRateConfigs&amp; refreshRateConfig)</span><br><span class="line">      : <span class="built_in">mHasSyncFramework</span>(<span class="built_in">running_without_sync_framework</span>(<span class="literal">true</span>)),</span><br><span class="line">        <span class="built_in">mDispSyncPresentTimeOffset</span>(<span class="built_in">present_time_offset_from_vsync_ns</span>(<span class="number">0</span>)),</span><br><span class="line">        <span class="built_in">mPrimaryHWVsyncEnabled</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mHWVsyncAvailable</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mRefreshRateConfigs</span>(refreshRateConfig) &#123;</span><br><span class="line">    <span class="comment">// Note: We create a local temporary with the real DispSync implementation</span></span><br><span class="line">    <span class="comment">// type temporarily so we can initialize it with the configured values,</span></span><br><span class="line">    <span class="comment">// before storing it for more generic use using the interface type.</span></span><br><span class="line">    <span class="keyword">auto</span> primaryDispSync = std::<span class="built_in">make_unique</span>&lt;impl::DispSync&gt;(<span class="string">&quot;SchedulerDispSync&quot;</span>);</span><br><span class="line">    primaryDispSync-&gt;<span class="built_in">init</span>(mHasSyncFramework, mDispSyncPresentTimeOffset);</span><br><span class="line">    mPrimaryDispSync = std::<span class="built_in">move</span>(primaryDispSync);</span><br><span class="line">    mEventControlThread = std::<span class="built_in">make_unique</span>&lt;impl::EventControlThread&gt;(function);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 Scheduler 构造方法中，有个比较重要的点需要额外指出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> primaryDispSync = <span class="built_in">std</span>::make_unique&lt;impl::DispSync&gt;(<span class="string">&quot;SchedulerDispSync&quot;</span>);</span><br><span class="line">  primaryDispSync-&gt;init(mHasSyncFramework, mDispSyncPresentTimeOffset);</span><br><span class="line">  mPrimaryDispSync = <span class="built_in">std</span>::move(primaryDispSync);</span><br><span class="line">  mEventControlThread = <span class="built_in">std</span>::make_unique&lt;impl::EventControlThread&gt;(function);</span><br></pre></td></tr></table></figure>

<p>这里做了两件事情，</p>
<p>​		1、创建 DispSync 实例，然后执行DispSync::init 方法，该方法内部会启动内部创建好的 DispSyncThread 线程，用来处理 vsync 信号。详见：<a href="6caea16d.html">DispSync分析</a>。然后将创建好的 DispSync 对象保存到 Scheudler 中的 mPrimaryDispSync 中，后续在创建 <a href="3614bdc1.html">EventThread</a> 时，它会派上用场。</p>
<p>​		2、创建 EventControlThread 实例，并启动其线程开始执行。详见：<a href="c3618467.html">EventControlThread </a></p>
<h4 id="2、创建-RenderEngine，用于后面-Layer-渲染和合成"><a href="#2、创建-RenderEngine，用于后面-Layer-渲染和合成" class="headerlink" title="2、创建 RenderEngine，用于后面 Layer 渲染和合成"></a>2、创建 RenderEngine，用于后面 Layer 渲染和合成</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> renderEngineFeature = <span class="number">0</span>;</span><br><span class="line">renderEngineFeature |= (useColorManagement ?</span><br><span class="line">                         renderengine::RenderEngine::USE_COLOR_MANAGEMENT : <span class="number">0</span>);</span><br><span class="line">renderEngineFeature |= (useContextPriority ?</span><br><span class="line">                          renderengine::RenderEngine::USE_HIGH_PRIORITY_CONTEXT : <span class="number">0</span>);</span><br><span class="line">renderEngineFeature |=(<span class="built_in">enable_protected_contents</span>(<span class="literal">false</span>) ? renderengine::RenderEngine::ENABLE_PROTECTED_CONTEXT: <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(b/77156734): We need to stop casting and use HAL types when possible.</span></span><br><span class="line">    <span class="comment">// Sending maxFrameBufferAcquiredBuffers as the cache size is tightly tuned to single-display.</span></span><br><span class="line">mCompositionEngine-&gt;<span class="built_in">setRenderEngine</span>(</span><br><span class="line">        renderengine::RenderEngine::<span class="built_in">create</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(defaultCompositionPixelFormat),</span><br><span class="line">                                               renderEngineFeature, maxFrameBufferAcquiredBuffers));</span><br><span class="line"></span><br><span class="line"><span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mVrFlingerRequestsDisplay,<span class="string">&quot;Starting with vr flinger active is not currently supported.&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="3、创建上层-HWComposer-，连通上层-HWC"><a href="#3、创建上层-HWComposer-，连通上层-HWC" class="headerlink" title="3、创建上层 HWComposer ，连通上层 HWC"></a>3、创建上层 HWComposer ，连通上层 HWC</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mCompositionEngine-&gt;setHwComposer(getFactory().createHWComposer(getBE().mHwcServiceName));</span><br><span class="line">mCompositionEngine-&gt;getHwComposer().registerCallback(this, getBE().mComposerSequenceId);</span><br><span class="line">// Process any initial hotplug and resulting display changes.</span><br><span class="line">processDisplayHotplugEventsLocked();</span><br></pre></td></tr></table></figure>



<h4 id="4、剩余工作，比如播放开机动画等"><a href="#4、剩余工作，比如播放开机动画等" class="headerlink" title="4、剩余工作，比如播放开机动画等"></a>4、剩余工作，比如播放开机动画等</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// initialize our drawing state</span><br><span class="line">mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">// set initial conditions (e.g. unblank default device)</span><br><span class="line">initializeDisplays();</span><br><span class="line"></span><br><span class="line">getRenderEngine().primeCache();</span><br><span class="line"></span><br><span class="line">// Inform native graphics APIs whether the present timestamp is supported:</span><br><span class="line"></span><br><span class="line">const bool presentFenceReliable =</span><br><span class="line">        !getHwComposer().hasCapability(HWC2::Capability::PresentFenceIsNotReliable);</span><br><span class="line">mStartPropertySetThread = getFactory().createStartPropertySetThread(presentFenceReliable);</span><br><span class="line"></span><br><span class="line">if (mStartPropertySetThread-&gt;Start() != NO_ERROR) &#123;</span><br><span class="line">    ALOGE(&quot;Run StartPropertySetThread failed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mScheduler-&gt;setChangeRefreshRateCallback(</span><br><span class="line">        [this](RefreshRateType type, Scheduler::ConfigEvent event) &#123;</span><br><span class="line">            Mutex::Autolock lock(mStateLock);</span><br><span class="line">            setRefreshRateTo(type, event);</span><br><span class="line">        &#125;);</span><br><span class="line">mScheduler-&gt;setGetCurrentRefreshRateTypeCallback([this] &#123;</span><br><span class="line">    Mutex::Autolock lock(mStateLock);</span><br><span class="line">    const auto display = getDefaultDisplayDeviceLocked();</span><br><span class="line">    if (!display) &#123;</span><br><span class="line">        // If we don&#x27;t have a default display the fallback to the default</span><br><span class="line">        // refresh rate type</span><br><span class="line">        return RefreshRateType::DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const int configId = display-&gt;getActiveConfig();</span><br><span class="line">    for (const auto&amp; [type, refresh] : mRefreshRateConfigs.getRefreshRates()) &#123;</span><br><span class="line">        if (refresh &amp;&amp; refresh-&gt;configId == configId) &#123;</span><br><span class="line">            return type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // This should never happen, but just gracefully fallback to default.</span><br><span class="line">    return RefreshRateType::DEFAULT;</span><br><span class="line">&#125;);</span><br><span class="line">mScheduler-&gt;setGetVsyncPeriodCallback([this] &#123;</span><br><span class="line">    Mutex::Autolock lock(mStateLock);</span><br><span class="line">    return getVsyncPeriod();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mRefreshRateConfigs.populate(getHwComposer().getConfigs(*display-&gt;getId()));</span><br><span class="line">mRefreshRateStats.setConfigMode(getHwComposer().getActiveConfigIndex(*display-&gt;getId()));</span><br><span class="line"></span><br><span class="line">ALOGV(&quot;Done initializing&quot;);</span><br></pre></td></tr></table></figure>





<h3 id="执行-run-方法"><a href="#执行-run-方法" class="headerlink" title="执行 run 方法"></a>执行 run 方法</h3>
            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/SurfaceFlinger/">SurfaceFlinger</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/692c4604.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">02-AOSP-OPENGL_ES</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/a6d96fd1.html">
        <span class="next-text nav-default">Ijkplayer-SDL_AudioCallback</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2022
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
