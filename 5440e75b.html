<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="SurfaceFlinger - INVALIDATE"/>




  <meta name="keywords" content="AndroidFrameworks,SurfaceFlinger," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/5440e75b.html"/>


<meta name="description" content="SurfaceFlinger 它还有另外一个重要的任务：合成Layer 。 从上文 SurfaceFlinger 可以知道：SurfaceFlinger中的MessageQueue会监听来自sf EventThread的vsync事件，然后将其转换为 INVALIDATE 类型的消息放入到消息队列中排队等待处理，等到处理该消息时，会将其传递到 SurfaceFlinger::onMessageRe">
<meta property="og:type" content="article">
<meta property="og:title" content="SurfaceFlinger - INVALIDATE">
<meta property="og:url" content="https://youngkaaa.github.io/5440e75b.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="SurfaceFlinger 它还有另外一个重要的任务：合成Layer 。 从上文 SurfaceFlinger 可以知道：SurfaceFlinger中的MessageQueue会监听来自sf EventThread的vsync事件，然后将其转换为 INVALIDATE 类型的消息放入到消息队列中排队等待处理，等到处理该消息时，会将其传递到 SurfaceFlinger::onMessageRe">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-05T11:49:56.000Z">
<meta property="article:modified_time" content="2023-02-24T12:01:17.395Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="SurfaceFlinger">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> SurfaceFlinger - INVALIDATE - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          SurfaceFlinger - INVALIDATE
        
      </h1>

      <time class="post-time">
          8月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>SurfaceFlinger 它还有另外一个重要的任务：合成Layer 。</p>
<p>从上文 <a href="2fa835ad.html">SurfaceFlinger</a> 可以知道：SurfaceFlinger中的MessageQueue会监听来自sf <a href="7b339bd2.html">EventThread</a>的vsync事件，然后将其转换为 INVALIDATE 类型的消息放入到消息队列中排队等待处理，等到处理该消息时，会将其传递到 SurfaceFlinger::onMessageReceived 中，最后在 SurfaceFlinger 中完成剩余操作。</p>
<p>而在 SurfaceFlinger::onMessageReceived() 方法中，主要处理了两种类型的消息，一种是 MessageQueue::INVALIDATE ，另外一种是：MessageQueue::REFRESH 。而本文主要分析前者，也就是 INVALIDATE 消息是怎么处理的。</p>
<p>INVALIDATE消息类型表示刷新，即刷新当前所有的Layer显示区域、宽高尺寸等信息。</p>
<p>这里先看其对应的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="type">int32_t</span> what)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">      <span class="built_in">populateExpectedPresentTime</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="type">int</span> graceTimeForPresentFenceMs = (mPropagateBackpressure &amp;&amp;</span><br><span class="line">          (mPropagateBackpressureClientComposition || !mHadClientComposition)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">bool</span> frameMissed = <span class="built_in">previousFrameMissed</span>(graceTimeForPresentFenceMs);</span><br><span class="line">      <span class="type">bool</span> hwcFrameMissed = mHadDeviceComposition &amp;&amp; frameMissed;</span><br><span class="line">      <span class="type">bool</span> gpuFrameMissed = mHadClientComposition &amp;&amp; frameMissed;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> (frameMissed) &#123;</span><br><span class="line">        mFrameMissedCount++;</span><br><span class="line">        mTimeStats-&gt;<span class="built_in">incrementMissedFrames</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hwcFrameMissed) &#123;</span><br><span class="line">        mHwcFrameMissedCount++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (gpuFrameMissed) &#123;</span><br><span class="line">        mGpuFrameMissedCount++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mUseSmart90ForVideo) &#123;</span><br><span class="line">        mScheduler-&gt;<span class="built_in">updateFpsBasedOnContent</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">performSetActiveConfig</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (frameMissed &amp;&amp; mPropagateBackpressure) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((hwcFrameMissed &amp;&amp; !gpuFrameMissed) || mPropagateBackpressureClientComposition) &#123;</span><br><span class="line">          <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">updateVrFlinger</span>();</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 先调用 handleMessageTransaction 来消化处理全局设置的 transactionFlags ，</span></span><br><span class="line"><span class="comment">       * 通过不同的 transactionFlags 标识位来调用 layer 不同的方法，通知 layer 使其完成一些更新计算等</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 然后调用 handleMessageInvalidate 来先查找到要显示的 layer，</span></span><br><span class="line"><span class="comment">       * 通过 latchBuffer 方法来从该 Layer 的消费队列中获取一个合适的Buffer来准备消费处理</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">bool</span> refreshNeeded = <span class="built_in">handleMessageTransaction</span>();</span><br><span class="line">      refreshNeeded |= <span class="built_in">handleMessageInvalidate</span>();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">updateCursorAsync</span>();</span><br><span class="line">      <span class="built_in">updateInputFlinger</span>();</span><br><span class="line"></span><br><span class="line">      refreshNeeded |= mRepaintEverything;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * refreshNeeded : 上面  handleMessageTransaction 、  handleMessageInvalidate 、mRepaintEverything 其中一个为 true 时</span></span><br><span class="line"><span class="comment">       * mBootStage ： 在上面 handleMessageInvalidate 、 handlePageFlip 中满足条件后会置为 BOOTANIMATION</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (refreshNeeded &amp;&amp; <span class="built_in">CC_LIKELY</span>(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">        <span class="comment">// 发送一条 REFRESH 消息，然后会在当前 onMessageReceived 中接受到，从而执行下面的 MessageQueue::REFRESH</span></span><br><span class="line">        <span class="built_in">signalRefresh</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">      <span class="comment">// 暂且不看</span></span><br><span class="line">      <span class="built_in">handleMessageRefresh</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接受到 MessageQueue::INVALIDATE 消息时，会通知相关的 Layer 来完成自身事务的处理，为后续绘制做好准备。</p>
<p>而这些逻辑主要都是集中在 handleMessageTransaction() 和 handleMessageInvalidate() 方法中。下面就着重分析这俩方法。</p>
<h3 id="handleMessageTransaction"><a href="#handleMessageTransaction" class="headerlink" title="handleMessageTransaction"></a>handleMessageTransaction</h3><p>先看一部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handleMessageTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// peekTransactionFlags 函数是拿到 mTransactionFlags，这个标志会在接收到一些事务的时候发生改变</span></span><br><span class="line">  <span class="type">uint32_t</span> transactionFlags = <span class="built_in">peekTransactionFlags</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> flushedATransaction = <span class="built_in">flushTransactionQueues</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> runHandleTransaction = transactionFlags &amp;&amp;</span><br><span class="line">      ((transactionFlags != eTransactionFlushNeeded) || flushedATransaction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先看是否有需要处理的事务，如果有的话就执行 handleTransaction</span></span><br><span class="line">  <span class="comment">// 如果没有调用 getTransactionFlags 方法来清理掉 mTransactionFlags 中指定位的值</span></span><br><span class="line">  <span class="keyword">if</span> (runHandleTransaction) &#123;</span><br><span class="line">    <span class="built_in">handleTransaction</span>(eTransactionMask);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">getTransactionFlags</span>(eTransactionFlushNeeded);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">transactionFlushNeeded</span>()) &#123;</span><br><span class="line">    <span class="built_in">setTransactionFlags</span>(eTransactionFlushNeeded);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> runHandleTransaction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleTransaction</span><span class="params">(<span class="type">uint32_t</span> transactionFlags)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 为 mDrawingState 创建一个副本 drawingState</span></span><br><span class="line">  <span class="function">State <span class="title">drawingState</span><span class="params">(mDrawingState)</span></span>;</span><br><span class="line"></span><br><span class="line">  Mutex::Autolock _l(mStateLock);</span><br><span class="line">  mDebugInTransaction = <span class="built_in">systemTime</span>();</span><br><span class="line"></span><br><span class="line">  mVsyncModulator.<span class="built_in">onTransactionHandled</span>();</span><br><span class="line">  <span class="comment">// 获取当前的 mTransactionFlags ，并且将其清空为 0 </span></span><br><span class="line">  <span class="comment">// 内部先将其与 ~eTransactionMask 做与操作清空掉，然后保存清空之前的值与 eTransactionMask 做 与操作，取出指定位的值</span></span><br><span class="line">  transactionFlags = <span class="built_in">getTransactionFlags</span>(eTransactionMask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 handleTransactionLocked 这个是真正处理事务的函数</span></span><br><span class="line">  <span class="built_in">handleTransactionLocked</span>(transactionFlags);</span><br><span class="line"></span><br><span class="line">  mDebugInTransaction = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其实就是将 mGeometryInvalid 置为 true </span></span><br><span class="line">  <span class="built_in">invalidateHwcGeometry</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">SurfaceFlinger::peekTransactionFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 原封不动返回 mTransactionFlags 属性的值</span></span><br><span class="line">  <span class="keyword">return</span> mTransactionFlags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">SurfaceFlinger::getTransactionFlags</span><span class="params">(<span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回 mTransactionFlags 中的值，返回指定位的值，并且清除掉mTransactionFlags中原来的值</span></span><br><span class="line">  <span class="keyword">return</span> mTransactionFlags.<span class="built_in">fetch_and</span>(~flags) &amp; flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 handleMessageTransaction() 方法中，首先会拿到 SurfaceFlinger 中的成员变量：mTransactionFlags ，然后根据它的值来做一些条件判断：</p>
<p>条件①：transactionFlags 值存在，并且不等于 eTransactionFlushNeeded</p>
<p>条件②：执行 flushTransactionQueues() 方法来拿到其返回值，这个条件暂且不管。</p>
<p>当条件①或者条件②满足其一时，则会执行 handleTransaction() 方法来完成后续的操作。</p>
<p>这里关于 mTransactionFlags 需要补充一些东西。该属性位于 SurfaceFlinger 类定义中，用来额外存储刷新策略，和他相关的定义有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  eTransactionNeeded = <span class="number">0x01</span>,        <span class="comment">// 0000 0000 0000 0001</span></span><br><span class="line">  eTraversalNeeded = <span class="number">0x02</span>,          <span class="comment">// 0000 0000 0000 0010</span></span><br><span class="line">  eDisplayTransactionNeeded = <span class="number">0x04</span>, <span class="comment">// 0000 0000 0000 0100</span></span><br><span class="line">  eDisplayLayerStackChanged = <span class="number">0x08</span>, <span class="comment">// 0000 0000 0000 1000 </span></span><br><span class="line">  eTransactionFlushNeeded = <span class="number">0x10</span>,   <span class="comment">// 0000 0000 0001 0000</span></span><br><span class="line">  eTransactionMask = <span class="number">0x1f</span>,          <span class="comment">// 0000 0000 0001 1111 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到这些定义就不难理解了吧，这是使用每一位来表示不同的标识，比如是否需要遍历操作等。这些标识在后面的分析中会经常遇到，所以这里先不分析挨个具体的含义，等到后面具体场景中再具体分析。</p>
<p>等到后续运行过程中，如果有对应的情况发生，会往 mTransactionFlags 中指定位上拼接标识。下面举几个实际场景：</p>
<p>① 在前面提及的创建 Layer 时，会调用到 SurfaceFlinger 中的 createLayer 方法中，在该方法内，会先创建好 Layer 。</p>
<p>然后调用 SurfaceFlinger 的 addClientLayer 方法来将该 Layer 加入到指定的地方，比如将该 Layer  加入到SurfaceFlinger 中mCurrentState.layersSortedByZ 中，或者加入到父 Layer 中作为其 子Layer 来使用。</p>
<p>最后回到 createLayer 方法中，会在最后调用setTransactionFlags() 方法来给 mTransactionFlags 设置 eTransactionNeeded 位信息。表示后续需要执行相关事务来处理这个新增的Layer。</p>
<p>② 由于 SurfaceFlinger 往 HWC 层注册了监听(在 SurfaceFlinger::init 方法中执行的，详见:<a href="2fa835ad.html">SurfaceFlinger 初始化</a>)，这样的话后续会在 SurfaceFlinger 中收到来自 HWC 的 vsync 事件和 hotplug(屏幕热插拔)事件，在接收热插拔事件的  SurfaceFlinger::onHotplugReceived() 方法中，会在方法最后同样来给 mTransactionFlags 设置 eTransactionNeeded 位信息。表示后续需要执行相关事务来处理这个新增的Layer。</p>
<p>而这里判断的条件①是不等于 eTransactionFlushNeeded ，我们以 createLayer 为前置操作来理解的话，这里的条件①就是满足的，因此会执行后续的 handleTransaction() 方法来处理事务。</p>
<p>在 handleTransaction() 中调用的是 getTransactionFlags() 方法，而在前面的 handleMessageTransaction() 方法中调用的是 peekTransactionFlags() ，前者这里在调用时传入了 eTransactionMask ，表示返回其对应位的值，并且清除掉对应位的值，可以理解为是消费掉对应位的值，而这里的 eTransactionMask 是消耗掉低5位的值。</p>
<p>接着就是最重要的 ：handleTransactionLocked() 方法了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleTransactionLocked</span><span class="params">(<span class="type">uint32_t</span> transactionFlags)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一步：事务处理之前的准备工作</span></span><br><span class="line"><span class="comment">   * 即；在执行 transaction 之前，先挨个调用其 notifyAvailableFrames 方法来进行准备</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mCurrentState.<span class="built_in">traverseInZOrder</span>([](Layer *layer) &#123;</span><br><span class="line">    layer-&gt;<span class="built_in">notifyAvailableFrames</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第二步：遍历 Layer ，处理每个 Layer 内部的事务，</span></span><br><span class="line"><span class="comment">   * 如果入参 flag 中有 eTraversalNeeded 标识，则遍历所有 Layer ，处理每个 Layer 中的事务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ((transactionFlags &amp; eTraversalNeeded) || mTraversalNeededMainThread) &#123;</span><br><span class="line">    <span class="comment">// 遍历 Layer </span></span><br><span class="line">    mCurrentState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer *layer) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取每个 Layer 自身的 mTransactionFlags , 进而可以判断每个 Layer 是否需要执行 transaction</span></span><br><span class="line">      <span class="type">uint32_t</span> trFlags = layer-&gt;<span class="built_in">getTransactionFlags</span>(eTransactionNeeded);</span><br><span class="line">      <span class="comment">// 如果该 Layer 的 mTransactionFlags 为 0，则表示该 Layer 不需要执行 transaction</span></span><br><span class="line">      <span class="keyword">if</span> (!trFlags) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 能执行到这里，表示该 Layer 需要执行 transaction ，那么此时调用其 doTransaction 方法，最终返回计算后的 flag</span></span><br><span class="line">      <span class="comment">// 该方法内部会判断该 Layer 中到底是啥发生变化了，是可见区域变化了还是输入状态变化了，会将对应变化的位标识加到返回值中</span></span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> flags = layer-&gt;<span class="built_in">doTransaction</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 如果该 layer 中是可见区域发生变化了，也就是返回值中有 eVisibleRegion</span></span><br><span class="line">      <span class="comment">// 那么此时会把 mVisibleRegionsDirty 就置为 true</span></span><br><span class="line">      <span class="comment">// mVisibleRegionsDirty 是属于 SurfaceFlinger 的成员变量，这里赋值之后，后续会用到它</span></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果该 layer 中是输入状态发生变化了，那么将 mInputInfoChanged 置为 true</span></span><br><span class="line">      <span class="comment">// mInputInfoChanged 是属于 SurfaceFlinger 的成员变量，这里赋值之后，后续会用到它</span></span><br><span class="line">      <span class="keyword">if</span> (flags &amp; Layer::eInputInfoChanged) &#123;</span><br><span class="line">        mInputInfoChanged = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    mTraversalNeededMainThread = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 第三步：处理显示设备的变化事务，当然一般只有一个显示设备，也就是手机屏幕</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (transactionFlags &amp; eDisplayTransactionNeeded) &#123;</span><br><span class="line">    <span class="built_in">processDisplayChangesLocked</span>();</span><br><span class="line">    <span class="built_in">processDisplayHotplugEventsLocked</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第四步：处理 Layer 中的图层堆栈信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (transactionFlags &amp; (eDisplayLayerStackChanged | eDisplayTransactionNeeded)) &#123;</span><br><span class="line">    sp&lt;<span class="type">const</span> DisplayDevice&gt; hintDisplay;</span><br><span class="line">    <span class="type">uint32_t</span> currentlayerStack = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> first = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每个 Layer， 然后判断该 Layer 是属于哪个 Display 的</span></span><br><span class="line">    mCurrentState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer *layer) &#123;</span><br><span class="line">      <span class="comment">// layerStack 是一个 uint32_t 的值，它表示当前的图层关联的图层堆栈</span></span><br><span class="line">      <span class="comment">// 使用它可以判断出来它属于哪个 Display ，因为有些 Layer 可能指定只在某个 Display 上显示</span></span><br><span class="line">      <span class="type">uint32_t</span> layerStack = layer-&gt;<span class="built_in">getLayerStack</span>();</span><br><span class="line">      <span class="comment">// first 在 traverseInZOrder 第一次时是 true ，后续就都是 false 了</span></span><br><span class="line">      <span class="comment">// 如果是第一个图层，或者是遍历时当前 Layer 的图层堆栈与上一个的不一样</span></span><br><span class="line">      <span class="keyword">if</span> (first || currentlayerStack != layerStack) &#123;</span><br><span class="line"></span><br><span class="line">        currentlayerStack = layerStack;</span><br><span class="line">        <span class="comment">// 确定此 layerstack 是否已镜像（多个显示）。如果是镜像就选择默认显示；如果不是镜像就选择唯一显示。</span></span><br><span class="line">        hintDisplay = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历当前所有的显示设备(当然一般只有一个屏幕在显示)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp;[token, display]: mDisplays) &#123;</span><br><span class="line">          <span class="comment">// 该 layer 是否属于该 Display ，即是否在该 Display 上显示</span></span><br><span class="line">          <span class="keyword">if</span> (display-&gt;<span class="built_in">getCompositionDisplay</span>()-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(),</span><br><span class="line">                                                                layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hintDisplay) &#123;</span><br><span class="line">              hintDisplay = <span class="literal">nullptr</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              hintDisplay = display;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!hintDisplay) &#123;</span><br><span class="line">        <span class="comment">// 使用默认的显示设备，绝大多数情况下走的都是这里，也就是绝大多数情况下都是使用的默认的</span></span><br><span class="line">        hintDisplay = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hintDisplay) &#123;</span><br><span class="line">        layer-&gt;<span class="built_in">updateTransformHint</span>(hintDisplay);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      first = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第五步：处理 SurfaceFlinger 自身的事务</span></span><br><span class="line"><span class="comment">   * 如果调用过 createLayer 等方法创建过 Layer 的话，也就是有新增 Layer 了</span></span><br><span class="line"><span class="comment">   * 此时会将 mVisibleRegionsDirty 置为 true ，然后将mLayersAdded恢复成默认的false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (mLayersAdded) &#123;</span><br><span class="line">    mLayersAdded = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Layers have been added.</span></span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (mLayersRemoved) &#123;</span><br><span class="line">    mLayersRemoved = <span class="literal">false</span>;</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer *layer) &#123;</span><br><span class="line">      <span class="comment">// mLayersPendingRemoval 中存储着 remove 掉的 Layer </span></span><br><span class="line">      <span class="comment">// 这里遍历上一帧（当前正在显示的帧）中的所有 Layer ，如果是被移除的，则</span></span><br><span class="line">      <span class="keyword">if</span> (mLayersPendingRemoval.<span class="built_in">indexOf</span>(layer) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// this layer is not visible anymore</span></span><br><span class="line">        Region visibleReg;</span><br><span class="line">        visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">        <span class="comment">// 如果Layer 有移除，则调用 invalidateLayerStack 更新 DisplayDevice 中原有的可视脏区</span></span><br><span class="line">        <span class="built_in">invalidateLayerStack</span>(layer, visibleReg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">commitInputWindowCommands</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后提交事务</span></span><br><span class="line">  <span class="built_in">commitTransaction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::commitTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果待移除的 Layer 还没有处理完毕，则这里将其处理掉</span></span><br><span class="line">  <span class="keyword">if</span> (!mLayersPendingRemoval.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="comment">// Notify removed layers now that they can&#x27;t be drawn from</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;l: mLayersPendingRemoval) &#123;</span><br><span class="line">      <span class="built_in">recordBufferingStats</span>(l-&gt;<span class="built_in">getName</span>().<span class="built_in">string</span>(),</span><br><span class="line">                           l-&gt;<span class="built_in">getOccupancyHistory</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ensure any buffers set to display on any children are released.</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;<span class="built_in">isRemovedFromCurrentState</span>()) &#123;</span><br><span class="line">        <span class="built_in">latchAndReleaseBuffer</span>(l);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the layer has been removed and has no parent, then it will not be reachable</span></span><br><span class="line">      <span class="comment">// when traversing layers on screen. Add the layer to the offscreenLayers set to</span></span><br><span class="line">      <span class="comment">// ensure we can copy its current to drawing state.</span></span><br><span class="line">      <span class="keyword">if</span> (!l-&gt;<span class="built_in">getParent</span>()) &#123;</span><br><span class="line">        mOffscreenLayers.<span class="built_in">emplace</span>(l.<span class="built_in">get</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mLayersPendingRemoval.<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this transaction is part of a window animation then the next frame</span></span><br><span class="line">  <span class="comment">// we composite should be considered an animation as well.</span></span><br><span class="line">  mAnimCompositionPending = mAnimTransactionPending;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">withTracingLock</span>([&amp;]() &#123;</span><br><span class="line">    <span class="comment">// 将 mCurrentState 赋值给 mDrawingState ，完成 state 的交换</span></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line">    <span class="comment">// clear the &quot;changed&quot; flags in current state</span></span><br><span class="line">    mCurrentState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 再遍历所有 Layer ，挨个调用其 commitChildList 方法</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer *layer) &#123;</span><br><span class="line">      <span class="comment">// 递归通知 Layer 内部将 Drawing 和 Current 进行交换</span></span><br><span class="line">      layer-&gt;<span class="built_in">commitChildList</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 纠正 mOffscreenLayers 中的 Layer 。</span></span><br><span class="line">      <span class="comment">// mOffscreenLayers 中的 Layer 意思其实就是当前被移除的 且无Parent的 Layer</span></span><br><span class="line">      <span class="comment">// 也就是无法触及的 Layer 了，而此时 mDrawingState 中又用到了该Layer ，那么此时将其从 mOffscreenLayers 中移除</span></span><br><span class="line">      <span class="keyword">if</span> (mOffscreenLayers.<span class="built_in">count</span>(layer)) &#123;</span><br><span class="line">        mOffscreenLayers.<span class="built_in">erase</span>(layer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 统一操作 mOffscreenLayers 中的 layer ，因为这些Layer 没有 parent ，通过 traverseInZOrder 方法是无法操作到的</span></span><br><span class="line">    <span class="comment">// 所以这里使用 mOffscreenLayers 数组来统一操作，主要是 doTransaction() 和 commitChildList()</span></span><br><span class="line">    <span class="built_in">commitOffscreenLayers</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  mTransactionPending = <span class="literal">false</span>;</span><br><span class="line">  mAnimTransactionPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  mTransactionCV.<span class="built_in">broadcast</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析之前，需要知道该方法的入参 transactionFlags ，它是前面 handleTransaction() 方法中调用 getTransactionFlags() 方法返回的 SurfaceFlinger 中 mTransactionFlags 的值，而当前handleTransactionLocked() 方法中主要的逻辑就是根据这个入参来展开的，根据这个入参来完成对应的事务逻辑。</p>
<p>handleTransactionLocked() 方法中逻辑较长，下面分为五步来分析：</p>
<p>①完成事务处理之前的准备工作，在真正的事务开始之前，会挨个遍历 mCurrentState 中的 Layer ，调用其  notifyAvailableFrames() 方法。</p>
<p>而关于 mCurrentState ，它是位于 SurfaceFlinger 中的属性，与之对应的还有一个：mDrawingState 。这两者的关系有点类似 <a href="https://youngkaaa.github.io/tags/AndroidFrameworks-Surface/">Surface</a> 中的双缓冲，其中 mDrawingState 表示当前正在使用中的，前台 State；而 mCurrentState 是后台 State ，在前台 State 显示期间，如果有状态变化，则会修改 mCurrentState ，修改完成之后，最后会交换这俩的值，将 mCurrentState 赋值给 mDrawingState 。</p>
<blockquote>
<p>比如在 SurfaceFlinger 中的 createLayer 方法执行时，会在创建完 Layer 之后，调用其addClientLayer 方法，该方法中会在满足一定条件时将创建的 Layer 保存到 mCurrentState.layersSortedByZ 集合中。</p>
<p>而这里 第一步中调用的mCurrentState.traverseInZOrder 方法就是按照 Z轴顺序来遍历 layersSortedByZ 集合中的 Layer ，也就是之前创建的那些 Layer。</p>
</blockquote>
<p>② 遍历 Layer ，处理每个 Layer 内部的事务。而在执行这一步时，需要满足的条件是：入参 transactionFlags 中需要有 eTraversalNeeded 位标识。也就是说说如果之前给 SurfaceFlinger 中的 mTransactionFlags 设置了 eTraversalNeeded 位标识的话，则这里的第二步会执行。</p>
<p>这里执行第二步时，会遍历 mCurrentState.traverseInZOrder 集合中的所有 Layer，先看看遍历每个 Layer 调用相关方法的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layer.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> compositionengine::LayerFE &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getTransactionFlags</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> mTransactionFlags; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> State&amp; <span class="title">getDrawingState</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> mDrawingState; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> State&amp; <span class="title">getCurrentState</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> mCurrentState; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> State&amp; <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mCurrentState; &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::atomic&lt;<span class="type">uint32_t</span>&gt; mTransactionFlags&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    State mCurrentState;</span><br><span class="line">    State mDrawingState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Layer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">Layer::doTransaction</span><span class="params">(<span class="type">uint32_t</span> flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mLayerDetached) &#123;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前 Layer 调用过 addChild 或者 removeLayer 方法，则会将 mChildrenChanged 置为 true</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (mChildrenChanged) &#123;</span><br><span class="line">    flags |= eVisibleRegion;</span><br><span class="line">    mChildrenChanged = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pushPendingState</span>();</span><br><span class="line">  <span class="comment">// 拿到当前的状态</span></span><br><span class="line">  State c = <span class="built_in">getCurrentState</span>();</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">applyPendingStates</span>(&amp;c)) &#123;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flags = <span class="built_in">doTransactionResize</span>(flags, &amp;c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 已经绘制了的上一帧的状态</span></span><br><span class="line">  <span class="function"><span class="type">const</span> State &amp;<span class="title">s</span><span class="params">(getDrawingState())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面开始就是挨个比较 mCurrentState 和上一帧已经绘制了的 mDrawState 的差距 </span></span><br><span class="line">  <span class="comment">// 然后根据差异值，来修改 flag ，为 flag 增加不同的标识</span></span><br><span class="line">  <span class="comment">// 添加的标识一般是 eVisibleRegion 表示当前 Layer 可见区域发生变化</span></span><br><span class="line">  <span class="comment">// 或者 eInputInfoChanged 表示输入状态发生变化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">getActiveGeometry</span>(c) != <span class="built_in">getActiveGeometry</span>(s)) &#123;</span><br><span class="line">    flags |= Layer::eVisibleRegion;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (c.sequence != s.sequence) &#123;</span><br><span class="line">    flags |= eVisibleRegion;</span><br><span class="line">    <span class="keyword">this</span>-&gt;contentDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> type = <span class="built_in">getActiveTransform</span>(c).<span class="built_in">getType</span>();</span><br><span class="line">    mNeedsFiltering = (!<span class="built_in">getActiveTransform</span>(c).<span class="built_in">preserveRects</span>() || type &gt;= ui::Transform::SCALE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mCurrentState.inputInfoChanged) &#123;</span><br><span class="line">    flags |= eInputInfoChanged;</span><br><span class="line">    mCurrentState.inputInfoChanged = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 mDrawingState 更新为 mCurrentState</span></span><br><span class="line">  <span class="built_in">commitTransaction</span>(c);</span><br><span class="line">  mCurrentState.callbackHandles = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Layer::commitTransaction</span><span class="params">(<span class="type">const</span> State &amp;stateToCommit)</span> </span>&#123;</span><br><span class="line">  mDrawingState = stateToCommit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遍历到每个 Layer 时，首先会调用其 getTransactionFlags() 方法来取出其 mTransactionFlags 中的值，如果等于0表示该 Layer 此时不需要处理事务。</p>
<blockquote>
<p>Layer 和 SurfaceFlinger 中都存在一个 mTransactionFlags 属性，该属性分别用来存储 该 Layer 和 该SurfaceFlinger 中待处理的事务信息。</p>
<p>比如对于 SurfaceFlinger 来说，当调用其 createLayer 时，其内部的 mTransactionFlags 会增加 eTransactionNeeded 标识；</p>
<p>又比如对于 Layer 来说，当调用其 addChild() 方法时，其内部的 mTransactionFlags 同样会被增加 eTransactionNeeded 标识；</p>
<p>巧的是， addChild() 方法可能会在 SurfaceFlinger 的 createLayer 方法中被调用。</p>
<p>与 mTransactionFlags 类似的，Layer 和 SurfaceFlinger 中同样都存在 mCurrentState 、 mDrawingState 属性，含义也都差不多。</p>
</blockquote>
<p>该 Layer 如果需要执行事务的话，则接着往下会执行其 doTransaction() 方法。在该方法中，会使用当前 Layer 的 mCurrentState 、 mDrawingState 属性来计算出差异，从而判断出该 Layer 前后到底是可见区域发生了变化，还是输入状态发生了变化。然后将对应的标识位：Layer::eVisibleRegion 、eInputInfoChanged 设置到入参 flag 中，最后返回出去。在返回之前，会调用 commitTransaction() 来将mCurrentState 、 mDrawingState 属性交换，也就是将 mCurrentState 的值赋值给 mDrawingState，后续该 Layer 就会执行新的 State 来处理绘制了。</p>
<p>在执行完 doTransaction() 方法之后，会分别判断返回值 flag 中的eVisibleRegion 、eInputInfoChanged 标志位。如果任意一个 Layer 返回的 flag 中存在这俩标志位的话，则会分别将 SurfaceFlinger 中对应的 mVisibleRegionsDirty 和 mInputInfoChanged 置为true，以供后续使用。</p>
<p>③ 处理显示设备的变化事务。这里暂且可以先不管，因为一般只有一个显示设备，也就是手机显示屏幕。</p>
<p>注意此时判断的是eDisplayTransactionNeeded 标志位，因此当后续有显示设备发生变化，那么就可以使用该标志位。比如在 SurfaceFlinger 中接受到 HWC 的热插拔事件时，会在 onHotplugReceived() 方法中增加该标志位。</p>
<p>④处理 Layer 中的图层堆栈信息。如果SurfaceFlinger 中的mTransactionFlags 中有 eDisplayLayerStackChanged 或者 eDisplayTransactionNeeded 标识位时，才会进行这一步的处理。</p>
<p>这一步的处理也是遍历 mCurrentState.traverseInZOrder 集合中的所有 Layer，在遍历时，会先取出该Layer的 LayerStack，而这个 LayerStack 是一个 uint32_t 的值，它表示当前Layer所关联的图层堆栈。可以使用它来判断它属于哪个 Display 显示设备，即该 Layer 在哪个显示设备上显示，有些 Layer 可能指定只在某个 Display 上显示，而有些 Layer 则是镜像显示，即可能会同时显示在多个 Display 显示设备上。</p>
<p>而这里的逻辑就是处理这种情况，即当遇到一个 Layer 的 LayerStack 和前一个 Layer 的不一样时，会遍历当前所有的 Display显示设备，判断该 Layer 当前没有显示设备可显示，还是有一个显示设备可显示，或者说是有两个及其以上的设备可显示。如果只有一个的话则用它指定的那个就行，这种情况对应hintDisplay不为null；否则就使用默认的，这种情况对应hintDisplay为null；</p>
<p>⑤ 处理 SurfaceFlinger 自身的事务 。即判断  SurfaceFlinger 中的  mLayersAdded 和 mLayersRemoved 属性的值是否为true，这俩值分别代表了SurfaceFlinger 中是否有新增或者删除 Layer 的行为。</p>
<blockquote>
<p>比如对于mLayersAdded 来说，会在 SurfaceFlinger 的 createLayer 中，在创建完 Layer 实例后，会执行 addClientLayer() 方法，该方法内会将 mLayersAdded 置为 true ，表示有新的 Layer 被添加进来了。</p>
</blockquote>
<p>而这里判断如果 mLayersAdded 或者 mLayersRemoved 等于true 的话，则会将 mVisibleRegionsDirty 置为true ，表示SurfaceFlinger 中存在脏区需要刷新。</p>
<p>到最后，会执行 commitTransaction() 方法来提交这次事务。</p>
<p>在 commitTransaction() 方法中首先会将 mLayersPendingRemoval 集合中存储的 Layer 给回收掉，然后将其清空掉。</p>
<blockquote>
<p>mLayersPendingRemoval 集合中存储的是已经不用的 Layer ，等待释放。具体是在 SurfaceFlinger::onHandleDestroyed() 方法中来添加 Layer 到 mLayersPendingRemoval 集合中的。还记得之前创建 BufferQueueLayer 时SurfaceControl 拿到的 handle 嘛？它就是继承自 BBinder ，并且额外实现了 LayerCleaner 接口，在其被回收调用析构方法时，在 LayerCleaner 中会调用 SurfaceFlinger::onHandleDestroyed() 方法来回收该 Layer的。详见：<a href="25fde216.html">Layer的创建 </a></p>
</blockquote>
<p>接着会将 SurfaceFlinger 中的 mCurrentState 赋值给 mDrawingState ，也就是完成交换工作，那么前面在 mCurrentState 中执行的事务，保存的属性就都可以在后续的逻辑中使用到了。</p>
<p>最后会遍历mDrawingState.layersSortedByZ 集合(也就是相当于前面的 mCurrentState.layersSortedByZ 集合)，挨个调用 Layer 的 commitChildList()方法来通知 Layer 完成 mCurrentXXXX 和 mDrawingXXX 属性的交换。这里的事务提交有点类似前面Surface中的 unlockAndPost 方法，就是将前后台交换而已。</p>
<p>至此就完成了  handleTransactionLocked() 方法的执行，也就是完成了 handleTransaction() 方法的执行，回到 handleMessageTransaction() 方法中，该方法最后返回了 runHandleTransaction 的值，而runHandleTransaction 如果是 true 的话，则内部会执行 handleTransaction() 方法，为false的话则内部不会执行该方法的。</p>
<p>接着回到  onMessageReceived() 方法中，执行完 handleMessageTransaction() 方法之后，接着就要执行 handleMessageInvalidate() 了。</p>
<h3 id="handleMessageInvalidate"><a href="#handleMessageInvalidate" class="headerlink" title="handleMessageInvalidate"></a>handleMessageInvalidate</h3><p>在看handleMessageInvalidate()方法之前，首先先看看 handlePageFlip() 方法，该方法是在handleMessageInvalidate()方法内被调用的，看完该方法之后，有助于handleMessageInvalidate()方法的理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">nsecs_t</span> latchTime = <span class="built_in">systemTime</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一步：遍历所有 Layer ，将到了展示时间的 Layer 加入到 mLayersWithQueuedFrames 集合中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer *layer) &#123;</span><br><span class="line">    <span class="comment">// 该 Layer 中是否已经有待消费的帧数据了</span></span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;<span class="built_in">hasReadyFrame</span>()) &#123;</span><br><span class="line">      frameQueued = <span class="literal">true</span>;</span><br><span class="line">      <span class="type">const</span> <span class="type">nsecs_t</span> expectedPresentTime = <span class="built_in">getExpectedPresentTime</span>();</span><br><span class="line">      <span class="comment">// 判断该 Layer 这一帧是否需要显示 ，如果需要的话则将其放入到  mLayersWithQueuedFrames 中</span></span><br><span class="line">      <span class="comment">// mLayersWithQueuedFrames 集合中存储的就是需要绘制的图层，该集合后面会用到</span></span><br><span class="line">      <span class="keyword">if</span> (layer-&gt;<span class="built_in">shouldPresentNow</span>(expectedPresentTime)) &#123;</span><br><span class="line">        mLayersWithQueuedFrames.<span class="built_in">push_back</span>(layer);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 上面也会使用到  useEmptyDamage ，也就是说没有待消费的帧数据时，或者有但是没到展示的时候，则统一都使用 useEmptyDamage</span></span><br><span class="line">      layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第二步：遍历mLayersWithQueuedFrames 集合，挨个调用Layer的 latchBuffer 方法来更新其内部的下一帧数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!mLayersWithQueuedFrames.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;layer: mLayersWithQueuedFrames) &#123;</span><br><span class="line">      <span class="comment">// 内部从消费队列获取一个新的合适的帧数据，并且将其更新到全局的 mActiveBuffer 中</span></span><br><span class="line">      <span class="comment">// 并且判断新老 mActiveBuffer ，也就是新帧和上一帧之间的差异，如果宽高、缩放、可见度等发生变化则 visibleRegions 置为 true</span></span><br><span class="line">      <span class="keyword">if</span> (layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime)) &#123;</span><br><span class="line">        mLayersPendingRefresh.<span class="built_in">push_back</span>(layer);</span><br><span class="line">      &#125;</span><br><span class="line">      layer-&gt;<span class="built_in">useSurfaceDamage</span>();</span><br><span class="line">      <span class="comment">// 上面 latchBuffer 中会将 mBufferLatched 置为 true，可以理解为 latchBuffer 成功</span></span><br><span class="line">      <span class="comment">// 此时将 newDataLatched 置为 true ，表示有新的 layer latch 成功了</span></span><br><span class="line">      <span class="keyword">if</span> (layer-&gt;<span class="built_in">isBufferLatched</span>()) &#123;</span><br><span class="line">        newDataLatched = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第三步：完成一些收尾的工作</span></span><br><span class="line"><span class="comment">   * 将 latchBuffer 的 visibleRegions 合并到 mVisibleRegionsDirty 中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 没到 Layer 的显示时间呢，所以此时发送 invalidate 消息等待下次 vsync 时再处理看看</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.<span class="built_in">empty</span>() || !newDataLatched)) &#123;</span><br><span class="line">    <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 修改 mBootStage ，因为newDataLatched=true表示有Layer latchBuffer 成功了，也就是有待显示的帧了</span></span><br><span class="line"><span class="comment">   * 系统显示的第一帧肯定就是开机动画了，所以将 mBootStage 改为 BOOTANIMATION</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mBootStage == BootStage::BOOTLOADER &amp;&amp; newDataLatched)) &#123;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;Enter boot animation&quot;</span>);</span><br><span class="line">    mBootStage = BootStage::BOOTANIMATION;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mLayersWithQueuedFrames 不为空表示当前有 layer 要展示</span></span><br><span class="line"><span class="comment">   * newDataLatched 有新的 Buffer 被 latch 住了等待消费呢</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> !mLayersWithQueuedFrames.<span class="built_in">empty</span>() &amp;&amp; newDataLatched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不关心该方法的作用，直接看该方法的逻辑。handlePageFlip() 方法内的逻辑主要分为三步：</p>
<p>① 遍历所有 Layer ，将到了展示时间的 Layer 加入到 mLayersWithQueuedFrames 集合中 。</p>
<p>注意这里遍历的是 mDrawingState 中的Layer集合，而前面 handleMessageTransaction() 方法中已经将 mCurrentState 赋值给 mDrawingState 了，相当于这里遍历的也是之前的mCurrentState 中的  Layer 集合。</p>
<p>在遍历到每个 Layer 时，首先会调用  Layer 的 hasReadyFrame() 方法来判断当前 Layer 是否已经有待消费的 Layer 了。后续我们的 Layer 子类默认都认为是 BufferQueueLayer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::hasReadyFrame</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hasFrameUpdate 中会判断内部的 mQueuedFrames 是否大于0，即是否有待消费的数据了，在其 onFrameAvailable 中会将 mQueuedFrames 自增</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasFrameUpdate</span>() || <span class="built_in">getSidebandStreamChanged</span>() || <span class="built_in">getAutoRefresh</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// BufferQueueLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::hasFrameUpdate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在 onFrameAvailable 中会将 mQueuedFrames 自增1</span></span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 hasReadyFrame() 方法中，会调用其他三个方法来决定最终的返回值，这三个方法基本都是交由子类来实现的，而这里我们只关注第一个：hasFrameUpdate() 方法。</p>
<p>BufferQueueLayer::hasFrameUpdate() 方法会根据 BufferQueueLayer 中的 mQueuedFrames  的值来决定返回值，如果mQueuedFrames大于 0 则返回true。而 mQueuedFrames 的修改是在 BufferQueueLayer 的 onFrameAvailable() 方法内完成的，即作为消费者端的 BufferQueueLayer ，它对应的生产者端生产了数据并且放入了 BufferQueue 队列时，这边的 onFrameAvailable() 方法会被回调，mQueuedFrames也就会自增1，从而大于0。具体详见：<a href="25fde216.html">BufferQueueLayer 的分析 </a></p>
<p>所以说，如果 BuffeQueueLayer 对应的生产者端（比如 Surface ）生产了数据并且放入了BufferQueue队列，那么这边的消费者侧BuffeQueueLayer就有数据可以消费了，也就是有帧可以显示了，此时 hasReadyFrame() 方法会返回 true。</p>
<p>接着会调用 Layer 的 shouldPresentNow() 方法来判断该 Layer 当前是否应该显示了。关于 shouldPresentNow() 方法的分析，详见：<a href="25fde216.html">BufferQueueLayer 的分析 </a>。</p>
<p>如果该 Layer 该显示了，那么会将其保存到 mLayersWithQueuedFrames 集合中。</p>
<p>这样的话，第一步执行完之后，mLayersWithQueuedFrames 集合中就会存储着那些目前应该显示出来的 Layer 了。</p>
<p>②遍历 mLayersWithQueuedFrames 集合，挨个调用 Layer 的 latchBuffer 方法来更新其内部的下一帧数据。</p>
<p>第一步筛选出那些此时应该显示出来的 Layer 存储在mLayersWithQueuedFrames 集合内，第二步这里就是遍历该集合，挨个调用Layer 的 latchBuffer() 方法来让该 Layer 内部更新待显示的帧数据，也就是 GraphicBuffer。</p>
<p>这里提到的：“更新待显示的帧数据” ，其实就是让 BufferQueueLayer 去从生产消费队列 BufferQueue 中出队一个待消费的 BufferItem，然后将其内部的数据保存到自身，等待后续使用。latchBuffer() 方法的分析详见 <a href="25fde216.html">BufferQueueLayer 的分析 </a>。</p>
<p>注意这里会将 latchBuffer 成功的那些 Layer 再次转存到 mLayersPendingRefresh 集合中，等待后续使用。</p>
<blockquote>
<p>到这里就不难明白：mLayersWithQueuedFrames 集合 和  mLayersPendingRefresh 集合的差异了吧。</p>
</blockquote>
<p>③完成一些收尾的工作。</p>
<p>收尾做的第一个工作就是将 latchBuffer 拿到的返回值 visibleRegions 设置到  SurfaceFlinger 中的 mVisibleRegionsDirty 属性中。而 mVisibleRegionsDirty 属性在前面handleMessageTransaction() 中的 handleTransactionLocked() 方法内也会修改，当时修改的原因是：当SurfaceFlinger 中有新的 Layer 被创建或者有 Layer 被移除回收的时候。而这里修改是当 Layer latchBuffer 时，在 latchBuffer() 方法内部，会判断如果：新出队的 BufferItem 的数据 GraphicBuffer 的宽高格式或者可见度等发生了变化的话，会将入参 visibleRegions 置为 true ，所以此时会将 visibleRegions 设置给 mVisibleRegionsDirty ，表示有显示区域发生了变化。</p>
<p>收尾的第二个工作就是判断当前是否没有 Layer 要显示，如果是的话则会通过调用 SurfaceFlinger::signalLayerUpdate() 方法去发送一条消息，等待下次刷新时再尝试处理吧。</p>
<p>这里简单解释下判断条件中的属性：</p>
<p>1）frameQueued &#x3D; true 的话表示存在有至少一个 Layer 中有待消费的 BufferItem 数据了。</p>
<p>2）mLayersWithQueuedFrames.empty() ： 即没有任何一个 Layer 到了该显示的时候，即没有任何一个 Layer 中存在目前该显示的帧数据。也就是所有的 Layer 中真数据都不该显示。</p>
<p>3）newDataLatched &#x3D; false 的话，表示没有 Layer 调用 latchBuffer 成功的更新了数据。也就是所有的 Layer 都是旧的、上次已显示的 帧数据。</p>
<p>收尾的第三个工作就是尝试修改 SurfaceFlinger 中的 mBootStage 属性值。该属性表示当前开机状态，如果 newDataLatched &#x3D; true 表示当前至少有一帧数据待显示了，那么系统一开始显示的第一帧肯定就是开机动画了，所以此时将其修改为 BootStage::BOOTANIMATION ，也就是说当前正在播放开机动画中….</p>
<p>最后当前  handlePageFlip() 方法返回，而返回值等于：!mLayersWithQueuedFrames.empty() &amp;&amp; newDataLatched 也就能看明白了，它表示mDrawingState 中的Layer集合 中有至少一个 Layer当前待显示下一帧，并且下一帧的数据已经通过 latchBuffer() 方法准备好了。</p>
<p>接着就可以看主角方法handleMessageInvalidate()了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handleMessageInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">  <span class="comment">// 遍历所有的 Layer ，判断哪些Layer该显示下一帧了，并且调用这些 layer的 latchBuffer 方法来准备好下一帧数据</span></span><br><span class="line">  <span class="type">bool</span> refreshNeeded = <span class="built_in">handlePageFlip</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mVisibleRegionsDirty 为 true 的话，表示前面的计算中发现有可见区域发生了变化，那么此时需要chong&#x27;xin</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (mVisibleRegionsDirty) &#123;</span><br><span class="line">    <span class="built_in">computeLayerBounds</span>();</span><br><span class="line">    <span class="keyword">if</span> (mTracingEnabled) &#123;</span><br><span class="line">      mTracing.<span class="built_in">notify</span>(<span class="string">&quot;visibleRegionsDirty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面 handlePageFlip 方法中，会将要展示的 layer latchBuffer 之后，</span></span><br><span class="line">  <span class="comment">// 然后将latchBuffer 成功的那些 Layer 加入到 mLayersPendingRefresh 集合中</span></span><br><span class="line">  <span class="comment">// 所以此时开始处理这些 layer</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;layer: mLayersPendingRefresh) &#123;</span><br><span class="line">    Region visibleReg;</span><br><span class="line">    visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">    <span class="built_in">invalidateLayerStack</span>(layer, visibleReg);</span><br><span class="line">  &#125;</span><br><span class="line">  mLayersPendingRefresh.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">return</span> refreshNeeded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::computeLayerBounds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历所有的显示设备，一般只有一个</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;pair: mDisplays) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;displayDevice = pair.second;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="comment">// 遍历所有的 layer ，并且调用其 computeBounds 方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;layer: mDrawingState.layersSortedByZ) &#123;</span><br><span class="line">      <span class="comment">// 只有该 Layer 是在该 Display 显示设备上显示时，才需要重新计算大小</span></span><br><span class="line">      <span class="keyword">if</span> (!display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(), layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重新计算大小</span></span><br><span class="line">      layer-&gt;<span class="built_in">computeBounds</span>(displayDevice-&gt;<span class="built_in">getViewport</span>().<span class="built_in">toFloatRect</span>(), ui::<span class="built_in">Transform</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::invalidateLayerStack</span><span class="params">(<span class="type">const</span> sp&lt;<span class="type">const</span> Layer&gt; &amp;layer, <span class="type">const</span> Region &amp;dirty)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp;[token, displayDevice]: mDisplays) &#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="comment">// 只有该 Layer 是在该 Display 显示设备上显示时，才需要重新计算大小</span></span><br><span class="line">    <span class="keyword">if</span> (display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(), layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">      <span class="comment">// 入参 dirty 是该 Layer 的显示区域，而这里是将该 Layer 的显示区域更新到 Display 中</span></span><br><span class="line">      display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">orSelf</span>(dirty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果明白了前面的 handlePageflip() 的话，那么这里就很好理解了。</p>
<p>首先会调用 handlePageflip() 方法来完成：遍历所有的 Layer ，判断哪些Layer该显示下一帧了，并且调用这些 layer的 latchBuffer 方法来准备好下一帧数据 的工作。</p>
<p>接着就使用 mVisibleRegionsDirty 属性中的值来决定是否需要重新计算 Layer 的尺寸区域。 mVisibleRegionsDirty 属性在前面handleMessageTransaction() 方法内，以及这里的 handlePageFlip() 方法中都会被修改，它被修改为 true 的话，表示存在 Layer 有显示区域发生变化，比如有 Layer 新增或者删除，或者有 Layer 中的帧数据 GraphicBuffer 的宽高尺寸可见度等发生了变化，即产生了脏区，那么此时需要重新计算显示区域。</p>
<p>接着会遍历 mLayersPendingRefresh 集合中的 Layer ，将这些 Layer 的显示区域刷新保存到其对应的显示设备 Display  中去，以供后续显示时使用。</p>
<p>而这个 mLayersPendingRefresh 集合中存储的Layer 正是那些 latchBuffer 成功的，也就是等待显示的 Layer 。</p>
<p>最后会将 handlePageflip() 方法的返回值返回出去，表示：mDrawingState 中的Layer集合 中有至少一个 Layer当前待显示下一帧，并且下一帧的数据已经通过 latchBuffer() 方法准备好了。也就是有至少一个 Layer 需要刷新显示新的帧。</p>
<p>好了，现在回到 onMessageReceived() 方法中来接着往下看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="type">int32_t</span> what)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">      <span class="type">bool</span> refreshNeeded = <span class="built_in">handleMessageTransaction</span>();</span><br><span class="line">      refreshNeeded |= <span class="built_in">handleMessageInvalidate</span>();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">updateCursorAsync</span>();</span><br><span class="line">      <span class="built_in">updateInputFlinger</span>();</span><br><span class="line"></span><br><span class="line">      refreshNeeded |= mRepaintEverything;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * refreshNeeded : 上面  handleMessageTransaction 、  handleMessageInvalidate 、mRepaintEverything 其中一个为 true 时</span></span><br><span class="line"><span class="comment">       * mBootStage ： 在上面 handleMessageInvalidate -&gt; handlePageFlip 中满足条件后会置为 BOOTANIMATION</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (refreshNeeded &amp;&amp; <span class="built_in">CC_LIKELY</span>(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">        <span class="comment">// 发送一条 REFRESH 消息，然后会在当前 onMessageReceived 中接受到，从而执行下面的 MessageQueue::REFRESH</span></span><br><span class="line">        <span class="built_in">signalRefresh</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">      <span class="comment">// 处理 REFRESH 消息</span></span><br><span class="line">      <span class="built_in">handleMessageRefresh</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::signalRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mRefreshPending = <span class="literal">true</span>;</span><br><span class="line">  mEventQueue-&gt;<span class="built_in">refresh</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MessageQueue.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mHandler-&gt;<span class="built_in">dispatchRefresh</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchRefresh</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 对于 refresh 消息，其 what 字段对应的是 MessageQueue::REFRESH</span></span><br><span class="line">    mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::REFRESH));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message &amp;message) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">    <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">      <span class="comment">// 处理 INVALIDATE 消息</span></span><br><span class="line">      <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">      mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> REFRESH:</span><br><span class="line">      <span class="comment">// 处理 REFRESH 消息</span></span><br><span class="line">      <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">      mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完上面的 handleMessageTransaction() 方法和 handleMessageInvalidate() 方法之后，会拿到返回值存储到 refreshNeeded 中，最后还会额外将 SurfaceFlinger 中的 mRepaintEverything 属性保存给它，因为说这三个值任意一个为 true 时，最终的refreshNeeded 就是 true。</p>
<blockquote>
<p>mRepaintEverything 属性是用来标记当前是否需要重新刷新显示所有的 Layer ，一般是当发生比较大的变化时，会调用 SurfaceFlinger::repaintEverything() 方法来触发。</p>
</blockquote>
<p>接着往下，会执行判断，来决定当前是否需要执行下一步：REFRESH 操作。条件有两个：</p>
<p>① refreshNeeded &#x3D; true ，这个前面讲过了，那三个只要其中一个为 true ，那么这里的 refreshNeeded 就是 true。</p>
<p>② mBootStage !&#x3D; BootStage::BOOTLOADER：这个在前面的  handleMessageInvalidate() 方法内的handlePageFlip() 方法内会修改，即一般系统显示的第一帧之前，就会将 mBootStage 设置为 BootStage.BOOTANIMATION 。也就是说如果在系统启动之前，开机动画播放之前，是不会处理 REFRESH 事件的。</p>
<p>当然绝大多数情况下都是满足条件的，所以会调用 signalRefresh() 方法来发送一条 REFRESH 消息到消息队列中，后续会再执行到当前的 onMessageReceived() 方法中来，但是那个时候的入参 what 就不是现在的 MessageQueue::INVALIDATE 了，而是：MessageQueue::REFRESH 。而关于 MessageQueue::REFRESH 的分析，请看<a href="7cbfb0e.html">下篇文章</a>。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/SurfaceFlinger/">SurfaceFlinger</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/7cbfb0e.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">SurfaceFlinger - REFRESH - (1)</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2fa835ad.html">
        <span class="next-text nav-default">SurfaceFlinger - INIT</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
