<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="GLES&EGL-GLES-02"/>




  <meta name="keywords" content="AndroidFrameworks,OpenGLES,EGL," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/710a8fa4.html"/>


<meta name="description" content="前面  GLES&amp;EGL-GLES-01 中讲到的前几个 gl 函数，本篇接着前面的分析往后看。 glTexImage2D先看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869">
<meta property="og:type" content="article">
<meta property="og:title" content="GLES&amp;EGL-GLES-02">
<meta property="og:url" content="https://youngkaaa.github.io/710a8fa4.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="前面  GLES&amp;EGL-GLES-01 中讲到的前几个 gl 函数，本篇接着前面的分析往后看。 glTexImage2D先看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-20T11:53:57.000Z">
<meta property="article:modified_time" content="2023-03-03T13:53:35.887Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="OpenGLES">
<meta property="article:tag" content="EGL">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> GLES&EGL-GLES-02 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          GLES&EGL-GLES-02
        
      </h1>

      <time class="post-time">
          7月 20 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>前面  <a href="e803de1e.html">GLES&amp;EGL-GLES-01</a> 中讲到的前几个 gl 函数，本篇接着前面的分析往后看。</p>
<h3 id="glTexImage2D"><a href="#glTexImage2D" class="headerlink" title="glTexImage2D"></a>glTexImage2D</h3><p>先看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/texture.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">glTexImage2D</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        GLenum target, GLint level, GLint internalformat,</span></span></span><br><span class="line"><span class="params"><span class="function">        GLsizei width, GLsizei height, GLint border,</span></span></span><br><span class="line"><span class="params"><span class="function">        GLenum format, GLenum type, <span class="type">const</span> GLvoid *pixels)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取当前线程的上下文 ogles_context_t 实例</span></span><br><span class="line">    <span class="type">ogles_context_t</span>* c = <span class="type">ogles_context_t</span>::<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 该方法只能处理 target 是 GL_TEXTURE_2D 的请求</span></span><br><span class="line">    <span class="keyword">if</span> (target != GL_TEXTURE_2D) &#123;</span><br><span class="line">        <span class="built_in">ogles_error</span>(c, GL_INVALID_ENUM);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宽高必须都大于等于0， boder 必须是0， level 必须大于等于0</span></span><br><span class="line">    <span class="keyword">if</span> (width&lt;<span class="number">0</span> || height&lt;<span class="number">0</span> || border!=<span class="number">0</span> || level &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ogles_error</span>(c, GL_INVALID_VALUE);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入参 format 和 internalformat 必须一致才行</span></span><br><span class="line">    <span class="keyword">if</span> (format != (GLenum)internalformat) &#123;</span><br><span class="line">        <span class="built_in">ogles_error</span>(c, GL_INVALID_OPERATION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 format 和 type 是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">validFormatType</span>(c, format, type)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> size = <span class="number">0</span>;</span><br><span class="line">    GGLSurface* surface = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据入参参数，先查找 active 位置的 EGLTextureObject 对象，然后为其内部 GGLSurface surface 进行内存分配</span></span><br><span class="line"><span class="comment">     * 最后分配内存之后的 EGLTextureObject.surface 使用入参 surface 来指向它；</span></span><br><span class="line"><span class="comment">     * 入参 size 表示内部为  EGLTextureObject.surface 分配内存的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> error = <span class="built_in">createTextureSurface</span>(c, &amp;surface, &amp;size, level, format, type, width, height);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">ogles_error</span>(c, error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传进来的像素指针数组不为空，调用 copyPixels 拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (pixels) &#123;</span><br><span class="line">        <span class="comment">// 这些和 createTextureSurface 内部计算规则一样的</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> formatIdx = <span class="built_in">convertGLPixelFormat</span>(format, type);</span><br><span class="line">        <span class="function"><span class="type">const</span> GGLFormat&amp; <span class="title">pixelFormat</span><span class="params">(c-&gt;rasterizer.formats[formatIdx])</span></span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> align = c-&gt;textures.unpackAlignment<span class="number">-1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> bpr = ((width * pixelFormat.size) + align) &amp; ~align;</span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> stride = bpr / pixelFormat.size;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据入参来构建一个 GGLSurface 对象实例，该对象中保存了当前 glTexImage2D 方法传入的像素数据信息</span></span><br><span class="line"><span class="comment">         * 比如像素数据的宽高、以及真正的像素数据地址pixel </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        GGLSurface userSurface;</span><br><span class="line">        userSurface.version = <span class="built_in">sizeof</span>(userSurface);</span><br><span class="line">        userSurface.width  = width;</span><br><span class="line">        userSurface.height = height;</span><br><span class="line">        userSurface.stride = stride;</span><br><span class="line">        userSurface.format = formatIdx;</span><br><span class="line">        userSurface.compressedFormat = <span class="number">0</span>;</span><br><span class="line">        userSurface.data = (GLubyte*)pixels; <span class="comment">// 保存像素源数据地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 复制像素，传入了 surface 和 userSurface ，也就是将  userSurface 复制到 surface 中</span></span><br><span class="line"><span class="comment">         * userSurface ： 根据入参临时构造出来的一个 GGLSurface 对象实例</span></span><br><span class="line"><span class="comment">         * surface     ： 根据入参，在上面 createTextureSurface 中创建并且分配好内存空间的 GGLSurface 对象实例，</span></span><br><span class="line"><span class="comment">         * -              而这个 surface 其实对应的是  active 位置的 EGLTextureObject 对象中的 surface </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * copyPixels 则将 userSurface 的数据拷贝到 surface 中去，也就是到 active 位置的 EGLTextureObject 对象中的 surface</span></span><br><span class="line"><span class="comment">         * 而拷贝主要是拷贝的 data 部分</span></span><br><span class="line"><span class="comment">         * 而当前 glTexImage2D 方法的作用也是用来将像素数据输入到纹理中的，完成了它主要的任务</span></span><br><span class="line"><span class="comment">         * 也就是说当前 glTexImage2D 方法执行完毕之后，会将输入的像素等信息保存到 EGLTextureObject.surface 中去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> err = <span class="built_in">copyPixels</span>(c, *surface, <span class="number">0</span>, <span class="number">0</span>, userSurface, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="built_in">ogles_error</span>(c, err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// generateMipmap 处理状态机</span></span><br><span class="line">        <span class="built_in">generateMipmap</span>(c, level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> GLenum <span class="title">validFormatType</span><span class="params">(<span class="type">ogles_context_t</span>* c, GLenum format, GLenum type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLenum error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (format&lt;GL_ALPHA || format&gt;GL_LUMINANCE_ALPHA) &#123;</span><br><span class="line">        error = GL_INVALID_ENUM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type != GL_UNSIGNED_BYTE &amp;&amp; type != GL_UNSIGNED_SHORT_4_4_4_4 &amp;&amp;</span><br><span class="line">        type != GL_UNSIGNED_SHORT_5_5_5_1 &amp;&amp; type != GL_UNSIGNED_SHORT_5_6_5) &#123;</span><br><span class="line">        error = GL_INVALID_ENUM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == GL_UNSIGNED_SHORT_5_6_5 &amp;&amp; format != GL_RGB) &#123;</span><br><span class="line">        error = GL_INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((type == GL_UNSIGNED_SHORT_4_4_4_4 ||</span><br><span class="line">         type == GL_UNSIGNED_SHORT_5_5_5_1)  &amp;&amp; format != GL_RGBA) &#123;</span><br><span class="line">        error = GL_INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">ogles_error</span>(c, error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，首先还是先做入参的合法性校验。接着会执行两步来完成剩余逻辑：</p>
<p>① 第一步，调用 createTextureSurface() 方法，根据入参格式宽高等信息，来为 active 位置的 EGLTextureObject 对象中的 surface 属性赋值，包括对应的内存申请和分配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/texture.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">createTextureSurface</span><span class="params">(<span class="type">ogles_context_t</span>* c,</span></span></span><br><span class="line"><span class="params"><span class="function">        GGLSurface** outSurface, <span class="type">int32_t</span>* outSize, GLint level,</span></span></span><br><span class="line"><span class="params"><span class="function">        GLenum format, GLenum type, GLsizei width, GLsizei height,</span></span></span><br><span class="line"><span class="params"><span class="function">        GLenum compressedFormat = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将 format 和 type 转换为对应的 GGLFormat 格式，详见 gl2format_table</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> formatIdx = <span class="built_in">convertGLPixelFormat</span>(format, type);</span><br><span class="line">    <span class="keyword">if</span> (formatIdx == <span class="number">0</span>) &#123; <span class="comment">// we don&#x27;t know what to do with this</span></span><br><span class="line">        <span class="keyword">return</span> GL_INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提前准备好对应的 宽、高、格式等属性</span></span><br><span class="line">    <span class="function"><span class="type">const</span> GGLFormat&amp; <span class="title">pixelFormat</span><span class="params">(c-&gt;rasterizer.formats[formatIdx])</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> align = c-&gt;textures.unpackAlignment<span class="number">-1</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> bpr = ((width * pixelFormat.size) + align) &amp; ~align;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = bpr * height;</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> stride = bpr / pixelFormat.size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// level一般是 0 ，所以这里可以暂时不考虑，</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> active = c-&gt;textures.active;</span><br><span class="line">        EGLTextureObject* tex = c-&gt;textures.tmu[active].texture;</span><br><span class="line">        <span class="comment">// 这里面也是走 reallocate 但是 level 不是 0，内部会初始化 EGLTextureObject.mMipmaps 而不是下面的surface</span></span><br><span class="line">        <span class="type">status_t</span> err = tex-&gt;<span class="built_in">reallocate</span>(level,</span><br><span class="line">                width, height, stride, formatIdx, compressedFormat, bpr);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR)</span><br><span class="line">            <span class="keyword">return</span> GL_OUT_OF_MEMORY;</span><br><span class="line">        GGLSurface&amp; surface = tex-&gt;<span class="built_in">editMip</span>(level);</span><br><span class="line">        *outSurface = &amp;surface;</span><br><span class="line">        *outSize = size;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * level为0 时，则调用 getAndBindActiveTextureObject 来获取 c-&gt;textures.active 位置的 EGLTextureObject 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sp&lt;EGLTextureObject&gt; tex = <span class="built_in">getAndBindActiveTextureObject</span>(c);</span><br><span class="line">    <span class="comment">// 根据入参 w h 等参数来为 EGLTextureObject 实例内部的 surface 重新分配内存</span></span><br><span class="line">    <span class="type">status_t</span> err = tex-&gt;<span class="built_in">reallocate</span>(level,</span><br><span class="line">            width, height, stride, formatIdx, compressedFormat, bpr);</span><br><span class="line">    <span class="comment">// 至此 createTextureSurface 就可以通过活跃的纹理，拿到纹理对象中临时的绘制图层</span></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR)</span><br><span class="line">        <span class="keyword">return</span> GL_OUT_OF_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 internalformat</span></span><br><span class="line">    tex-&gt;internalformat = format;</span><br><span class="line">    <span class="comment">// 最后获取 EGLTextureObject 中的 GGLSurface ，也就是上面 reallocate 中重新分配内存的 Surface</span></span><br><span class="line">    *outSurface = &amp;tex-&gt;surface;</span><br><span class="line">    <span class="comment">// 这个size 其实也是 reallocate 内部分配的 surface.data 的大小，因为其内部计算size也是 height*bpr</span></span><br><span class="line">    *outSize = size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">sp&lt;EGLTextureObject&gt; <span class="title">getAndBindActiveTextureObject</span><span class="params">(<span class="type">ogles_context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;EGLTextureObject&gt; tex;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> active = c-&gt;textures.active;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 active 的位置找到 tmu 中已激活的纹理对象，然后取出其中的 name</span></span><br><span class="line"><span class="comment">     * 而该 name 就是之前调用 glBindTexture 方法时传入的纹理id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> GLuint name = c-&gt;textures.tmu[active].name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到 c-&gt;textures.active 位置对应的 texture_unit_t 实例</span></span><br><span class="line">    <span class="function"><span class="type">texture_unit_t</span>&amp; <span class="title">u</span><span class="params">(c-&gt;textures.tmu[active])</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (u.texture)</span><br><span class="line">        u.texture-&gt;<span class="built_in">decStrong</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 name 是0，则说明是默认的纹理对象。那么 tex 对应的就是 c-&gt;textures.defaultTexture 了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="number">0</span>) &#123;</span><br><span class="line">        tex = c-&gt;textures.defaultTexture;</span><br><span class="line">        <span class="comment">// 刷新 tmu 数组中其他的 texture_unit_t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;GGL_TEXTURE_UNIT_COUNT ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;textures.tmu[i].texture == tex.<span class="built_in">get</span>())</span><br><span class="line">                <span class="built_in">invalidate_texture</span>(c, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不是默认的纹理对象时，此时调用 replaceTexture 方法来返回该 EGLTextureObject 实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tex = c-&gt;surfaceManager-&gt;<span class="built_in">replaceTexture</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将取出来的 EGLTextureObject 放置到 c-&gt;textures.tmu[active] 位置去，也就是将该纹理激活</span></span><br><span class="line"><span class="comment">     * 这里再次将其绑定到 active 位置，和前面 glBindTexture 中一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    u.texture = tex.<span class="built_in">get</span>();</span><br><span class="line">    u.texture-&gt;<span class="built_in">incStrong</span>(c);</span><br><span class="line">    u.name = name;</span><br><span class="line">    <span class="built_in">invalidate_texture</span>(c, active);</span><br><span class="line">    <span class="keyword">return</span> tex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/opengl/libagl/TextureObjectManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EGLTextureObject&gt; <span class="title">EGLSurfaceManager::replaceTexture</span><span class="params">(GLuint name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;EGLTextureObject&gt; tex;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到该 name 之前保存的 EGLTextureObject</span></span><br><span class="line"><span class="comment">     * 而该 name 之前保存的时机点是在 glBindTexture 方法中，该方法会传入一个 GLuint texture</span></span><br><span class="line"><span class="comment">     * 然后将 texture 作为 name 在 mTextures 中查找，如果没有的话会创建一个保存进去，此时 texture 也就是 name 是作为key的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">ssize_t</span> index = mTextures.<span class="built_in">indexOfKey</span>(name);</span><br><span class="line">    <span class="comment">// 该 name 存在对应的 EGLTextureObject </span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">const</span> sp&lt;EGLTextureObject&gt;&amp; old = mTextures.<span class="built_in">valueAt</span>(index);</span><br><span class="line">        <span class="comment">// 判断原先放入的 EGLTextureObject 的引用数个数，如果等于1则直接返回这个</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> refs = old-&gt;<span class="built_in">getStrongCount</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ggl_likely</span>(refs == <span class="number">1</span>)) &#123;</span><br><span class="line">            tex = old;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是1，表示有多个地方在引用它，此时新建一个 EGLTextureObject 然后将 old 参数保存到这个新建的对象里面</span></span><br><span class="line">            <span class="comment">// 然后移除old 将新创建的对象放入，最后返回这个新建的对象</span></span><br><span class="line">            tex = <span class="keyword">new</span> <span class="built_in">EGLTextureObject</span>();</span><br><span class="line">            tex-&gt;<span class="built_in">copyParameters</span>(old);</span><br><span class="line">            mTextures.<span class="built_in">removeItemsAt</span>(index);</span><br><span class="line">            mTextures.<span class="built_in">add</span>(name, tex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EGLTextureObject::reallocate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        GLint level, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> s,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> format, <span class="type">int</span> compressedFormat, <span class="type">int</span> bpr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 计算出要分配的内存大小</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = h * bpr;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * level 一般都是 0，可以只考虑0的情况来分析</span></span><br><span class="line"><span class="comment">     * 释放了 GGLSurface 中的数据内存，重新申请一套内存，并且设置当前纹理相关的数据进去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * mSize 是记录的 surface 中 data 上次分配的内存大小</span></span><br><span class="line"><span class="comment">         * size!=mSize 那么表示 surface 中 data 和新的尺寸不一样，那么则需要重新分配</span></span><br><span class="line"><span class="comment">         * 或者 !surface.data 也就是第一次的时候，surface 还没有分配内存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (size!=mSize || !surface.data) &#123;</span><br><span class="line">            <span class="comment">// 如果之前分配了内存，在分配新内存之前先释放掉之前的</span></span><br><span class="line">            <span class="keyword">if</span> (mSize &amp;&amp; surface.data) &#123;</span><br><span class="line">                <span class="built_in">free</span>(surface.data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 为其分配新内存大小</span></span><br><span class="line">            surface.data = (GGLubyte*)<span class="built_in">malloc</span>(size);</span><br><span class="line">            <span class="comment">// 分配失败了，内存不足</span></span><br><span class="line">            <span class="keyword">if</span> (!surface.data) &#123;</span><br><span class="line">                mSize = <span class="number">0</span>;</span><br><span class="line">                mIsComplete = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录新的内存大小</span></span><br><span class="line">            mSize = size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改surface 的其他属性</span></span><br><span class="line">        surface.version = <span class="built_in">sizeof</span>(GGLSurface);</span><br><span class="line">        surface.width  = w;</span><br><span class="line">        surface.height = h;</span><br><span class="line">        surface.stride = s;</span><br><span class="line">        surface.format = format;</span><br><span class="line">        surface.compressedFormat = compressedFormat;</span><br><span class="line">        <span class="keyword">if</span> (mMipmaps)</span><br><span class="line">            <span class="built_in">freeMipmaps</span>();</span><br><span class="line">        mIsComplete = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// level 不等于 0 时，操作的是 mMipmaps 而不是上面的 surface</span></span><br><span class="line">        <span class="keyword">if</span> (!mMipmaps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">allocateMipmaps</span>() != NO_ERROR)</span><br><span class="line">                <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGW_IF</span>(level<span class="number">-1</span> &gt;= mNumExtraLod,</span><br><span class="line">                <span class="string">&quot;specifying mipmap level %d, but # of level is %d&quot;</span>,</span><br><span class="line">                level, mNumExtraLod+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        GGLSurface&amp; mipmap = <span class="built_in">editMip</span>(level);</span><br><span class="line">        <span class="keyword">if</span> (mipmap.data)</span><br><span class="line">            <span class="built_in">free</span>(mipmap.data);</span><br><span class="line"></span><br><span class="line">        mipmap.data = (GGLubyte*)<span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (!mipmap.data) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;mipmap, <span class="number">0</span>, <span class="built_in">sizeof</span>(GGLSurface));</span><br><span class="line">            mIsComplete = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mipmap.version = <span class="built_in">sizeof</span>(GGLSurface);</span><br><span class="line">        mipmap.width  = w;</span><br><span class="line">        mipmap.height = h;</span><br><span class="line">        mipmap.stride = s;</span><br><span class="line">        mipmap.format = format;</span><br><span class="line">        mipmap.compressedFormat = compressedFormat;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if the texture is complete</span></span><br><span class="line">        mIsComplete = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">const</span> GGLSurface* prev = &amp;surface;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;mNumExtraLod ; i++) &#123;</span><br><span class="line">            <span class="type">const</span> GGLSurface* curr = mMipmaps + i;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;format != surface.format) &#123;</span><br><span class="line">                mIsComplete = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> w = (prev-&gt;width  &gt;&gt; <span class="number">1</span>) ? : <span class="number">1</span>;</span><br><span class="line">            <span class="type">uint32_t</span> h = (prev-&gt;height &gt;&gt; <span class="number">1</span>) ? : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (w != curr-&gt;width || h != curr-&gt;height) &#123;</span><br><span class="line">                mIsComplete = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 createTextureSurface() 方法中，会首先通过调用 getAndBindActiveTextureObject() 方法来获取 c-&gt;textures.tmu 数组中 c-&gt;textures.active 位置对应的 EGLTextureObject 实例，该实例正好是之前通过调用 glBindTexture 方法时绑定那个纹理id对应的纹理对象实例。而在  getAndBindActiveTextureObject() 方法内，会多了一个c-&gt;surfaceManager-&gt;replaceTexture() 操作，该操作是保证该 EGLTextureObject 对象实例只被引用一次。</p>
<p>接着拿到这个 EGLTextureObject 对象实例后，会调用其 reallocate() 方法来进行重新分配内存。具体分配内存得看前后 size 是否发生变化，而size的话计算跟宽、高、格式都有关。如果 size 发生变化的话，会释放掉该 EGLTextureObject 实例中 surface 中的内存，然后重新为其赋值，并且为其内部 data 属性申请对应size大小的内存空间，用来后期存放像素数据。</p>
<p>最后会将创建好的这个 surface 实例保存给入参，也就是保存给在 glTexImage2D() 方法中定义的那个 surface。</p>
<p>② 第二步会进行像素数据的复制。前面为 c-&gt;textures.tmu 数组中 c-&gt;textures.active 位置对应的 EGLTextureObject 实例中的 surface 分配好了对应大小的内存，接着会将入参 pixels ，也就是输入进来的像素数据复制到该 surface 中去。</p>
<p>复制时，首先会将要复制的数据pixels等临时保存到一个临时的 userSurface 中去，接着会调用 copyPixels() 方法来将 userSurface  中的数据挨个复制到前面刚分配好内存的 surface 中去。</p>
<p>至此，当前 glTexImage2D() 方法就执行完毕了，该方法会将传入的像素数据 pixels 复制到 c-&gt;textures.tmu 数组中 c-&gt;textures.active 位置对应的 EGLTextureObject 实例中的 surface.data 中，以供后续使用。</p>
<h3 id="glActiveTexture"><a href="#glActiveTexture" class="headerlink" title="glActiveTexture"></a>glActiveTexture</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/texture.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">glActiveTexture</span><span class="params">(GLenum texture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 还是先拿到当前线程的 context</span></span><br><span class="line">    <span class="type">ogles_context_t</span>* c = <span class="type">ogles_context_t</span>::<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里条件判断有些问题吧，应该是 大于等于 ，而不是大于</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">uint32_t</span>(texture-GL_TEXTURE0) &gt; <span class="built_in">uint32_t</span>(GGL_TEXTURE_UNIT_COUNT)) &#123;</span><br><span class="line">        <span class="built_in">ogles_error</span>(c, GL_INVALID_ENUM);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 到这里会修改 active 的值，他是 c-&gt;textures.tmu 数组的索引，取值范围是 [0-GGL_TEXTURE_UNIT_COUNT)</span></span><br><span class="line"><span class="comment">     * 外部可以传入 GL_TEXTURE0 、GL_TEXTURE1 等，这里会将其转为对应的索引值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    c-&gt;textures.active = texture - GL_TEXTURE0;</span><br><span class="line">    <span class="comment">// 到这里，里面会修改 rasterizer.procs 中的属性字段</span></span><br><span class="line">    c-&gt;rasterizer.procs.<span class="built_in">activeTexture</span>(c, c-&gt;textures.active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入该方法，首先还是拿到之前保存在该线程中的 ogles_context_t 实例，接着会进行入参参数合法性的判断。</p>
<p>在参数判断时，这里的 大于 应该是  大于等于，因为 texture-GL_TEXTURE0 计算的值，后续是要赋值给 c-&gt;textures.active 的，它是 c-&gt;textures.tmu 数组的索引，而该数组长度为 GGL_TEXTURE_UNIT_COUNT，所以如果 texture-GL_TEXTURE0 等于 GGL_TEXTURE_UNIT_COUNT 就越界了。猜测是源码中手误写错了，不纠结这个接着往下看。</p>
<p>正如上面所言：texture-GL_TEXTURE0 计算的值，要赋值给 c-&gt;textures.active ，所以说入参 texture 只能是：GL_TEXTURE0 、GL_TEXTURE1 这两者之一。</p>
<p>最后会调用 c-&gt;rasterizer.procs.activeTexture() 方法来将当前 ogles_context_t 实例和赋值之后的 c-&gt;textures.active 传入进去。</p>
<p>对于 c-&gt;rasterizer.procs.activeTexture() 来说，它的赋值初始化也是在 ogles_init() 中的，具体的逻辑就不分析了，详见： <a href="4446cd65.html">GLES&amp;EGL-EGL-03</a> 。他最终调用到这里：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_activeTexture</span><span class="params">(<span class="type">void</span>* con, GGLuint tmu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * con 是 ogles_context_t 实例，tmu 是外部赋值之后的 c-&gt;textures.active</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">    <span class="comment">// 参数不合法，index 越界了</span></span><br><span class="line">    <span class="keyword">if</span> (tmu &gt;= <span class="built_in">GGLuint</span>(GGL_TEXTURE_UNIT_COUNT)) &#123;</span><br><span class="line">        <span class="built_in">ggl_error</span>(c, GGL_INVALID_ENUM);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 context_t 中对应的值</span></span><br><span class="line">    c-&gt;activeTMUIndex = tmu;</span><br><span class="line">    c-&gt;activeTMU = &amp;(c-&gt;state.texture[tmu]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是老套路，先通过 GGL_CONTEXT  宏来将入参 ogles_context_t 实例转换为 context_t 类型去使用，其实就是拿到该 ogles_context_t 实例中的第一个属性 context_t  rasterizer，后期访问c就相当于访问 ogles_context_t.rasterizer 。</p>
<p>而这里的入参 tmu 就是前面赋值之后的 c-&gt;textures.active，也就是外部 glActiveTexture() 方法中的  texture-GL_TEXTURE0 的值，此时条件判断变成了 大于等于，正确了，所以外部的条件错了也没事儿，里面反正还会在判断一次，里面是对的就行。</p>
<p>接下来会修改 c 中的，也就是 ogles_context_t.rasterizer 中的属性：</p>
<p>① 修改 activeTMUIndex 属性为入参 tmu ，也就是 c-&gt;textures.active ；</p>
<p>② 修改 activeTMU 属性为 c-&gt;state.texture[tmu] ，也就是 c-&gt;state.texture[ c-&gt;textures.active ] ，也就是当前激活的纹理数据 texture_t 实例。这个 c-&gt;state.texture 数组和 texture_t 都比较陌生，下面先看看这个数组的初始化吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/private/pixelflinger/ggl_context.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ogles_context_t</span> *<span class="title">ogles_init</span><span class="params">(<span class="type">size_t</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> base = <span class="built_in">malloc</span>(extra + <span class="built_in">sizeof</span>(<span class="type">ogles_context_t</span>) + <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> (!base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ogles_context_t</span> *c = (<span class="type">ogles_context_t</span> *)((<span class="built_in">ptrdiff_t</span>(base) + extra + <span class="number">31</span>) &amp; ~<span class="number">0x1F</span>L);</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">ogles_context_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 c-&gt;rasterizer 中的属性</span></span><br><span class="line">    <span class="built_in">ggl_init_context</span>(&amp;(c-&gt;rasterizer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_init_context</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">context_t</span>));</span><br><span class="line">    <span class="built_in">ggl_init_procs</span>(c);</span><br><span class="line">    <span class="built_in">ggl_init_trap</span>(c);</span><br><span class="line">    <span class="built_in">ggl_init_scanline</span>(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 texture 相关属性，包括 state.texture</span></span><br><span class="line">    <span class="built_in">ggl_init_texture</span>(c);</span><br><span class="line">    <span class="built_in">ggl_init_picker</span>(c);</span><br><span class="line">    <span class="built_in">ggl_init_raster</span>(c);</span><br><span class="line">    c-&gt;formats = <span class="built_in">gglGetPixelFormatTable</span>();</span><br><span class="line">    c-&gt;state.blend.src = GGL_ONE;</span><br><span class="line">    c-&gt;state.blend.dst = GGL_ZERO;</span><br><span class="line">    c-&gt;state.blend.src_alpha = GGL_ONE;</span><br><span class="line">    c-&gt;state.blend.dst_alpha = GGL_ZERO;</span><br><span class="line">    c-&gt;state.mask.color = <span class="number">0xF</span>;</span><br><span class="line">    c-&gt;state.mask.depth = <span class="number">0</span>;</span><br><span class="line">    c-&gt;state.mask.stencil = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    c-&gt;state.logic_op.opcode = GGL_COPY;</span><br><span class="line">    c-&gt;state.alpha_test.func = GGL_ALWAYS;</span><br><span class="line">    c-&gt;state.depth_test.func = GGL_LESS;</span><br><span class="line">    c-&gt;state.depth_test.clearValue = FIXED_ONE;</span><br><span class="line">    c-&gt;shade.w0 = FIXED_ONE;</span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;ditherMatrix, gDitherMatrix, <span class="built_in">sizeof</span>(gDitherMatrix));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// platform/system/core/libpixelflinger/buffer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_init_texture</span><span class="params">(<span class="type">context_t</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将 c-&gt;state.texture 数组中的 texture_t 都初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i&lt;GGL_TEXTURE_UNIT_COUNT ; i++) &#123;</span><br><span class="line">        <span class="type">texture_t</span>&amp; t = c-&gt;state.texture[i];</span><br><span class="line">        t.s_coord = GGL_ONE_TO_ONE;</span><br><span class="line">        t.t_coord = GGL_ONE_TO_ONE;</span><br><span class="line">        t.s_wrap = GGL_REPEAT;</span><br><span class="line">        t.t_wrap = GGL_REPEAT;</span><br><span class="line">        t.min_filter = GGL_NEAREST;</span><br><span class="line">        t.mag_filter = GGL_NEAREST;</span><br><span class="line">        t.env = GGL_MODULATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将默认的 activeTMU 保存为 c-&gt;state.texture 数组的第一个</span></span><br><span class="line">    c-&gt;activeTMU = &amp;(c-&gt;state.texture[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c-&gt;state.texture 是一个长度为  GGL_TEXTURE_UNIT_COUNT &#x3D; 2 的，类型为 texture_t 的数组，它的初始化同样是在 ogles_init() 方法中，最终会调用到 ggl_init_texture() 方法内完成该数组的初始化，以及其 activeTMU 属性的初始化。</p>
<blockquote>
<p>这个 c-&gt;state.texture 数组，和前面提到的 c-&gt;textures.tmu 数组肯定有关系的，他俩的长度都是 GGL_TEXTURE_UNIT_COUNT &#x3D; 2。不同的是，一个类型是 texture_t ，一个类型是 texture_unit_t 。并且外部传来的 c-&gt;textures.active  值可以同时当做这俩的索引来用，因此这俩可以说是一一对应的了。</p>
</blockquote>
<p>接着简单看看这个 texture_t 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/private/pixelflinger/ggl_context.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">texture_t</span> &#123;</span><br><span class="line">  </span><br><span class="line">	<span class="type">surface_t</span>			surface;</span><br><span class="line"></span><br><span class="line">	<span class="type">texture_iterators_t</span>	iterators;</span><br><span class="line"></span><br><span class="line">    <span class="type">texture_shade_t</span>     shade;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span>			s_coord;</span><br><span class="line">  </span><br><span class="line">	<span class="type">uint32_t</span>            t_coord;</span><br><span class="line">  </span><br><span class="line">	<span class="type">uint16_t</span>			s_wrap;</span><br><span class="line">  </span><br><span class="line">	<span class="type">uint16_t</span>            t_wrap;</span><br><span class="line">  </span><br><span class="line">	<span class="type">uint16_t</span>            min_filter;</span><br><span class="line">  </span><br><span class="line">	<span class="type">uint16_t</span>            mag_filter;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span>            env;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span>             env_color[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>				enable;</span><br><span class="line">  </span><br><span class="line">	<span class="type">uint8_t</span>				dirty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先不管它内部的属性代表啥意义，就光看它内部的属性名是不是就觉得很熟悉，但是又想不上来它怎么熟悉的？和哪个类熟悉？它和前面的 EGLTextureObject 比较相像，下面就贴一下这个类，可以上下做对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/TextureObjectManager.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EGLTextureObject</span> : <span class="keyword">public</span> LightRefBase&lt;EGLTextureObject&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 省略其他定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line">    GGLSurface          surface;</span><br><span class="line">  </span><br><span class="line">    GLenum              wraps;</span><br><span class="line">  </span><br><span class="line">    GLenum              wrapt;</span><br><span class="line">  </span><br><span class="line">    GLenum              min_filter;</span><br><span class="line">  </span><br><span class="line">    GLenum              mag_filter;</span><br><span class="line">  </span><br><span class="line">    GLenum              internalformat;</span><br><span class="line">  </span><br><span class="line">    GLint               crop_rect[<span class="number">4</span>];</span><br><span class="line">  </span><br><span class="line">    GLint               generate_mipmap;</span><br><span class="line"></span><br><span class="line">    GLint               direct;</span><br><span class="line"></span><br><span class="line">    ANativeWindowBuffer* buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而对于 EGLTextureObject 来说就比较熟悉了，前面在 glBindTexture() 方法中创建，对应着一个纹理id；接着在 glTexParameteri() 方法中给它设置对应的纹理参数，此时会将设置的参数值保存到对应的（ c-&gt;textures.tmu[c-&gt;textures.active] ） EGLTextureObject 中去；接着会调用  glTexImage2D() 方法来将要处理的图像数据，比如宽、高、格式、像素内容等信息存入到其内部的 GGLSurface surface 中去（当然存储之前会自动为其分配合适的内存大小）。所以说至此，这个 EGLTextureObject 中绝大部分的属性都已经被赋值了。</p>
<p>而看到这里的 texture_t 类型，它里面的属性和 EGLTextureObject 中的属性好多都是相像的，但是他俩之间还没有产生关联，等往后接着看吧。</p>
<p>所以说，在 ggl_activeTexture() 方法中会修改 activeTMU ，后续就可以直接使用了。</p>
<p>至此，glActiveTexture() 方法执行完毕了，该方法中会修改 c-&gt;textures.active 的值，并且会同时修改 ogles_context_t.rasterizer 属性中的 activeTMUIndex 和 activeTMU ，使得 activeTMUIndex 等于 c-&gt;textures.active ；使得 activeTMU 等于 c-&gt;state.texture[ c-&gt;textures.active ] 。</p>
<h3 id="glEnable"><a href="#glEnable" class="headerlink" title="glEnable"></a>glEnable</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/opengl/libagl/state.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">glEnable</span><span class="params">(GLenum cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程保存的 ogles_context_t 实例</span></span><br><span class="line">    <span class="type">ogles_context_t</span>* c = <span class="type">ogles_context_t</span>::<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">enable_disable</span>(c, cap, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">enable_disable</span><span class="params">(<span class="type">ogles_context_t</span>* c, GLenum cap, <span class="type">int</span> enabled)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((cap &gt;= GL_LIGHT0) &amp;&amp; (cap&lt;GL_LIGHT0+OGLES_MAX_LIGHTS)) &#123;</span><br><span class="line">        c-&gt;lighting.lights[cap-GL_LIGHT0].enable = enabled;</span><br><span class="line">        c-&gt;lighting.enabledLights &amp;= ~(<span class="number">1</span>&lt;&lt;(cap-GL_LIGHT0));</span><br><span class="line">        c-&gt;lighting.enabledLights |= (enabled&lt;&lt;(cap-GL_LIGHT0));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 glEnable 方法入参 cap 来分类处理</span></span><br><span class="line">    <span class="comment">// 下面主要看 GL_TEXTURE_2D 的情况</span></span><br><span class="line">    <span class="keyword">switch</span> (cap) &#123;</span><br><span class="line">    <span class="keyword">case</span> GL_POINT_SMOOTH:</span><br><span class="line">        c-&gt;point.smooth = enabled;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GL_LINE_SMOOTH:</span><br><span class="line">        c-&gt;line.smooth = enabled;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GL_POLYGON_OFFSET_FILL:</span><br><span class="line">        c-&gt;polygonOffset.enable = enabled;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GL_CULL_FACE:</span><br><span class="line">        c-&gt;cull.enable = enabled;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GL_LIGHTING:</span><br><span class="line">        c-&gt;lighting.enable = enabled;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GL_COLOR_MATERIAL:</span><br><span class="line">        c-&gt;lighting.colorMaterial.enable = enabled;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GL_NORMALIZE:</span><br><span class="line">    <span class="keyword">case</span> GL_RESCALE_NORMAL:</span><br><span class="line">        c-&gt;transforms.rescaleNormals = enabled ? cap : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> GL_CLIP_PLANE0:</span><br><span class="line">    <span class="keyword">case</span> GL_CLIP_PLANE1:</span><br><span class="line">    <span class="keyword">case</span> GL_CLIP_PLANE2:</span><br><span class="line">    <span class="keyword">case</span> GL_CLIP_PLANE3:</span><br><span class="line">    <span class="keyword">case</span> GL_CLIP_PLANE4:</span><br><span class="line">    <span class="keyword">case</span> GL_CLIP_PLANE5:</span><br><span class="line">        c-&gt;clipPlanes.enable &amp;= ~(<span class="number">1</span>&lt;&lt;(cap-GL_CLIP_PLANE0));</span><br><span class="line">        c-&gt;clipPlanes.enable |= (enabled&lt;&lt;(cap-GL_CLIP_PLANE0));</span><br><span class="line">        <span class="built_in">ogles_invalidate_perspective</span>(c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> GL_FOG:</span><br><span class="line">    <span class="keyword">case</span> GL_DEPTH_TEST:</span><br><span class="line">        <span class="built_in">ogles_invalidate_perspective</span>(c);</span><br><span class="line">        [[fallthrough]];</span><br><span class="line">    <span class="keyword">case</span> GL_BLEND:</span><br><span class="line">    <span class="keyword">case</span> GL_SCISSOR_TEST:</span><br><span class="line">    <span class="keyword">case</span> GL_ALPHA_TEST:</span><br><span class="line">    <span class="keyword">case</span> GL_COLOR_LOGIC_OP:</span><br><span class="line">    <span class="keyword">case</span> GL_DITHER:</span><br><span class="line">    <span class="keyword">case</span> GL_STENCIL_TEST:</span><br><span class="line">    <span class="keyword">case</span> GL_TEXTURE_2D:</span><br><span class="line">        <span class="comment">// 主要看这里</span></span><br><span class="line">        c-&gt;rasterizer.procs.<span class="built_in">enableDisable</span>(c, cap, enabled);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GL_TEXTURE_EXTERNAL_OES:</span><br><span class="line">        c-&gt;rasterizer.procs.<span class="built_in">enableDisable</span>(c, GL_TEXTURE_2D, enabled);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> GL_MULTISAMPLE:</span><br><span class="line">    <span class="keyword">case</span> GL_SAMPLE_ALPHA_TO_COVERAGE:</span><br><span class="line">    <span class="keyword">case</span> GL_SAMPLE_ALPHA_TO_ONE:</span><br><span class="line">    <span class="keyword">case</span> GL_SAMPLE_COVERAGE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">ogles_error</span>(c, GL_INVALID_ENUM);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部可以调用当前方法来开启某些开关，开启某些能力支持。与他对应的还有一个 glDisable()，不过其实现逻辑大同小异，这里只分析这一个就行。</p>
<p>比如在开机动画中会执行如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDisable</span>(GL_DITHER);</span><br><span class="line"><span class="built_in">glDisable</span>(GL_SCISSOR_TEST);</span><br><span class="line"><span class="built_in">glDisable</span>(GL_BLEND);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnable</span>(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure>

<p>即使用这俩方法开开启和关系一些能力开关。这里着重分析 glEnable(GL_TEXTURE_2D) 的情况。最终会执行到 ：c-&gt;rasterizer.procs.enableDisable() 方法中，此时入参 cap &#x3D; GL_TEXTURE_2D ，enabled &#x3D; 1 。</p>
<p>而 c-&gt;rasterizer.procs.enableDisable() 方法的实现实际对应的是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// platform/system/core/libpixelflinger/pixelflinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ggl_enableDisable</span><span class="params">(<span class="type">void</span>* con, GGLenum name, GGLboolean en)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">GGL_CONTEXT</span>(c, con);</span><br><span class="line">    <span class="built_in">enable_disable</span>(c, name, en ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">enable_disable</span><span class="params">(<span class="type">context_t</span>* c, GGLenum name, <span class="type">int</span> en)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">    <span class="keyword">case</span> GGL_BLEND:             <span class="built_in">ggl_enable_blending</span>(c, en);      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_SCISSOR_TEST:      <span class="built_in">ggl_enable_scissor_test</span>(c, en);  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_ALPHA_TEST:        <span class="built_in">ggl_enable_alpha_test</span>(c, en);    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_COLOR_LOGIC_OP:    <span class="built_in">ggl_enable_logic_op</span>(c, en);      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_DITHER:            <span class="built_in">ggl_enable_dither</span>(c, en);        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_STENCIL_TEST:      <span class="built_in">ggl_enable_stencil_test</span>(c, en);  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_DEPTH_TEST:        <span class="built_in">ggl_enable_depth_test</span>(c, en);    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_AA:                <span class="built_in">ggl_enable_aa</span>(c, en);            <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 处理到这里</span></span><br><span class="line">    <span class="keyword">case</span> GGL_TEXTURE_2D:        <span class="built_in">ggl_enable_texture2d</span>(c, en);     <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> GGL_W_LERP:            <span class="built_in">ggl_enable_w_lerp</span>(c, en);        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_FOG:               <span class="built_in">ggl_enable_fog</span>(c, en);           <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GGL_POINT_SMOOTH_NICE: <span class="built_in">ggl_enable_point_aa_nice</span>(c, en); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ggl_enable_texture2d</span><span class="params">(<span class="type">context_t</span>* c, <span class="type">int</span> enable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果 c-&gt;activeTMU-&gt;enable 中的状态和入参值不一样，那么修改它</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;activeTMU-&gt;enable != enable) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> tmu = c-&gt;activeTMUIndex;</span><br><span class="line">        <span class="comment">// 修改它的值，后续会用到</span></span><br><span class="line">        c-&gt;activeTMU-&gt;enable = enable;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> mask = <span class="number">1UL</span> &lt;&lt; tmu;</span><br><span class="line">        <span class="comment">// 同时会修改 c-&gt;state.enabled_tmu 的值</span></span><br><span class="line">        <span class="keyword">if</span> (enable)                 c-&gt;state.enabled_tmu |= mask;</span><br><span class="line">        <span class="keyword">else</span>                        c-&gt;state.enabled_tmu &amp;= ~mask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;state.enabled_tmu)   c-&gt;state.enables |= GGL_ENABLE_TMUS;</span><br><span class="line">        <span class="keyword">else</span>                        c-&gt;state.enables &amp;= ~GGL_ENABLE_TMUS;</span><br><span class="line">        <span class="built_in">ggl_state_changed</span>(c, GGL_TMU_STATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而他为啥对应的是 ggl_enableDisable() ? 原因就不讲了吧，前面提过好多次了。</p>
<p>而对于入参 cap &#x3D; GL_TEXTURE_2D ，enabled &#x3D; 1 的情况，内部最终会修改 c-&gt;activeTMU-&gt;enable 和 c-&gt;state.enabled_tmu 的值。</p>
<p>至于不同的  cap 修改的是哪些值，这里不列出了。我们只需要知道 glEnable() 和 glDisable() 可以修改 ogles_context_t 属性中的值就行了。</p>
<p>剩下的 gl 方法分析详见 <a href="60dbf32.html">GLES&amp;EGL-GLES-03</a> </p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/OpenGLES/">OpenGLES</a>
		  
			<a href="/tags/EGL/">EGL</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/60dbf32.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">GLES&EGL-GLES-03</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/e803de1e.html">
        <span class="next-text nav-default">GLES&EGL-GLES-01</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
