<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Kotlin协程 - 协程挂起原理"/>




  <meta name="keywords" content="Kotlin Coroutine," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/e2cf098c.html"/>


<meta name="description" content="对于挂起方法来说，它在定义的时候仅仅比普通方法多了 suspend 关键字修饰而已，在编译之后，编译器会为其入参最后一位增加 Continuation 入参，作为回调Callback。但是这样该方法就支持挂起了？究竟什么才是挂起呢？ 挂起？与挂起相对的就是不挂起，也可以说是阻塞，也就是普通的方法。我们知道，操作系统会调度线程来执行线程内的代码逻辑。而对于单核CPU来说，同一时刻就只能有一个进程（中">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin协程 - 协程挂起原理">
<meta property="og:url" content="https://youngkaaa.github.io/e2cf098c.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="对于挂起方法来说，它在定义的时候仅仅比普通方法多了 suspend 关键字修饰而已，在编译之后，编译器会为其入参最后一位增加 Continuation 入参，作为回调Callback。但是这样该方法就支持挂起了？究竟什么才是挂起呢？ 挂起？与挂起相对的就是不挂起，也可以说是阻塞，也就是普通的方法。我们知道，操作系统会调度线程来执行线程内的代码逻辑。而对于单核CPU来说，同一时刻就只能有一个进程（中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/e2cf098c/pic_01.png">
<meta property="article:published_time" content="2022-05-05T10:48:56.000Z">
<meta property="article:modified_time" content="2022-11-02T13:21:21.995Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Kotlin Coroutine">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/e2cf098c/pic_01.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Kotlin协程 - 协程挂起原理 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Kotlin协程 - 协程挂起原理
        
      </h1>

      <time class="post-time">
          5月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>对于挂起方法来说，它在定义的时候仅仅比普通方法多了 suspend 关键字修饰而已，在编译之后，编译器会为其入参最后一位增加 Continuation 入参，作为回调Callback。但是这样该方法就支持挂起了？究竟什么才是挂起呢？</p>
<h3 id="挂起？"><a href="#挂起？" class="headerlink" title="挂起？"></a>挂起？</h3><p>与挂起相对的就是不挂起，也可以说是阻塞，也就是普通的方法。我们知道，操作系统会调度线程来执行线程内的代码逻辑。而对于单核CPU来说，同一时刻就只能有一个进程（中的线程）在执行，但是实际环境中会存在很多个线程任务等待CPU来调度执行，那么操作系统按照什么规则来调度它们呢？</p>
<p>1、协作式，简单来说就是挨个执行，执行完线程A任务之后再去执行下一个,在执行线程A时，线程内如果有耗时操作比如IO操作等，此时线程A可以主动让出执行权，此时操作系统去调度执行下一个等待的线程。但是这种存在隐患，即个别居心不良的线程会一直霸占CPU导致其他线程任务被饿死。</p>
<p>2、抢占式，也就是调度权完全是操作系统来把控。操作系统会分配时间片来调度执行那些等待的线程。这样的话每个线程基本都有机会被执行。当一个线程被执行过程中可能会因为其时间片用光而被操作系统暂停，而去执行另外的线程。</p>
<p>这里描述的很简单，关于协作式和抢占式更完整详细的描述可以查看相关文献。</p>
<p>所以当一个CPU调度到一个线程A，开始执行该线程内逻辑时，在其时间片区间内CPU就一直被该线程占用，除非该线程A内逻辑被执行完成。而如果该线程A内部有一个耗时操作，比如IO操作，此时CPU会一直等待其IO操作完成，在等待的这段时间内，CPU被占用但没有工作就是属于浪费了。换种说法来描述就是：CPU为何被占用了？是因为线程A内的逻辑没有执行完，用Java Thread 来举例就是其 run 方法逻辑没有执行完毕，而run方法没有执行完毕正是因为其内部存在IO等耗时操作阻塞着，后续代码无法接着执行，CPU就一直阻塞等在这里。</p>
<blockquote>
<p>上述描述的场景就是 阻塞，也可以理解为同步、非挂起。下面描述非阻塞，也可以理解为异步、挂起。</p>
</blockquote>
<p>所以想要不阻塞的话，可以将耗时的操作从线程A中剔除，扔到另外一个线程B去执行(并设置回调，回调中包括着耗时操作之后的代码逻辑)，然后直接将线程A 中的run 方法 return 掉，此时线程A run 方法也就执行完毕了，那么CPU就会去调度其他线程，相当于释放掉了CPU。</p>
<p>等线程B后续被调度执行完内部的耗时操作之后，执行回调指定方法，从而接着执行剩余的逻辑。</p>
<p>当然这里牵扯到线程转换，你在哪个线程执行回调，剩余逻辑就在哪个线程执行。比如在Android中，规定了UI操作必须在主线程执行。所以可以存在这种具体场景：通过网络请求IO获取后端数据，然后将数据显示到页面上。在Android中常见的做法就是将网络请求IO耗时操作挪到子线程去执行，执行完成之后Post一个消息去主线程中执行回调onSuccess，在回调中拿到请求结果并执行UI的展示操作。</p>
<p>所以这个过程就是从主线程执行一部分，然后耗时IO到子线程执行，最后展示又回到主线程。</p>
<blockquote>
<p>因为Android中主线程永远不会退出，回去循环执行一个指定消息队列中的消息任务，所以这里的Post就是往该消息队列中插入任务即可，后续主线程会取出它并执行对应逻辑，在此处对应逻辑指的就是[执行回调onSuccess中的逻辑]</p>
</blockquote>
<p>上述将IO耗时操作扔到另外一个线程去执行，这就是挂起。当IO操作在另外一个线程执行完毕后又返回执行剩余逻辑这就是(挂起之后的)恢复。</p>
<h3 id="传统挂起"><a href="#传统挂起" class="headerlink" title="传统挂起"></a>传统挂起</h3><p>传统的要实现非阻塞效果，基本都是借助Callback来异步编程。比如举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUserId</span><span class="params">(Callback callback)</span> &#123;</span><br><span class="line">    <span class="comment">// 启动线程去执行耗时操作</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.run();</span><br><span class="line">            <span class="comment">// balabala 耗时操作</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> someTimeCost();</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(userId)) &#123;</span><br><span class="line">                callback.onSuccess(userId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.onFailure();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> currentTimeMillis=System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 其他准备工作</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 耗时操作</span></span><br><span class="line">    getUserId(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">            <span class="comment">// 其他 balabala 操作</span></span><br><span class="line">            updateUIByUserId(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 其他 balabala 操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在调用 test 方法时，内部会先进行一些准备工作，准备工作之后调用 getUserId 进行网络请求，传入 Callback 等待其耗时逻辑执行完之后，再执行剩余的 updateUIByUserId 等更新UI操作。</p>
<p>这种方式便可以实现传统意义上的挂起，上述就相当于挂起了 test() 方法，而不必让test() 等待耗时操作执行完再返回。但是这种会存在：嵌套地狱 的问题，即业务复杂的话Callback嵌套会很深。</p>
<p>接下来看协程的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserId</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">   <span class="keyword">return</span> withContext(Dispatchers.IO)&#123;</span><br><span class="line">        someTimeCost()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> userId = getUserId()</span><br><span class="line">    <span class="comment">// 其他 balabala 操作</span></span><br><span class="line">    updateUIByUserId(userId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要看 launch 方法体内的逻辑，先调用 getUserId 挂起方法去获取 userId，此时 launch 方法内会被挂起，即当前CPU会被释放而调度执行其他线程，此处属于一个挂起点。等挂起方法执行完毕之后，会接着执行后续的 updateUIByUserId 逻辑。整个过程看起来就像是一步步顺序执行的一样，也就是同步方式编程。</p>
<p>而通过前文可以知道，suspend 标记的 getUserId 方法会在编译之后为其入参末尾增加一个 Continuation 入参，担当传统意义上的 Callback 。</p>
<h3 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h3><p>再举一次之前举过的例子：<br>假设Kotlin代码为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch&#123;</span><br><span class="line">        println(<span class="string">&quot;coroutine in&quot;</span>)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">        println(<span class="string">&quot;coroutine finish&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原Kotlin协程代码逻辑很简单，使用 GlobalScope 协程域来启动一个协程，内部先打印输出”coroutine in” ,然后执行耗时操作这里使用挂起方法 delay 来代替，完事之后接着输出 “coroutine finish”。所以这里内部只调用了一个挂起方法 delay ，所以只存在一个挂起点(那就是delay)。</p>
<blockquote>
<p>挂起点可以【简单理解】为调用挂起方法的位置，比如此处delay位置就是一个挂起点。</p>
<p>但是有些挂起方法虽然使用 suspend 修饰但是内部并没有实际挂起。</p>
</blockquote>
<p>所以说使用 delay 作为分割线，其之后的代码相当于是要等挂起方法执行完毕之后才能被调用的。</p>
<p>一个办法是将其包装到Callback中传入到delay中，等delay时间到了后再执行Callback，当然在协程中的Callback 是 Continuation 。</p>
<p>比如：可以new一个 Continuation ，然后在其 resumeWith 方法内把 println(“coroutine finish”) 包括进去，再把该 Continuation 对象传入到 delay 中等其完事儿后执行该 Continuation 对象的 resumeWith 即可完成对剩余逻辑的执行。</p>
<p>这是一种方法，这种方法的话，就会在遇到每以个挂起点时，都会创建一个 Continuation 对象实例。这种方式可能有点太重量级了，因为会创建很多个对象。</p>
<p>所以官方后续采用了另外一种方式:状态机</p>
<p>先看看反编译之后的文件吧，共两个class : <code>Demo01Kt.class</code> 和 <code>Demo01Kt$main $1.class</code> ，这里主要看第二个：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01Kt$main$1.class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个中间类 Demo01Kt$main$1 代表的是源代码中 launch 方法体的内容，即花括号的内容</span></span><br><span class="line"><span class="comment"> * 它其实是一个 lambda ，不过位于 launch 最后，所以可以写到方法体外用花括号包起来</span></span><br><span class="line"><span class="comment"> * 其就是一个类型为：suspend CoroutineScope.() -&gt; Unit 的 lambda</span></span><br><span class="line"><span class="comment"> * 因为 suspend 修饰了他，所以继承自 SuspendLambda ，且在方法参数最后一位增加一个 Continuation 参数，</span></span><br><span class="line"><span class="comment"> * 且因为是 CoroutineScope. 的，所以会在参数第一位加一个 CoroutineScope 参数 ，</span></span><br><span class="line"><span class="comment"> * 所以实现了 Function2 ，一共两个参数：CoroutineScope 和 Continuation 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 而由于继承自 SuspendLambda ，所以其内部的 create 、invokeSuspend 方法会被实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01Kt</span>$<span class="title">main</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function2</span>&lt;<span class="type">CoroutineScope, Continuation&lt;? super Unit</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 构造方法、create、invoke 等方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * resumeWith() 中调用，在 &#123;<span class="doctag">@link</span> BaseContinuationImpl&#125; 中可以知道。</span></span><br><span class="line"><span class="comment">     * 可以先看看上面这个类里面的逻辑，总的来说，调用 Continuation 的 resumeWith 方法之后，最后会执行到这里</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在其&#123;<span class="doctag">@link</span> BaseContinuationImpl#resumeWith(Object)&#125; 方法中，会执行死循环来调用invokeSuspend方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果其返回了 CoroutineSingletons.COROUTINE_SUSPENDED 表示内部挂起了，那么return掉，终止死循环。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1-&gt; 存储 CoroutineSingletons.COROUTINE_SUSPENDED</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object coroutine_suspended = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2-&gt; label默认是0，所以刚开始执行的应该是 case 0</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            case <span class="number">0</span>:</span><br><span class="line">                ResultKt.throwOnFailure($result);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.1 -&gt; 按照协程体内的逻辑，先sout输出 ，并且会更新 label 为 1，下次执行当前方法时，会执行  1 的case</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;coroutine in&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.2 -&gt; 执行到第一个delay 挂起函数，挂起 100ms。注意这里传入的第二个参数 this，作为 Continuation 类型传入的</span></span><br><span class="line"><span class="comment">                 * 因为delay是被suspend修饰的函数，那么编译之后会自动在最后一位增加 Continuation 类型的参数</span></span><br><span class="line"><span class="comment">                 * 如果 delay 内部返回了 CoroutineSingletons.COROUTINE_SUSPENDED 表示挂起了，此时返回CoroutineSingletons.COROUTINE_SUSPENDED出去</span></span><br><span class="line"><span class="comment">                 * 此时在 &#123;<span class="doctag">@link</span> BaseContinuationImpl#resumeWith(Object)&#125; 中会直接return而终止其外部while死循环</span></span><br><span class="line"><span class="comment">                 * 此时该 Continuation 会停止执行，此时 label=1，等待该协程下次被调用 resumeWith 方法</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 而这里 delay，传入 100ms，相当于协程挂起100ms，停止执行当前协程体内代码，线程去执行其他协程逻辑，而在delay方法中，可以理解为 postDelay</span></span><br><span class="line"><span class="comment">                 * 延迟100ms后执行当前 Continuation 的 resumeWith 方法。</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 所以总的来说：这里 return CoroutineSingletons.COROUTINE_SUSPENDED 出去，当前协程体执行终止，外部也终止，协程体逻辑停止执行，等待指</span></span><br><span class="line"><span class="comment">                 * 定时间后，协程体代码再次被执行，此时 label = 1</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (DelayKt.delay(<span class="number">100</span>, (Continuation) <span class="keyword">this</span>) == coroutine_suspended) &#123;</span><br><span class="line">                    <span class="keyword">return</span> coroutine_suspended;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3 -&gt; 从 2.2 处开始等待100ms之后，再次执行 Continuation 的 resumeWith 方法，由于此时 label=1 所以执行到 case 1 这里，</span></span><br><span class="line"><span class="comment">             * 这里判断入参result是否合法，不合法则会抛出异常终止执行，如果合法，则 break 掉当前 switch语句，执行到最下面输出 coroutine finish</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            case <span class="number">1</span>:</span><br><span class="line">                ResultKt.throwOnFailure($result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println((Object) <span class="string">&quot;coroutine finish&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协程真正的实现方式上并没有使用上述的方式，而是将挂起点之前和之后的所有代码都封装到一个类对象中。比如这里会将 suspend lambda 编译成一个中间类：<code>Demo01Kt$main$1</code>，而这个中间类是继承自 SuspendLambda 的，所以实现了 invokeSuspend ，实现这个方法其实也就是实现了 resumeWith 方法，因为调用 resumeWith 时最终是会调用到 invokeSuspend 中的。</p>
<p>而在编译器实现的 invokeSuspend 方法中，会将挂起点之前，挂起点之后的代码逻辑分散在 switch 中，使用 int label 来决定case 分支，默认 label &#x3D; 0。</p>
<p>当第一次执行 <code>Demo01Kt$main$1</code>类的resumeWith 方法时，会走到invokeSuspend 方法内，执行 case 0 的分支，先将”coroutine in<br>“ 打印出来，然后调用 delay 方法，第二个参数把 this 当做 Continuation 传入其中。注意这里最重要的一个点是在delay之前将label置为了1。</p>
<blockquote>
<p>delay 也是被suspend 修饰的挂起方法，它是协程库提供的现成的挂起方法。可以将其理解为Android中的postDelay，即延迟指定时间之后再执行后续的方法</p>
<p>由于delay 是挂起方法，所以经由CPS转换之后，最后一位会增加 Continuation 入参，所以这里传入了两个参数。</p>
</blockquote>
<p>这里传入的this 就可以看做是 Callback ，也可以看做是上面提及的包装了剩余代码的 Continuation 对象实例，但是不同的是这里并没有按照上面说的新建 Continuation 对象实例，而是复用之前的 <code>Demo01Kt$main$1</code>类实例。</p>
<p>那么等后续delay时长够了后，会执行入参this，也就是<code>Demo01Kt$main$1</code>类实例的resumeWith方法，进而再次执行到当前 invokeSuspend 方法内，此时label已经是1了，所以接着执行 case 1 的逻辑，也就是判断本次调用invokeSuspend方法时的入参result是否是成功的，也就是是否产生了异常，</p>
<p>1、没有异常，也就是表示前面挂起方法delay执行成功，则接着往下switch执行完毕，最后执行剩余代码输出”coroutine finish”。</p>
<p>2、有异常，此时 ResultKt.throwOnFailure() 方法处会将result.exception中的异常信息throw出去而终止掉后续代码的执行。</p>
<blockquote>
<p>也就是说在其他线程发生的异常，通过result传到了当前线程处再抛出，所以可以在协程中直接 try catch 获取挂起方法在其他线程内的异常</p>
<p>对于当前例子的协程代码来说，就好像是在 delay 处抛出了异常，但实际上是在另外线程产生了异常在当前位置抛出而已</p>
</blockquote>
<p>所以这里 invokeSuspend 中使用的就是：状态机。通过协程内部维护的label不同的值来表示不用的状态，表示其内部代码执行的不同时段状态。这个label就像是线程中的程序计数器一样，用来记录当前线程要执行的下一行代码地址。后续线程只需要调度它执行它的resumeWith方法，它内部会恢复好上次的执行位置并接着往后执行。</p>
<p>还有最重要的一点需要指出，在上面<code>Demo01Kt$main$1</code>类的 invokeSuspend 方法内有如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object coroutine_suspended = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="keyword">if</span> (DelayKt.delay(<span class="number">100</span>, (Continuation) <span class="keyword">this</span>) == coroutine_suspended) &#123;</span><br><span class="line">                    <span class="keyword">return</span> coroutine_suspended;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>也就是会判断delay 方法的返回值是否是：<code>COROUTINE_SUSPENDED</code>。它的定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intrinsics.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> COROUTINE_SUSPENDED: Any <span class="keyword">get</span>() = CoroutineSingletons.COROUTINE_SUSPENDED</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using enum here ensures two important properties:</span></span><br><span class="line"><span class="comment">//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)</span></span><br><span class="line"><span class="comment">//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from</span></span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.3&quot;</span>)</span></span><br><span class="line"><span class="meta">@PublishedApi</span> <span class="comment">// This class is Published API via serialized representation of SafeContinuation, don&#x27;t rename/move</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">CoroutineSingletons</span> &#123; COROUTINE_SUSPENDED, UNDECIDED, RESUMED &#125;</span><br></pre></td></tr></table></figure>

<p>他最终指向一个枚举值，并且全局唯一。实际上对于 suspend 挂起方法而言，其内部可能会：</p>
<p>1、返回 COROUTINE_SUSPENDED 。外部调用它的方法拿到返回值之后就知道该方法是挂起了，所以会直接 return掉，停止执行剩余的逻辑，此时对应的线程在执行该方法时由于其内部return掉了所以方法执行完毕，从而导致线程让出执行权，操作系统就可以去调度执行其他的线程了，而不用再此死等着。这便是挂起，这便是协程的协作式。</p>
<p>2、返回正常计算结果。表示该方法虽然是使用 suspend 标记的，但是内部并没有挂起，所以此时这里不会resturn 掉，而是接着执行。</p>
<blockquote>
<p>这也正是为什么在CPS转换之后，返回值统一都变成了Object，因为该方法内部可能会返回两种类型的值。</p>
</blockquote>
<p>看完这些还是有些云里雾里，因为还有一个点没有提，那便是 Continuation 的 resumeWith 方法，该方法的全部逻辑都是在其子类： BaseContinuationImpl 中的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ContinuationImpl.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseContinuationImpl</span>(</span><br><span class="line">    <span class="comment">// This is `public val` so that it is private on JVM and cannot be modified by untrusted code, yet</span></span><br><span class="line">    <span class="comment">// it has a public getter (since even untrusted code is allowed to inspect its call stack).</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;</span><br><span class="line">    <span class="comment">// This implementation is final. This fact is used to unroll resumeWith recursion.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从当前 BaseContinuationImpl 开始执行</span></span><br><span class="line"><span class="comment">         * result 一开始应该是没有值的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> param = result</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Invoke &quot;resume&quot; debug probe on every resumed continuation, so that a debugging library infrastructure</span></span><br><span class="line">            <span class="comment">// can precisely track what part of suspended callstack was already resumed</span></span><br><span class="line">            probeCoroutineResumed(current)</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在当前 BaseContinuationImpl 的基础上运行如下逻辑，即执行 current.invokeSuspend 方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            with(current) &#123;</span><br><span class="line">                <span class="keyword">val</span> completion = completion!! <span class="comment">// fail fast when trying to resume continuation without completion</span></span><br><span class="line">                <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 调用 current.invokeSuspend()，执行续体下一个状态码对应的代码（协程恢复执行）</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 如果下一部分代码又调用了挂起函数挂起了协程，直接return，等待挂起函数继续调用续体的resumeWith</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 到这里的话表示当前协程的Lambda表达式代码都执行完毕了，</span></span><br><span class="line"><span class="comment">                         * 此时 invokeSuspend() 会返回当前协程的结果，将其包装到 Result 中返回</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        Result.success(outcome)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                        <span class="comment">// 如果挂起函数resume恢复了异常对象 或者 协程代码块中throw了异常，将异常封装到Result中</span></span><br><span class="line">                        Result.failure(exception)</span><br><span class="line">                    &#125;</span><br><span class="line">                releaseIntercepted() <span class="comment">// this state machine instance is terminating</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * completion 此时指向的是当前 BaseContinuationImpl 实例内部包装的  Continuation</span></span><br><span class="line"><span class="comment">                 * 也就是当前 BaseContinuationImpl 执行完毕之后的下一个 Continuation</span></span><br><span class="line"><span class="comment">                 * 也就是当前代码执行完毕后，接着执行的代码块逻辑</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 如果它是继承自 BaseContinuationImpl 的，那么它肯定实现了 invokeSuspend 方法</span></span><br><span class="line"><span class="comment">                 * 也就是说它是一个待执行的代码逻辑块，此时将其保存给 completion ，</span></span><br><span class="line"><span class="comment">                 * 然后将上一个的返回结果 outcome 作为入参供下一个使用</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 而如果不是继承自 BaseContinuationImpl 的，那可能是 StandaloneCoroutine</span></span><br><span class="line"><span class="comment">                 * 也就是他们是作为最顶层的接收者的，他们是最后一层，表示内部的都执行完了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                    <span class="comment">// unrolling recursion via loop</span></span><br><span class="line">                    current = completion</span><br><span class="line">                    param = outcome</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// top-level completion reached -- invoke and return</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 一般就是 AbstractCoroutine 了，比如 StandaloneCoroutine 。</span></span><br><span class="line"><span class="comment">                     * 此时表示协程执行完毕了，通知到最外层去执行一些收尾工作</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    completion.resumeWith(outcome)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文可知：</p>
<p>1、当要执行该协程时，是直接调用 Continuation.resumeWith 方法，最终触发到 invokeSuspend 方法内的。</p>
<p>2、suspend lambda 在编译之后会自动生成一个与之对应的中间类，比如上面的 <code>Demo01Kt$main$1</code>类。该类继承自 SuspendLambda 。</p>
<p>3、在启动协程时，会有两次中间类<code>Demo01Kt$main$1</code>的创建，其中第二次是调用 create 方法将外部创建的 StandaloneCoroutine 对象实例作为 Continuation 类型传入到 <code>Demo01Kt$main$1</code>类构造方法中，也就是最终会赋值到 BaseContinuationImpl.completion 中。</p>
<p>所以说当前 BaseContinuationImpl 中的一些属性就是：</p>
<p>1、completion ： 外部launch启动时，创建的 StandaloneCoroutine 实例</p>
<p>2、this ： 也就是中间类<code>Demo01Kt$main$1</code>的实例，更准确的来说该实例是第二次创建的那个。该类实现了 invokeSuspend 方法，内部包括了所有的代码逻辑，通过label状态机来进行拆分执行。</p>
<p>可以看到这里当invokeSuspend 返回 COROUTINE_SUSPENDED 时，resumeWith 方法死循环就会退出，从而导致resumeWith 方法执行完毕，也就是实现挂起功能。如果返回不是它，则将返回结果包装成 Result 对象，然后等待其要不传递给下一个待执行的协程lambda中，要不传递给最外层StandaloneCoroutine中进行最终的收尾工作。</p>
<h4 id="复杂例子"><a href="#复杂例子" class="headerlink" title="复杂例子"></a>复杂例子</h4><p>接下来看一个比较复杂的示例，主要用于理解上面 resumeWith 中的 <code>completion is BaseContinuationImpl</code> 条件怎么执行的。</p>
<p>Kotlin代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Demo01().test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserId</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;youngkaaa&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">(userId: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">$&#123;userId&#125;</span>&#x27;s info&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            <span class="keyword">val</span> userId = getUserId()</span><br><span class="line">            <span class="keyword">val</span> userInfo = getUserInfo(userId)</span><br><span class="line">            println(userInfo)</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">2500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin原代码看起来比较简单的，就是定义了两个挂起方法，先获取userId，再通过获取到的userId拿到其对应的userInfo，其中使用delay用来模拟耗时操作。最后将获取到的userInfo打印输出。</p>
<p>但是反编译之后的代码就比较复杂了。</p>
<p>共产生5个 class 文件：<code>Demo01Kt.class</code> 、<code>Demo01.class</code> 、  <code>Demo01$test$1.class</code> 、<code>Demo01$getUserId$1.class</code> 和 <code>Demo01$getUserInfo$1.class</code>。</p>
<p>先看最简单的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01Kt.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> void main() &#123;</span><br><span class="line">        new Demo01().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看编译器为两个挂起方法生成的中间类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01$getUserId$.class </span></span><br><span class="line"><span class="comment">// 对应的是 getUserId 挂起方法，注意这里继承的是 ContinuationImpl</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">getUserId</span>$1 <span class="title">extends</span> <span class="title">ContinuationImpl</span> &#123;</span><br><span class="line">    <span class="comment">// 用来临时保存结果</span></span><br><span class="line">    <span class="comment">/* synthetic */</span> Object result;</span><br><span class="line">    <span class="comment">// 持有 Demo01 类的实例，用于后续挂起被恢复时可以接着调用 getUserId 方法执行后续逻辑</span></span><br><span class="line">    <span class="keyword">final</span> <span class="comment">/* synthetic */</span> Demo01 <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 状态机标识</span></span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX WARN: &#x27;super&#x27; call moved to the top of the method (can break code semantics) */</span></span><br><span class="line">    Demo01$getUserId$<span class="number">1</span>(Demo01 <span class="keyword">this</span>$<span class="number">0</span>, Continuation&lt;? <span class="keyword">super</span> Demo01$getUserId$<span class="number">1</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">super</span>(continuation);</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">        Object userId;</span><br><span class="line">        <span class="keyword">this</span>.result = $result;</span><br><span class="line">        <span class="keyword">this</span>.label |= Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 接着调用 getUserId 方法完成其内部逻辑的执行</span></span><br><span class="line">        userId = <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span>getUserId((Continuation) <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------ 分割线 ------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Demo01$getUserInfo$1.class</span></span><br><span class="line"><span class="comment">// 对应的是 getUserInfo 挂起方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">getUserInfo</span>$1 <span class="title">extends</span> <span class="title">ContinuationImpl</span> &#123;</span><br><span class="line">    Object L$<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* synthetic */</span> Object result;</span><br><span class="line">    <span class="keyword">final</span> <span class="comment">/* synthetic */</span> Demo01 <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">    int label;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX WARN: &#x27;super&#x27; call moved to the top of the method (can break code semantics) */</span></span><br><span class="line">    Demo01$getUserInfo$<span class="number">1</span>(Demo01 <span class="keyword">this</span>$<span class="number">0</span>, Continuation&lt;? <span class="keyword">super</span> Demo01$getUserInfo$<span class="number">1</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">super</span>(continuation);</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invokeSuspend(<span class="meta">@NotNull</span> Object $result) &#123;</span><br><span class="line">        Object userInfo;</span><br><span class="line">        <span class="keyword">this</span>.result = $result;</span><br><span class="line">        <span class="keyword">this</span>.label |= Integer.MIN_VALUE;</span><br><span class="line">        userInfo = <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0.</span>getUserInfo(<span class="literal">null</span>, (Continuation) <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，针对这两个挂起方法，编译器为其分别产生了一个中间类，从中间类的命名也可以分辨出来是哪个方法。这两个中间类逻辑都差不多：</p>
<p>1、都是直接继承自 ContinuationImpl 的，而不是像之前的继承自 SuspendLambda，因为它并不是一个 suspend lambda 的。当然同时会实现其中的 invokeSuspend 方法，将这俩挂起方法内部的实际逻辑填充到该方法里面去用于后续执行。</p>
<p>2、这俩类都是会持有 Demo01 类对象实例，后续在执行其 invokeSuspend 方法时，会调用到 Demo01 对象实例中的具体方法。</p>
<p>接下来来看看 Demo01 类是什么：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以看到，将原来的 getUserId 无参方法变成了一个入参Continuation 的方法，并且返回值从 String 改为了 Object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> java.lang.Object getUserId(kotlin.coroutines.Continuation&lt;? <span class="keyword">super</span> java.lang.String&gt; var1) &#123;</span><br><span class="line">        Object $continuation;</span><br><span class="line">        label20: &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 从 Demo01$test$1 # invokeSuspend 中调用过来时:</span></span><br><span class="line"><span class="comment">             * -  var1 = Demo01$test$1 实例</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 从 Demo01$getUserId$1 # invokeSuspend 方法调用过来时:</span></span><br><span class="line"><span class="comment">             * -  var1 = Demo01$getUserId$1 实例</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (var1 instanceof Demo01$getUserId$<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 看这里就行了，下面的if可以不用管，基本都满足，详见Demo01$getUserId$1#invokeSuspend</span></span><br><span class="line"><span class="comment">                 * 所以这里将入参 var1 保存给 $continuation 并且终止 label20 代码块的执行</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                $continuation = (Demo01$getUserId$<span class="number">1</span>) var1;</span><br><span class="line">                <span class="keyword">if</span> ((((Demo01$getUserId$<span class="number">1</span>) $continuation).label &amp; Integer.MIN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">                    ((Demo01$getUserId$<span class="number">1</span>) $continuation).label -= Integer.MIN_VALUE;</span><br><span class="line">                    <span class="keyword">break</span> label20;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果入参 var1 不是 Demo01$getUserId$1 实例，则新建一个 Demo01$getUserId$1 实例</span></span><br><span class="line"><span class="comment">             * 并且将当前Demo01实例 this 和 入参 var1 传入，保存在 Demo01$getUserId$1 中</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 所以结合上面的 instanceof 可以知道： Demo01$getUserId$1 只会存在一个实例</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 将入参 Demo01$test$1 保存到新创建的 Demo01$getUserId$1 实例内部，</span></span><br><span class="line"><span class="comment">             * 而因为 Demo01$getUserId$1 继承自 ContinuationImpl ，所以 Demo01$test$1 其实就会被保</span></span><br><span class="line"><span class="comment">             * 存到 BaseContinuationImpl 中的 completion 。后续等执行到其 resumeWith 方法时就可以了</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 所以总的来说：$continuation 一定是一个Demo01$getUserId$1 实例，其内部包装了：Demo01实例和Demo01$test$1实例</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            $continuation = new Demo01$getUserId$<span class="number">1</span>(Demo01.<span class="keyword">this</span>, var1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Object $result = ((Demo01$getUserId$<span class="number">1</span>) $continuation).result;</span><br><span class="line">        Object var4 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 拿到 $continuation 对象内部的 label ，刚开始默认是 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        switch (((Demo01$getUserId$<span class="number">1</span>) $continuation).label) &#123;</span><br><span class="line">            case <span class="number">0</span>:</span><br><span class="line">                ResultKt.throwOnFailure($result);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 将其改为 1</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ((Demo01$getUserId$<span class="number">1</span>) $continuation).label = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 执行 getUserId 中的 delay(1000) 的逻辑，内部会返回 COROUTINE_SUSPENDED</span></span><br><span class="line"><span class="comment">                 * 也就是会挂起，此时会直接 return 掉</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 注意这里将 $continuation 传递到 delay 中了，内部会等 1000ms 之后再次执行这个 $continuation的 resumeWith 方法</span></span><br><span class="line"><span class="comment">                 * 也就是执行 Demo01$getUserId$1 的 invokeSusupend 方法，会再次执行到当前方法内来</span></span><br><span class="line"><span class="comment">                 * 此时入参 var1 就是 Demo01$getUserId$1 实例了，再次取出其中的label 此时等于1</span></span><br><span class="line"><span class="comment">                 * 会执行到下面的 case 1 ，没有异常的话就到最后返回 &quot;&quot;youngkaaa &quot;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000L</span>, (Continuation) $continuation) == var4) &#123;</span><br><span class="line">                    <span class="keyword">return</span> var4;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            case <span class="number">1</span>:</span><br><span class="line">                ResultKt.throwOnFailure($result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到最后，返回&quot;youngkaaa&quot;</span></span><br><span class="line"><span class="comment">         * 但是此时当前 Demo01$getUserId$1 内部的 Continuation 封装的是 Demo01$test$1 实例</span></span><br><span class="line"><span class="comment">         * 所以在 BaseContinuationImpl 中的 resumeWith 方法中，就会执行其内部的 completion 的 invokeSuspend 方法</span></span><br><span class="line"><span class="comment">         * 也就是执行 Demo01$test$1 的 invokeSuspend 方法。从而实现对 Demo01$test$1 的恢复执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;youngkaaa&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> java.lang.Object getUserInfo(java.lang.String userId, kotlin.coroutines.Continuation&lt;? <span class="keyword">super</span> java.lang.String&gt; var2) &#123;</span><br><span class="line">        Object $continuation;</span><br><span class="line">        label20: &#123;</span><br><span class="line">            <span class="keyword">if</span> (var2 instanceof Demo01$getUserInfo$<span class="number">1</span>) &#123;</span><br><span class="line">                $continuation = (Demo01$getUserInfo$<span class="number">1</span>) var2;</span><br><span class="line">                <span class="keyword">if</span> ((((Demo01$getUserInfo$<span class="number">1</span>) $continuation).label &amp; Integer.MIN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">                    ((Demo01$getUserInfo$<span class="number">1</span>) $continuation).label -= Integer.MIN_VALUE;</span><br><span class="line">                    <span class="keyword">break</span> label20;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $continuation = new Demo01$getUserInfo$<span class="number">1</span>(Demo01.<span class="keyword">this</span>, var2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object $result = ((Demo01$getUserInfo$<span class="number">1</span>) $continuation).result;</span><br><span class="line">        Object var5 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">        switch (((Demo01$getUserInfo$<span class="number">1</span>) $continuation).label) &#123;</span><br><span class="line">            case <span class="number">0</span>:</span><br><span class="line">                ResultKt.throwOnFailure($result);</span><br><span class="line">                ((Demo01$getUserInfo$<span class="number">1</span>) $continuation).L$<span class="number">0</span> = userId;</span><br><span class="line">                ((Demo01$getUserInfo$<span class="number">1</span>) $continuation).label = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (DelayKt.delay(<span class="number">1000L</span>, (Continuation) $continuation) == var5) &#123;</span><br><span class="line">                    <span class="keyword">return</span> var5;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            case <span class="number">1</span>:</span><br><span class="line">                userId = (String) ((Demo01$getUserInfo$<span class="number">1</span>) $continuation).L$<span class="number">0</span>;</span><br><span class="line">                ResultKt.throwOnFailure($result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userId + <span class="string">&quot;&#x27;s info&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> void test() &#123;</span><br><span class="line">        BuildersKt.launch$default(GlobalScope.INSTANCE, (CoroutineContext) <span class="literal">null</span>, (CoroutineStart) <span class="literal">null</span>, new Demo01$test$<span class="number">1</span>(<span class="keyword">this</span>, (Continuation) <span class="literal">null</span>),<span class="number">3</span>, (Object) <span class="literal">null</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2500L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，编译之后，CPS转换之后会自动为该方法末尾增加 Continuation 入参。此时接着看最后一个class文件的内容：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo01$test$1.class </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Demo01</span>$<span class="title">test</span>$1 <span class="title">extends</span> <span class="title">SuspendLambda</span> <span class="title">implements</span> <span class="title">Function2</span>&lt;<span class="type">CoroutineScope, Continuation&lt;? super Unit</span>&gt;, <span class="type">Object&gt;</span> &#123;</span><br><span class="line">    int label;</span><br><span class="line">    <span class="keyword">final</span> <span class="comment">/* synthetic */</span> Demo01 <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* JADX WARN: &#x27;super&#x27; call moved to the top of the method (can break code semantics) */</span></span><br><span class="line">    Demo01$test$<span class="number">1</span>(Demo01 $receiver, Continuation&lt;? <span class="keyword">super</span> Demo01$test$<span class="number">1</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">2</span>, continuation);</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = $receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 [createCoroutineUnintercepted] 方法中通过 suspend lambda 语句创建一个 Continuation 实例时会调用到这里</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里传入的第一个参数是：value = StandaloneCoroutine ，</span></span><br><span class="line"><span class="comment">     * 第二个参数也可以理解为是 StandaloneCoroutine</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 然后这里会将第二个入参 continuation = StandaloneCoroutine 传递到 Demo01$test$1 构造方法中，</span></span><br><span class="line"><span class="comment">     * 最终保存到 BaseContinuationImpl 中的 completion 属性中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这个作为最顶层的 continuation 实例，在 BaseContinuationImpl#resumeWith 方法中会用到</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Continuation&lt;<span class="built_in">Unit</span>&gt; create(<span class="meta">@Nullable</span> Object value, <span class="meta">@NotNull</span> Continuation&lt;?&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">return</span> new Demo01$test$<span class="number">1</span>(<span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span>, continuation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object invoke(<span class="meta">@NotNull</span> CoroutineScope p1, <span class="meta">@Nullable</span> Continuation&lt;? <span class="keyword">super</span> <span class="built_in">Unit</span>&gt; continuation) &#123;</span><br><span class="line">        <span class="keyword">return</span> create(p1, continuation).invokeSuspend(<span class="built_in">Unit</span>.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.jetbrains.annotations.Nullable</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> java.lang.Object invokeSuspend(<span class="meta">@org</span>.jetbrains.annotations.NotNull java.lang.Object $result) &#123;</span><br><span class="line">        Object var10000;</span><br><span class="line">        label17: &#123;</span><br><span class="line">            Object var5 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">            Demo01 var6;</span><br><span class="line">            switch (<span class="keyword">this</span>.label) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 第一次时，label为默认值 0</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                case <span class="number">0</span>:</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    var6 = Demo01.<span class="keyword">this</span>;</span><br><span class="line">                    <span class="keyword">this</span>.label = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 调用到当前 Demo01 类实例中的 getUserId 方法，将当前 Demo01$test$1 实例传递进去</span></span><br><span class="line"><span class="comment">                     * 而当前 Demo01$test$1 继承自 SuspendLambda，也就是继承自 Continuation</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    var10000 = var6.getUserId(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (var10000 == var5) &#123;</span><br><span class="line">                        <span class="keyword">return</span> var5;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                case <span class="number">1</span>:</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    var10000 = $result;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                case <span class="number">2</span>:</span><br><span class="line">                    ResultKt.throwOnFailure($result);</span><br><span class="line">                    var10000 = $result;</span><br><span class="line">                    <span class="keyword">break</span> label17;</span><br><span class="line">                default:</span><br><span class="line">                    <span class="keyword">throw</span> new IllegalStateException(<span class="string">&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String userId = (String) var10000;</span><br><span class="line">            var6 = Demo01.<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.label = <span class="number">2</span>;</span><br><span class="line">            var10000 = var6.getUserInfo(userId, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (var10000 == var5) &#123;</span><br><span class="line">                <span class="keyword">return</span> var5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String userInfo = (String) var10000;</span><br><span class="line">        boolean var4 = <span class="literal">false</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(userInfo);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Unit</span>.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意此时为 test 方法中launch内的suspend lambda生成的类叫：<code>Demo01$test$1</code>。该类是继承自 SuspendLambda 的，这个类会被创建两次：</p>
<p>1、第一次是在上面的Demo01.class文件中的 test() 方法内，此时传入的receiver是Demo01.this 对象实例自身，第二个参数 continuation仍旧是null</p>
<p>2、第二次是在launch时，最终调用 create 方法将创建的 StandaloneCoroutine 当做 Continuation 传入进来保存起来</p>
<p>这两点在前前文都有说过了。</p>
<p>到此所有的class 文件都看完了。而在这个场景下，编译器一共生成了三个对象实例，他们三个的关系如下：</p>
<p><img src="/e2cf098c/pic_01.png" alt="pic01"></p>
<p>即：</p>
<p>1、为launch方法的 suspend lambda 生成的 <code>Demo01$test$1</code>类继承自 SuspendLambda ，内部持有的 completion &#x3D; StandaloneCoroutine，而这个StandaloneCoroutine 实例就是在 launch 中新创建的那个实例。</p>
<p>而在其实现的 invokeSuspend 方法中包括了 test()方法的launch 方法内的逻辑。</p>
<p>2、为 getUserId方法生成的 <code>Demo01$getUserId$1</code>类继承自 ContinuationImpl 。它的全局唯一对象实例是在 Demo01.class 内的 getUserId 方法内被创建的，</p>
<p>而getUserId()该方法最初是被<code>Demo01$test$1</code>类的 invokeSuspend() 方法调用并且传入了<code>Demo01$test$1.this</code> 。所以这里创建的<code>Demo01$getUserId$1</code>唯一对象实例内部的 completion &#x3D; <code>Demo01$test$1</code>类实例。</p>
<p>3、为 getUserInfo 方法生成的 <code>Demo01$getUserInfo$1</code>类继承自 ContinuationImpl 。它的全局唯一对象实例是在 Demo01.class 内的 getUserInfo 方法内被创建的，</p>
<p>而 getUserInfo()该方法最初是被<code>Demo01$test$1</code>类的 invokeSuspend() 方法调用并且传入了<code>Demo01$test$1.this</code> 。所以这里创建的<code>Demo01$getUserInfo$1</code>唯一对象实例内部的 completion &#x3D; <code>Demo01$test$1</code>类实例。</p>
<p>那么在launch方法执行之后，</p>
<p>1、不久之后<code>Demo01$test$1</code>类的 resumeWith 方法，也就是其 invokeSuspend 方法会在合适的 Dispatchers 线程内被调用(详见前文)</p>
<p>2、<code>Demo01$test$1</code>类的 invokeSuspend() 方法执行 case 0 的部分：先将label置为1，然后调用 Demo01 对象中的 getUserId() 方法，将 <code>Demo01$test$1</code>类实例传入其中</p>
<p>3、Demo01 对象中的 getUserId() 方法内，先判断入参 var1 不是</p>
<p><code>Demo01$getUserId$1</code> ，则会创建一个新的 <code>Demo01$getUserId$1</code>实例，并且将 Demo01 对象实例和 <code>Demo01$test$1</code>类实例保存起来。所以此时<code>Demo01$getUserId$1</code>实例中的 completion &#x3D; <code>Demo01$test$1</code>类实例。然后接着往下执行，拿到新创建的<code>Demo01$getUserId$1</code>实例中的 result (此时是默认值null)和 label (此时是默认值0)。</p>
<p>接着执行 Demo01 对象中的 getUserId() 方法内 case 0 部分逻辑，即先将<code>Demo01$getUserId$1</code>实例的label改为1，在调用 delay方法来挂起当前方法。注意此时传给delay的continuation是<code>Demo01$getUserId$1</code>实例哦，这个下一步要用。</p>
<p>4、等1000ms之后，delay完成后，会执行该 continuation入参的resumeWith() 也就是其 invokeSuspend() 方法，其实也就是<code>Demo01$getUserId$1</code>实例的 invokeSuspend 方法。此时在其 invokeSuspend 方法中会又调用回 Demo01 对象中的 getUserId() 方法内。注意此时传给 getUserId() 方法的入参是 this， 也就是 <code>Demo01$getUserId$1</code>实例自身。</p>
<p>5、又回到Demo01 对象中的 getUserId() 方法内，此时入参是 <code>Demo01$getUserId$1</code>实例，那么instanceof成立且其内部的if条件（ label &amp; Integer.MIN_VALUE ）也成立，那么此时直接复用入参 var1 。然后读取出其内部的 result （还是 null ），label &#x3D;1 （上面第3步修改的），判断没有异常则执行到最后返回”youngkaaa”。</p>
<p>到这里挂起方法 getUserId() 内的逻辑执行完毕了，会接着回到<code>Demo01$getUserId$1</code> 的 resumeWith 方法内：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ContinuationImpl.kt</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseContinuationImpl</span>(</span><br><span class="line">    <span class="comment">// This is `public val` so that it is private on JVM and cannot be modified by untrusted code, yet</span></span><br><span class="line">    <span class="comment">// it has a public getter (since even untrusted code is allowed to inspect its call stack).</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;</span><br><span class="line">    <span class="comment">// This implementation is final. This fact is used to unroll resumeWith recursion.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume</span></span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> param = result</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Invoke &quot;resume&quot; debug probe on every resumed continuation, so that a debugging library infrastructure</span></span><br><span class="line">            <span class="comment">// can precisely track what part of suspended callstack was already resumed</span></span><br><span class="line">            probeCoroutineResumed(current)</span><br><span class="line">            with(current) &#123;</span><br><span class="line">                <span class="keyword">val</span> completion = completion!! <span class="comment">// fail fast when trying to resume continuation without completion</span></span><br><span class="line">                <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                        <span class="comment">// 标记点1</span></span><br><span class="line">                        <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                        Result.success(outcome)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                        Result.failure(exception)</span><br><span class="line">                    &#125;</span><br><span class="line">                releaseIntercepted() <span class="comment">// this state machine instance is terminating</span></span><br><span class="line">                <span class="comment">// 标记点2</span></span><br><span class="line">                <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                    <span class="comment">// 标记点3</span></span><br><span class="line">                    <span class="comment">// unrolling recursion via loop</span></span><br><span class="line">                    current = completion</span><br><span class="line">                    param = outcome</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// top-level completion reached -- invoke and return</span></span><br><span class="line">                    <span class="comment">// 标记点4</span></span><br><span class="line">                    completion.resumeWith(outcome)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时相当于执行到了上面代码中的 <code>标记点1</code> 处。由于返回结果是”youngkaaa”，所以不会return 从而执行到<code>标记点2</code>处。</p>
<p>而此时 this 是 <code>Demo01$getUserId$1</code>，其内部的 completion 是 <code>Demo01$test$1</code>类实例，它是继承自 SuspemdLambda 的，所以执行到<code>标记点3</code>处，将内部的current 置为 <code>Demo01$test$1</code>类实例，将 param 置为 “youngkaaa”。然后开始下一次循环，此时会执行 <code>Demo01$test$1</code>类的 invokeSuspend 方法内。这一流程就相当于 getUserId() 挂起方法执行完毕了。</p>
<p>6、回到 <code>Demo01$test$1</code>类的 invokeSuspend 方法内，此时入参result 是 “youngkaaa” ，label &#x3D;1 （上面第2步中修改的）。所以执行 case 1，没有异常 break 掉执行到后面，此时将入参 result 保存到 String userId 中，然后将 label 置为2，再去调用 getUserInfo 方法，并且将 <code>Demo01$test$1</code>类实例传入其中。</p>
<p>7、接下来就到了 Demo01 对象中的 getUserInfo() 方法内。剩下的逻辑同上面的 3、4、5。</p>
<p>8、最后执行完 getUserInfo() 方法之后会再次回到 <code>Demo01$test$1</code>类的 invokeSuspend 方法内。此时result &#x3D; “youngkaaa’s info”，label&#x3D;2，再次判断result没有异常则break掉，回到最外部将result保存到 String userInfo 中然后打印输出出来。</p>
<p>9、此时 <code>Demo01$test$1</code>类的 invokeSuspend 方法执行完毕，回到 <code>Demo01$test$1</code>类的 resumeWith 方法内，如上面代码所示，会最终执行到 <code>标记点4</code>，因为<code>Demo01$test$1</code>类中的 completion 是 StandaloneCoroutine ，它是继承自 Continuation 的，而不是 BaseContinuationImpl ，此时调用到 StandaloneCoroutine.resumeWith 方法内完整协程整体的收尾工作。</p>
<p>当然执行到这里就表示协程执行完毕了。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Kotlin-Coroutine/">Kotlin Coroutine</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/ff74222f.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Kotlin协程 - 拦截器原理</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/b72a4fb1.html">
        <span class="next-text nav-default">Kotlin协程 - 协程启动原理</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
