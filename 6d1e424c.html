<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Jetpack- ViewModel"/>




  <meta name="keywords" content="Jetpack," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/6d1e424c.html"/>


<meta name="description" content="ViewModel 是 Android 新架构模式：MVVM 中很重要的一部分。它的目的是封装页面状态，以及一些业务逻辑方法。优点是可以缓存状态，当页面Activity发生配置变化等操作时数据可以保存下来。 对它的更多解释和使用方法详见官方：https:&#x2F;&#x2F;developer.android.com&#x2F;topic&#x2F;libraries&#x2F;architecture&#x2F;viewmodel 关键类介绍ViewM">
<meta property="og:type" content="article">
<meta property="og:title" content="Jetpack- ViewModel">
<meta property="og:url" content="https://youngkaaa.github.io/6d1e424c.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="ViewModel 是 Android 新架构模式：MVVM 中很重要的一部分。它的目的是封装页面状态，以及一些业务逻辑方法。优点是可以缓存状态，当页面Activity发生配置变化等操作时数据可以保存下来。 对它的更多解释和使用方法详见官方：https:&#x2F;&#x2F;developer.android.com&#x2F;topic&#x2F;libraries&#x2F;architecture&#x2F;viewmodel 关键类介绍ViewM">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-02T02:48:56.000Z">
<meta property="article:modified_time" content="2023-01-06T13:10:52.779Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Jetpack">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Jetpack- ViewModel - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Jetpack- ViewModel
        
      </h1>

      <time class="post-time">
          7月 02 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>ViewModel 是 Android 新架构模式：MVVM 中很重要的一部分。它的目的是封装页面状态，以及一些业务逻辑方法。优点是可以缓存状态，当页面Activity发生配置变化等操作时数据可以保存下来。</p>
<p>对它的更多解释和使用方法详见官方：<a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/architecture/viewmodel">https://developer.android.com/topic/libraries/architecture/viewmodel</a></p>
<h3 id="关键类介绍"><a href="#关键类介绍" class="headerlink" title="关键类介绍"></a>关键类介绍</h3><h4 id="ViewModelStoreOwner"><a href="#ViewModelStoreOwner" class="headerlink" title="ViewModelStoreOwner"></a>ViewModelStoreOwner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewModelStoreOwner</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns owned &#123;<span class="doctag">@link</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是一个接口，只提供一个 getViewModelStore() 方法，返回一个非空的 ViewModelStore 实例。</p>
<blockquote>
<p>看到这个接口的命名，以及其内部的方法定义，是否觉得很熟悉呢？前面的 Lifecycle 分析中也有类似的：LifecycleOwner 接口，提供一个 getLifecycle() 方法返回一个Lifecycle 实例。其实类似的接口类还有好几个，详见 ComponentActivity 类头的实现关系。</p>
</blockquote>
<h4 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往mMap 中放入对应的 ViewModel。如果该key之前存在ViewModel的话，就调用其 onCleard()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> viewModel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, ViewModel viewModel)</span> &#123;</span><br><span class="line">        <span class="type">ViewModel</span> <span class="variable">oldViewModel</span> <span class="operator">=</span> mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewModel <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 遍历内部所有的 ViewMode，然后挨个调用其 clear 方法</span></span><br><span class="line"><span class="comment">     * ViewMode # clear</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类的定义也很简单，内部就封装了一个 <code>HashMap&lt;String,ViewModel&gt;</code> 列表，可以支持通知存储多个 ViewModel 实例，不同的ViewModel使用不同的String key 来获取。</p>
<p>并且额外的提供了 put() , get() , clear() 方法。</p>
<p>调用 put() 时，如果要put的key对应已经存在对应的ViewModel 了，那么将新的放入，旧的调用 onCleared() 方法来通知清除，表示该ViewModel不再被ViewModelStore 保存了；</p>
<p>调用 clear() 时，会遍历其内部所有的 ViewModel 并挨个调用其 clear() 方法。</p>
<h4 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="comment">// Can&#x27;t use ConcurrentHashMap, because it can lose values on old apis (see b/37042460)</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; mBagOfTags = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">mCleared</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method will be called when this ViewModel is no longer used and will be destroyed.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * It is useful when ViewModel observes some data and you need to clear this subscription to</span></span><br><span class="line"><span class="comment">     * prevent a leak of this ViewModel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCleared</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        mCleared = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// Since clear() is final, this method is still called on mock objects</span></span><br><span class="line">        <span class="comment">// and in those cases, mBagOfTags is null. It&#x27;ll always be empty though</span></span><br><span class="line">        <span class="comment">// because setTagIfAbsent and getTag are not final so we can skip</span></span><br><span class="line">        <span class="comment">// clearing it</span></span><br><span class="line">        <span class="keyword">if</span> (mBagOfTags != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object value : mBagOfTags.values()) &#123;</span><br><span class="line">                    <span class="comment">// see comment for the similar call in setTagIfAbsent</span></span><br><span class="line">                    closeWithRuntimeException(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onCleared();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets a tag associated with this viewmodel and a key.</span></span><br><span class="line"><span class="comment">     * If the given &#123;<span class="doctag">@code</span> newValue&#125; is &#123;<span class="doctag">@link</span> Closeable&#125;,</span></span><br><span class="line"><span class="comment">     * it will be closed once &#123;<span class="doctag">@link</span> #clear()&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If a value was already set for the given key, this call does nothing and</span></span><br><span class="line"><span class="comment">     * returns currently associated value, the given &#123;<span class="doctag">@code</span> newValue&#125; would be ignored</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If the ViewModel was already cleared then close() would be called on the returned object if</span></span><br><span class="line"><span class="comment">     * it implements &#123;<span class="doctag">@link</span> Closeable&#125;. The same object may receive multiple close calls, so method</span></span><br><span class="line"><span class="comment">     * should be idempotent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">setTagIfAbsent</span><span class="params">(String key, T newValue)</span> &#123;</span><br><span class="line">        T previous;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">            previous = (T) mBagOfTags.get(key);</span><br><span class="line">            <span class="keyword">if</span> (previous == <span class="literal">null</span>) &#123;</span><br><span class="line">                mBagOfTags.put(key, newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> previous == <span class="literal">null</span> ? newValue : previous;</span><br><span class="line">        <span class="keyword">if</span> (mCleared) &#123;</span><br><span class="line">            <span class="comment">// It is possible that we&#x27;ll call close() multiple times on the same object, but</span></span><br><span class="line">            <span class="comment">// Closeable interface requires close method to be idempotent:</span></span><br><span class="line">            <span class="comment">// &quot;if the stream is already closed then invoking this method has no effect.&quot; (c)</span></span><br><span class="line">            closeWithRuntimeException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the tag associated with this viewmodel and the specified key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;TypeParameterUnusedInFormals&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">getTag</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mBagOfTags == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) mBagOfTags.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeWithRuntimeException</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Closeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Closeable) obj).close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ViewModel 类是一个抽象类，但是其内部并没有必须要子类实现的抽象方法，唯一子类可以实现的就是 onClear() 方法。</p>
<p>其中定义了如下的属性和方法：</p>
<p>1、Map&lt;String,Object&gt; mBagOfTags：用来储存一些额外的数据，这个开发者不需要关注，这是官方给其后续扩充能力所留下的，比如 viewModelScope 协程域就存储在这个里面，后续会被 close() 掉，从而取消掉该协程域内的所有协程任务。</p>
<p>2、onCleared() : 该方法表示该 ViewModel 不再被 ViewModelStore 存储，或者存储该 ViewModel 的 Owner 被销毁了。子类可以实现该方法来完成一些数据资源的清理释放。</p>
<p>3、clear()、setTagIfAbsent() 、getTag() ：这几个方法都是操作 mBagOfTags 的，比如 clear 会通过  closeWithRuntimeException() 方法挨个释放 mBagOfTags 中的Value对象；setTagIfAbsent() 用来往 mBagOfTags 中存储数据；getTag() 用来从 mBagOfTags 中取数据。这三个方法都是外部不可访问的，仅供同一个包内访问。所以这些对外部开发者来说，基本不用考虑。</p>
<p>所以说这三个类的关系是：ViewModelStoreOwner 中持有（包括）ViewModelStore 实例并返回供外部使用；ViewModelStore 中存储着若干ViewModel 实例；ViewModel 中存储着开发者定义的若干属性实例。</p>
<h3 id="ViewModel-for-Activity"><a href="#ViewModel-for-Activity" class="headerlink" title="ViewModel for Activity"></a>ViewModel for Activity</h3><p>还是从 ComponentActivity 来开始分析，它实现了 ViewModelStoreOwner 接口。</p>
<blockquote>
<p>ComponentActivity 在前面 Lifecycle 中已经分析过了，这里不再赘述。</p>
</blockquote>
<p>先看 ComponentActivity 是怎么实现的该接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentActivity</span> <span class="keyword">extends</span> <span class="title class_">androidx</span>.core.app.ComponentActivity <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ContextAware</span>,</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        HasDefaultViewModelProviderFactory,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner,</span><br><span class="line">        ActivityResultRegistryOwner,</span><br><span class="line">        ActivityResultCaller,</span><br><span class="line">        MenuHost &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ViewModelStore 其实就是包装了了一个HashMap，暴露put方法，可以理解为一个HashMap&lt;String,ViewModel&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ViewModelStore mViewModelStore;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureViewModelStore();</span><br><span class="line">        <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span> <span class="comment">/* synthetic access */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ensureViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Activity # getLastNonConfigurationInstance() 方法</span></span><br><span class="line"><span class="comment">             * getLastNonConfigurationInstance 和 onRetainNonConfigurationInstance 方法搭配使用，后者保存，前者获取</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 和 onSaveInstanceState 与 onRestoreInstanceState 组合也是类似的。</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 不同的是，getLastNonConfigurationInstance 组合是返回 Object，适合一些不方便的，比如 Bitmap，或者 Socket链接等</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span> (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果上次保存了，那么就拿到上次保存的 ViewModel</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class="line">                mViewModelStore = nc.viewModelStore;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果上次没有保存，那么就新建一个吧</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (mViewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">                mViewModelStore = <span class="keyword">new</span> <span class="title class_">ViewModelStore</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">onRetainNonConfigurationInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Maintain backward compatibility.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 由于这里把 onRetainNonConfigurationInstance 方法变成了final，所以后续继承的Activity都没法使用这个方法了，所以这里当初应</span></span><br><span class="line"><span class="comment">         * 该是考虑到了后续继承的Activity使用，所以新建了这个方法，使得后续Activity可以使用该方法来保存</span></span><br><span class="line"><span class="comment">         * 该方法目前已被废弃，可以直接把要保存的数据放在ViewModel里就行了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">custom</span> <span class="operator">=</span> onRetainCustomNonConfigurationInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">ViewModelStore</span> <span class="variable">viewModelStore</span> <span class="operator">=</span> mViewModelStore;</span><br><span class="line">        <span class="comment">// 当前mViewModelStore=null，表示没有调用过 getViewModelStore() 方法</span></span><br><span class="line">        <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No one called getViewModelStore(), so see if there was an existing</span></span><br><span class="line">            <span class="comment">// ViewModelStore from our last NonConfigurationInstance</span></span><br><span class="line">            <span class="comment">// 此时 getLastNonConfigurationInstance 方法来看看之前有无保存的ViewModel</span></span><br><span class="line">            <span class="type">NonConfigurationInstances</span> <span class="variable">nc</span> <span class="operator">=</span> (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">            <span class="keyword">if</span> (nc != <span class="literal">null</span>) &#123;</span><br><span class="line">                viewModelStore = nc.viewModelStore;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里viewModelStore还是null的话，表示当前确实没有东西要保存，所以直接返回吧</span></span><br><span class="line">        <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span> &amp;&amp; custom == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 新建一个 NonConfigurationInstances，将viewModel这些保存起来。</span></span><br><span class="line"><span class="comment">         * 而 viewModelStore 其实就是一个 HashMap 里面存的是 ViewModel。也就是将当前 Activity 中的 ViewModel 那些保存起来</span></span><br><span class="line"><span class="comment">         * 等下次 Activity 重建时再将其恢复。注意这里说的保存恢复不牵扯序列化持久化那些，是同一个对象的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">NonConfigurationInstances</span> <span class="variable">nci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonConfigurationInstances</span>();</span><br><span class="line">        nci.custom = custom;</span><br><span class="line">        nci.viewModelStore = viewModelStore;</span><br><span class="line">        <span class="keyword">return</span> nci;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，对于 mViewModeStore 的获取是懒加载方式，即用到的时候再去初始化。</p>
<p>初始化它使用的是 ensureViewModelStore() 方法。在该方法中会首先判断 mViewModeStore 是否为空，为空则先从：Activity.getLastNonConfigurationInstance()方法中获取上一次保存的对象实例。如果上次没有保存则获取到的值是 null ，则此时会 new 创建一个 ViewModelStore 实例。</p>
<p>逻辑是比较简单的，但是此时这里多出了一个陌生的方法：Activity.getLastNonConfigurationInstance() 。该方法属于 Activity 类，和它相关的还有一个方法：onRetainNonConfigurationInstance()，该方法返回一个Object 。</p>
<p>这俩方法都很陌生，基本都没咋用过。但是我要是说另外一对方法的话，肯定就会熟悉些了：onSaveInstanceState() 和 onRestoreInstanceState() 。这俩方法一般用于在Activity页面异常销毁比如内存不足时的数据存储持久化工作，操作的都是 Bundle 对象。</p>
<p>而 getLastNonConfigurationInstance() 、 onRetainNonConfigurationInstance() 方法操作的对象都是 Object 。和上面方法类似的使用场景：在 Configuration Change 导致的 Activity 销毁时，会先调用 onRetainNonConfigurationInstance 然后返回一个要保存的对象实例，后面等 Activity 重建时，就可以通过 getLastNonConfigurationInstance 来拿到上次保存的对象实例。</p>
<p>而这两对方法还有其他区别嘛？</p>
<p>1、颗粒度不一样。onSaveInstanceState()是保存到Bundle中，只能保存Bundle能接受的数据类型，比如一些基本类型的数据。而onRetainNonConfigurationInstance()可以保存任何类型的数据，数据类型是Object</p>
<p>2、onSaveInstanceState()数据最终存储到ActivityManagerService的ActivityRecord中了，也就是存到AMS进程中去了。而 onRetainNonConfigurationInstance() 数据是存储到ActivityClientRecord中，也就是存到应用本身的进程中了</p>
<p>3、onSaveInstanceState存到系统进程中，所以App被杀之后还是能恢复的。而onRetainNonConfigurationInstance存到本身进程中，App被杀是没法恢复的。</p>
<p>这样的话，利用 getLastNonConfigurationInstance() 、 onRetainNonConfigurationInstance() 方法就完成了对 ViewModelStore 的保存和恢复。后续只需要拿到这个 ViewModelStore 实例，就可以拿到内部的 ViewModel 了。</p>
<p>额外的，还有ViewModel 的清理逻辑，在 ComponentActivity 的构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ComponentActivity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Lifecycle</span> <span class="variable">lifecycle</span> <span class="operator">=</span> getLifecycle();</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加生命周期检测，如果是ondestroy的话，那么就调用 ViewModelStore # clear 方法来清空内部所有的ViewModel</span></span><br><span class="line"><span class="comment">     * 具体通过调用内部每个 ViewModel # clear 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                <span class="comment">// Clear out the available context</span></span><br><span class="line">                mContextAwareHelper.clearAvailableContext();</span><br><span class="line">                <span class="comment">// And clear the ViewModelStore</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果是由于 configuration change 导致的 destroy 则不会清空 viewModel</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                    getViewModelStore().clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里还加了一个兜底，如果生命周期有发生变化，则初始化 ViewModelStore</span></span><br><span class="line"><span class="comment">     * 当然初始化 ViewModelStore 是只需要一次即可，所以回调过一次之后就会 remove 掉观察者</span></span><br><span class="line"><span class="comment">     * 所以 mViewModelStore 也不算是完全的懒加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getLifecycle().addObserver(<span class="keyword">new</span> <span class="title class_">LifecycleEventObserver</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> &#123;</span><br><span class="line">            ensureViewModelStore();</span><br><span class="line">            getLifecycle().removeObserver(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 ComponentActivity 的构造方法中，一开始就会注册Lifecycle 生命周期监听，等当前Activity的生命周期到了 ON_DESTROY (除去configuration change引起的)时，就会调用 ViewModelStore.clear() 方法，该方法内部会执行ViewModel的清理工作。</p>
<p>所以说，ComponentActivity 或者说是常用的 Activity ，当它被调用 onDestroy() 即将销毁时，其内部的 ViewModelStore 中的ViewModel就会被回收清理。当然这一切都是现成做好的，开发者只需要正常使用就行了，不需要关注这些。</p>
<h3 id="ViewModel-for-Fragment"><a href="#ViewModel-for-Fragment" class="headerlink" title="ViewModel for Fragment"></a>ViewModel for Fragment</h3><p>同样的，不止是 Activity(更准确来说是继承自 ComponentActivity的那些Activity子类们) 中存在ViewModel，对于Fragment 官方也做了支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.fragment.app.Fragment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fragment</span> <span class="keyword">implements</span> <span class="title class_">ComponentCallbacks</span>, OnCreateContextMenuListener, LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner,</span><br><span class="line">        ActivityResultCaller &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFragmentManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t access ViewModels from detached fragment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getMinimumMaxLifecycleState() == Lifecycle.State.INITIALIZED.ordinal()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Calling getViewModelStore() before a Fragment &quot;</span></span><br><span class="line">                    + <span class="string">&quot;reaches onCreate() when using setMaxLifecycle(INITIALIZED) is not &quot;</span></span><br><span class="line">                    + <span class="string">&quot;supported&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mFragmentManager.getViewModelStore(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFragmentManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t access ViewModels from detached fragment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mDefaultFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Application</span> <span class="variable">application</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">appContext</span> <span class="operator">=</span> requireContext().getApplicationContext();</span><br><span class="line">            <span class="keyword">while</span> (appContext <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">                <span class="keyword">if</span> (appContext <span class="keyword">instanceof</span> Application) &#123;</span><br><span class="line">                    application = (Application) appContext;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                appContext = ((ContextWrapper) appContext).getBaseContext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (application == <span class="literal">null</span> &amp;&amp; FragmentManager.isLoggingEnabled(Log.DEBUG)) &#123;</span><br><span class="line">                Log.d(FragmentManager.TAG, <span class="string">&quot;Could not find Application instance from &quot;</span></span><br><span class="line">                        + <span class="string">&quot;Context &quot;</span> + requireContext().getApplicationContext() + <span class="string">&quot;, you will &quot;</span></span><br><span class="line">                        + <span class="string">&quot;not be able to use AndroidViewModel with the default &quot;</span></span><br><span class="line">                        + <span class="string">&quot;ViewModelProvider.Factory&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mDefaultFactory = <span class="keyword">new</span> <span class="title class_">SavedStateViewModelFactory</span>(</span><br><span class="line">                    application,</span><br><span class="line">                    <span class="built_in">this</span>,</span><br><span class="line">                    getArguments());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对于 Fragment 也实现了 ViewModelOwner 和 HasDefaultViewModelProviderFactory 接口。</p>
<p>在其 getViewModelStore() 方法实现中，主要将逻辑甩给了其内部的 FragmentManager 。</p>
<p>在其getDefaultViewModelProviderFactory() 方法中，最终使用的还是 SavedStateViewModelFactory ，和 ComponentActivity 是一样的，后面会分析该类。</p>
<p>接着看FragmentManager 中的相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.fragment.app.FragmentManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FragmentManager</span> <span class="keyword">implements</span> <span class="title class_">FragmentResultOwner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FragmentManagerViewModel mNonConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">(<span class="meta">@NonNull</span> Fragment f)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mNonConfig.getViewModelStore(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressLint(&quot;SyntheticAccessor&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attachController</span><span class="params">(<span class="meta">@NonNull</span> FragmentHostCallback&lt;?&gt; host,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> FragmentContainer container, <span class="meta">@Nullable</span> <span class="keyword">final</span> Fragment parent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHost != <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already attached&quot;</span>);</span><br><span class="line">        mHost = host;</span><br><span class="line">        mContainer = container;</span><br><span class="line">        mParent = parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Get the FragmentManagerViewModel</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (host <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="type">ViewModelStore</span> <span class="variable">viewModelStore</span> <span class="operator">=</span> ((ViewModelStoreOwner) host).getViewModelStore();</span><br><span class="line">            mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mNonConfig = <span class="keyword">new</span> <span class="title class_">FragmentManagerViewModel</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Ensure that the state is in sync with FragmentManager</span></span><br><span class="line">        mNonConfig.setIsStateSaved(isStateSaved());</span><br><span class="line">        mFragmentStore.setNonConfig(mNonConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 FragmentManager 中，存在一个 FragmentManagerViewModel mNonConfig 实例中。</p>
<p>首先先简单看看该实例的赋值过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.fragment.app.FragmentActivity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FragmentActivity</span> <span class="keyword">extends</span> <span class="title class_">ComponentActivity</span> <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ActivityCompat</span>.OnRequestPermissionsResultCallback,</span><br><span class="line">        ActivityCompat.RequestPermissionsRequestCodeValidator &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里创建出来的 FragmentController 会传入一个 HostCallbacks 实例，该实例会保存在 FragmentController 中的 mHost 属性中</span></span><br><span class="line"><span class="comment">     * 这个需要记住，因为后续 mHost 使用的挺多的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">FragmentController</span> <span class="variable">mFragments</span> <span class="operator">=</span> FragmentController.createController(<span class="keyword">new</span> <span class="title class_">HostCallbacks</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FragmentActivity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里添加 OnContextAvailableListener 监听，后续等到 ComponentActivity.onCreate() 方法执行时</span></span><br><span class="line"><span class="comment">         * 其内部会调用该回调来通知监听方，这里的 onContextAvailable() 方法被执行</span></span><br><span class="line"><span class="comment">         * 所以 mFragments.attachHost() 其实是在 ComponentActivity.onCreate() 方法执行时被调用的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        addOnContextAvailableListener(<span class="keyword">new</span> <span class="title class_">OnContextAvailableListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onContextAvailable</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> &#123;</span><br><span class="line">                <span class="comment">// 当后期回调 OnContextAvailableListener.onContextAvailable() 时会执行到这里</span></span><br><span class="line">                <span class="comment">// 从而调用到 FragmentController.attachHost 中，</span></span><br><span class="line">                <span class="comment">// 传入的 parent=null，因为此时Fragment 的host 直接是Activity，这个parent是Fragment嵌套时才会有值的</span></span><br><span class="line">                mFragments.attachHost(<span class="literal">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line">                <span class="type">Bundle</span> <span class="variable">savedInstanceState</span> <span class="operator">=</span> getSavedStateRegistry()</span><br><span class="line">                        .consumeRestoredStateForKey(FRAGMENTS_TAG);</span><br><span class="line">                <span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Parcelable</span> <span class="variable">p</span> <span class="operator">=</span> savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">                    mFragments.restoreSaveState(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HostCallbacks</span> <span class="keyword">extends</span> <span class="title class_">FragmentHostCallback</span>&lt;FragmentActivity&gt; <span class="keyword">implements</span></span><br><span class="line">            <span class="title class_">ViewModelStoreOwner</span>,</span><br><span class="line">            OnBackPressedDispatcherOwner,</span><br><span class="line">            ActivityResultRegistryOwner,</span><br><span class="line">            FragmentOnAttachListener &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HostCallbacks</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(FragmentActivity.<span class="built_in">this</span> <span class="comment">/*fragmentActivity*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Lifecycle <span class="title function_">getLifecycle</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// Instead of directly using the Activity&#x27;s Lifecycle, we</span></span><br><span class="line">            <span class="comment">// use a LifecycleRegistry that is nested exactly outside of</span></span><br><span class="line">            <span class="comment">// when Fragments get their lifecycle changed</span></span><br><span class="line">            <span class="comment">// TODO(b/127528777) Drive Fragment Lifecycle with LifecycleObserver</span></span><br><span class="line">            <span class="keyword">return</span> mFragmentLifecycleRegistry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可以看到这里 getViewModelStore 会调用 FragmentActivity.getViewModelStore() </span></span><br><span class="line"><span class="comment">         * 也就是调用到 ComponentActivity.getViewModelStore() 中，拿到 Activity 中的 ViewModelStore</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> FragmentActivity.<span class="built_in">this</span>.getViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略其他无关方法</span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx.fragment.app.FragmentController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FragmentController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachHost</span><span class="params">(<span class="meta">@Nullable</span> Fragment parent)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用到 FragmentManager.attachController 中，此时会将 mHost 传入</span></span><br><span class="line">        <span class="comment">// 此时 mHost 就是上面的 HostCallbacks 实例</span></span><br><span class="line">        mHost.mFragmentManager.attachController(</span><br><span class="line">                mHost, mHost <span class="comment">/*container*/</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// androidx.fragment.app.FragmentManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FragmentManager</span> <span class="keyword">implements</span> <span class="title class_">FragmentResultOwner</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;SyntheticAccessor&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attachController</span><span class="params">(<span class="meta">@NonNull</span> FragmentHostCallback&lt;?&gt; host,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> FragmentContainer container, <span class="meta">@Nullable</span> <span class="keyword">final</span> Fragment parent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mHost != <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already attached&quot;</span>);</span><br><span class="line">        mHost = host;</span><br><span class="line">        mContainer = container;</span><br><span class="line">        mParent = parent;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the FragmentManagerViewModel</span></span><br><span class="line">        <span class="comment">// 如果按照上面的路径来的话，此时 parent =null，host就是上面的 HostCallbacks 实例</span></span><br><span class="line">        <span class="comment">// 那么会走第二个分支来创建</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (host <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="type">ViewModelStore</span> <span class="variable">viewModelStore</span> <span class="operator">=</span> ((ViewModelStoreOwner) host).getViewModelStore();</span><br><span class="line">            mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mNonConfig = <span class="keyword">new</span> <span class="title class_">FragmentManagerViewModel</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Ensure that the state is in sync with FragmentManager</span></span><br><span class="line">        mNonConfig.setIsStateSaved(isStateSaved());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看完上面的赋值流程之后，不难知道：这里的 FragmentManagerViewModel mNonConfig 被赋值时机，其实是在 ComponentActivity 的onCreate() 方法被调用时，而执行的也是 FragmentManagerViewModel.getInstance(viewModelStore) 。此时传入的 viewModel 是从 host.getViewModelStore() 中获取的，也就是 ComponentActivity.getViewModelStore() 方法返回的，也就是 Fragment 外层 Activity 中的 ViewModelStore 实例。</p>
<p>接着往下看它的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// androidx.fragment.app.FragmentManagerViewModel</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FragmentManagerViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> FragmentManager.TAG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个有参 FragmentManagerViewModel ，所以需要自定义 Factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ViewModelProvider.<span class="type">Factory</span> <span class="variable">FACTORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>.Factory() &#123;</span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">            <span class="type">FragmentManagerViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FragmentManagerViewModel</span>(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照前面的逻辑分析，这里的  viewModelStore  应该是该 Fragment 对应的 FragmentActivity 中的 ViewModelStore 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">static</span> FragmentManagerViewModel <span class="title function_">getInstance</span><span class="params">(ViewModelStore viewModelStore)</span> &#123;</span><br><span class="line">        <span class="type">ViewModelProvider</span> <span class="variable">viewModelProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(viewModelStore,</span><br><span class="line">                FACTORY);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 往 FragmentActivity 中的 ViewModelStore 实例内创建并存放一个 FragmentManagerViewModel 实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> viewModelProvider.get(FragmentManagerViewModel.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储着所有的 Fragment 所对应的  ViewModel 实例。</span></span><br><span class="line"><span class="comment">     * key是 Fragment.mWho ，也就是一个uuid</span></span><br><span class="line"><span class="comment">     * value是该 Fragment 所对应的 ViewModelStore 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModelStore&gt; mViewModelStores = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> mStateAutomaticallySaved;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FragmentManagerViewModel simultaneously supports two modes:</span></span><br><span class="line"><span class="comment">     * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">     *     &lt;li&gt;Automatically saved: in this model, it is assumed that the ViewModel is added to</span></span><br><span class="line"><span class="comment">     *     an appropriate &#123;<span class="doctag">@link</span> ViewModelStore&#125; that has the same lifecycle as the</span></span><br><span class="line"><span class="comment">     *     FragmentManager and that &#123;<span class="doctag">@link</span> #onCleared()&#125; indicates that the Fragment&#x27;s host</span></span><br><span class="line"><span class="comment">     *     is being permanently destroyed.&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *     &lt;li&gt;Not automatically saved: in this model, the FragmentManager is responsible for</span></span><br><span class="line"><span class="comment">     *     calling &#123;<span class="doctag">@link</span> #getSnapshot()&#125; and later restoring the ViewModel with</span></span><br><span class="line"><span class="comment">     *     &lt;code&gt;restoreFromSnapshot&lt;/code&gt;.&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">     * These states are mutually exclusive.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stateAutomaticallySaved Whether the ViewModel will be automatically saved.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FragmentManagerViewModel(<span class="type">boolean</span> stateAutomaticallySaved) &#123;</span><br><span class="line">        mStateAutomaticallySaved = stateAutomaticallySaved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelStore <span class="title function_">getViewModelStore</span><span class="params">(<span class="meta">@NonNull</span> Fragment f)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用每个 Fragment 实例所分配的 uuid 来作为key</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ViewModelStore</span> <span class="variable">viewModelStore</span> <span class="operator">=</span> mViewModelStores.get(f.mWho);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果该 Fragment 还没有创建对应的  ViewModelStore 实例，则为其创建一个并放入 mViewModelStores 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (viewModelStore == <span class="literal">null</span>) &#123;</span><br><span class="line">            viewModelStore = <span class="keyword">new</span> <span class="title class_">ViewModelStore</span>();</span><br><span class="line">            mViewModelStores.put(f.mWho, viewModelStore);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> viewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先可以看到 FragmentManagerViewModel 是继承自 ViewModel 的，所以它自身可以作为一个 ViewModel 存入其他 ViewModelStore 中。</p>
<p>其次在其 getInstance() 方法传入的是一个FragmentActivity 的 ViewModelStore，内部会使用它来构造一个 ViewModelProvider 并调用 get() 方法创建并保存该 FragmentManagerViewModel 实例。额外这里定制了 Factory ，因为FragmentManagerViewModel 只有一个有参的构造方法。ViewModelProvider 和 Factory下面章节会讲的，这里先不纠结。</p>
<p>所以说，该方法执行完毕，创建出来一个 FragmentManagerViewModel 实例，并且该实例会保存在 FragmentActivity 中的 viewModelStore 中。</p>
<p>而回到 FragmentManagerViewModel 中，它内部有一个 <code>HashMap&lt;String,ViewModel&gt; mViewModelStores</code>，这个列表存储着每个Fragment 各自的 ViewModelStore 实例。详见上面代码中的注释。</p>
<p>小结一下：每个 Fragment 都可能存在一个 ViewModelStore 实例，这些实例统一都存储在 FragmentManagerViewModel 中的 Map 内，而 FragmentManagerViewModel 实例又存储在 FragmentActivity 中的 ViewModelStore 实例中。而 Fragment 实现了 ViewModelStoreOwner 接口，在其实现的 getViewModelStore() 方法中会返回存储在 FragmentManagerViewModel 中对应给它自身的那个 ViewModelStore 实例。</p>
<p>比如此时有一个 FragmentActivity ，内部存在2个 Fragment ：那么此时 FragmentActivity 中存在一个 ViewModelStore 实例，这个 ViewModelStore 中存在一个 FragmentManagerViewModel 实例，而这个FragmentManagerViewModel实例中存在两个 ViewModelStore实例，这两个ViewModelStore实例分别对应给这俩 Fragment。</p>
<p>而 Fragment 中所对应的 ViewModel 实例，它被销毁的实际是其在被调用 onDestroy() 方法时。具体源码详见：FragmentStateManager.destroy() 方法中的逻辑，这里就不再贴代码了。</p>
<h3 id="ViewModelProvider"><a href="#ViewModelProvider" class="headerlink" title="ViewModelProvider"></a>ViewModelProvider</h3><p>ViewModel 的创建工作是交由：ViewModelProvider 来完成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewModelProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_KEY</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implementations of &#123;<span class="doctag">@code</span> Factory&#125; interface are responsible to instantiate ViewModels.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a new instance of the given &#123;<span class="doctag">@code</span> Class&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> modelClass a &#123;<span class="doctag">@code</span> Class&#125; whose instance is requested</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;T&gt;        The type parameter for the ViewModel.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a newly created ViewModel</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Factory mFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ViewModelStore mViewModelStore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates &#123;<span class="doctag">@code</span> ViewModelProvider&#125;. This will create &#123;<span class="doctag">@code</span> ViewModels&#125;</span></span><br><span class="line"><span class="comment">     * and retain them in a store of the given &#123;<span class="doctag">@code</span> ViewModelStoreOwner&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method will use the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> HasDefaultViewModelProviderFactory#getDefaultViewModelProviderFactory() default factory&#125;</span></span><br><span class="line"><span class="comment">     * if the owner implements &#123;<span class="doctag">@link</span> HasDefaultViewModelProviderFactory&#125;. Otherwise, a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> NewInstanceFactory&#125; will be used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(owner.getViewModelStore(), owner <span class="keyword">instanceof</span> HasDefaultViewModelProviderFactory</span><br><span class="line">                ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()</span><br><span class="line">                : NewInstanceFactory.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates &#123;<span class="doctag">@code</span> ViewModelProvider&#125;, which will create &#123;<span class="doctag">@code</span> ViewModels&#125; via the given</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Factory&#125; and retain them in a store of the given &#123;<span class="doctag">@code</span> ViewModelStoreOwner&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> owner   a &#123;<span class="doctag">@code</span> ViewModelStoreOwner&#125; whose &#123;<span class="doctag">@link</span> ViewModelStore&#125; will be used to</span></span><br><span class="line"><span class="comment">     *                retain &#123;<span class="doctag">@code</span> ViewModels&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> factory a &#123;<span class="doctag">@code</span> Factory&#125; which will be used to instantiate</span></span><br><span class="line"><span class="comment">     *                new &#123;<span class="doctag">@code</span> ViewModels&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStoreOwner owner, <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(owner.getViewModelStore(), factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates &#123;<span class="doctag">@code</span> ViewModelProvider&#125;, which will create &#123;<span class="doctag">@code</span> ViewModels&#125; via the given</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Factory&#125; and retain them in the given &#123;<span class="doctag">@code</span> store&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> store   &#123;<span class="doctag">@code</span> ViewModelStore&#125; where ViewModels will be stored.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> factory factory a &#123;<span class="doctag">@code</span> Factory&#125; which will be used to instantiate</span></span><br><span class="line"><span class="comment">     *                new &#123;<span class="doctag">@code</span> ViewModels&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewModelProvider</span><span class="params">(<span class="meta">@NonNull</span> ViewModelStore store, <span class="meta">@NonNull</span> Factory factory)</span> &#123;</span><br><span class="line">        mFactory = factory;</span><br><span class="line">        mViewModelStore = store;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an existing ViewModel or creates a new one in the scope (usually, a fragment or</span></span><br><span class="line"><span class="comment">     * an activity), associated with this &#123;<span class="doctag">@code</span> ViewModelProvider&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The created ViewModel is associated with the given scope and will be retained</span></span><br><span class="line"><span class="comment">     * as long as the scope is alive (e.g. if it is an activity, until it is</span></span><br><span class="line"><span class="comment">     * finished or process is killed).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelClass The class of the ViewModel to create an instance of it if it is not</span></span><br><span class="line"><span class="comment">     *                   present.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;        The type parameter for the ViewModel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A ViewModel that is an instance of the given type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> modelClass.getCanonicalName();</span><br><span class="line">        <span class="keyword">if</span> (canonicalName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在ViewModelProvider中，存在两个属性：</p>
<p>1、final Factory mFactory：final 修饰的，只能在构造方法中被赋值。指向一个 ViewModelProvider.Factory 接口实例，用来返回一个ViewModel 实例。</p>
<p>2、final ViewModelStore mViewModelStore：也是final修饰的，只能在构造方法中赋值。它用来存储创建出来的ViewModel。前面讲到它内部会有个Map来存储若干个ViewModel 实例，并提供查找、添加的方法。而有了这个 ViewModel 的容器之后，ViewModelProvider 就像是个工具类了，它在这个ViewModelStore的基础上进行操作。</p>
<p>而 ViewModelProvider 有好几个重载的构造方法，但是实际是为了给如上两个属性赋值而已，所以可以接收ViewModelStoreOwner 通过它来获取 ViewModelStore 实例，也可以直接接收ViewModelStore 实例，另外的Factory可以直接传入，也可以不传，不传的话则默认从 ViewModelStoreOwner 对象中拿，如果该实例实现了HasDefaultViewModelProviderFactory接口的话，则通过其实现的getDefaultViewModelProviderFactory()方法来获取Factory 实例。比如常用的传入ComponentActivity 实例，它就是默认实现了该接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HasDefaultViewModelProviderFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HasDefaultViewModelProviderFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the default &#123;<span class="doctag">@link</span> ViewModelProvider.Factory&#125; that should be</span></span><br><span class="line"><span class="comment">     * used when no custom &#123;<span class="doctag">@code</span> Factory&#125; is provided to the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ViewModelProvider&#125; constructors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelProvider.Factory&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ComponentActivity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentActivity</span> <span class="keyword">extends</span> <span class="title class_">androidx</span>.core.app.ComponentActivity <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ContextAware</span>,</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        HasDefaultViewModelProviderFactory,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner,</span><br><span class="line">        ActivityResultRegistryOwner,</span><br><span class="line">        ActivityResultCaller &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ViewModelProvider.Factory <span class="title function_">getDefaultViewModelProviderFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                    + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mDefaultFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            mDefaultFactory = <span class="keyword">new</span> <span class="title class_">SavedStateViewModelFactory</span>(</span><br><span class="line">                    getApplication(),</span><br><span class="line">                    <span class="built_in">this</span>,</span><br><span class="line">                    getIntent() != <span class="literal">null</span> ? getIntent().getExtras() : <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mDefaultFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以使用一个参数的构造方法，传入一个 ComponentActivity(更常见的是它的子类，其继承关系翻看前面 Lifecycyle中的分析)来完成ViewModelProvider的创建。</p>
<p>完成对其创建之后，就可以通过 get() 方法来创建或者获取对应ViewModel实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewModelProvider</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">canonicalName</span> <span class="operator">=</span> modelClass.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">    <span class="type">ViewModel</span> <span class="variable">viewModel</span> <span class="operator">=</span> mViewModelStore.get(key);</span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建&#x2F;获取 ViewModel 时，因为操作的是 ViewModelStore 实例，其内部Map 是key是String，value是ViewModel实例，所以这里会先对每个ViewModel 拼接一个唯一String Key，格式为：</p>
<p>“androidx.lifecycle.ViewModelProvider.DefaultKey” + modelClass.getCanonicalName() 。</p>
<p>后续便使用该key去 ViewModelStore 中先去获取是否已存在对应的 ViewModel 实例，存在的话则取出返回。</p>
<p>不然的话则调用 Factory  实例的 create() 方法来创建对应的 ViewModel 实例，然后将其保存到 ViewModelStore 中并返回出去。</p>
<p>所以get() 方法之后，该 ViewModelStore 实例中就会存储着该 ViewModel 实例，后续只要使用的是同一个 ViewModelStore 实例的话，那么就能取出来这个 ViewModel 实例。而这个 ViewModelStore 是由 ViewModelStoreOwner 接口的实现类所持有的，常见的也就是 CoponentActivity 了，因此只要 ComponentActivity 实例是同一个，那么就能取出之前保存的ViewModel 实例。</p>
<p>这样的结论可以让ViewModel有其他的使用场景：</p>
<p>1). 完成 Activity 和 Fragment 之间的通讯。</p>
<blockquote>
<p>比如在Activity 中通过 ViewModelProvider 的 get 方法第一次存入了指定的 ViewModel，后续在其内部的 Fragment 中，再次创建 ViewModelProvider 实例，此时传入 getActivity() 实例，那么就保证了两次构建ViewModelProvider时的 ViewModelStoreOwner 是同一个实例了。那自然是可以取出之前在Activity 中保存的 ViewModel 了，自然就可以完成通讯工作了。</p>
</blockquote>
<p>2). 完成 Fragment 和 Fragment 之间的通讯。</p>
<blockquote>
<p>这个跟上面第一中场景类似，都是通过 getActivity() 方法传入同一个 ViewModelStoreOwner 实例。那么其内部的 ViewModelStore 中的 ViewModel 自然是可以互相访问到的。</p>
</blockquote>
<h3 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h3><p>接着上面分析到的 Factory.create() 处，我们来看几个常见的实现类：</p>
<h4 id="SavedStateViewModelFactory-："><a href="#SavedStateViewModelFactory-：" class="headerlink" title="SavedStateViewModelFactory ："></a>SavedStateViewModelFactory ：</h4><p>前面 ComponentActivity 中实现的HasDefaultViewModelProviderFactory 接口中的方法时，创建了一个 SavedStateViewModelFactory 实例，这个类中还有一些关于 SavedState 相关的逻辑，先不考虑，只看本文相关的。</p>
<p>在其构造方法中会为内部的 mFactory 创建其他的实现类，也就是其内部的 Factory 主要借助以下这两个类： AndroidViewModelFactory 和 NewInstanceFactory 。因此SavedStateViewModelFactory 类其他逻辑就先不分析了，直接看其他那俩。</p>
<h4 id="NewInstanceFactory："><a href="#NewInstanceFactory：" class="headerlink" title="NewInstanceFactory："></a>NewInstanceFactory：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NewInstanceFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NewInstanceFactory sInstance;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve a singleton instance of NewInstanceFactory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A valid &#123;<span class="doctag">@link</span> NewInstanceFactory&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">static</span> NewInstanceFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> <span class="title class_">NewInstanceFactory</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;ClassNewInstance&quot;)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> modelClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很简单，就是实现 Factory 接口，然后实现其 create 方法，在该方法中根据传入的 ViewModel Class 来反射创建其实例。</p>
<p>而这种方式调用的是 ViewModel 类的无餐构造方法。如果没有无参构造方法时，会抛出异常；或者开发者自定义的 ViewModel 需要通过构造方法传入参数的话，那么NewInstanceFactory它也满足不了。这种场景就得通过自定义Factory来解决了。</p>
<h4 id="AndroidViewModelFactory"><a href="#AndroidViewModelFactory" class="headerlink" title="AndroidViewModelFactory"></a>AndroidViewModelFactory</h4><p>在讲它之前，首先得看下 AndroidViewModel ，它继承自 ViewModel ，内部多了一个 Application 属性，并且为该属性新增了一个构造方法。</p>
<p>前面刚提到了 NewInstanceFactory 无法实现有参ViewModel 的创建，需要自行实现 Factory ，然后这就又出来一个 Application 参数的 ViewModel。咱们看看官方是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AndroidViewModelFactory</span> <span class="keyword">extends</span> <span class="title class_">ViewModelProvider</span>.NewInstanceFactory &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AndroidViewModelFactory sInstance;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve a singleton instance of AndroidViewModelFactory.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application an application to pass in &#123;<span class="doctag">@link</span> AndroidViewModel&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A valid &#123;<span class="doctag">@link</span> AndroidViewModelFactory&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AndroidViewModelFactory <span class="title function_">getInstance</span><span class="params">(<span class="meta">@NonNull</span> Application application)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> <span class="title class_">AndroidViewModelFactory</span>(application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Application mApplication;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> AndroidViewModelFactory&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application an application to pass in &#123;<span class="doctag">@link</span> AndroidViewModel&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AndroidViewModelFactory</span><span class="params">(<span class="meta">@NonNull</span> Application application)</span> &#123;</span><br><span class="line">        mApplication = application;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">ViewModel</span>&gt; T <span class="title function_">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">            <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> modelClass.getConstructor(Application.class).newInstance(mApplication);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cannot create an instance of &quot;</span> + modelClass, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的是，AndroidViewModelFactory 是直接继承自 NewInstanceFactory ，这样做是因为AndroidViewModelFactory 被设计的作用是不仅可以创建AndroidViewModel，也可以创建ViewModel。 而这里相当于也是间接的实现了  Factory 接口。</p>
<p>接着它提供了一个 Application 参数的构造方法，用来接收外部创建AndroidViewModel 时需要的 Application 参数。</p>
<p>最后重写 create() 方法，内部会先判断本次要创建的 ViewModel 类是否继承自 AndroidViewModel ，是的话则反射调用其一个参数Application的构造方法将Application传入进去。否则调用 super，即走 NewInstanceFactory 的create() 方法实现去创建 ViewModel。</p>
<p>看完这个类，也就明白了怎么去自定义一个 Factory 去创建实例化我们自己的有参ViewModel 。唯一不同的是我们自定义的时候一般不需要继承自 NewInstanceFactory ，而是直接实现 Factory 接口就行了。</p>
<p>提到了 AndroidViewModel ，额外补充几句，为什么这里是保存的 Application ，而不是Context 呢？我们知道： ViewModel 的生命周期可能比 ViewModelStoreOwner 更长，因此 ViewModel 不应保留任何对与生命周期相关的 API（例如 Context或Resources）的引用，以免发生内存泄漏。而Application的生命周期肯定是大于等于ViewModel 的， 因此短声明周期的ViewModel持有长生命周期的Application就没啥问题了。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Jetpack/">Jetpack</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/84ecfaa3.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Jetpack- LiveData</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/91da79fe.html">
        <span class="next-text nav-default">Surface学习(三)--Layer简介</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
