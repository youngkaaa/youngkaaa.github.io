<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Retrofit-动态代理中的秘密"/>




  <meta name="keywords" content="retrofit," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/b80024b2.html"/>


<meta name="description" content="Retrofit 也是一个优秀的开源库，它的作用主要是用来完成网络请求，它和 OkHttp 就有些许的类似，不止这里的用途，更连其内部的一些类和设计理念，都有很多相似的。但是和 OkHttp 不同的是， Retrofit 它并不是一个纯粹的网络库，它是基于 OkHttp 来进行的二次开发，相当于是 OkHttp 的一个代理实现，在其原有的能力上做了增强，使得开发者可以更简便快速的使用它来进行需求的">
<meta property="og:type" content="article">
<meta property="og:title" content="Retrofit-动态代理中的秘密">
<meta property="og:url" content="https://youngkaaa.github.io/b80024b2.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="Retrofit 也是一个优秀的开源库，它的作用主要是用来完成网络请求，它和 OkHttp 就有些许的类似，不止这里的用途，更连其内部的一些类和设计理念，都有很多相似的。但是和 OkHttp 不同的是， Retrofit 它并不是一个纯粹的网络库，它是基于 OkHttp 来进行的二次开发，相当于是 OkHttp 的一个代理实现，在其原有的能力上做了增强，使得开发者可以更简便快速的使用它来进行需求的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-25T13:49:56.000Z">
<meta property="article:modified_time" content="2023-03-10T14:04:18.109Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="retrofit">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Retrofit-动态代理中的秘密 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Retrofit-动态代理中的秘密
        
      </h1>

      <time class="post-time">
          1月 25 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>Retrofit 也是一个优秀的开源库，它的作用主要是用来完成网络请求，它和 OkHttp 就有些许的类似，不止这里的用途，更连其内部的一些类和设计理念，都有很多相似的。但是和 OkHttp 不同的是， Retrofit 它并不是一个纯粹的网络库，它是基于 OkHttp 来进行的二次开发，相当于是 OkHttp 的一个代理实现，在其原有的能力上做了增强，使得开发者可以更简便快速的使用它来进行需求的开发。</p>
<p>本文主要讲解 Retrofit 的中动态代理是怎么生效的，以及 ServiceMethod 的创建流程。</p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>在正式开始分析源码之前，先看一个官方提供的示例，来学习下 Retrofit 的简单使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SimpleService</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 请求的 host </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">API_URL</span> <span class="operator">=</span> <span class="string">&quot;https://api.github.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应的结果所对应的Java实体类</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Contributor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String login;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> contributions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Contributor</span><span class="params">(String login, <span class="type">int</span> contributions)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.login = login;</span><br><span class="line">      <span class="built_in">this</span>.contributions = contributions;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个接口，用来后续使用动态代理来生成实例</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GitHub</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个方法，该方法就对应一个请求</span></span><br><span class="line">    <span class="meta">@GET(&quot;/repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line">    Call&lt;List&lt;Contributor&gt;&gt; <span class="title function_">contributors</span><span class="params">(<span class="meta">@Path(&quot;owner&quot;)</span> String owner, <span class="meta">@Path(&quot;repo&quot;)</span> String repo)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 通过 Retrofit.Builder 来构建一个 Retrofit 实例</span></span><br><span class="line">    <span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">            .baseUrl(API_URL)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 retrofit 的 create() 方法来创建一个该 GitHub 接口的代理类</span></span><br><span class="line">    <span class="type">GitHub</span> <span class="variable">github</span> <span class="operator">=</span> retrofit.create(GitHub.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用代理类实例中的 contributors 方法来获取一个 Call 对象实例</span></span><br><span class="line">    Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(<span class="string">&quot;square&quot;</span>, <span class="string">&quot;retrofit&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行这个 Call 的 execute 方法来完成请求，拿到最终的结果 List&lt;Contributor&gt;</span></span><br><span class="line">    List&lt;Contributor&gt; contributors = call.execute().body();</span><br><span class="line">    <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">      System.out.println(contributor.login + <span class="string">&quot; (&quot;</span> + contributor.contributions + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结来说就是：</p>
<p>① 先定义一个接口，在该接口内定义对应的方法来获取网络请求结果。</p>
<p>② 创建 Retrofit 实例，然后调用 retrofit 的 create() 方法传入该接口，最终会返回一个该接口的代理类对象实例</p>
<p>③ 开发者拿到这个代理类之后，就可以调用其对应的方法来拿到网络获取所需的 Call 接口的实例，在使用它就可以完成网络请求获取数据了。</p>
<p>这里面遇到了好多没见过的东西，比如 Call ，以及 @GET ，@Path 等，他们都代表的是什么？这些接着往后看就知道了。</p>
<p>###create</p>
<p>选择开始分析的切入点，我们从 Retrofit 中的  create() 方法来看。先来看看它内部是怎么为这个入参接口创建代理类实例的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrofit.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查入参 service 的合法性，以及处理外部设置的 validateEagerly 属性</span></span><br><span class="line">    validateServiceInterface(service);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的 service 接口，调用 Proxy.newProxyInstance() 方法来创建一个对应的代理类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;service&#125;, <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="meta">@Nullable</span></span><br><span class="line">        Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 如果外部开发者调用的方法是属于 Object 的，那么直接触发就行，比如 Object 的 hashCode 方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确保参数不为null</span></span><br><span class="line">            args = args != <span class="literal">null</span> ? args : emptyArgs;</span><br><span class="line">            <span class="comment">// 创建对应的 ServiceMethod 实例</span></span><br><span class="line">            <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                    : loadServiceMethod(method).invoke(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 create() 方法中主要做两件事情：</p>
<h4 id="validateServiceInterface"><a href="#validateServiceInterface" class="headerlink" title="validateServiceInterface"></a>validateServiceInterface</h4><p>第一步，调用 validateServiceInterface() 方法来完成入参的校验和外部设置的 validateEagerly 属性的处理。下面看看他是怎么去处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrofit.java</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validateServiceInterface</span><span class="params">(Class&lt;?&gt; service)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果传入的该 Class 不是接口，那么直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!service.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;API declarations must be interfaces.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Class&lt;?&gt;&gt; check = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    check.add(service);</span><br><span class="line">    <span class="comment">// 该 Class 此时确实是接口，那么检查它是不是泛型的，以及检查父接口(如果有的话)</span></span><br><span class="line">    <span class="keyword">while</span> (!check.isEmpty()) &#123;</span><br><span class="line">        Class&lt;?&gt; candidate = check.removeFirst();</span><br><span class="line">        <span class="comment">// 接口不能是泛型的</span></span><br><span class="line">        <span class="keyword">if</span> (candidate.getTypeParameters().length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Type parameters are unsupported on &quot;</span>).append(candidate.getName());</span><br><span class="line">            <span class="keyword">if</span> (candidate != service) &#123;</span><br><span class="line">                message.append(<span class="string">&quot; which is an interface of &quot;</span>).append(service.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(message.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果该接口继承自别的接口，则往上去检查父接口是否满足上面的条件</span></span><br><span class="line">        Collections.addAll(check, candidate.getInterfaces());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始处理外部设置的 validateEagerly 属性</span></span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">        <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line">        <span class="comment">// 提前加载当前接口中的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!platform.isDefaultMethod(method) &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                loadServiceMethod(method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 validateServiceInterface() 方法中，首先会检查入参 service 是不是一个接口，如果不是接口的话则直接抛出异常，因为我们后续动态生成代理类时，使用的是Java中提供的 Proxy.newProxyInstance() ，它只支持接口的动态代理。</p>
<p>接着还会再做合法性判断，比如会检查该接口是否有泛型，是不是继承自别的接口，使得话还会再去检查父接口。这一番检查完毕之后，会完成最后一个工作：处理外部设置给当前 Retrofit 的 validateEagerly 属性，如果它被指定为 true 的话，则这里会额外的提前遍历当前接口中定义的方法，挨个去执行 loadServiceMethod() 来加载该方法；如果是false的话则忽略。</p>
<p>当前 Retrofit 中的 validateEagerly 属性是啥时候被赋值的呢？(我们顺便回顾下 Retrofit 的创建流程)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrofit.java</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Retrofit</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Retrofit(</span><br><span class="line">            okhttp3.Call.Factory callFactory,</span><br><span class="line">            HttpUrl baseUrl,</span><br><span class="line">            List&lt;Converter.Factory&gt; converterFactories,</span><br><span class="line">            List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">            <span class="meta">@Nullable</span> Executor callbackExecutor,</span><br><span class="line">            <span class="type">boolean</span> validateEagerly) &#123;</span><br><span class="line">        <span class="built_in">this</span>.callFactory = callFactory;</span><br><span class="line">        <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">        <span class="built_in">this</span>.converterFactories = converterFactories;</span><br><span class="line">        <span class="built_in">this</span>.callAdapterFactories = callAdapterFactories;</span><br><span class="line">        <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">        <span class="built_in">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他属性定义</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改 validateEagerly 的值</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">validateEagerly</span><span class="params">(<span class="type">boolean</span> validateEagerly)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Retrofit <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>(</span><br><span class="line">                    callFactory,</span><br><span class="line">                    baseUrl,</span><br><span class="line">                    unmodifiableList(converterFactories),</span><br><span class="line">                    unmodifiableList(callAdapterFactories),</span><br><span class="line">                    callbackExecutor,</span><br><span class="line">                    validateEagerly);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Retrofit 的创建是通过其 Builder 来实现的，也就是 Builder 模式，这种模式下创建出来的 Retrofit 后期属性不能修改，只能重新创建。而对于这里 validateEagerly 属性，在 Builder 中默认是 false的，可修改，最终通过 build() 方法设置给 Retrofit 中。</p>
<p>那这个属性有什么用呢？</p>
<p>举个例子，假如你在某个接口中定义了很多个方法，但是其中有一个有错误，比如没有加上 HTTP 注解，比如@GET，那么后期等你调用该方法时，肯定会抛出一个 IllegalArgumentException 异常，提示你：“HTTP method annotation is required (e.g., @GET, @POST, etc.). ”。但是如果你测试的时候没有调用过这个方法，那么等上线之后就会出现异常导致APP崩溃。而又由于 Retrofit 是基于动态代理的，所以正常情况下是等外部调用该方法时，触发动态代理 invoke() 方法，接着才会去处理该方法，为其创建 ServiceMethod 实例等操作，也就是某种意义上的懒加载，因此只有调用时才能发现该方法定义有问题。那么有没有一种方式可以预先检查好呢？那就是通过指定 validateEagerly  的值为 true，那么就会在一开始 create() 时检查，早发现早解决，而不用等到正式调用该方法。所以这种情况先可以在开发测试时将其置为 true ，上线后将其置为 false ，毕竟用哪个再去初始化哪个才是比较合理，高性能的。</p>
<h4 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy.newProxyInstance"></a>Proxy.newProxyInstance</h4><p>第二步，使用Java提供的  Proxy.newProxyInstance() 方法来完成动态代理，最终会生成一个当前入参接口 service 对应的代理类实例返回出去。这样的话，外部开发者就通过调用 Retrofit 中 create() 方法拿到了一个接口类实例对象。接着就可以调用其内部之前定义的方法了，比如上面例子中的 contributors(“square”, “retrofit”) 方法并且传入参数。</p>
<p>如果你不了解 Java动态代理的话，请先去看看这篇文章： <a href="4d381682.html">Java 动态代理原理分析</a> 。看完这篇文章了解了动态代理之后，再去看下面的内容才会更好理解，不然会觉得云里雾里的。</p>
<h3 id="InvocationHandler-invoke"><a href="#InvocationHandler-invoke" class="headerlink" title="InvocationHandler#invoke"></a>InvocationHandler#invoke</h3><p>前面在 create() 方法中拿到了动态代理生成的实例，那么后续调用其内部方法时，就会走到前面创建的 InvocationHandler 实例中的 invoke() 方法内，invoke() 方法中的代码这里为了分析方便再贴一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果外部开发者调用的方法是属于 Object 的，那么直接触发就行，比如 Object 的 hashCode 方法</span></span><br><span class="line"><span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保参数不为null</span></span><br><span class="line">args = args != <span class="literal">null</span> ? args : emptyArgs;</span><br><span class="line"><span class="comment">// 创建对应的 ServiceMethod 实例</span></span><br><span class="line"><span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">        ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">        : loadServiceMethod(method).invoke(args);</span><br></pre></td></tr></table></figure>

<p>这里首先会判断外部调用的方法是否是属于 Object 的，是的话则无需额外处理，直接触发就行了。接着会将入参 args 纠正一下，确保其不会是 null。</p>
<p>最后会按照当前调用的方法是不是默认方法来分类执行，什么是默认方法，简单来说就是该方法当时在接口中定义时，使用了 default 关键字，默认方法这种写法是从 Java8 开始引入的。</p>
<p>① 如果是默认方法的话，则直接调用其提供的默认实现就行，不用额外做方法代理。</p>
<p>② 如果不是默认方法的话，则会调用 loadServiceMethod()  获取或者创建该方法对应的 ServiceMethod 实例。</p>
<p>当然，几乎所有的情况都是走的第二种情况，而上面第一种情况中的处理主要是防止你这个接口中还有其他用途的定义，你传入的这个接口不一定专门用来给 Retrofit 来用的，内部定义的方法也不都是和 Retrofit 相关的，当然还是建议接口内方法定义的纯粹些，单一职责。</p>
<p>这里又遇到了 loadServiceMethod() 方法，那我们接下来就看这个方法中都做了什么吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrofit.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 首先从 serviceMethodCache 中查找该 method 之前创建并缓存的 ServiceMethod 实例</span></span><br><span class="line"><span class="comment">     * 如果找着了，就直接返回就行了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 上面没找着，那么接下来得为其创建一个新的，并且放入到 serviceMethodCache</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">        result = serviceMethodCache.get(method);</span><br><span class="line">        <span class="comment">// 再次检查，double check</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 解析方法中的注解，然后将其存储并且包装成 ServiceMethod 实例返回</span></span><br><span class="line"><span class="comment">             * 然后将其缓存到 serviceMethodCache 中供下次使用</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            result = ServiceMethod.parseAnnotations(<span class="built_in">this</span>, method);</span><br><span class="line">            serviceMethodCache.put(method, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> loadServiceMethod() 方法中会首先从 serviceMethodCache 中检查之前的，没有的话才会去新建一个，然后再缓存起来供下次使用。</p>
<p>注意这里在创建 ServiceMethod 实例并且放入到 serviceMethodCache 中时，会整体加锁执行，这是因为要保证创建实例和存入Map 这两步是一个完整的事务，要一起执行完毕不能中间被阻断打乱。</p>
<p>接下来逻辑的重心就在 ServiceMethod.parseAnnotations() 方法中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceMethod.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; ServiceMethod&lt;T&gt; <span class="title function_">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先通过 RequestFactory.parseAnnotations 方法来解析当前方法头、方法参数以及其注解</span></span><br><span class="line"><span class="comment">     * 并且将这些读取出来的值保存到 RequestFactory 实例内的对应属性中，供后续使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">RequestFactory</span> <span class="variable">requestFactory</span> <span class="operator">=</span> RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到当前调用方法的返回值类型，带泛型的。比如返回 returnType = Call&lt;List&lt;Contributor&gt;&gt;</span></span><br><span class="line">    <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line">    <span class="comment">// 判断该方法的返回值是否有泛型，有的话泛型类型是否是确定的，像 Call&lt;List&lt;?&gt;&gt; 这种就是不行的</span></span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(</span><br><span class="line">                method,</span><br><span class="line">                <span class="string">&quot;Method return type must not include a type variable or wildcard: %s&quot;</span>,</span><br><span class="line">                returnType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回值类型不能是 void 的</span></span><br><span class="line">    <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Service methods cannot return void.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建真正的 HttpServiceMethod 实例 </span></span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，首先会调用 RequestFactory.parseAnnotations() 方法来构建一个 RequestFactory 实例，其内部在构建 RequestFactory 实例时，回去解析当前方法中的注解信息，下面看看该方法中是怎么处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestFactory.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RequestFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> RequestFactory <span class="title function_">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> &#123;</span><br><span class="line">        <span class="comment">// 实际是通过 Builder 来完成 RequestFactory 的创建的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Builder</span>(retrofit, method).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">        Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">            <span class="built_in">this</span>.retrofit = retrofit;</span><br><span class="line">            <span class="built_in">this</span>.method = method;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 保存该方法方法头上的注释列表</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 保存该方法入参对应的类型，比如:</span></span><br><span class="line"><span class="comment">             * Call&lt;List&lt;Contributor&gt;&gt; contributors(<span class="doctag">@Path</span>(&quot;owner&quot;) String owner, <span class="doctag">@Path</span>(&quot;repo&quot;) String repo);</span></span><br><span class="line"><span class="comment">             * 此时 parameterTypes 拿到的就是： [String ， String]</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 保存该方法入参对应的注解，比如:</span></span><br><span class="line"><span class="comment">             * Call&lt;List&lt;Contributor&gt;&gt; contributors(<span class="doctag">@Path</span>(&quot;owner&quot;) String owner, <span class="doctag">@Path</span>(&quot;repo&quot;) String repo);</span></span><br><span class="line"><span class="comment">             * parameterAnnotationsArray 拿到的就是： <span class="doctag">@Path</span>(&quot;owner&quot;) ， <span class="doctag">@Path</span>(&quot;repo&quot;)</span></span><br><span class="line"><span class="comment">             * 而为啥 parameterAnnotationsArray 为啥是个二维数组呢？因为同一个入参上面可能有多个注解描述它</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 因此说：parameterAnnotationsArray.length==parameterTypes.length</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        RequestFactory <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 遍历方法头上的注释，比如: <span class="doctag">@GET</span>(&quot;/repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">                parseMethodAnnotation(annotation);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 上面 parseMethodAnnotation() 解析完之后，发现该方法没有定义 HTTP 相关的注解，比如 @GET</span></span><br><span class="line">            <span class="keyword">if</span> (httpMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有 body 时的判断</span></span><br><span class="line">            <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> methodError(</span><br><span class="line">                            method,</span><br><span class="line">                            <span class="string">&quot;Multipart can only be specified on HTTP methods with request body (e.g., @POST).&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> methodError(</span><br><span class="line">                            method,</span><br><span class="line">                            <span class="string">&quot;FormUrlEncoded can only be specified on HTTP methods with &quot;</span></span><br><span class="line">                                    + <span class="string">&quot;request body (e.g., @POST).&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> parameterAnnotationsArray.length;</span><br><span class="line">            parameterHandlers = <span class="keyword">new</span> <span class="title class_">ParameterHandler</span>&lt;?&gt;[parameterCount];</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 遍历当前方法入参对应的注解列表，然后挨个处理每个入参上的注解</span></span><br><span class="line"><span class="comment">             * 挨个解析每个入参上的注解，然后解析到的结果存储到 parameterHandlers 数组指定位置上去</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, lastParameter = parameterCount - <span class="number">1</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line"></span><br><span class="line">                parameterHandlers[p] =</span><br><span class="line">                        parseParameter(p, parameterTypes[p], parameterAnnotationsArray[p], p == lastParameter);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 其他参数的合法性判断</span></span><br><span class="line">            <span class="keyword">if</span> (relativeUrl == <span class="literal">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Missing either @%s URL or @Url parameter.&quot;</span>, httpMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Non-body HTTP method cannot contain @Body.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Form-encoded method must contain at least one @Field.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">                <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Multipart method must contain at least one @Part.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestFactory</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在  RequestFactory.parseAnnotations() 方法中，会先创建一个 RequestFactory.Builder 实例，此时在 RequestFactory.Builder 类的构造方法中就会去提前拿到当前方法中的注解，比如在方法头上加的注解保存到 methodAnnotations 中，方法中的入参类型列表保存到 parameterTypes 中，方法中入参上的注释保存到 parameterAnnotationsArray 中，接着调用其 build() 方法来完成上面这三个属性的处理：</p>
<p>先处理 methodAnnotations 列表中的注解，也就是处理当前方法头上的注解，挨个调用 parseMethodAnnotation() 方法来完成解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestFactory.java</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseMethodAnnotation</span><span class="params">(Annotation annotation)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断方法头上的注释是那种，比如是 @GET 时</span></span><br><span class="line">    <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> DELETE) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">&quot;DELETE&quot;</span>, ((DELETE) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> GET) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">&quot;GET&quot;</span>, ((GET) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HEAD) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">&quot;HEAD&quot;</span>, ((HEAD) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PATCH) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">&quot;PATCH&quot;</span>, ((PATCH) annotation).value(), <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> POST) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">&quot;POST&quot;</span>, ((POST) annotation).value(), <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> PUT) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">&quot;PUT&quot;</span>, ((PUT) annotation).value(), <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> OPTIONS) &#123;</span><br><span class="line">        parseHttpMethodAndPath(<span class="string">&quot;OPTIONS&quot;</span>, ((OPTIONS) annotation).value(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> HTTP) &#123;</span><br><span class="line">        <span class="type">HTTP</span> <span class="variable">http</span> <span class="operator">=</span> (HTTP) annotation;</span><br><span class="line">        parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> retrofit2.http.Headers) &#123;</span><br><span class="line">        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();</span><br><span class="line">        <span class="keyword">if</span> (headersToParse.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method, <span class="string">&quot;@Headers annotation is empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        headers = parseHeaders(headersToParse);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Multipart) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Only one encoding annotation is allowed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        isMultipart = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> FormUrlEncoded) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Only one encoding annotation is allowed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        isFormEncoded = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseHttpMethodAndPath</span><span class="params">(String httpMethod, String value, <span class="type">boolean</span> hasBody)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前已经遇到过 httpMethod 了，也就是当前方法方法头上定义了不止一个 HTTP 注解</span></span><br><span class="line">    <span class="comment">// 此时会直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.httpMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method,</span><br><span class="line">                <span class="string">&quot;Only one HTTP method is allowed. Found: %s and %s.&quot;</span>,</span><br><span class="line">                <span class="built_in">this</span>.httpMethod, httpMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HTTP Method 名，比如 &quot;GET&quot; / &quot;POST&quot;</span></span><br><span class="line">    <span class="built_in">this</span>.httpMethod = httpMethod;</span><br><span class="line">    <span class="comment">// 是否存在 body ，&quot;GET&quot;时是false，&quot;POST&quot;时是true</span></span><br><span class="line">    <span class="built_in">this</span>.hasBody = hasBody;</span><br><span class="line">    <span class="comment">// 方法头上注释的值，比如：&quot;/repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续开始处理 PATH</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">question</span> <span class="operator">=</span> value.indexOf(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    <span class="comment">// 存在？ 的话，那么这里判断 ? 之后的 query 部分是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (question != -<span class="number">1</span> &amp;&amp; question &lt; value.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Ensure the query string does not have any named parameters.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queryParams</span> <span class="operator">=</span> value.substring(question + <span class="number">1</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">queryParamMatcher</span> <span class="operator">=</span> PARAM_URL_REGEX.matcher(queryParams);</span><br><span class="line">        <span class="keyword">if</span> (queryParamMatcher.find()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> methodError(</span><br><span class="line">                    method,</span><br><span class="line">                    <span class="string">&quot;URL query string \&quot;%s\&quot; must not have replace block. &quot;</span></span><br><span class="line">                            + <span class="string">&quot;For dynamic query parameters use @Query.&quot;</span>,</span><br><span class="line">                    queryParams);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.relativeUrl = value;</span><br><span class="line">    <span class="built_in">this</span>.relativeUrlParamNames = parsePathParameters(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的 parseMethodAnnotation() 方法内它主要是处理方法头上的注释的。比如前面例子中的：@GET(“&#x2F;repos&#x2F;{owner}&#x2F;{repo}&#x2F;contributors”) 。</p>
<p>回到 RequestFactory#build()方法中接着往下看，会在上面 parseMethodAnnotation() 方法中解析完方法头上的注释之后，判断状态是否正确，比如此时 httpMethod 是否为空，为空的话表示当前方法的方法头上没有定义 HTTP 类型的注解，比如 @GET，那么此时会抛出异常，当然还有其他判断。</p>
<p>接着往后会开始处理 parameterAnnotationsArray 中的注解，也就是当前方法每个入参上加的注解，比如前面例子中的 @Path 。这里会挨个处理注解，并将解析到的结果存储到 parameterHandlers 数组中对应位置上。这里看看解析用的方法 parseParameter()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestFactory.java</span></span><br><span class="line"></span><br><span class="line">ParameterHandler&lt;?&gt; parseParameter(</span><br><span class="line">        <span class="type">int</span> p, Type parameterType, <span class="meta">@Nullable</span> Annotation[] annotations, <span class="type">boolean</span> allowContinuation) &#123;</span><br><span class="line">    ParameterHandler&lt;?&gt; result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (annotations != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历当前入参上加的所有注解，解析每一个注解。当然一般只有一个。</span></span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            <span class="comment">// 解析当前入参上 当前循环到的注解 annotation ，</span></span><br><span class="line">            ParameterHandler&lt;?&gt; annotationAction =</span><br><span class="line">                    parseParameterAnnotation(p, parameterType, annotations, annotation);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (annotationAction == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前参数上有两个 Retrofit 注解，此时抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> parameterError(</span><br><span class="line">                        method, p, <span class="string">&quot;Multiple Retrofit annotations found, only one allowed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有多个的话，只用第一个，当然也不会有两个，因为遇到第二个上面就会抛出异常</span></span><br><span class="line">            result = annotationAction;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前参数上没有注解</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前处理的是最后一个入参的话 allowContinuation = true</span></span><br><span class="line">        <span class="keyword">if</span> (allowContinuation) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断该参数类型是不是 Continuation ，使得话表示他是一个协程挂起方法</span></span><br><span class="line">                <span class="comment">// 那么会将 isKotlinSuspendFunction 参数置为 true</span></span><br><span class="line">                <span class="keyword">if</span> (Utils.getRawType(parameterType) == Continuation.class) &#123;</span><br><span class="line">                    isKotlinSuspendFunction = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoClassDefFoundError ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> parameterError(method, p, <span class="string">&quot;No Retrofit annotation found.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parameterType() 方法中会解析每个入参上加的注释。这里需要注意下该方法的最后一个入参 allowContinuation 的值，当遍历到最后一个参数时他会被置为 true ，否则就一直是 false 。</p>
<p>而在方法内部会判断每个参数上加的注解不能超过一个，否则直接抛出异常，注意这里说的注解是 Retrofit 中的注解，你加其他的注解没问题。</p>
<p>最后会在 allowContinuation  &#x3D; true ，也就是最后一个参数时，并且该参数上没有加任何 Retrofit  注解，这种情况下会判断它是不是 kotlin.coroutines.Continuation 类型的，是的话表示当前方法是一个协程挂起方法。为什么呢？可以看看我写的协程原理介绍的系列文章：<a href="4ee2033c.html">站点文章索引 中的 Coroutine部分</a> 。</p>
<p>至此，  RequestFactory.parseAnnotations() 方法就介绍完了，最终也就拿到了该 RequestFactory 实例。</p>
<p>接着回到 ServiceMethod.parseAnnotations() 方法中来，执行完上面逻辑拿到了 RequestFactory  实例，接着往下会判断当前方法的返回值类型，不能是那种不确定的泛型，即比如  Call&lt;List&lt;?&gt;&gt; 这种就是不行的，当然也不能是无返回值的void 。</p>
<p>最后会调用  HttpServiceMethod.parseAnnotations() 方法来完成 HttpServiceMethod 实例的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServiceMethod.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title function_">parseAnnotations</span><span class="params">(</span></span><br><span class="line"><span class="params">        Retrofit retrofit, Method method, RequestFactory requestFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前方法是否是协程挂起方法</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isKotlinSuspendFunction</span> <span class="operator">=</span> requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">continuationWantsResponse</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">continuationBodyNullable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到当前方法头上的注释</span></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    Type adapterType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前方法的返回值，分为两种类型，一种是协程挂起方法的返回值获取，另外一种是其他方法的返回值获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">        <span class="comment">// 当是协程挂起方法时，此时拿到该方法的参数列表</span></span><br><span class="line">        Type[] parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        <span class="comment">// 拿到该方法中最后一个参数 kotlin.coroutines.Continuation</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span></span><br><span class="line">                Utils.getParameterLowerBound(<span class="number">0</span>, (ParameterizedType) parameterTypes[parameterTypes.length - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 判断该 kotlin.coroutines.Continuation  参数是否是泛型类型的，当然肯定是....</span></span><br><span class="line">        <span class="keyword">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该 kotlin.coroutines.Continuation  参数对应的泛型类型，作为该挂起方法的返回值</span></span><br><span class="line">            responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) responseType);</span><br><span class="line">            <span class="comment">// 拿到该挂起方法的返回值了，将 continuationWantsResponse 置为 true</span></span><br><span class="line">            continuationWantsResponse = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当然这种情况基本不可能发生</span></span><br><span class="line">        &#125;</span><br><span class="line">        adapterType = <span class="keyword">new</span> <span class="title class_">ParameterizedTypeImpl</span>(<span class="literal">null</span>, Call.class, responseType);</span><br><span class="line">        annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到普通方法的返回值类型</span></span><br><span class="line">        adapterType = method.getGenericReturnType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 返回值类型 和 注解，返回一个 CallAdapter</span></span><br><span class="line"><span class="comment">     * 如果Service方法返回值是： Call&lt;T&gt; 的话，那么使用的是 DefaultCallAdapterFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到该 CallAdapter 对应真正类型，比如是 Call&lt;User&gt;  时，这里获取到的就是泛型的类型 User</span></span><br><span class="line">    <span class="type">Type</span> <span class="variable">responseType</span> <span class="operator">=</span> callAdapter.responseType();</span><br><span class="line">    <span class="comment">// 返回值的泛型类型不能是  okhttp3.Response 和 Response</span></span><br><span class="line">    <span class="keyword">if</span> (responseType == okhttp3.Response.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method,</span><br><span class="line">                <span class="string">&quot;&#x27;&quot;</span> + getRawType(responseType).getName()</span><br><span class="line">                        + <span class="string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseType == Response.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">&quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (requestFactory.httpMethod.equals(<span class="string">&quot;HEAD&quot;</span>) &amp;&amp; !Void.class.equals(responseType)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodError(method, <span class="string">&quot;HEAD method must use Void as response type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到解析 Response 的 Converter</span></span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);</span><br><span class="line">    okhttp3.Call.<span class="type">Factory</span> <span class="variable">callFactory</span> <span class="operator">=</span> retrofit.callFactory;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果不是挂起方法的话，那么就只是使用 CallAdapted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CallAdapted</span>&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) &#123;</span><br><span class="line">        <span class="comment">// 有返回值的挂起方法则使用 SuspendForResponse 实例</span></span><br><span class="line">        <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SuspendForResponse</span>&lt;&gt;(</span><br><span class="line">                        requestFactory,</span><br><span class="line">                        callFactory,</span><br><span class="line">                        responseConverter,</span><br><span class="line">                        (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有返回值的挂起方法则使用 SuspendForBody</span></span><br><span class="line">        <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SuspendForBody</span>&lt;&gt;(</span><br><span class="line">                        requestFactory,</span><br><span class="line">                        callFactory,</span><br><span class="line">                        responseConverter,</span><br><span class="line">                        (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">                        continuationBodyNullable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中逻辑较多，下面一步步来讲解：</p>
<p>① 获取当前方法的返回类型，这里分为两种情况：获取协程挂起方法的返回值和获取普通方法的返回值。其中后者很简单就是通过 method.getGenericReturnType() 拿到就行了，而前者怎么实现呢？怎么获取挂起方法的返回值呢？</p>
<p>我们知道，当然如果你不知道，你可以先去看看我写的协程原理的系列文章：<a href="4ee2033c.html">站点文章索引 中的 Coroutine部分</a> 。那么从这里开始我认为你是看了文章对协程挂起方法理解了的。协程挂起方法在编译之后，回往方法的最后一位插入一个 kotlin.coroutines.Continuation 类型的参数，当然该 kotlin.coroutines.Continuation是支持泛型，其泛型类型就代表着最终该挂起方法的返回值。因为如果你把  kotlin.coroutines.Continuation 当做一个 Callback 来理解就好懂些，不然建议你还是再去看看这些文章 <a href="4ee2033c.html">站点文章索引 中的 Coroutine部分</a> ，再琢磨琢磨。</p>
<p>所以这里获取协程的返回值时调用的是 method.getGenericParameterTypes() 拿到入参类型的列表，接着拿 parameterTypes.length - 1 最后一位参数，然后取它的泛型类型来作为返回值类型的。</p>
<p>② 接着会通过 createCallAdapter() 方法来创建一个 CallAdapter 实例，关于 CallAdapter 相关的分析详见 ：<a href="3e87a46f.html">Retrofit-执行中的秘密</a></p>
<p>③ 接着拿到 CallAdapter 中返回的 responseType ，也就是当前方法定义的返回值中的泛型类型，比如上面例子中定义的返回值时 Call&lt;List<Contributor>&gt; ，那么这里拿到的 responseType 就是 List<Contributor> ，有了这个类型，后面就可以选择合适的 Converter 实例来进行类型转换了。所以接下来就是获取一个对应的 Converter 实例 ，关于 Converter 的分析详见 <a href="3e87a46f.html">Retrofit-执行中的秘密</a></p>
<p>④ 根据当前方法的类型来创建不同的 HttpServiceMethod 实例。下面分为三种情况：</p>
<ul>
<li>如果当前不是挂起方法时，此时会将 callFactory 、callAdapter 以及 Converter  实例保存到 CallAdapted 实例中返回。</li>
<li>如果当前是挂起方法并且拿到了其返回值时，此时会将 callFactory 、callAdapter 以及 Converter  实例保存到 SuspendForResponse 实例中返回。</li>
<li>如果当前是挂起方法但没有拿到其返回值时，此时会将 callFactory 、callAdapter 以及 Converter  实例保存到 SuspendForBody  实例中返回。</li>
</ul>
<p>注意这里说到的 callFactory  实际是 okhttp3.Call.Factory 接口的实现类，一般就是 OkHttpClient 实例，当然外部可以在创建 Retrofit 时，通过其 Builder 指定。</p>
<p>至此，loadServiceMethod() 方法执行完毕了，拿到了其返回的 ServiceMethod 实例，实际是 HttpServiceMethod  的几个子类实例。接着回到 Retrofit.java#create() 方法内创建的 InvocationHandler 实例中，下一步应该是调用这个 HttpServiceMethod   的 invoke() 方法来将外部开发者调用时传入的参数传进去来执行真正的逻辑了，这些统一放在下一篇 <a href="3e87a46f.html">Retrofit-执行中的秘密</a> 中去讲。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/retrofit/">retrofit</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/3e87a46f.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Retrofit-执行中的秘密</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/a4b11ed8.html">
        <span class="next-text nav-default">OkHttp 连接缓存池</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
