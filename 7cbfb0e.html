<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="SurfaceFlinger - REFRESH - (1)"/>




  <meta name="keywords" content="AndroidFrameworks,SurfaceFlinger," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/7cbfb0e.html"/>


<meta name="description" content="正如前文中所分析的，在 SurfaceFlinger 中会先处理 MessageQueue::INVALIDATE 消息，会遍历其中所有的 Layer ，找出此时需要显示的那些 Layer ，挨个调用其latchBuffer 方法来更新其内部帧数据 GraphicBuffer ，以供后续显示时使用。 当处理完 INVALIDATE 消息之后，绝大多数情况下会执行 REFRESH 消息来进行绘制显示">
<meta property="og:type" content="article">
<meta property="og:title" content="SurfaceFlinger - REFRESH - (1)">
<meta property="og:url" content="https://youngkaaa.github.io/7cbfb0e.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="正如前文中所分析的，在 SurfaceFlinger 中会先处理 MessageQueue::INVALIDATE 消息，会遍历其中所有的 Layer ，找出此时需要显示的那些 Layer ，挨个调用其latchBuffer 方法来更新其内部帧数据 GraphicBuffer ，以供后续显示时使用。 当处理完 INVALIDATE 消息之后，绝大多数情况下会执行 REFRESH 消息来进行绘制显示">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-05T12:40:56.000Z">
<meta property="article:modified_time" content="2023-02-24T12:16:16.629Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="SurfaceFlinger">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> SurfaceFlinger - REFRESH - (1) - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          SurfaceFlinger - REFRESH - (1)
        
      </h1>

      <time class="post-time">
          8月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>正如<a href="5440e75b.html">前文中</a>所分析的，在 SurfaceFlinger 中会先处理 MessageQueue::INVALIDATE 消息，会遍历其中所有的 Layer ，找出此时需要显示的那些 Layer ，挨个调用其latchBuffer 方法来更新其内部帧数据 GraphicBuffer ，以供后续显示时使用。</p>
<p>当处理完 INVALIDATE 消息之后，绝大多数情况下会执行 REFRESH 消息来进行绘制显示。</p>
<p>老规矩，先看下相关源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 mRefreshPending 和 mRepaintEverything 置为 false</span></span><br><span class="line">  mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> repaintEverything = mRepaintEverything.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预处理</span></span><br><span class="line">  <span class="built_in">preComposition</span>();</span><br><span class="line">  <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line">  <span class="built_in">calculateWorkingSet</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历当前所有的显示设备，挨个进行刷新、绘制显示</span></span><br><span class="line">  <span class="comment">// 当然一般情况下只有一个显示设备</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp;[token, display]: mDisplays) &#123;</span><br><span class="line">    <span class="built_in">beginFrame</span>(display);</span><br><span class="line">    <span class="built_in">prepareFrame</span>(display);</span><br><span class="line">    <span class="built_in">doDebugFlashRegions</span>(display, repaintEverything);</span><br><span class="line">    <span class="built_in">doComposition</span>(display, repaintEverything);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">logLayerStats</span>();</span><br><span class="line">  <span class="built_in">postFrame</span>();</span><br><span class="line">  <span class="built_in">postComposition</span>();</span><br><span class="line"></span><br><span class="line">  mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">  mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp;[token, displayDevice]: mDisplays) &#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">    mHadClientComposition =</span><br><span class="line">        mHadClientComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">    mHadDeviceComposition =</span><br><span class="line">        mHadDeviceComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mVsyncModulator.<span class="built_in">onRefreshed</span>(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">  mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 handleMessageRefresh() 中，逻辑步骤较多，这里先不总述，先拆分成单个的方法来分析，等分析完成之后，再完成小结。</p>
<h3 id="preComposition"><a href="#preComposition" class="headerlink" title="preComposition"></a>preComposition</h3><p>先看其源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  mRefreshStartTime = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从下往上遍历 ，然后对每个 Layer 调用其 onPreComposition 判断其是否还有未处理的的 Frame ，</span></span><br><span class="line">   <span class="comment">// 如果有就将 needExtraInvalidate 置为 true ，表示需要进行额外的合成和渲染操作</span></span><br><span class="line">  mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer *layer) &#123;</span><br><span class="line">    <span class="comment">// onPreComposition ： 该 layer 中的消费队列中如果还有待处理的 Buffer 的话，则返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;<span class="built_in">onPreComposition</span>(mRefreshStartTime)) &#123;</span><br><span class="line">      needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有 layer 中还有待处理的 buffer 的话，则会再次请求vsync ，等待下次vsync到达时再处理</span></span><br><span class="line">  <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">    <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// BufferLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::onPreComposition</span><span class="params">(<span class="type">nsecs_t</span> refreshStartTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mBufferLatched 在 latchBuffer 方法中会被置为true</span></span><br><span class="line">    <span class="keyword">if</span> (mBufferLatched) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">        mFrameEventHistory.<span class="built_in">addPreComposition</span>(mCurrentFrameNumber, refreshStartTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前面 latchBuffer 之后会置为 true ，表示当前获取到了待处理的 Buffer ，此时将其置为false</span></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果还有待处理的 Buffer ，那么则返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasReadyFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>preComposition() 方法中的逻辑比较简单，就是遍历 mDrawingState.layersSortedByZ 集合中的 Layer ，挨个调用其 onPreComposition() 方法，来通知这些 Layer 马上要进行合成工作了，这些 Layer 内部可以在此时完成一些合成前的初始化工作。</p>
<p>比如对于 BufferQueueLayer 来说，该方法在其父类 BufferLayer 中实现了，会将一些属性值重置掉，然后返回 ：hasReadyFrame() ，即当前 Layer 中是否还有待消费处理的帧数据。</p>
<p>在 <a href="5440e75b.html">前文INVALIDATE</a> 中的  SurfaceFlinger::handlePageFlip() 方法中分析到：如果有 Layer 的 hasReadyFrame() 返回true 也就是有待消费的帧数据时，会调用其 latchBuffer 方法来取出一个待处理的数据。也就是说能调用 latchBuffer 方法的前提肯定是该 Layer 的 hasReadyFrame() 方法返回 true 了。而在 latchBuffer() 中会从生产消费队列中出队一个待消费的 BufferItem ，同时将其内部的 mQueuedFrames 递减，那么这里再次调用 hasReadyFrame() 方法时就可能是  false ，因为 mQueuedFrames 的值发生了变化。</p>
<p>而当前 preComposition() 方法是在 latchBuffer() 方法执行之后调用的，所以此时还需要再调用一次 hasReadyFrame() 方法来判断当前 Layer 是否还有 <strong>下一帧</strong> 待消费处理的数据，而不是直接将其认为是肯定有的而返回 true 。</p>
<p>回到 SurfaceFlinger::preComposition() 方法中来，当有任意一个 Layer 的 onPreComposition() 方法返回了 true，也就是有存在至少一个 Layer 中还有待消费的帧数据，那么会将 needExtraInvalidate 置为 true，然后调用 signalLayerUpdate() 方法去触发下一次刷新。</p>
<h3 id="rebuildLayerStacks"><a href="#rebuildLayerStacks" class="headerlink" title="rebuildLayerStacks"></a>rebuildLayerStacks</h3><p>先看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只重建可见的脏区域</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mVisibleRegionsDirty)) &#123;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 mGeometryInvalid 置为 true ，这个值影响后续是否需要 hwc 合成</span></span><br><span class="line">    <span class="built_in">invalidateHwcGeometry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对每一个显示设备重建可见Layer</span></span><br><span class="line"><span class="comment">     * 其实就是遍历每个 DisplayDevice ，并且针对每个 DisplayDevice 都会再遍历一遍所有的 Layer ，计算出每个 DisplayDevice 中有那些 Layer 是需要展示的</span></span><br><span class="line"><span class="comment">     * 以及每个 Layer 要在该 DisplayDevice 上展示的区域，都存在该 DisplayDevice 内部的 mCompositionDisplay 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;pair: mDisplays) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// mDisplays 是一个 map，它是 value 就是 DisplayDevice</span></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> &amp;displayDevice = pair.second;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// DisplayDevice 的 getCompositionDisplay ，返回一个 std::shared_ptr&lt; compositionengine::Display &gt;</span></span><br><span class="line">      <span class="comment">// getCompositionDisplay 位于 DisplayDevice.h 中</span></span><br><span class="line">      <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Display 继承自 Output ， Output 的 getState ，返回一个 OutputCompositionState</span></span><br><span class="line">      <span class="comment">// displayState ： OutputCompositionState ： 是输出的原始合成状态数据</span></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> &amp;displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//两个区域， opaqueRegion 是不透明区域， dirtyRegion 是脏区域</span></span><br><span class="line">      Region opaqueRegion;</span><br><span class="line">      Region dirtyRegion;</span><br><span class="line">      <span class="comment">// OutputLayers 其实就是一个 vector&lt;compositionengine::OutputLayer&gt;</span></span><br><span class="line">      compositionengine::Output::OutputLayers layersSortedByZ;</span><br><span class="line"></span><br><span class="line">      Vector&lt;sp&lt;Layer&gt;&gt; deprecated_layersSortedByZ;</span><br><span class="line">      Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// transform 是逻辑到物理的转换</span></span><br><span class="line">      <span class="type">const</span> ui::Transform &amp;tr = displayState.transform;</span><br><span class="line">      <span class="comment">// bounds 是物理显示屏的区域，也就是显示屏的宽高区域，比如是(LTRB)：[0,0,480,800]</span></span><br><span class="line">      <span class="type">const</span> Rect bounds = displayState.bounds;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * OutputCompositionState 是输出合成的原始数据, 如果它的 isEnabled 为 false ,</span></span><br><span class="line"><span class="comment">       * 则表示这个 DisplayDevice 不需要此次合成, 所以这里就不需要执行具体的逻辑</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有Layer，计算每个可见Layer 在当前displayDevice 中的可见区域等</span></span><br><span class="line">        <span class="built_in">computeVisibleRegions</span>(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有需要绘制的 Layer ,这里是从底向上遍历的，而 computeVisibleRegions 中是从上往下遍历的</span></span><br><span class="line">        mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer *layer) &#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 从 BufferLayer 开始(继承关系)，内部就会存在一个 compositionengine::Layer 实例,叫做 compositionLayer </span></span><br><span class="line"><span class="comment">           * 该 Layer 中有 layerFE 那些参数，指向的又是这个 BufferLayer ，也就是互相引用了</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">auto</span> compositionLayer = layer-&gt;<span class="built_in">getCompositionLayer</span>();</span><br><span class="line">          <span class="keyword">if</span> (compositionLayer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="type">const</span> <span class="keyword">auto</span> displayId = displayDevice-&gt;<span class="built_in">getId</span>();</span><br><span class="line">          <span class="comment">// 拿到 BufferLayer 实例</span></span><br><span class="line">          sp&lt;compositionengine::LayerFE&gt; layerFE = compositionLayer-&gt;<span class="built_in">getLayerFE</span>();</span><br><span class="line"></span><br><span class="line">          <span class="type">bool</span> needsOutputLayer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 只有显示设备与 layerStackId 匹配时才需要输出到显示设备中</span></span><br><span class="line">          <span class="keyword">if</span> (display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(), layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">            <span class="comment">// 拿到当前 layer 剔除掉全透明区域之后，剩余的要绘制展示的区域，</span></span><br><span class="line">            <span class="comment">// transform可以暂时都不考虑，认为transfrom之后数据原封不动</span></span><br><span class="line">            Region <span class="built_in">drawRegion</span>(tr.<span class="built_in">transform</span>(layer-&gt;visibleNonTransparentRegion));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 layer 要绘制的区域 和 display 的边框区域  取交集，交集区域才是当前 layer 绘制区域落在屏幕上的内容</span></span><br><span class="line">            <span class="comment">// 也就是该 layer 最终在该 display 上绘制显示的区域</span></span><br><span class="line">            drawRegion.<span class="built_in">andSelf</span>(bounds);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果计算出来的该区域不为空，表示该 layer 需要在该 display 上显示内容，此时将needsOutputLayer 置为 true</span></span><br><span class="line">            <span class="keyword">if</span> (!drawRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">              <span class="comment">// 是否需要输出显示</span></span><br><span class="line">              needsOutputLayer = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果存在至少一个 Layer 需要在当前 Display 显示设备上输出展示，那么将其加入到 layersSortedByZ 列表中</span></span><br><span class="line">          <span class="comment">// layersSortedByZ 是 compositionengine::Output::OutputLayers 类型的，存储的是 compositionengine::OutputLayer 列表</span></span><br><span class="line">          <span class="comment">// 而 deprecated_layersSortedByZ 存储的是 Layer 列表</span></span><br><span class="line">          <span class="keyword">if</span> (needsOutputLayer) &#123;</span><br><span class="line">            <span class="comment">// getOrCreateOutputLayer 是创建或者获取之前的 OutputLayer 并返回，优先用之前的，没有的话才创建新的</span></span><br><span class="line">            <span class="comment">// 然后将该 OutputLayer对象 放入到 layersSortedByZ 列表末尾</span></span><br><span class="line">            layersSortedByZ.<span class="built_in">emplace_back</span>(display-&gt;<span class="built_in">getOrCreateOutputLayer</span>(displayId, compositionLayer, layerFE));</span><br><span class="line">            <span class="comment">// 如果需要输出显示, 就添加到 deprecated_layersSortedByZ 中, 后面添加到显示设备中</span></span><br><span class="line">            deprecated_layersSortedByZ.<span class="built_in">add</span>(layer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到末尾刚插入的那个 OutputLayer对象 ，然后调用其 editState 方法拿到其内部的 mState </span></span><br><span class="line">            <span class="keyword">auto</span> &amp;outputLayerState = layersSortedByZ.<span class="built_in">back</span>()-&gt;<span class="built_in">editState</span>();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 修改该 OutputLayer 对象内部 State 中的 visibleRegion 为该layer 在当前 displayDevice 中展示的区域</span></span><br><span class="line"><span class="comment">             * 这个 viewport 也可以理解为设备的边框，和上面的 bounds 差不多，比如都是 (LTRB):[0,0,480,800]</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 这里先将该 Layer 的可见区域和 disvice 的可见区域 做并集，求出该 layer 最终在该 display 上绘制显示的区域</span></span><br><span class="line"><span class="comment">             * 然后 transform 之后赋值给 visibleRegion 。transform可以暂时都不考虑，认为transfrom之后数据原封不动</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 因为上面刚把这个 OutputLayer 创建出来，所以其 state 只有 hwc 被赋值了，到这里就又给 visibleRegion 赋值了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            outputLayerState.visibleRegion = tr.<span class="built_in">transform</span>(layer-&gt;visibleRegion.<span class="built_in">intersect</span>(displayState.viewport));</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果该 layer 在当前 displayDevice 中不需要展示，此时检查下该 layer 是否之前在该 displayDevice 中展示过</span></span><br><span class="line"><span class="comment">             * 如果之前展示过，则它肯定在之前的时候，执行过上面if的代码而创建了对应的 OutputLayer 并且放入到了 display 中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">bool</span> hasExistingOutputLayer = display-&gt;<span class="built_in">getOutputLayerForLayer</span>(compositionLayer.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * mLayersWithQueuedFrames 内部存储了那些已经有生产者生产了数据的那些 Layer ，</span></span><br><span class="line"><span class="comment">             * 具体是在 handlePageFlip 方法中遍历所有layer，遇到已经有 frameBuffer 待消费的就将其放入到这个里面去</span></span><br><span class="line"><span class="comment">             * 所以这里就是从 mLayersWithQueuedFrames 中查找是否存在当前 layer ，即判断当前 layer 是否内部有待消费的 buffer</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">bool</span> hasQueuedFrames = std::<span class="built_in">find</span>(mLayersWithQueuedFrames.<span class="built_in">cbegin</span>(),</span><br><span class="line">                                             mLayersWithQueuedFrames.<span class="built_in">cend</span>(),</span><br><span class="line">                                             layer) != mLayersWithQueuedFrames.<span class="built_in">cend</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasExistingOutputLayer &amp;&amp; hasQueuedFrames) &#123;</span><br><span class="line">              <span class="comment">// 如果满足以上两种情况，就将它们添加到 layersNeedingFences 列表中，这个列表就是用来设置 Fence 同步机制的</span></span><br><span class="line">              layersNeedingFences.<span class="built_in">add</span>(layer);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 最终将要展示的 OutputLayer 列表设置给 Display 中 mOutputLayersOrderedByZ 列表中</span></span><br><span class="line"><span class="comment">       * 所以每一次循环，会把该 displayDevice 中的mOutputLayersOrderedByZ 全部替换为新的</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 注意这里的 layersSortedByZ 存储的是 OutputLayer 的列表，而 deprecated_layersSortedByZ 存储的是 Layer 列表</span></span><br><span class="line"><span class="comment">       * 而这俩是挨个对应的，因为 OutputLayer 也是封装了 Layer 那些参数而已</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 并且这里的 layersSortedByZ 是存储到 display 中，也就是 mCompositionDisplay 中</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 而下面的 deprecated_layersSortedByZ 是存在 DisplayDevice 中的</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      display-&gt;<span class="built_in">setOutputLayersOrderedByZ</span>(std::<span class="built_in">move</span>(layersSortedByZ));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将最终要展示的 Layer 列表设置给 Display 中 mVisibleLayersSortedByZ</span></span><br><span class="line">      displayDevice-&gt;<span class="built_in">setVisibleLayersSortedByZ</span>(deprecated_layersSortedByZ);</span><br><span class="line">      <span class="comment">// 设置图层的 Fence 信号</span></span><br><span class="line">      displayDevice-&gt;<span class="built_in">setLayersNeedingFences</span>(layersNeedingFences);</span><br><span class="line"></span><br><span class="line">      Region undefinedRegion&#123;bounds&#125;;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 这里的 opaqueRegion 就是上面 computeVisibleRegions 方法的最后一个入参，对应的就是该方法内部的 aboveOpaqueLayers</span></span><br><span class="line"><span class="comment">       * 也就是该 Device 设备中所有 Layer 的完全不透明区域总和</span></span><br><span class="line"><span class="comment">       * transform可以暂时都不考虑，认为transfrom之后数据原封不动</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 所以其实这句就是： bounds.subtractSelf(opaqueRegion)</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 也就是先把 opaqueRegion 取反，取反之后的代表的意思就是：剔除掉所有完全不透明区域之后的剩余区域,也就是可见区域</span></span><br><span class="line"><span class="comment">       * 然后将 bounds 区域 和取反之后的区域做 并集 之后的结果就是 undefinedRegion 最终的值了</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 比如在上面 computeVisibleRegions 中的例子，有一个全屏不透明的 Layer，所以最终返回的 opaqueRegion 是 [0,0,480,800]</span></span><br><span class="line"><span class="comment">       * 也就是整个屏幕都是。其实对其取之后就是除去 [0,0,480,800] 区域之外的所有无限空间(记为 Region2 )</span></span><br><span class="line"><span class="comment">       * 而 bounds 是 [0,0,480,800] ，所以整体在去和 Region2 做交集时，最终结果就是 0，因为他俩刚好互补了</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 而如果上面只有一个顶部状态栏的layer时(且完全不透明)，[0,0,480,36] ，此时对其取反之后的值就是除[0,0,480,36]  之外的区间内容了(记为 Region3 )</span></span><br><span class="line"><span class="comment">       * 然后再使用 bounds 是 [0,0,480,800] ，所以整体在去和 Region3 做交集时，最终结果就是 [0,36,480,800],</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      undefinedRegion.<span class="built_in">subtractSelf</span>(tr.<span class="built_in">transform</span>(opaqueRegion));</span><br><span class="line"></span><br><span class="line">      display-&gt;<span class="built_in">editState</span>().undefinedRegion = undefinedRegion;</span><br><span class="line">  </span><br><span class="line">      display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">orSelf</span>(dirtyRegion);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::invalidateHwcGeometry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mGeometryInvalid = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rebuildLayerStacks() 方法中的逻辑比较复杂，苏毅相关注释也写的比较详细。下面单独展开分析。</p>
<p>进入到 rebuildLayerStacks() 方法中，首先判断的是mVisibleRegionsDirty 的值是不是 true ，这个属性在前面讲过不少次了，可以翻看前面。当它是 true 时，当前方法内部才会执行真正的逻辑，并且同时会将它置为 false。</p>
<h4 id="DisplayDevice简述"><a href="#DisplayDevice简述" class="headerlink" title="DisplayDevice简述"></a>DisplayDevice简述</h4><p>接着就开始遍历 mDisplays 列表了，而对于 mDisplays 来说，它内部存储目前所有已接入的显示设备。</p>
<p>之前在讲到 SurfaceFlinger 的初始化时提到：SurfaceFlinger 中会往 HWC 中注册监听，用来监听硬件 vsync 和 hotplug 热插拔事件，分别对应着：SurfaceFlinger::onVsyncReceived() 方法和 SurfaceFlinger::onHotplugReceived()  方法，前者这里不讲了，在之前的 Vsync 文章中<a href="6caea16d.html"> Vsync - DispSync &amp; DispSyncSource</a>。讲过了，而后者正是显示设备接入Android系统时的回调。</p>
<p>一般情况下，显示设备肯定是比 SurfaceFlinger 启动早的，因此在 SurfaceFlinger 的 init 初始化中，刚给 HWC 注册了回调，就立马会收到 onHotplugReceived()  方法的回调，通知有显示设备接入了。此时在该方法中，会先将其封装成一个 HotplugEvent 事件加入到 mPendingHotplugEvents 列表中，然后执行 SurfaceFlinger::processDisplayHotplugEventsLocked() 方法来统一处理 mPendingHotplugEvents 列表中的事件，然后经由 SurfaceFlinger::processDisplayChangesLocked() 方法来处理，最终会通过 SurfaceFlinger::setupNewDisplayDeviceInternal() 方法来创建一个 DisplayDevice 实例放入到 SurfaceFlinger 中的 mDisplays 容器中，而这个新创建出来的 DisplayDevice 就代表了硬件层面的一个显示设备。</p>
<blockquote>
<p>当然绝大多数情况下只会有一个显示设备，即 mDisplays 容器中只会有一个 DisplayDevice 实例。</p>
</blockquote>
<p>而创建的 DisplayDevice 实例中，额外还有一个 mCompositionDisplay 属性，它是一个  compositionengine::Display 类型的实例，而该属性的赋值是在 DisplayDevice 的构造方法中的，具体是通过 ：mFlinger-&gt;getCompositionEngine().createDisplay() ，也就是拿到 SurfaceFlinger 中唯一的 CompositionEngine 实例，然后调用 CompositionEngine::createDisplay() 方法来创建的 compositionengine::Display 类型的实例。</p>
<p>而 compositionengine::Display 在创建时，传入了 CompositionEngine 实例，因为它继承自compositionengine::impl::Output 类，该类中有一个 mCompositionEngine 属性会保存该 CompositionEngine 实例。</p>
<p>因此说，DisplayDevice 实例中，存在一个 compositionengine::Display 类型的实例 mCompositionDisplay 。而该 compositionengine::Display 实例是继承自compositionengine::impl::Output 的，内部会保存着SurfaceFlinger中唯一的 CompositionEngine 实例。</p>
<p>看到 DisplayDevice 中的 mCompositionDisplay 属性，是不是有点类似 BufferLayer 中的 mCompositionLayer 属性呢，mCompositionLayer 的类型是：compositionengine::Layer，他俩之间是不是有什么联系呢？往后看吧，后面再说。</p>
<p>好消息好消息，在本文之后，我又写了一篇专门针对 DisplayDevice 的文章，详见这里：<a href="127ce872.html">DisplayDevice</a></p>
<p>回到 rebuildLayerStacks() 方法中来，mVisibleRegionsDirty 是 true 时，会开始遍历 mDisplays 容器中的显示设备 DisplayDevice 。然后拿到该 DisplayDevice 中的 mCompositionDisplay 属性赋值给 display ，再调用 mCompositionDisplay.getState() 拿到该  mCompositionDisplay 中对应的  state，也就是一个 OutputCompositionState 实例赋值给 displayState 。这俩属性都代表了显示设备的信息，后续会使用它。比如后续的 displayState.transform 拿到该显示设备的变换矩阵信息，这里默认不考虑它，后续遇到transform变换可以忽略，以及后续通过 displayState.bounds 拿到的显示设备显示区域信息，比如按照LTRB顺序下的：[0,0,480,800] ，即左上和右下坐标信息，代表了该显示设备的宽高尺寸信息。</p>
<p>接着通过 displayState.isEnabled 来判断该显示设备当前是否需要进行本次的合成工作，需要的话则会进行 Layer 遍历计算工作。这里将其认为是 true 。</p>
<p>接下来是先执行 computeVisibleRegions() 方法来将当前 DisplayDevice 传入进去，去计算每个 Layer 在该 DisplayDevice 中的显示区域等信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="type">const</span> sp&lt;<span class="type">const</span> DisplayDevice&gt; &amp;displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Region &amp;outDirtyRegion, Region &amp;outOpaqueRegion)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同样还是先拿到该 DisplayDevice 中的 mCompositionDisplay 属性的值</span></span><br><span class="line">  <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 Layer 的上层 Layer 所有的不透明区域。也就是说这部分的区域是都不需要绘制的，需要从脏区域中减去</span></span><br><span class="line">  Region aboveOpaqueLayers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 Layer 的上层 Layer 所有的可见区域。</span></span><br><span class="line">  Region aboveCoveredLayers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 脏区域: 需要绘制的地方</span></span><br><span class="line">  Region dirty;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// outDirtyRegion 是要返回的绘制区域，所以这里先清除之前遗留的数据</span></span><br><span class="line">  outDirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从这里开始遍历，也就是说上面定义的变量是会随着遍历一直存在的，在按照 Z 轴遍历图层的时候</span></span><br><span class="line"><span class="comment">   * 每遍历到的一层时都需要将其添加到之前定义的区域中，因为对于它下面的图层来说，它就是上层的图层</span></span><br><span class="line"><span class="comment">   * 遍历 mDrawingState 中需要绘制的 Layer，这里传入的是一个函数 Visitor</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer *layer)</span><br><span class="line">                                        &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前遍历到的 Layer 的 mDrawingState</span></span><br><span class="line">    <span class="type">const</span> Layer::State &amp;<span class="built_in">s</span>(layer-&gt;<span class="built_in">getDrawingState</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Android支持多个屏幕，layer可以定制化的只显示到某个显示屏幕上。其中就是靠 layerStack(Layer栈) 来实现的</span></span><br><span class="line"><span class="comment">     * Layer 的 stack 值如果和 DisplayDevice 的 stack 值一样，说明这个 layer 是属于这个显示屏幕的</span></span><br><span class="line"><span class="comment">     * 所以这里跳过那些不属于当前 DisplayDevice 的 Layer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(), layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当前 Layer 的完全不透明区域</span></span><br><span class="line"><span class="comment">     * 默认初始化的 Region ，其内部只有一个 Rect， LTRB 值一开始默认都是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Region opaqueRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当前 Layer 的可见区域。这个区域是需要计算的，被上层 Layer 覆盖的，完全透明的都需要减去。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当前 Layer 被上层 Layer 覆盖的区域。（被透明区域覆盖的区域也算被覆盖区域）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Region coveredRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完全透明的区域。（这部分区域没有必要合成）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Region transparentRegion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意上面定义的 opaqueRegion 、 visibleRegion 、coveredRegion 、 transparentRegion 属性，这些都是在循环里面定义的</span></span><br><span class="line"><span class="comment">     * 所以对于每个遍历的 Layer 来说，都是全新的</span></span><br><span class="line"><span class="comment">     * 而外部定义的 aboveOpaqueLayers、aboveCoveredLayers以及 dirty ，会一直存在直到当前方法返回，所以这三个属性中的值都是会叠加的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只处理可见的 Layer </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_LIKELY</span>(layer-&gt;<span class="built_in">isVisible</span>())) &#123;</span><br><span class="line">      <span class="comment">// 该 layer 是否是透明的，比如某些情况下底部导航栏对应的Layer就是透明的</span></span><br><span class="line">      <span class="type">const</span> <span class="type">bool</span> translucent = !layer-&gt;<span class="built_in">isOpaque</span>(s);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * getScreenBounds : 获取当前 Layer 图层的边界</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 举例：</span></span><br><span class="line"><span class="comment">       *    假如外面拿到也就是显示设备的 bounds 是：[0,0,480,800]，也就是显示设备宽高是：480,800 </span></span><br><span class="line"><span class="comment">       *    底部导航栏的Layer通过 getScreenBounds() 方法拿到的 bounds是(LTRB)：[0,728,480,800]</span></span><br><span class="line"><span class="comment">       *    那此时也就是说导航栏位于屏幕最底部，宽度和屏幕一样都是480，高度是(800-728)= 72</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       *    又假如顶部状态栏Layer拿到的是 [0,0,480,36] </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      Rect <span class="built_in">bounds</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先将该 Layer 的边框区域设置为可见区域</span></span><br><span class="line">      visibleRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line"></span><br><span class="line">      ui::Transform tr = layer-&gt;<span class="built_in">getTransform</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果可见区域不为空，也就是上面拿到的 layer 的边框区域不为0</span></span><br><span class="line">      <span class="keyword">if</span> (!visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 先处理 layer 是透明的情况</span></span><br><span class="line">        <span class="keyword">if</span> (translucent) &#123;</span><br><span class="line">          <span class="comment">// 如果 layer 是透明的，判断该 Layer 是否旋转过，可以认为是 false，直接看下面 else </span></span><br><span class="line">          <span class="keyword">if</span> (tr.<span class="built_in">preserveRects</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果可以进行透明区域优化, 则执行透明区域优化</span></span><br><span class="line">            transparentRegion = tr.<span class="built_in">transform</span>(layer-&gt;<span class="built_in">getActiveTransparentRegion</span>(s));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 Transform 太复杂, 就不执行透明区域优化</span></span><br><span class="line">            transparentRegion.<span class="built_in">clear</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算 【完全不透明】 的区域 ，对于 opaqueRegion 的赋值，只有这里一处。</span></span><br><span class="line"><span class="comment">         * 所以说如果该 Layer 不是完全不透明的话，也就是不满足这里的条件，那么 opaqueRegion 就一直都是 0，</span></span><br><span class="line"><span class="comment">         * 如果满足的话 opaqueRegion 会被赋值为当前 Layer 的bounds，也就是其可见区域</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 比如遇到一个不透明的 Layer 时，就会走到这里里面去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int32_t</span> layerOrientation = tr.<span class="built_in">getOrientation</span>();</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">getAlpha</span>() == <span class="number">1.0f</span> &amp;&amp; !translucent &amp;&amp;</span><br><span class="line">            layer-&gt;<span class="built_in">getRoundedCornerState</span>().radius == <span class="number">0.0f</span> &amp;&amp;</span><br><span class="line">            ((layerOrientation &amp; ui::Transform::ROT_INVALID) == <span class="literal">false</span>)) &#123;</span><br><span class="line">          opaqueRegion = visibleRegion;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果可见区域是空, 也就是该 Layer 不可见，即没有进入到上面的if条件体内</span></span><br><span class="line"><span class="comment">     * 那么此时跳过该 Layer </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">      layer-&gt;<span class="built_in">clearVisibilityRegions</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算当前 Layer 被覆盖的区域 = 上层区域覆盖的区域 和 当前layer可见区域  取intersect交集</span></span><br><span class="line"><span class="comment">     * aboveCoveredLayers 的定义是在 traverseInReverseZOrder 之外的，所以在遍历过程中可以一直存储值,它内部存储的</span></span><br><span class="line"><span class="comment">     * 值的含义是：在遍历到当前 Layer 时，它之前的Layer(也就是它上层的 Layer)的所有 visibleRegion 显示区间的显示区域总和(并集)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第一次执行到这里时，aboveCoveredLayers 内部还是初始态，都是0,然后此时的 Layer 假设是 [  0, 728, 480, 800]</span></span><br><span class="line"><span class="comment">     * - 也就是 visibleRegion 是 [  0, 728, 480, 800]</span></span><br><span class="line"><span class="comment">     * - 那么此时计算出来的 coveredRegion 就是 [0,0,0,0],因为 aboveCoveredLayers 都是 0，取交集之后就都是 0 了</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第二次执行到这里时，aboveCoveredLayers 内部存储的是上个 Layer 的显示区间，也就是底部导航栏的区域 [0, 728, 480, 800]</span></span><br><span class="line"><span class="comment">     * - 而此时状态栏Layer 是: [0,0,480,36] ,此时两者求交集 coveredRegion 是:[  0,   0,   0,   0]</span></span><br><span class="line"><span class="comment">     * - 也就是状态栏和底部导航栏没有相交区域，上面的导航栏Layer没有对当前状态栏 Layer 产生任何遮挡</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第三次执行到这里时，aboveCoveredLayers 内部存储的是第一二个 Layer 的显示区间，也就是底部导航栏和状态栏的区域 ：</span></span><br><span class="line"><span class="comment">     * - [0,0,480,36] 、 [0,728,480,800]，而此时 Layer 假设值全屏的，是: [0,0,480,800] ,</span></span><br><span class="line"><span class="comment">     * - 此时两者求交集 coveredRegion 是:[0,0,480,36] 和 [0,728,480,800]</span></span><br><span class="line"><span class="comment">     * - 也就是说上面的导航栏和状态栏对当前全屏Layer产生了遮挡，分别遮挡了[0,0,480,36] 和 [0,728,480,800]两个区域</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 所以此时 coveredRegion 表示的就是当前 Layer 这次被上层遮挡的区域</span></span><br><span class="line"><span class="comment">     * 再次提醒一下：coveredRegion 是在循环中定义的，而aboveCoveredLayers 是在循环外定义的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    coveredRegion = aboveCoveredLayers.<span class="built_in">intersect</span>(visibleRegion);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 aboveCoveredLayers 和 visibleRegion 取并集，并且将结果存入到 aboveCoveredLayers 中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 也就是说将当前 Layer 的可视区域并入到 aboveCoveredLayers 中去，为下一个 Layer 计算做准备</span></span><br><span class="line"><span class="comment">     * 因为等到下一次遍历，下一个 Layer 也是要执行上面的 aboveCoveredLayers.intersect(visibleRegion) 逻辑来计算其被遮盖的区域的</span></span><br><span class="line"><span class="comment">     * 而当前 Layer 是在其上面的，先于它遍历，可能会对它产生遮挡，所以得记录下来当前的区域到 aboveCoveredLayers 中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第一次执行到这里时，aboveCoveredLayers 内部还是初始态，都是0, 然后此时的 Layer 假设是导航栏 [  0, 728, 480, 800]</span></span><br><span class="line"><span class="comment">     * - 也就是 visibleRegion 是 [  0, 728, 480, 800]</span></span><br><span class="line"><span class="comment">     * - 那么此时计算出来的 aboveCoveredLayers 就是 [  0, 728, 480, 800] 了</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第二次执行到这里时，aboveCoveredLayers 是上次的 [  0, 728, 480, 800], 然后此时的 Layer 假设是导状态栏[0,0,480,36]</span></span><br><span class="line"><span class="comment">     * - 也就是 visibleRegion 是 [0,0,480,36]</span></span><br><span class="line"><span class="comment">     * - 那么此时计算出来的 aboveCoveredLayers 就是: [  0,   0, 480,  36] 和 [  0, 728, 480, 800] </span></span><br><span class="line"><span class="comment">     * - 也就是内部包括了两个区域：底部导航栏 和 顶部状态栏</span></span><br><span class="line"><span class="comment">     *   </span></span><br><span class="line"><span class="comment">     * 比如第三次执行到这里时，aboveCoveredLayers 内部存储的是第一二个 Layer 的显示区间，也就是底部导航栏和状态栏的区域 ：</span></span><br><span class="line"><span class="comment">     * - [0,0,480,36] 、 [0,728,480,800]，而此时 Layer 假设值全屏的，是: [0,0,480,800] ,</span></span><br><span class="line"><span class="comment">     * - 那么此时计算出来的 aboveCoveredLayers 就是:[0,0,480,800]</span></span><br><span class="line"><span class="comment">     * - 也就是 aboveCoveredLayers 内部目前包括了整个屏幕区间</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    aboveCoveredLayers.<span class="built_in">orSelf</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * aboveOpaqueLayers 的定义是在 traverseInReverseZOrder 之外的，所以在遍历过程中可以一直存储值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这里的 subtract ，相当于 A &amp; ~B ，也就是 A 和 非B 求交集</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * aboveOpaqueLayers 表示的是当前上层完全不透明区域的区域，，对其取反~之后就是除去上层遮挡区域之后剩下的可见展示区域</span></span><br><span class="line"><span class="comment">     * 然后将其和 visibleRegion 取&amp; 交集，求出的就是 visibleRegion 可见的区域，也就是剔除掉 visibleRegion 不可见的区域之后的区域</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这里是除了上面给 visibleRegion 赋值之外，唯一修改 visibleRegion 的地方啦</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第一次执行到这里时，aboveOpaqueLayers 内部还是初始态，都是0, 然后此时的 Layer 假设是导航栏 [  0, 728, 480, 800]</span></span><br><span class="line"><span class="comment">     * - 也就是 visibleRegion 是 [  0, 728, 480, 800]。 对 aboveOpaqueLayers 取反之后再和 visibleRegion 取交集</span></span><br><span class="line"><span class="comment">     * - 那么此时计算之后 visibleRegion 就还是 [  0, 728, 480, 800]。因为上层完全不可见区域 aboveOpaqueLayers 是空的，、</span></span><br><span class="line"><span class="comment">     * - 没有对当前 Layer visibleRegion 产生任何遮挡</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 然后执行到下面：aboveOpaqueLayers.orSelf(opaqueRegion); 会修改 aboveOpaqueLayers，</span></span><br><span class="line"><span class="comment">     * 而由于opaqueRegion都是0，所以修改后 aboveOpaqueLayers 都还是 0</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第二次执行到这里时，aboveOpaqueLayers 内部还是0, 然后此时的 Layer 假设是状态栏[0,0,480,36]</span></span><br><span class="line"><span class="comment">     * - 也就是 visibleRegion 是 [0,0,480,36] 。 对 aboveOpaqueLayers 取反之后再和 visibleRegion 取交集 ，</span></span><br><span class="line"><span class="comment">     * - 那么此时计算之后 visibleRegion 就还是[0,0,480,36]。</span></span><br><span class="line"><span class="comment">     * - 因为上层完全不可见区域 aboveOpaqueLayers 还都是 0，(因为上个Layer不是完全不透明，所以aboveOpaqueLayers还是0)</span></span><br><span class="line"><span class="comment">     * - 没有对当前 Layer visibleRegion 产生任何遮挡</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 然后执行到下面：aboveOpaqueLayers.orSelf(opaqueRegion); 会修改 aboveOpaqueLayers，</span></span><br><span class="line"><span class="comment">     * 而由于opaqueRegion都是0，所以修改后 aboveOpaqueLayers 都还是 0</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第三次执行到这里时，aboveOpaqueLayers 内部还是0, 然后此时的全屏 Layer 是 [0,0,480,800] </span></span><br><span class="line"><span class="comment">     * - 也就是 visibleRegion 是 [0,0,480,800]。 对 aboveOpaqueLayers 取反之后再和 visibleRegion 取交集 ，</span></span><br><span class="line"><span class="comment">     * - 那么此时计算之后 visibleRegion 就还是 [0,0,480,800]。</span></span><br><span class="line"><span class="comment">     * - 因为上层完全不可见区域 aboveOpaqueLayers 还都是 0，(因为上个Layer不是完全不透明，所以aboveOpaqueLayers还是0)</span></span><br><span class="line"><span class="comment">     * - 没有对当前 Layer visibleRegion 产生任何遮挡</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    visibleRegion.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 Layer::doTransaction 方法中，判断出来如果 Layer 前后的 sequence 发生变化，则会将其置为 true</span></span><br><span class="line"><span class="comment">     * 也就是会将该 Layer 整体标记为 脏区，也就是整体都需要重新刷新显示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;contentDirty) &#123;</span><br><span class="line">      <span class="comment">// 这种情况下，将整个区域都设置为脏区，因为整个区域都需要刷新</span></span><br><span class="line">      dirty = visibleRegion;</span><br><span class="line">      <span class="comment">// 将当前Layer当前新的显示区域(visibleRegion) 和 之前旧的显示区域(layer-&gt;visibleRegion)合并在一起，前后整体都需要刷新</span></span><br><span class="line">      dirty.<span class="built_in">orSelf</span>(layer-&gt;visibleRegion);</span><br><span class="line">      <span class="comment">// 图层的可见区域处理了之后, 图层就没有脏区域了</span></span><br><span class="line">      layer-&gt;contentDirty = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 计算暴露区域。暴露区域由两部分组成</span></span><br><span class="line"><span class="comment">       * 1) 现在可见并且以前被覆盖的区域</span></span><br><span class="line"><span class="comment">       * 2) 现在新增的暴露区域（以前这个区域区域被遮挡了）</span></span><br><span class="line"><span class="comment">       * 新暴露的区域: 可见区域间去被覆盖的区域</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * visibleRegion : 上面计算出来是当前 Layer 可见的区域,</span></span><br><span class="line"><span class="comment">       * -  即该 Layer 的 bounds 区域减去 aboveOpaqueLayers 上层完全遮挡的区域</span></span><br><span class="line"><span class="comment">       * coveredRegion : 上面计算出来是当前 Layer 被上层遮挡的区域</span></span><br><span class="line"><span class="comment">       * -  即当前Layer上层所有可见Layer区域总和的 aboveCoveredLayers 和 该 Layer 的 bounds 区域求并集的结果区域</span></span><br><span class="line"><span class="comment">       * -  也就是当前 Layer 被上层所有 Layer 可见区域所遮挡的区域  </span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 使用 visibleRegion - coveredRegion 计算出来的就是当前 Layer 本次暴露出来的区域</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 比如第一次执行到这里时，此时的 Layer 假设是底部导航栏 [  0, 728, 480, 800] , </span></span><br><span class="line"><span class="comment">       * - 也就是 visibleRegion 是 [0,728,480,800] , 上面计算出来的 coveredRegion 就是 [0,0,0,0],</span></span><br><span class="line"><span class="comment">       * - 所以此时计算出来的 newExposed 是 [0,728,480,800], 也就是导航栏 Layer 完全显示暴露出来，没有被遮挡</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 比如第二次执行到这里时，此时的 Layer 假设是顶部状态栏 [0,0,480,36] , </span></span><br><span class="line"><span class="comment">       * - 也就是 visibleRegion 是 [0,0,480,36], 上面计算出来的 coveredRegion 就是 [0,0,0,0],</span></span><br><span class="line"><span class="comment">       * - 所以此时计算出来的 newExposed 是 [0,0,480,36], 也就是状态栏Layer 完全显示暴露出来，没有被遮挡</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 比如第三次执行到这里时，此时的 Layer 假设是全屏不透明Layer [0,0,480,800] , </span></span><br><span class="line"><span class="comment">       * - 也就是 visibleRegion 是 [0,0,480,800], 上面计算出来的 coveredRegion 就是 [0,0,480,36] 和 [0,728,480,800]</span></span><br><span class="line"><span class="comment">       * - 也就是说当前全屏 Layer 被状态栏和导航栏 遮挡了部分空间</span></span><br><span class="line"><span class="comment">       * - 所以此时计算出来的 newExposed 是[0,36,480,728], 也就是顶部状态栏和底部导航栏之间的空间是可见的</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">const</span> Region newExposed = visibleRegion - coveredRegion;</span><br><span class="line">  </span><br><span class="line">      <span class="type">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;</span><br><span class="line">      <span class="type">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 这里同理，和上面 newExposed 类似，只是计算出来的是该 Layer 上次的暴露区域</span></span><br><span class="line"><span class="comment">       * 这里拿到上一次计算出来的 visibleRegion 和 coveredRegion， 然后计算出上一次的暴露区间 oldExposed </span></span><br><span class="line"><span class="comment">       * 当同一个Layer 被多次遍历处理时，这里计算出来的 oldExposed 和 newExposed 一样，那么就表示前后没有脏区产生</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Region 重写了 &amp;， 对应的是 intersect ，也就是求交集， | 对应的就是求并集了</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * (visibleRegion &amp; oldCoveredRegion) ：现在可见，但是之前由于被遮挡而不可见的区间，因为之前被覆盖了的</span></span><br><span class="line"><span class="comment">       * (newExposed - oldExposed) ： 当前layer 前后两次暴露出去区域的差值，是新增的暴露区域</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 脏区域 = 新增的没有被覆盖的区域 + 新增的暴露区域</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * 这里计算出来的 dirty 可能是空的，也就是没有新增变化的区域，也就是没有脏区</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      dirty = (visibleRegion &amp; oldCoveredRegion) | (newExposed - oldExposed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将脏区减去上层不可见的遮挡区域，就是脏区剩余的可见的区域了</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * subtract ，相当于 A &amp; ~B ，也就是 A 和 非B 求交集</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * aboveOpaqueLayers 表示的是当前上层完全不透明区域的区域，，对其取反~之后就是除去上层遮挡区域之后剩下的可见展示区域</span></span><br><span class="line"><span class="comment">     * 然后将其和 dirty 取&amp; 交集，求出的就是 dirty 可见的区域，剔除掉 dirty 不可见的区域</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 第一次时，假设是底部导航栏Layer ，由于该 layer 是透明的，所以第一次执行到这里时 aboveOpaqueLayers是0，</span></span><br><span class="line"><span class="comment">     * -   此时opaqueRegion 也是0，因为是透明的，所以本次遍历执行完毕后 aboveOpaqueLayers 都还是0</span></span><br><span class="line"><span class="comment">     * -   所以此时 dirty 原封不动</span></span><br><span class="line"><span class="comment">     * 第二次时，假设是顶部状态栏Layer ，由于该 layer 是透明的，所以第二次执行到这里时 aboveOpaqueLayers是0，</span></span><br><span class="line"><span class="comment">     * -   此时opaqueRegion 也是0，因为是透明的，所以本次遍历执行完毕后 aboveOpaqueLayers 都还是0</span></span><br><span class="line"><span class="comment">     * -   所以此时 dirty 原封不动</span></span><br><span class="line"><span class="comment">     * 第三次时，假设是全屏Layer ，由于该 layer 是不透明的，所以第二次执行到这里时 aboveOpaqueLayers 还是0，</span></span><br><span class="line"><span class="comment">     * -   此时opaqueRegion 不是0，是visibleRegion，也就是[0,0,480,800] ，</span></span><br><span class="line"><span class="comment">     * -   所以本次遍历执行完毕后 aboveOpaqueLayers 就是 [0,0,480,800] 了，也就是整屏不透明，该Layer之下的都显不出来了</span></span><br><span class="line"><span class="comment">     * -   所以此时 dirty 原封不动</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dirty.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将新增的脏区域添加到返回参数中</span></span><br><span class="line"><span class="comment">     * outDirtyRegion 是当前方法的入参,是在 traverseInReverseZOrder 之外的，所以在遍历过程中可以一直存储值</span></span><br><span class="line"><span class="comment">     * 这里是将脏区并入到 outDirtyRegion 中，也就是 outDirtyRegion 中存储的是遍历过的每个 Layer 的脏区之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    outDirtyRegion.<span class="built_in">orSelf</span>(dirty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * opaqueRegion 的赋值只有上面一处，</span></span><br><span class="line"><span class="comment">     * 要么是等于 visibleRegion ，也就是该 Layer 是完全不透明的，满足上面的条件</span></span><br><span class="line"><span class="comment">     * 要不就是等于0的，也就是该Layer 不满足上面的条件</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 而这里是操作修改 aboveOpaqueLayers 的唯一地方。也就是将每个 Layer 的 opaqueRegion 合并在一起存储起来</span></span><br><span class="line"><span class="comment">     * 它代表的是，当前 Layer 之前的(之上的)所有 Layer 完全不可见区域的叠加总和</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 第一次时，假设是底部导航栏Layer ，由于该 layer 是透明的，所以第一次执行到这里时 aboveOpaqueLayers是0，</span></span><br><span class="line"><span class="comment">     * -   此时opaqueRegion 也是0，因为是透明的，所以下面代码执行完毕后 aboveOpaqueLayers 都还是0</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 第二次时，假设是顶部状态栏Layer ，由于该 layer 是透明的，所以第二次执行到这里时 aboveOpaqueLayers是0，</span></span><br><span class="line"><span class="comment">     * -   此时opaqueRegion 也是0，因为是透明的，所以下面代码执行完毕后 aboveOpaqueLayers 都还是0</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 第三次时，假设是全屏Layer ，由于该 layer 是不透明的，所以第二次执行到这里时 aboveOpaqueLayers 还是0，</span></span><br><span class="line"><span class="comment">     * -   此时 opaqueRegion 不是0，是 visibleRegion，也就是[0,0,480,800] ，</span></span><br><span class="line"><span class="comment">     * -   所以下面代码执行完毕后 aboveOpaqueLayers 就是 [0,0,480,800] 了，也就是整屏不透明，该Layer之下的都显示不出来了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    aboveOpaqueLayers.<span class="built_in">orSelf</span>(opaqueRegion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存当前 Layer 的可见区域，它是该 Layer 的 bounds 区域减去上层 aboveOpaqueLayers</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第一次执行到这里时，此时的 Layer 假设是底部导航栏 [  0, 728, 480, 800] , </span></span><br><span class="line"><span class="comment">     * - 而由于上面 visibleRegion.subtractSelf(aboveOpaqueLayers) 时 aboveOpaqueLayers 都是 0，</span></span><br><span class="line"><span class="comment">     * - 也就是对于 底部导航栏Layer 来说，它上面没有任何不透明Layer遮挡它，所以它完全显示</span></span><br><span class="line"><span class="comment">     * - 也就是此时 visibleRegion = [0,728,480,800]</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第二次执行到这里时，此时的 Layer 假设是顶部状态栏 [0,0,480,36] , </span></span><br><span class="line"><span class="comment">     * - 而由于上面 visibleRegion.subtractSelf(aboveOpaqueLayers) 时 aboveOpaqueLayers 还是 0，</span></span><br><span class="line"><span class="comment">     * - 因为上次底部导航栏Layer 是透明的，所以上次遍历完成后 aboveOpaqueLayers 并没有增加</span></span><br><span class="line"><span class="comment">     * - 也就是对于 顶部状态栏Layer 来说，它上面没有任何不透明Layer遮挡它，所以它完全显示</span></span><br><span class="line"><span class="comment">     * - 也就是此时 visibleRegion = [0,0,480,36]</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第三次执行到这里时，此时的 Layer 假设是全屏不透明Layer [0,0,480,800] , </span></span><br><span class="line"><span class="comment">     * - 而由于上面 visibleRegion.subtractSelf(aboveOpaqueLayers) 时 aboveOpaqueLayers 还是 0，</span></span><br><span class="line"><span class="comment">     * - 因为之前底部导航栏、顶部状态栏Layer 都是透明的，所以之前遍历完成后 aboveOpaqueLayers 并没有增加</span></span><br><span class="line"><span class="comment">     * - 也就是对于 全屏不透明Layer 来说，它上面没有任何不透明Layer遮挡它，所以它完全显示</span></span><br><span class="line"><span class="comment">     * - 也就是此时 visibleRegion = [0,0,480,800]</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    layer-&gt;<span class="built_in">setVisibleRegion</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存当前 Layer 上层被遮挡的区域，其是就是 aboveCoveredLayers 和 visibleRegion 的并集</span></span><br><span class="line"><span class="comment">     * coveredRegion 自从被赋值之后就一直没变化了，所以可以详见上面 coveredRegion 的分析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    layer-&gt;<span class="built_in">setCoveredRegion</span>(coveredRegion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * transparentRegion 大多数情况下都是空的</span></span><br><span class="line"><span class="comment">     * and : A &amp; B ,即对 A 和 B 求交集</span></span><br><span class="line"><span class="comment">     * nand : 也就是 subtract ，相当于 A &amp; ~B ，也就是 A 和 非B 求交集</span></span><br><span class="line"><span class="comment">     * transparentRegion 代表的是透明区域，而 ~B 就相当于是透明区域之外的区域，</span></span><br><span class="line"><span class="comment">     * 然后将其和 Layer 的可见区域 visibleRegion 做交集，就是 Layer 当前非透明的可见区域了</span></span><br><span class="line"><span class="comment">     * 这里主要是为了剔除全透明区域，全透明区域就可以跳过渲染了</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第一次执行到这里时，此时的 Layer 假设是底部导航栏 [  0, 728, 480, 800] , transparentRegion 都是 0，</span></span><br><span class="line"><span class="comment">     * - 此时就是 visibleRegion 和 ~transparentRegion 取交集了。最终结果等于 visibleRegion</span></span><br><span class="line"><span class="comment">     * - 也就是当前 layer 除去全透明区域剩下的显示区域是 visibleRegion</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第二次执行到这里时，此时的 Layer 假设是顶部状态栏 [0,0,480,36] , transparentRegion 还是 0，</span></span><br><span class="line"><span class="comment">     * - 此时就是 visibleRegion 和 ~transparentRegion 取交集了。最终结果等于 visibleRegion</span></span><br><span class="line"><span class="comment">     * - 也就是当前 layer 除去全透明区域剩下的显示区域是 visibleRegion</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如第三次执行到这里时，此时的 Layer 假设是全屏不透明Layer [0,0,480,800] ,transparentRegion 还是 0，</span></span><br><span class="line"><span class="comment">     * - 此时就是 visibleRegion 和 ~transparentRegion 取交集了。最终结果等于 visibleRegion</span></span><br><span class="line"><span class="comment">     * - 也就是当前 layer 除去全透明区域剩下的显示区域是 visibleRegion</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    layer-&gt;<span class="built_in">setVisibleNonTransparentRegion</span>(</span><br><span class="line">        visibleRegion.<span class="built_in">subtract</span>(transparentRegion));</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="comment">// 遍历所有 Layer 之后，将计算出来的所有 完全不透明 区域赋值给入参 outOpaqueRegion</span></span><br><span class="line">  outOpaqueRegion = aboveOpaqueLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>computeVisibleRegions() 方法中的逻辑比较难以理解，所以代码中补充了较多的注释以及举例。</p>
<p>该方法主要的目的是：在以当前遍历到的 DisplayDevice 为基础的情况下，计算所有的Layer 在其上面显示时的区域信息，比如该Layer的可见区域，被遮挡区域等。当然可能会遇到Layer不属于该 DisplayDevice 的，此时会跳过该Layer。</p>
<p>当前方法执行完毕之后，会把：①所有在该 DisplayDevice 上显示的 Layer 的完全不透明区域总和  赋值给入参outOpaqueRegion；②把所有在该 DisplayDevice 上显示的 Layer 的脏区区域总和  赋值给入参outDirtyRegion。</p>
<p>执行完computeVisibleRegions() 方法计算完 Layer 的显示区域等信息之后，接着往下执行，又开始遍历 mDrawingState.layersSortedByZ 集合中的Layer。</p>
<p>遍历到的 Layer ，首先会调用其 getCompositionLayer() 方法来获取其内部的 mCompositionLayer 属性赋值给 compositionLayer ，目前只有 ColorLayer 和 BufferLayer 实现了该方法，其他都是返回 null。后面都默认认为是 BufferLayer 。</p>
<p>再通过 compositionLayer 的 getLayerFE() 方法来拿到其内部存储的 mLayerFE 复制给 layerFE ，拿到的其实就是 BufferLayer 自身。</p>
<blockquote>
<p>BufferLayer ，以及BufferLayer 中的 mCompositionLayer 属性的关系详见：<a href="25fde216.html">BufferQueueLayer</a></p>
</blockquote>
<p>因此这里的 layerFE 可以理解为就是当前遍历到的 Layer 实例，或者直接当做 BufferQueueLayer 来理解，而compositionLayer 可以理解为是 layerFE ，也就是BufferQueueLayer 中的 mCompositionLayer 属性。正如前面所言的，这俩是互相引用的，有了其中一个都可以找到另外一个。</p>
<p>接着往下，会判断当前遍历到的 Layer 是否是位于当前 DisplayDevice 中的，是的话就会：</p>
<p>①先拿出该 Layer 中的 layer-&gt;visibleNonTransparentRegion 属性，该属性在前面 computeVisibleRegions() 方法中计算并通过调用 Layer::setVisibleNonTransparentRegion() 来设置保存给对应的Layer ，它表示的含义是该 Layer 在当前 DisplayDevice 显示设备中，剔除掉全透明区域之后，剩余的要绘制展示的区域。</p>
<p>②将其和当前 DisplayDevice 的显示区域 bounds 取交集，也也就是该 layer 最终落在该 DisplayDevice 上需要显示的区域了。如果计算出来的区域不为空，则表示该 Layer 需要在再该  DisplayDevice 中显示一些内容，此时会将 needsOutputLayer 置为 true。</p>
<p>因此这一步主要是为了计算当前遍历到的 Layer ，在经过computeVisibleRegions() 方法计算之后，是否在当前 DisplayDevice 中有内容要显示，有的话则后续需要为其创建对应的 compositionengine::OutputLayer ，没有的话则表示此时该 Layer 在当前 DisplayDevice 中不显示，再做其他操作。而具体有无显示的结果，是保存在 needsOutputLayer 属性中的。</p>
<p>因此下面根据 needsOutputLayer 来判执行不同的逻辑。</p>
<p>①如果needsOutputLayer &#x3D; true 的话，表示该Layer 在当前 DisplayDevice 中有内容要显示，此时会先通过compositionengine::Display 的 getOrCreateOutputLayer() 方法来为该 Layer 创建一个 compositionengine::OutputLayer 实例。</p>
<h4 id="OutputLayer简述"><a href="#OutputLayer简述" class="headerlink" title="OutputLayer简述"></a>OutputLayer简述</h4><p>这里插入简单讲一下 OutputLayer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OutputLayer.h</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">OutputLayer</span> : <span class="keyword">public</span> compositionengine::OutputLayer &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">OutputLayer</span>(<span class="type">const</span> compositionengine::Output&amp;, std::shared_ptr&lt;compositionengine::Layer&gt;,</span><br><span class="line">                  sp&lt;compositionengine::LayerFE&gt;);</span><br><span class="line">      ~<span class="built_in">OutputLayer</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">const</span> CompositionEngine&amp;, std::optional&lt;DisplayId&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">const</span> compositionengine::Output&amp; <span class="title">getOutput</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">      <span class="function">compositionengine::Layer&amp; <span class="title">getLayer</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">      <span class="function">compositionengine::LayerFE&amp; <span class="title">getLayerFE</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">const</span> OutputLayerCompositionState&amp; <span class="title">getState</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">      <span class="function">OutputLayerCompositionState&amp; <span class="title">editState</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">writeStateToHWC</span><span class="params">(<span class="type">bool</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 对应的 Display </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">const</span> compositionengine::Output&amp; mOutput;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 对应要展示的 Layer</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      std::shared_ptr&lt;compositionengine::Layer&gt; mLayer;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对应的 BufferQueueLayer </span></span><br><span class="line">      sp&lt;compositionengine::LayerFE&gt; mLayerFE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 状态</span></span><br><span class="line">      OutputLayerCompositionState mState;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// OutputLayerCompositionState.h</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">OutputLayerCompositionState</span> &#123;</span><br><span class="line">    <span class="comment">// 该 Layer 的可见区域</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> forceClientComposition&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Rect displayFrame;</span><br><span class="line"></span><br><span class="line">    FloatRect sourceCrop;</span><br><span class="line"></span><br><span class="line">    Hwc2::Transform bufferTransform&#123;<span class="built_in">static_cast</span>&lt;Hwc2::Transform&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// z坐标</span></span><br><span class="line">    <span class="type">uint32_t</span> z;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Hwc</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Hwc</span><span class="params">(std::shared_ptr&lt;HWC2::Layer&gt; hwcLayer)</span> : hwcLayer(hwcLayer) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The HWC Layer backing this layer</span></span><br><span class="line">        std::shared_ptr&lt;HWC2::Layer&gt; hwcLayer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储着该 hwcLayer 的 composition type</span></span><br><span class="line">        Hwc2::IComposerClient::Composition hwcCompositionType&#123;</span><br><span class="line">                Hwc2::IComposerClient::Composition::INVALID&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部就是将对应的 buffer 做了缓存而已，存储着对应的 buffer</span></span><br><span class="line">        HwcBufferCache hwcBufferCache;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 OutputLayer::initialize 中会被初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::optional&lt;Hwc&gt; hwc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里首先需要区分的就是：compositionengine::impl::OutputLayer 和 compositionengine::OutputLayer 。这里的源代码中贴出来的是前者，里面多了几个属性；而对于后者来说他内部只是定义了一些方法而已，并没有额外的属性。另外可以看到：前者是继承自后者的，在其基础上额外扩充了几个属性而已，下面简单看看其属性：</p>
<p>① mOutput：它是 compositionengine::Output 类型的，实际对应的是一个 compositionengine::Display 实例，因为compositionengine::Display 继承自 compositionengine::Output ，再往上推的话它就是 DisplayDevice 中的 mCompositionDisplay 属性实例，而 mCompositionDisplay 属性是在 DisplayDevice 一开始的构造方法中通过 SurfaceFlinger 中的 CompositionEngine 的 createDisplay() 方法来创建出来的。</p>
<p>因此，这里的 mOutput 我们可以理解为是：DisplayDevice 中的 mCompositionDisplay 。</p>
<p>② mLayer：它是 compositionengine::Layer 类型的，实际对应的是 BufferLayer 中的 mCompositionLayer ，这点在后面的逻辑中可以得到确认。</p>
<p>③ mLayerFE ：它是 compositionengine::LayerFE 类型的，实际对应的是 BufferLayer 实例，或者说是 BufferQueueLayer 实例。这点在后面的逻辑中可以得到确认。</p>
<p>④ mState ：它是 OutputLayerCompositionState 类型的，而 OutputLayerCompositionState 中有较多的属性，比如其中的 visibleRegion 、z 、forceClientComposition 、hwc 等。这些属性在后面会一一遇到。</p>
<p>下面接着看 OutputLayer 的创建工作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;compositionengine::OutputLayer&gt; <span class="title">Output::getOrCreateOutputLayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::optional&lt;DisplayId&gt; displayId, std::shared_ptr&lt;compositionengine::Layer&gt; layer,</span></span></span><br><span class="line"><span class="params"><span class="function">        sp&lt;compositionengine::LayerFE&gt; layerFE)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先从  OutputLayer 类实例的  mOutputLayersOrderedByZ 集合中查找该 layer 是否已经创建过 OutputLayer 了</span></span><br><span class="line">    <span class="comment">// 如果创建过了就直接返回之前创建的那个实例，否则才会创建一个新的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; outputLayer : mOutputLayersOrderedByZ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outputLayer &amp;&amp; &amp;outputLayer-&gt;<span class="built_in">getLayer</span>() == layer.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">move</span>(outputLayer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有的话则创建一个新的 OutputLayer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">createOutputLayer</span>(mCompositionEngine, displayId, *<span class="keyword">this</span>, layer, layerFE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OutputLayer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;compositionengine::OutputLayer&gt; <span class="title">createOutputLayer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> CompositionEngine&amp; compositionEngine, std::optional&lt;DisplayId&gt; displayId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> compositionengine::Output&amp; output, std::shared_ptr&lt;compositionengine::Layer&gt; layer,</span></span></span><br><span class="line"><span class="params"><span class="function">        sp&lt;compositionengine::LayerFE&gt; layerFE)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先创建对应的对象实例  </span></span><br><span class="line">    <span class="keyword">auto</span> result = std::<span class="built_in">make_unique</span>&lt;OutputLayer&gt;(output, layer, layerFE);</span><br><span class="line">    <span class="comment">// 调用其 initialize 方法来初始化</span></span><br><span class="line">    result-&gt;<span class="built_in">initialize</span>(compositionEngine, displayId);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OutputLayer::<span class="built_in">OutputLayer</span>(<span class="type">const</span> Output&amp; output, std::shared_ptr&lt;Layer&gt; layer, sp&lt;LayerFE&gt; layerFE)</span><br><span class="line">      : <span class="built_in">mOutput</span>(output), <span class="built_in">mLayer</span>(layer), <span class="built_in">mLayerFE</span>(layerFE) &#123;&#125;</span><br><span class="line"></span><br><span class="line">OutputLayer::~<span class="built_in">OutputLayer</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param compositionEngine   对应 SF 中的全局唯一的 CompositionEngine 对象实例，从 Display 中传入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputLayer::initialize</span><span class="params">(<span class="type">const</span> CompositionEngine&amp; compositionEngine,</span></span></span><br><span class="line"><span class="params"><span class="function">                             std::optional&lt;DisplayId&gt; displayId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!displayId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到 CompositionEngine 中的 HWComposer 对象实例，该对象实例在 SF::init 中创建</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; hwc = compositionEngine.<span class="built_in">getHwComposer</span>();</span><br><span class="line">    <span class="comment">// 通过 HWComposer 去创建一个 Layer ，保存在 hwc 中</span></span><br><span class="line">    mState.hwc.<span class="built_in">emplace</span>(std::<span class="built_in">shared_ptr</span>&lt;HWC2::Layer&gt;(hwc.<span class="built_in">createLayer</span>(*displayId),</span><br><span class="line">                                                    [&amp;hwc, displayId](HWC2::Layer* layer) &#123;</span><br><span class="line">                                                        hwc.<span class="built_in">destroyLayer</span>(*displayId, layer);</span><br><span class="line">                                                    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里说的是 ：compositionengine::Display 中的 getOrCreateOutputLayer() 方法，因为这里的 display 属性存储的是 DisplayDevice 的 mCompositionDisplay 属性，也就是compositionengine::Display 实例。但是由于compositionengine::Display 继承自compositionengine::impl::Output 类，而getOrCreateOutputLayer() 方法是属于 Output 类的。</p>
<p>另外在 Output 类中，还有一个 ：OutputLayers mOutputLayersOrderedByZ 属性，也就是一个存储 compositionengine::OutputLayer 的容器。</p>
<p>在 getOrCreateOutputLayer() 方法中，首先会判断 mOutputLayersOrderedByZ 容器中之前有没有存储该 Layer 对应的 OutputLayer ，有的话则直接返回之前的，没有的话则创建新的 OutputLayer 。</p>
<p>在创建新的  OutputLayer 时，会额外的为其创建一个 HWC2::Layer 实例，然后保存到该 Output 中的 mState 实例中的  hwc 内。具体的这里不再细讲，后面会再补充的。</p>
<p>在拿到创建好的 OutputLayer 实例之后，会将其保存到 rebuildLayerStacks() 方法中定义的  layersSortedByZ 容器内；同时还会将当前 Layer 保存到 rebuildLayerStacks() 方法中定义的  deprecated_layersSortedByZ 容器内。</p>
<p>最后给新创建出来的 OutputLayer 中的 mStae 实例内的 visibleRegion 属性赋值，赋值为：当前 Layer 在该 Display 上的显示区域，因此是将 layer-&gt;visibleRegion 和 Display 的显示区域 bounds 做交集。</p>
<p>至此，新创建出来的 OutputLayer 中的 mState 中，hwc 和 visibleRegion 属性都赋值了。</p>
<p>②如果 needsOutputLayer &#x3D; false 时，此时表示该 Layer 在该 Display 中没有显示区域，即不用显示。此时有可能是该 Layer 刚被从该 Display 中移除，那么此时需要做额外判断。如果懂了前面讲的，那么这里的 hasExistingOutputLayer 和 hasQueuedFrames 属性值的计算就不难理解了吧，这里牵扯到 fence 同步，暂时先跳过。</p>
<p>至此就完成了 if (displayState.isEnabled) 条件体内的逻辑。小结下就是：遍历所有的Layer，计算其在当前 DisplayDevice 中的显示区域信息，然后为Layer创建对应的 OutputLayer 实例，这些都会存储在对应的容器中，比如 layersSortedByZ 和 deprecated_layersSortedByZ。</p>
<p>接下来调用 display 的 setOutputLayersOrderedByZ() 方法来保存前面计算出来的 layersSortedByZ 。也就是说 layersSortedByZ 容器中的 OutputLayer 实例们，最终都会存储在该 compositionengine::Display ，也就是compositionengine::impl::Output 中的 mOutputLayersOrderedByZ 属性中，后续调用其 getOrCreateOutputLayer() 等方法时就可以用到了。</p>
<p>接着将 deprecated_layersSortedByZ 保存到当前 DisplayDevice 中的 mVisibleLayersSortedByZ 属性中。</p>
<p>而 layersSortedByZ 和 deprecated_layersSortedByZ 中的元素是一一对应的，因此 compositionengine::impl::Output 中的 mOutputLayersOrderedByZ 和 DisplayDevice 中的 mVisibleLayersSortedByZ 中的元素也是一一对应的了。</p>
<p>最后一步是修改 compositionengine::impl::Output 实例的 mState 中的  undefinedRegion 和 dirtyRegion 的值。</p>
<p>至此就完成了 mDisplays 循环中的逻辑，这样的循环还会接着执行，每次循环都对应的一个显示设备 DisplayDevice。但是一般情况下只会有一个默认的DisplayDevice 。</p>
<p>至此也就完成了 rebuildLayerStacks()  方法的分析，在该方法中，会遍历 mDisplays 中所有的显示设备，然后每个显示设备都会去尝试计算所有的 Layer 在其上显示的区域等信息，如果有Layer 在当前 DisplayDevice 上显示内容，则会为其创建 OutputLayer 实例，并将这些统一都保存到 compositionengine::impl::Output 中的 mOutputLayersOrderedByZ 和 DisplayDevice 中的 mVisibleLayersSortedByZ 中 ，以供后续使用。同时还会额外更新一些 State 中的属性，比如 OutputLayer 中的 mState，compositionengine::impl::Output 实例的 mState。这些值等到后面会用到的。</p>
<blockquote>
<p>该方法中，if 条件和 for 循环嵌套比较多，可以多看几遍源码，理解清楚结构之后，再分析。大的框架结构先在心里有数，再去看细节会更好理解。</p>
<p>不只是看这个方法，看源码都可以是这个策略。</p>
</blockquote>
<h3 id="calculateWorkingSet"><a href="#calculateWorkingSet" class="headerlink" title="calculateWorkingSet"></a>calculateWorkingSet</h3><p>先看其源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SurfaceFlinger.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::calculateWorkingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mGeometryInvalid 已经在 rebuildLayerStacks 中修改为了 true</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mGeometryInvalid)) &#123;</span><br><span class="line">    mGeometryInvalid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记在前面的 rebuildLayerStacks 方法中，会遍历每一个 DisplayDevice 设备，然后计算出每个 Layer 在该 DisplayDevice 上的显示区域</span></span><br><span class="line"><span class="comment">     * 如果计算出来的显示区域不为空则表示该 Layer 要在该 DisplayDevice 上展示，此时会统一都将其包装成 OutputLayer 对象然后将其统一都保存</span></span><br><span class="line"><span class="comment">     * 到对应 DisplayDevice 的 mOutputLayersOrderedByZ 列表中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 所以到这里的时候，就可以再次遍历每个 DisplayDevice ，然后挨个处理其内部的 mOutputLayersOrderedByZ 中的 OutputLayer 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp;[token, displayDevice]: mDisplays) &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 拿到 DisplayDevice 中的 mCompositionDisplay</span></span><br><span class="line">      <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">      <span class="type">uint32_t</span> zOrder = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 处理每个显示设备中的图层，将这些 display 中的 layer 按照 Z 轴的顺序进行处理</span></span><br><span class="line"><span class="comment">       * getOutputLayersOrderedByZ 拿到的是 Display 中的 mOutputLayersOrderedByZ ，</span></span><br><span class="line"><span class="comment">       * 也就是上面 rebuildLayerStacks 方法中设置的要展示的 layer 列表</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;layer: display-&gt;<span class="built_in">getOutputLayersOrderedByZ</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个 layer 是 OutputLayer, 获取的是 OutputCompositionState，首先是拿到图层的合成状态</span></span><br><span class="line"><span class="comment">         * 上面在 rebuildLayerStacks 中创建 OutputLayer 时，自动会在 OutputLayer 构造方法中调用其 initialize 方法</span></span><br><span class="line"><span class="comment">         * 然后在该方法中会从全局的 CompositionEngine 中拿到唯一的 HWComposer 对象实例，然后调用其 createLayer 方法来创建一个 HWC2::Layer 并返回</span></span><br><span class="line"><span class="comment">         * 并保存到该 OutputLayer中的 OutputCompositionState.hwc 中，所以说到现在，OutputCompositionState 中 hwc 是被初始化了的</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 而在上面 rebuildLayerStacks 遍历时，还给 OutputCompositionState 的 visibleRegion 赋值的</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 所以到现在：就 hwc 和 visibleRegion 被赋值了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">auto</span> &amp;compositionState = layer-&gt;<span class="built_in">editState</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先给  OutputCompositionState.forceClientComposition 赋值，即如果上层创建 hwc 成功了，则将其赋值为 true</span></span><br><span class="line"><span class="comment">         * forceClientComposition 指强制 GPU 合成（Client）</span></span><br><span class="line"><span class="comment">         * 如果为 true ，将在此输出上使用客户端组合，即 OpenGL ES 合成，如果为 false 则为 hwc 合成</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 根据是否创建了 HWC 来决定是否需要开启 forceClientComposition</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 而 hwc 的创建是在上面 rebuildLayerStacks  getOrCreateOutputLayer  方法中</span></span><br><span class="line"><span class="comment">         * 该方法中会通过对应 Display 、Layer 来创建 OutputLayer ，同时会尝试去上层 HWComposer -&gt; HWC2 中创建 Layer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compositionState.forceClientComposition = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!compositionState.hwc || mDebugDisableHWC || mDebugRegion) &#123;</span><br><span class="line">          compositionState.forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再给 compositionState 的 z 属性设置值</span></span><br><span class="line">        compositionState.z = zOrder++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * layer : OutputLayer</span></span><br><span class="line"><span class="comment">         * getLayerFE() 其实就是返回对应的  BufferLayer  , 这里调用到了它的父类 Layer 中</span></span><br><span class="line"><span class="comment">         * layer-&gt;getLayer() 返回的就是 BufferLayer 中的 mCompositionLayer ，也就是 compositionengine::Layer</span></span><br><span class="line"><span class="comment">         * 所以翻译之后，应该是如下的：</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * BufferLayer.latchCompositionState(BufferLayer.getCompositionLayer.editState().frontEnd)</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 也就是说传入的是： compositionengine::Layer 中的 mState (LayerCompositionState) 中的 frontEnd (LayerFECompositionState)</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * latchCompositionState 内部逻辑简单来说就是将 OutputLayer 中的 layerFE (也就是BufferLayer) 中的属性，赋值到 layer.mState.frontEnd 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        layer-&gt;<span class="built_in">getLayerFE</span>().<span class="built_in">latchCompositionState</span>(layer-&gt;<span class="built_in">getLayer</span>().<span class="built_in">editState</span>().frontEnd, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重新计算OutputLayer的几何状态，即大小尺寸等</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 上面 latchCompositionState 中，刚刚将 OutputLayer 中的 layerFE(也就是BufferLayer) 中的属性，赋值到其内部的 layer.mState.frontEnd 中</span></span><br><span class="line"><span class="comment">         * 那么此时就可以使用 layer.mState.frontEnd 中的参数值来重新计算该 Layer 的位置那些信息了，计算之后的信息会存储在该 OutputLayer.mState 中</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 这里是给 OutputLayer 中的 compositionState 中的剩余参数赋值，比如其 displayFrame 之类的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        layer-&gt;<span class="built_in">updateCompositionState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上面刚刚为该 OutputLayer.mState 计算好的位置大小等几何信息等，此时将这些位置信息写入到 hwc 中的 HWC2::Layer 中去</span></span><br><span class="line"><span class="comment">         * 该 HWC2::Layer 存储在上层 HWComposer &gt; Device &gt; Display 中，也就是写入到上层 HAL 中去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        layer-&gt;<span class="built_in">writeStateToHWC</span>(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当前 calculateWorkingSet() 方法是在前面的rebuildLayerStacks()  方法之后调用的。因此前面初始化计算的一些属性这里都可以用。</p>
<p>首先判断 mGeometryInvalid 的值是否是 true，是true 是才会进行后续的操作。而这个值的修改是在前面 ebuildLayerStacks()  方法中调通过调用 invalidateHwcGeometry() 方法时修改的，所以这里肯定是 true了。</p>
<p>接着又开始遍历 mDisplays 了，遍历其中每个  DisplayDevice 。</p>
<p>在遍历过程中，首先先拿到当前 DisplayDevice 中的 mCompositionDisplay 属性值，也就是前面一直在讲的 compositionengine::Display 类型的实例。然后通过调用其 getOutputLayersOrderedByZ() 方法来拿到前面在 rebuildLayerStacks()  方法中计算并保存的 mOutputLayersOrderedByZ 集合，该集合中存储着若干个 OutputLayer 实例，这些 OutputLayer 实例都是对应着一个将在当前DisplayDevice上显示的 Layer 。接着就是开始遍历这个 mOutputLayersOrderedByZ 集合了。</p>
<p>遍历 mOutputLayersOrderedByZ 集合时，拿到其中的 OutputLayer 实例，调用其 editState() 方法拿到其内部的 mState ，它是一个位于 OutputLayer 中 OutputLayerCompositionState 类型的实例，其属性在上面 [ OutputLayer简述 ] 中有简单提到。</p>
<p>接下来首先会去修改 OutputLayerCompositionState 的 forceClientComposition  的值，它的值表示当前 Layer 是否要使用客户端来合成。即：如果是 true 的话则使用客户端 OpenGLES 来合成，否则使用HWC 来合成。</p>
<p>而使用 HWC 合成的前提是其内部的 hwc 属性不为空，而这个 hwc 属性是在该 OutputLayer 一开始创建时就尝试创建并赋值的，如果此时为空那么表示创建失败，此时也就不能使用 HWC 来合成了，所以此时将其置为 true。</p>
<p>接着往下就是修改其 z 坐标值，z坐标值会随着遍历而逐渐递增。</p>
<p>在看接下来的逻辑之前，首先需要明确几个方法：</p>
<p>① layer-&gt;getLayerFE() ：正如前面创建 OutputLayer 时所言，这里的 Layer 是 OutputLayer ，其 getLayerFE() 方法返回的是其内部的 mLayerFE 属性，它实际对应的是 BufferLayer 实例，或者说是一个 BufferQueueLayer 实例。</p>
<p>② layer-&gt;getLayer() ： 返回的是一个 compositionengine::Layer 类型的实例，也就是 BufferLayer 或者说是 BufferQueueLayer 中的 mCompositionLayer 实例。关于这俩的关系，详见：<a href="25fde216.html">BufferQueueLayer</a></p>
<p>③ compositionengine::Layer::editState()：返回 compositionengine::Layer 中的 mState 属性，它是一个 LayerCompositionState 类型的实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LayerCompositionState.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LayerCompositionState</span> &#123;</span><br><span class="line"></span><br><span class="line">  LayerFECompositionState frontEnd;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LayerFECompositionState.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LayerFECompositionState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下会省略部分属性</span></span><br><span class="line">  </span><br><span class="line">    Region geomVisibleRegion;</span><br><span class="line">   </span><br><span class="line">    <span class="type">bool</span> isSecure&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> geomUsesSourceCrop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> geomBufferUsesDisplayInverseTransform&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> geomBufferTransform&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ui::Transform geomLayerTransform;</span><br><span class="line">    ui::Transform geomInverseLayerTransform;</span><br><span class="line">  </span><br><span class="line">    Hwc2::IComposerClient::BlendMode blendMode&#123;Hwc2::IComposerClient::BlendMode::INVALID&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> alpha&#123;<span class="number">1.f</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> type&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Hwc2::IComposerClient::Composition compositionType&#123;Hwc2::IComposerClient::Composition::INVALID&#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;GraphicBuffer&gt; buffer;</span><br><span class="line">    <span class="type">int</span> bufferSlot&#123;BufferQueue::INVALID_BUFFER_SLOT&#125;;</span><br><span class="line">    sp&lt;Fence&gt; acquireFence;</span><br><span class="line">    Region surfaceDamage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 LayerCompositionState 中只有一个  LayerFECompositionState frontEnd 属性，因此对于 LayerCompositionState 中的属性设置都会保存在其内部的 frontEnd 中。比如其中的 buffer 和 bufferSlot 属性在前面的  BufferQueueLayer::updateActiveBuffer() 方法中就已经赋值了。</p>
<p>然后我们再接着看 latchCompositionState() 方法，该方法中会将拿到的 BufferQueueLayer.mCompositionLayer.mState.frontEnd 也就是 LayerFECompositionState 属性传递进去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Layer::latchCompositionState</span><span class="params">(compositionengine::LayerFECompositionState &amp;compositionState,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> includeGeometry)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// includeGeometry 此时传入的是 true</span></span><br><span class="line">  <span class="keyword">if</span> (includeGeometry) &#123;</span><br><span class="line">    <span class="built_in">latchGeometry</span>(compositionState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Layer::latchGeometry</span><span class="params">(compositionengine::LayerFECompositionState &amp;compositionState)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先获取当前 Layer 中的一些状态值</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> &amp;drawingState&#123;<span class="built_in">getDrawingState</span>()&#125;;</span><br><span class="line">  <span class="keyword">auto</span> alpha = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">getAlpha</span>());</span><br><span class="line">  <span class="keyword">auto</span> blendMode = HWC2::BlendMode::None;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isOpaque</span>(drawingState) || alpha != <span class="number">1.0f</span>) &#123;</span><br><span class="line">    blendMode = mPremultipliedAlpha ? HWC2::BlendMode::Premultiplied : HWC2::BlendMode::Coverage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> type = drawingState.metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> appId = drawingState.metadata.<span class="built_in">getInt32</span>(METADATA_OWNER_UID, <span class="number">0</span>);</span><br><span class="line">  sp&lt;Layer&gt; parent = mDrawingParent.<span class="built_in">promote</span>();</span><br><span class="line">  <span class="keyword">if</span> (parent.<span class="built_in">get</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;parentState = parent-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> parentType = parentState.metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> parentAppId = parentState.metadata.<span class="built_in">getInt32</span>(METADATA_OWNER_UID, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (parentType &gt;= <span class="number">0</span> || parentAppId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      type = parentType;</span><br><span class="line">      appId = parentAppId;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始挨个赋值了，将当前 BufferQueueLayer 中的属性赋值给入参 compositionState</span></span><br><span class="line">  compositionState.geomLayerTransform = <span class="built_in">getTransform</span>();</span><br><span class="line">  compositionState.geomInverseLayerTransform = compositionState.geomLayerTransform.<span class="built_in">inverse</span>();</span><br><span class="line">  compositionState.geomBufferSize = <span class="built_in">getBufferSize</span>(drawingState);</span><br><span class="line">  compositionState.geomContentCrop = <span class="built_in">getContentCrop</span>();</span><br><span class="line">  compositionState.geomCrop = <span class="built_in">getCrop</span>(drawingState);</span><br><span class="line">  compositionState.geomBufferTransform = mCurrentTransform;</span><br><span class="line">  compositionState.geomBufferUsesDisplayInverseTransform = <span class="built_in">getTransformToDisplayInverse</span>();</span><br><span class="line">  compositionState.geomActiveTransparentRegion = <span class="built_in">getActiveTransparentRegion</span>(drawingState);</span><br><span class="line">  compositionState.geomLayerBounds = mBounds;</span><br><span class="line">  compositionState.geomUsesSourceCrop = <span class="built_in">usesSourceCrop</span>();</span><br><span class="line">  compositionState.isSecure = <span class="built_in">isSecure</span>();</span><br><span class="line"></span><br><span class="line">  compositionState.blendMode = <span class="built_in">static_cast</span>&lt;Hwc2::IComposerClient::BlendMode&gt;(blendMode);</span><br><span class="line">  compositionState.alpha = alpha;</span><br><span class="line">  compositionState.type = type;</span><br><span class="line">  compositionState.appId = appId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面讲到过了，对于这个 LayerFECompositionState 来说，它内部的 buffer 和 bufferSlot 属性是已经赋值了的，但是其他的一大堆属性都还没有赋值，所以这里就是给这些属性赋值的。也就是将当前 BufferLayer (或者干脆理解成 BufferQueueLayer )中的属性一一赋值给 LayerFECompositionState 中。</p>
<p>至此：BufferQueueLayer.mCompositionLayer.mState.frontEnd ，也就是 LayerFECompositionState 中的属性就基本都有值了，这些值都来自于 BufferQueueLayer 中的属性。</p>
<p>因此可以将这个BufferQueueLayer.mCompositionLayer 理解成是 BufferQueueLayer 在 CompositionEngine 中的一个副本吧。</p>
<p>接着往后走：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputLayer::updateCompositionState</span><span class="params">(<span class="type">bool</span> includeGeometry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时传入的 includeGeometry = true </span></span><br><span class="line">    <span class="keyword">if</span> (includeGeometry) &#123;</span><br><span class="line">        mState.displayFrame = <span class="built_in">calculateOutputDisplayFrame</span>();</span><br><span class="line">        mState.sourceCrop = <span class="built_in">calculateOutputSourceCrop</span>();</span><br><span class="line">        mState.bufferTransform =</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;Hwc2::Transform&gt;(<span class="built_in">calculateOutputRelativeBufferTransform</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mLayer-&gt;<span class="built_in">getState</span>().frontEnd.isSecure &amp;&amp; !mOutput.<span class="built_in">getState</span>().isSecure) ||</span><br><span class="line">            (mState.bufferTransform &amp; ui::Transform::ROT_INVALID)) &#123;</span><br><span class="line">            mState.forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在开始准备为 OutputLayer 中的 mState 中的属性赋值了，因为前面刚给其内部的 BufferQueueLayer.mCompositionLayer.mState.frontEnd 赋值了，接下来 OutputLayer 中的 mState 属性赋值就可以借助 frontEnd 了。里面的这几个计算方法这里不分析了，感兴趣的可以去研究下。</p>
<p>我们只需要这里的 updateCompositionState 是通知当前 OutputLayer 去根据最新的 frontEnd 中的属性去更新自身 mState 中的值。</p>
<p>接着往后看最后一步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OutputLayer.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputLayer::writeStateToHWC</span><span class="params">(<span class="type">bool</span> includeGeometry)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果他内部的 hwc 创建失败了，那没法使用hwc，此时直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!mState.hwc) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 hwc 内部的 hwcLayer</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; hwcLayer = (*mState.hwc).hwcLayer;</span><br><span class="line">  <span class="keyword">if</span> (!hwcLayer) &#123;</span><br><span class="line">      <span class="built_in">ALOGE</span>(<span class="string">&quot;[%s] failed to write composition state to HWC -- no hwcLayer for output %s&quot;</span>,</span><br><span class="line">            mLayerFE-&gt;<span class="built_in">getDebugName</span>(), mOutput.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外部传入的是 true</span></span><br><span class="line">  <span class="keyword">if</span> (includeGeometry) &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 下面就开始将当前 OutputLayer.mState 中的属性更新到 hwc.hwcLayer 中去</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;<span class="built_in">setDisplayFrame</span>(mState.displayFrame);</span><br><span class="line">          error != HWC2::Error::None) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;[%s] Failed to set display frame [%d, %d, %d, %d]: %s (%d)&quot;</span>,</span><br><span class="line">                mLayerFE-&gt;<span class="built_in">getDebugName</span>(), mState.displayFrame.left, mState.displayFrame.top,</span><br><span class="line">                mState.displayFrame.right, mState.displayFrame.bottom, <span class="built_in">to_string</span>(error).<span class="built_in">c_str</span>(),</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(error));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;<span class="built_in">setSourceCrop</span>(mState.sourceCrop); error != HWC2::Error::None) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;[%s] Failed to set source crop [%.3f, %.3f, %.3f, %.3f]: &quot;</span></span><br><span class="line">                <span class="string">&quot;%s (%d)&quot;</span>,</span><br><span class="line">                mLayerFE-&gt;<span class="built_in">getDebugName</span>(), mState.sourceCrop.left, mState.sourceCrop.top,</span><br><span class="line">                mState.sourceCrop.right, mState.sourceCrop.bottom, <span class="built_in">to_string</span>(error).<span class="built_in">c_str</span>(),</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(error));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;<span class="built_in">setZOrder</span>(mState.z); error != HWC2::Error::None) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;[%s] Failed to set Z %u: %s (%d)&quot;</span>, mLayerFE-&gt;<span class="built_in">getDebugName</span>(), mState.z,</span><br><span class="line">                <span class="built_in">to_string</span>(error).<span class="built_in">c_str</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(error));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> error =</span><br><span class="line">                  hwcLayer-&gt;<span class="built_in">setTransform</span>(<span class="built_in">static_cast</span>&lt;HWC2::Transform&gt;(mState.bufferTransform));</span><br><span class="line">          error != HWC2::Error::None) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;[%s] Failed to set transform %s: %s (%d)&quot;</span>, mLayerFE-&gt;<span class="built_in">getDebugName</span>(),</span><br><span class="line">                <span class="built_in">toString</span>(mState.bufferTransform).<span class="built_in">c_str</span>(), <span class="built_in">to_string</span>(error).<span class="built_in">c_str</span>(),</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(error));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; outputIndependentState = mLayer-&gt;<span class="built_in">getState</span>().frontEnd;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;<span class="built_in">setBlendMode</span>(</span><br><span class="line">                  <span class="built_in">static_cast</span>&lt;HWC2::BlendMode&gt;(outputIndependentState.blendMode));</span><br><span class="line">          error != HWC2::Error::None) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;[%s] Failed to set blend mode %s: %s (%d)&quot;</span>, mLayerFE-&gt;<span class="built_in">getDebugName</span>(),</span><br><span class="line">                <span class="built_in">toString</span>(outputIndependentState.blendMode).<span class="built_in">c_str</span>(), <span class="built_in">to_string</span>(error).<span class="built_in">c_str</span>(),</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(error));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;<span class="built_in">setPlaneAlpha</span>(outputIndependentState.alpha);</span><br><span class="line">          error != HWC2::Error::None) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;[%s] Failed to set plane alpha %.3f: %s (%d)&quot;</span>, mLayerFE-&gt;<span class="built_in">getDebugName</span>(),</span><br><span class="line">                outputIndependentState.alpha, <span class="built_in">to_string</span>(error).<span class="built_in">c_str</span>(),</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(error));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> error =</span><br><span class="line">                  hwcLayer-&gt;<span class="built_in">setInfo</span>(outputIndependentState.type, outputIndependentState.appId);</span><br><span class="line">          error != HWC2::Error::None) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;[%s] Failed to set info %s (%d)&quot;</span>, mLayerFE-&gt;<span class="built_in">getDebugName</span>(),</span><br><span class="line">                <span class="built_in">to_string</span>(error).<span class="built_in">c_str</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(error));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步是调用 OutputLayer::writeStateToHWC() 来将其内部 mState 和其内部 mLayer.mState.frontEnd 中的属性保存到其内部 mState.hwc.hwcLayer 中去。</p>
<p>而这个 mState.hwc.hwcLayer 是在 OutputLayer 一开始创建的时候执行的 OutputLayer::initialize() 方法来自动创建赋值的。</p>
<p>这样的话，calculateWorkingSet() 就分析完了，在该方法中会遍历所有的 DisplayDevice ，然后再挨个遍历其内部要展示的 Layer 列表，为每个 Layer 设置对应的属性，并将最终设置好的属性都保存到HWC 中去，等待后续使用。</p>
<p>到这里，就将 handleMessageRefresh() 方法中的：preComposition() 、rebuildLayerStacks() 和 calculateWorkingSet() 方法分析完了，这三个方法完成的只是 Layer 组合绘制之前的准备工作，比如计算 Layer 的显示区域，计算 Layer 中的状态信息以及同步到 HWC 中等。</p>
<p>由于篇幅问题，后续的逻辑在下一篇文章中分析。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/SurfaceFlinger/">SurfaceFlinger</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/bf779c6b.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">SurfaceFlinger - REFRESH - (2)</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/5440e75b.html">
        <span class="next-text nav-default">SurfaceFlinger - INVALIDATE</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
