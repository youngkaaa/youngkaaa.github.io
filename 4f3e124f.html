<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="leakcanary回收检测原理"/>




  <meta name="keywords" content="leakcanary," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/4f3e124f.html"/>


<meta name="description" content="正如前文 leakcanary install 分析 所说，完成了 leakcanary 的 install() 初始化准备工作，接下来就等着其对应监测的对象发生变化就行了。 在此之前，需要先补充一下Java中常见的几种引用，对后续的分析会有帮助。 引用分类在Java 中，按照引用的强弱类型分为四种： ① 强引用，他就是我们平时开发时使用的默认引用类型。如果一个对象具备强引用，垃圾回收器绝不会回收">
<meta property="og:type" content="article">
<meta property="og:title" content="leakcanary回收检测原理">
<meta property="og:url" content="https://youngkaaa.github.io/4f3e124f.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="正如前文 leakcanary install 分析 所说，完成了 leakcanary 的 install() 初始化准备工作，接下来就等着其对应监测的对象发生变化就行了。 在此之前，需要先补充一下Java中常见的几种引用，对后续的分析会有帮助。 引用分类在Java 中，按照引用的强弱类型分为四种： ① 强引用，他就是我们平时开发时使用的默认引用类型。如果一个对象具备强引用，垃圾回收器绝不会回收">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-25T13:49:56.000Z">
<meta property="article:modified_time" content="2023-03-13T12:45:35.480Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="leakcanary">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> leakcanary回收检测原理 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          leakcanary回收检测原理
        
      </h1>

      <time class="post-time">
          2月 25 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>正如前文 <a href="7e3c732d.html">leakcanary install 分析</a> 所说，完成了 leakcanary 的 install() 初始化准备工作，接下来就等着其对应监测的对象发生变化就行了。</p>
<p>在此之前，需要先补充一下Java中常见的几种引用，对后续的分析会有帮助。</p>
<h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p>在Java 中，按照引用的强弱类型分为四种：</p>
<p>① 强引用，他就是我们平时开发时使用的默认引用类型。如果一个对象具备强引用，垃圾回收器绝不会回收它。当内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>错误，使程序异常终止，也不会出现回收具有强引用的对象来解决内存不足的情况。</p>
<p>② 软引用，它对应着我们平时开发中的 SoftReference 类。对于软引用关联着的对象，在JVM应用即将发生内存溢出异常之前，将会把这些软引用关联的对象列进去回收对象范围之中进行第二次回收。如果这次回收之后还是没有足够的内存，才会抛出内存溢出异常。</p>
<p>③ 弱引用，它对应着我们平时开发中的 WeakReference 类。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，简言之就是：一旦发生GC必定回收被弱引用关联的对象，不管当前的内存是否足够。也就是弱引用只能活到下次GC之时。</p>
<p>④ 虚引用，它对应着我们平时开发中的 PhantomReference 类。一个对象是否关联到虚引用，完全不会影响该对象的生命周期，也无法通过虚引用来获取一个对象的实例，并且PhantomReference 类覆盖了Reference#get() 方法，并且总是返回null 。为对象设置一个虚引用的唯一目的是：能在此对象被垃圾收集器回收的时候收到一个<strong>系统通知</strong>。</p>
<p>这里面最常用的还是 弱引用 ，WeakReference ，对于软引用来说，它是在快要 OOM 的时候才会回收，那个时候相对来说是比较晚了，很容易再次触发 OOM，所以一般是使用 LruCache，而不是 SoftReference 。</p>
<p>接下来看看 leakcanary 中前面提到的 InstallableWatcher 的四个实例。</p>
<h3 id="ActivityWatcher"><a href="#ActivityWatcher" class="headerlink" title="ActivityWatcher"></a>ActivityWatcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityWatcher.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> val application: Application,</span><br><span class="line">  <span class="keyword">private</span> val reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个 Application.ActivityLifecycleCallbacks 接口实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">lifecycleCallbacks</span> <span class="operator">=</span></span><br><span class="line">    object : Application.ActivityLifecycleCallbacks by <span class="title function_">noOpDelegate</span><span class="params">()</span> &#123;</span><br><span class="line">      override fun <span class="title function_">onActivityDestroyed</span><span class="params">(activity: Activity)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 Activity 被销毁时执行 expectWeaklyReachable 方法通知到外部去</span></span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          activity, <span class="string">&quot;$&#123;activity::class.java.name&#125; received Activity#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  override fun <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// install 时注册回调</span></span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun <span class="title function_">uninstall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// uninstall 时移除回调</span></span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来看 ActivityWatcher 实例的创建，在前面 AppWatcher.kt#appDefaultWatchers() 中讲过了，它的构造方法传入的第一个参数 application 就是当前应用的Application实例；第二个参数 reachabilityWatcher 实际是 AppWatcher.kt 中的 objectWatcher ，也就是一个 ObjectWatcher 实例 ，先简单看看 ObjectWatcher 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectWatcher.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectWatcher</span> constructor(</span><br><span class="line">  <span class="keyword">private</span> val clock: Clock,</span><br><span class="line">  <span class="keyword">private</span> val checkRetainedExecutor: Executor,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Calls to [watch] will be ignored when [isEnabled] returns false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> val isEnabled: () -&gt; Boolean = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">) : ReachabilityWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">onObjectRetainedListeners</span> <span class="operator">=</span> mutableSetOf&lt;OnObjectRetainedListener&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前正在观察的对象实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">watchedObjects</span> <span class="operator">=</span> mutableMapOf&lt;String, KeyedWeakReference&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ReferenceQueue 实例，用来给后续创建的 WeakReference 实例来用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">queue</span> <span class="operator">=</span> ReferenceQueue&lt;Any&gt;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他内部接收 clock 和 checkRetainedExecutor 实例，其中后者是用来后续处理延迟任务的。并且在 ObjectWatcher 中还有好几个属性，比如 watchedObjects 、queue 等，这些后续再分析。</p>
<p>而 AppWatcher 中会创建好一个 ObjectWatcher 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppWatcher.kt</span></span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">objectWatcher</span> <span class="operator">=</span> ObjectWatcher(</span><br><span class="line">  clock = &#123; SystemClock.uptimeMillis() &#125;,</span><br><span class="line">  checkRetainedExecutor = &#123;</span><br><span class="line">    <span class="comment">// 为其内部的  checkRetainedExecutor 赋值</span></span><br><span class="line">    check(isInstalled) &#123;</span><br><span class="line">      <span class="string">&quot;AppWatcher not installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主线程延迟固定时长 retainedDelayMillis 后执行</span></span><br><span class="line">    mainHandler.postDelayed(it, retainedDelayMillis)</span><br><span class="line">  &#125;,</span><br><span class="line">  isEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在 AppWatcher 中创建的这个 ObjectWatcher ，为其指定了一个 Executor  实例，即使用主线程 Handler ，来使得任务在 retainedDelayMillis 时间之后再执行。而这个 retainedDelayMillis 时间是在前面 AppWatcher.kt#manualInstall() 方法中设置的，默认是 5分钟后。</p>
<p>回到 ActivityWatcher 中，所以此时它内部的 reachabilityWatcher 其实就是 AppWatcher 中创建的那个 ObjectWatcher 实例。因此这里调用 expectWeaklyReachable() 方法会调用到 ObjectWatcher 中去，注意这里调用 expectWeaklyReachable() 方法时传入的是第一个参数是当前 activity 实例，也就是后续要观察的对象实例，观察该对象后续有没有被回收掉，第二个参数是一个字符串，用来描述这次调用。</p>
<p>那么接下来的重心就是 ObjectWatcher 中的 expectWeaklyReachable() 方法了，但是暂时这里先不讲，等分析完四个 InstallableWatcher 实例之后再分析它。</p>
<p>因此总结来说，在 ActivityWatcher 中，是通过监测该 Activity 的 onDestroy 事件来完成的。</p>
<h3 id="FragmentAndViewModelWatcher"><a href="#FragmentAndViewModelWatcher" class="headerlink" title="FragmentAndViewModelWatcher"></a>FragmentAndViewModelWatcher</h3><p>先看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FragmentAndViewModelWatcher,kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentAndViewModelWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> val application: Application,</span><br><span class="line">  <span class="keyword">private</span> val reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> val fragmentDestroyWatchers: List&lt;(Activity) -&gt; Unit&gt; = run &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">fragmentDestroyWatchers</span> <span class="operator">=</span> mutableListOf&lt;(Activity) -&gt; Unit&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Android 8.0及其之后的系统，会添加一个 AndroidOFragmentDestroyWatcher</span></span><br><span class="line">    <span class="keyword">if</span> (SDK_INT &gt;= O) &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(</span><br><span class="line">        AndroidOFragmentDestroyWatcher(reachabilityWatcher)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否存在 &quot;androidx.fragment.app.Fragment&quot; 类，存在的话，</span></span><br><span class="line"><span class="comment">     * 则反射创建 AndroidXFragmentDestroyWatcher 实例，并将 reachabilityWatcher 传进去</span></span><br><span class="line"><span class="comment">     * AndroidXFragmentDestroyWatcher 这些就是一个 (activity)-&gt;Unit 高阶函数，入参接收Activity，返回void</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 最后如果 AndroidXFragmentDestroyWatcher 创建成功则会将其加入到 fragmentDestroyWatchers 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">      ANDROIDX_FRAGMENT_CLASS_NAME,</span><br><span class="line">      ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">      reachabilityWatcher</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否存在 &quot;android.support.v4.app.Fragment&quot; 类，存在的话，</span></span><br><span class="line"><span class="comment">     * 则反射创建 AndroidSupportFragmentDestroyWatcher 实例，并将 reachabilityWatcher 传进去</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 最后如果 AndroidSupportFragmentDestroyWatcher 创建成功则会将其加入到 fragmentDestroyWatchers 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">      ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,</span><br><span class="line">      ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">      reachabilityWatcher</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后返回 fragmentDestroyWatchers 列表</span></span><br><span class="line">    fragmentDestroyWatchers</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">lifecycleCallbacks</span> <span class="operator">=</span> object : Application.ActivityLifecycleCallbacks by <span class="title function_">noOpDelegate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是监测 Activity 的 onCreate 事件</span></span><br><span class="line">    override fun <span class="title function_">onActivityCreated</span><span class="params">(</span></span><br><span class="line"><span class="params">        activity: Activity,</span></span><br><span class="line"><span class="params">        savedInstanceState: Bundle?</span></span><br><span class="line"><span class="params">      )</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历 fragmentDestroyWatchers 中的那些 （Activity) -&gt; Unit 实例</span></span><br><span class="line"><span class="comment">         * 并且挨个调用该实例，将当前刚创建好的 Activity 传入进去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (watcher in fragmentDestroyWatchers) &#123;</span><br><span class="line">          watcher(activity)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  override fun <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 还是注册 ActivityLifecycleCallbacks</span></span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun <span class="title function_">uninstall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 还是移除 ActivityLifecycleCallbacks</span></span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 install 中还是注册 ActivityLifecycleCallbacks 回调，在回调中只处理了 onActivityCreated() ，也就是当有 Activity  OnCreate 时，会去遍历 fragmentDestroyWatchers 列表中的 (Activity) -&gt; Unit 实例 ，挨个执行其实例方法。</p>
<p>而 fragmentDestroyWatchers 列表中按照不同条件，可能会添加三个不同的实例：AndroidOFragmentDestroyWatcher 、AndroidXFragmentDestroyWatcher 以及 AndroidSupportFragmentDestroyWatcher ，下面分别来分析这三个(Activity) -&gt; Unit 实例：</p>
<h4 id="AndroidOFragmentDestroyWatcher"><a href="#AndroidOFragmentDestroyWatcher" class="headerlink" title="AndroidOFragmentDestroyWatcher"></a>AndroidOFragmentDestroyWatcher</h4><p>先看看源码解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AndroidOFragmentDestroyWatcher.kt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressLint(&quot;NewApi&quot;)</span></span><br><span class="line">internal <span class="keyword">class</span> <span class="title class_">AndroidOFragmentDestroyWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> val reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : (Activity) -&gt; Unit &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// FragmentLifecycleCallbacks 实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">fragmentLifecycleCallbacks</span> <span class="operator">=</span> object : FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onFragmentViewDestroyed</span><span class="params">(</span></span><br><span class="line"><span class="params">      fm: FragmentManager,</span></span><br><span class="line"><span class="params">      fragment: Fragment</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">      <span class="comment">// 当 Fragment 的 Fragment#onDestroyView() 方法被调用后，会执行当前回调</span></span><br><span class="line">      <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> fragment.view</span><br><span class="line">      <span class="title function_">if</span> <span class="params">(view != <span class="literal">null</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 开始监测该 Fragment 中的根 View 是否会被回收</span></span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          view, <span class="string">&quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroyView() callback &quot;</span> +</span><br><span class="line">          <span class="string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onFragmentDestroyed</span><span class="params">(</span></span><br><span class="line"><span class="params">      fm: FragmentManager,</span></span><br><span class="line"><span class="params">      fragment: Fragment</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">      <span class="comment">// 当 Fragment 的 Fragment#onDestroy() 方法被调用后，会执行当前回调</span></span><br><span class="line">      <span class="comment">// 开始监测该 Fragment 实例是否会被回收</span></span><br><span class="line">      reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">        fragment, <span class="string">&quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroy() callback&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun <span class="title function_">invoke</span><span class="params">(activity: Activity)</span> &#123;</span><br><span class="line">    <span class="comment">// 当外部调用当前方法时，会传入刚刚 onCreate 的 Activity 实例</span></span><br><span class="line">    <span class="comment">// 此时拿到其内部的 fragmentManager ，为其注册 FragmentLifecycleCallbacks</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> activity.fragmentManager</span><br><span class="line">    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AndroidOFragmentDestroyWatcher 中，外部调用其实例时，会执行到其内部 invoke() 方法中，此时传入进来的 Activity 就是前面刚拿到的刚刚执行 onCreate 方法的 Activity 实例，此时拿到其内部的 FragmentManager ，再往其实例中注册 FragmentLifecycleCallbacks 回调，监测其内部 Fragment 的生命周期回调。</p>
<p>对于其 Fragment 的生命周期回调，只关系其：onDestroyView() 和 onDestroy() 方法，前者会去监测 Fragment 中的根View的实例是否会被回收；后者会去监测该 Fragment 实例是否会被回收。</p>
<h4 id="AndroidXFragmentDestroyWatcher"><a href="#AndroidXFragmentDestroyWatcher" class="headerlink" title="AndroidXFragmentDestroyWatcher"></a>AndroidXFragmentDestroyWatcher</h4><p>先看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AndroidXFragmentDestroyWatcher.kt</span></span><br><span class="line"></span><br><span class="line">internal <span class="keyword">class</span> <span class="title class_">AndroidXFragmentDestroyWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> val reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : (Activity) -&gt; Unit &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">fragmentLifecycleCallbacks</span> <span class="operator">=</span> object : FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onFragmentCreated</span><span class="params">(</span></span><br><span class="line"><span class="params">      fm: FragmentManager,</span></span><br><span class="line"><span class="params">      fragment: Fragment,</span></span><br><span class="line"><span class="params">      savedInstanceState: Bundle?</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">      <span class="comment">// 观察该 Fragment 中的 ViewModel 是否会被回收</span></span><br><span class="line">      ViewModelClearedWatcher.install(fragment, reachabilityWatcher)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onFragmentViewDestroyed</span><span class="params">(</span></span><br><span class="line"><span class="params">      fm: FragmentManager,</span></span><br><span class="line"><span class="params">      fragment: Fragment</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">      <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> fragment.view</span><br><span class="line">      <span class="title function_">if</span> <span class="params">(view != <span class="literal">null</span>)</span> &#123;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          view, <span class="string">&quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroyView() callback &quot;</span> +</span><br><span class="line">          <span class="string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onFragmentDestroyed</span><span class="params">(</span></span><br><span class="line"><span class="params">      fm: FragmentManager,</span></span><br><span class="line"><span class="params">      fragment: Fragment</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">      reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">        fragment, <span class="string">&quot;$&#123;fragment::class.java.name&#125; received Fragment#onDestroy() callback&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun <span class="title function_">invoke</span><span class="params">(activity: Activity)</span> &#123;</span><br><span class="line">    <span class="comment">// 只处理那些可以存放 Fragment 的 Activity，也就是 FragmentActivity</span></span><br><span class="line">    <span class="keyword">if</span> (activity is FragmentActivity) &#123;</span><br><span class="line">      <span class="comment">// 拿到其中 supportFragmentManager 对应的 FragmentManager 实例</span></span><br><span class="line">      <span class="type">val</span> <span class="variable">supportFragmentManager</span> <span class="operator">=</span> activity.supportFragmentManager</span><br><span class="line">      <span class="comment">// 再往其内部注册 FragmentLifecycleCallbacks 回调</span></span><br><span class="line">      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 观察该 Activity 中的 ViewModel 是否会被回收</span></span><br><span class="line">      ViewModelClearedWatcher.install(activity, reachabilityWatcher)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 AndroidXFragmentDestroyWatcher 中，还是对其内部的 Fragment 来进行观察，比如还是在 Fragment 的 onDestroyView() 中观察其 根View 实例是否会被回收；在Fragment 的 onDestroy() 中观察其自身Fragment实例是否会被回收，这两点和上面的  AndroidOFragmentDestroyWatcher 类似，不同的是：AndroidXFragmentDestroyWatcher 中观察的是 androidx.fragment.app.Fragment，而 AndroidOFragmentDestroyWatcher 中观察的是 android.app.Fragment ，并且还是 Android O 及其之后的版本才会生效的。</p>
<p>在此之外，还额外对其内部的 ViewModel 的回收进行了监测，具体是通过 ViewModelClearedWatcher.install() 方法来实现的，比如在其 invoke() 方法中会对传入的 Activity 中的 ViewModel 的回收进行监测；在 Fragment 的 onCreate() 方法中会对 Fragment 中的 ViewModel 的回收进行监测；</p>
<p>下面看看 ViewModelClearedWatcher.install() 中的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewModelClearedWatcher</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">internal <span class="keyword">class</span> <span class="title class_">ViewModelClearedWatcher</span>(</span><br><span class="line">  storeOwner: ViewModelStoreOwner,</span><br><span class="line">  <span class="keyword">private</span> val reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 反射拿到当前 storeOwner.viewModelStore 中的 mMap 属性</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> val viewModelMap: Map&lt;String, ViewModel&gt;? = <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">mMapField</span> <span class="operator">=</span> ViewModelStore::class.java.getDeclaredField(<span class="string">&quot;mMap&quot;</span>)</span><br><span class="line">    mMapField.isAccessible = <span class="literal">true</span></span><br><span class="line">    <span class="meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span></span><br><span class="line">    mMapField[storeOwner.viewModelStore] as Map&lt;String, ViewModel&gt;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ignored: Exception) &#123;</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写 ViewModel 的 onCleared 方法</span></span><br><span class="line">  override fun <span class="title function_">onCleared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历当前 storeOwner.viewModelStore 中的 mMap 中的 ViewModel ，挨个去检查他们有无被回收</span></span><br><span class="line">    viewModelMap?.values?.forEach &#123; viewModel -&gt;</span><br><span class="line">      reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">        viewModel, <span class="string">&quot;$&#123;viewModel::class.java.name&#125; received ViewModel#onCleared() callback&quot;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  companion object &#123;</span><br><span class="line">    fun <span class="title function_">install</span><span class="params">(</span></span><br><span class="line"><span class="params">      storeOwner: ViewModelStoreOwner,</span></span><br><span class="line"><span class="params">      reachabilityWatcher: ReachabilityWatcher</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 因为要创建的 ViewModelStoreOwner 是有参的，所以需要单独为其定义一个 Factory</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="type">val</span> <span class="variable">provider</span> <span class="operator">=</span> ViewModelProvider(storeOwner, object : Factory &#123;</span><br><span class="line">        <span class="meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span></span><br><span class="line">        override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T =</span><br><span class="line">          ViewModelClearedWatcher(storeOwner, reachabilityWatcher) as T</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 然后创建该 ViewModelClearedWatcher 实例</span></span><br><span class="line">      provider.get(ViewModelClearedWatcher::class.java)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ViewModelClearedWatcher 的 install () 方法中，会创建一个 ViewModelClearedWatcher 实例并且存入到当前入参 ViewModelStoreOwner 中的 ViewModelStore 中。</p>
<p>而 ViewModelClearedWatcher 是继承自 ViewModel 的，当该 ViewModelStoreOwner 对应的页面被销毁时，会将 ViewModelStoreOwner 中的 ViewModelStore 内的 ViewModelStore 挨个调用 onClear() 方法来清空掉，所以这个时机正好可以作为监测的切入点。因此在 ViewModelClearedWatcher 中重写了 onCleared() 方法，此时会通过反射拿到当前入参 ViewModelStoreOwner 中的 ViewModelStore 中的 mMap 实例，接着遍历他内部的 ViewModel 实例，挨个去监测其是否会被回收。</p>
<p>关于上面 ViewModelStoreOwner 、ViewModelStore 等概念的介绍详见：<a href="6d1e424c.html">Jetpack- ViewModel</a> 。</p>
<p>所以说，外部可以调用 ViewModelClearedWatcher 的 install () 方法来完成入参 ViewModelStoreOwner 中 ViewModel 的回收监测。</p>
<p>回到 AndroidXFragmentDestroyWatcher 中，此时就可以看明白里面怎么完成 Activity 和 Fragment 的 ViewModel 回收监测了吧。</p>
<h4 id="AndroidSupportFragmentDestroyWatcher"><a href="#AndroidSupportFragmentDestroyWatcher" class="headerlink" title="AndroidSupportFragmentDestroyWatcher"></a>AndroidSupportFragmentDestroyWatcher</h4><p>该类中的逻辑跟最前面的 AndroidOFragmentDestroyWatcher 类似，这里就不讲了。</p>
<h3 id="RootViewWatcher"><a href="#RootViewWatcher" class="headerlink" title="RootViewWatcher"></a>RootViewWatcher</h3><p>先看其代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RootViewWatcher.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RootViewWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> val reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">listener</span> <span class="operator">=</span> OnRootViewAddedListener &#123; rootView -&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该 RootView 对应的 Window 类型来决定要不要监测其移除</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">trackDetached</span> <span class="operator">=</span> when(rootView.windowType) &#123;</span><br><span class="line">      <span class="comment">// PhoneWindow 时，也就是 Activity 、Dialog 中的根 Window</span></span><br><span class="line">      PHONE_WINDOW -&gt; &#123;</span><br><span class="line">        when (rootView.phoneWindow?.callback?.wrappedCallback) &#123;</span><br><span class="line">          is Activity -&gt; <span class="literal">false</span></span><br><span class="line">          is Dialog -&gt; &#123;</span><br><span class="line">            <span class="comment">// Use app context resources to avoid NotFoundException</span></span><br><span class="line">            <span class="comment">// https://github.com/square/leakcanary/issues/2137</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">resources</span> <span class="operator">=</span> rootView.context.applicationContext.resources</span><br><span class="line">            resources.getBoolean(R.bool.leak_canary_watcher_watch_dismissed_dialogs)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> -&gt; <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// PopupWindow 不需要要监测</span></span><br><span class="line">      POPUP_WINDOW -&gt; <span class="literal">false</span></span><br><span class="line">      <span class="comment">// Toast 这些是要监测的</span></span><br><span class="line">      TOOLTIP, TOAST, UNKNOWN -&gt; <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trackDetached) &#123;</span><br><span class="line">      <span class="comment">// 如果需要监测的话，则为当前根 View 添加 OnAttachStateChangeListener 回调</span></span><br><span class="line">      rootView.addOnAttachStateChangeListener(object : OnAttachStateChangeListener &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务，该任务被执行时，会去监测当前 view 后续会不会被回收</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">watchDetachedView</span> <span class="operator">=</span> Runnable &#123;</span><br><span class="line">          reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">            rootView, <span class="string">&quot;$&#123;rootView::class.java.name&#125; received View#onDetachedFromWindow() callback&quot;</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onViewAttachedToWindow</span><span class="params">(v: View)</span> &#123;</span><br><span class="line">          <span class="comment">// 当该 View 被添加到 Window 中时，则移除该任务</span></span><br><span class="line">          mainHandler.removeCallbacks(watchDetachedView)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onViewDetachedFromWindow</span><span class="params">(v: View)</span> &#123;</span><br><span class="line">          <span class="comment">// 当该 View 从 Window 中移除时，则执行该任务</span></span><br><span class="line">          mainHandler.post(watchDetachedView)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将内部定义的 listener 加入到 onRootViewsChangedListeners 列表中</span></span><br><span class="line">    <span class="comment">// 这样的话 listener 后续就可以接受到 回调了</span></span><br><span class="line">    Curtains.onRootViewsChangedListeners += listener</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun <span class="title function_">uninstall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 移除该 listener</span></span><br><span class="line">    Curtains.onRootViewsChangedListeners -= listener</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>z在 install() 方法中会将内部定义的 listener 加入到 onRootViewsChangedListeners 列表中，这样的话，该 listener 后续就可以接受到 回调了。</p>
<p>而在这个 listener 接收到回调时，会先判断该 View 对应的 Window 类型，然后再根据 Window 类型来决定要不要执行后续的监测工作。</p>
<p>如果需要监测的话，则会给该 根View 注册 OnAttachStateChangeListener 回调，然后在其 onViewDetachedFromWindow() 时，去判断该 根View 后续是否会被回收。</p>
<p>逻辑很简单，但是这里的 listener 是 OnRootViewAddedListener 类型的，并且是将其加入到 Curtains.onRootViewsChangedListeners 列表中的，所以我们需要看看该 OnRootViewAddedListener 什么时候会被调用。</p>
<p>在此之前，我们简单了解下 Android 中的 WindowManager 。在 Android 开发中，如果要显示一个全局悬浮 View ，一种方式是往往每个 Activity 中的根 DecorView 中 addView 来显示，但是这样的话页面切换时，新老页面中会同时存在两个 View ；另外一种更常用的方式是获取全局 WindowManager 实例，然后调用 WindowManager 的 addView 方法来添加一个全局的View来显示。我们通过源码来简单分析下这种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.view.ViewManager</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ViewManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeView</span><span class="params">(View view)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// android.view.WindowManager</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WindowManager</span> <span class="keyword">extends</span> <span class="title class_">ViewManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">WindowManager</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到 WindowManagerGlobal 单例对象</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WindowManagerGlobal</span> <span class="variable">mGlobal</span> <span class="operator">=</span> WindowManagerGlobal.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将所有的工作交给 WindowManagerGlobal 来实现，</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，调用 WindowManager 的 addView 方法时，实际会执行到全局单例的  WindowManagerGlobal 中去，接着我们看看这个类是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.view.WindowManagerGlobal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowManagerGlobal</span> &#123;</span><br><span class="line">    <span class="comment">// 存储当前 addView 添加进来的 View</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;View&gt;();</span><br><span class="line">    <span class="comment">// 存储上面 mViews 中每个 View 创建的 ViewRootImpl 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewRootImpl&gt;();</span><br><span class="line">    <span class="comment">// 存储 addView 时为每个 View 设置的布局信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;view must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;display must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams) params;</span><br><span class="line">        <span class="keyword">if</span> (parentWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                            &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ViewRootImpl root;</span><br><span class="line">        <span class="type">View</span> <span class="variable">panelParentView</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 从 mViews 里面寻找当前要添加的这个 view 的 index。大于等于 0 表示已存在在 mViews 里面了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findViewLocked(view, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                    mRoots.get(index).doDie();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;View &quot;</span> + view</span><br><span class="line">                            + <span class="string">&quot; has already been added to the window manager.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果这是一个子窗口(popupWindow)，找到他的父窗口</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                    wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mViews.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                        panelParentView = mViews.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建 ViewRootImpl，并且将View与之绑定</span></span><br><span class="line"><span class="comment">             * 然后在整个APP 全局唯一的 WindowManagerGlobal 中将每个 view、viewRootImpl、windowLayoutParams 缓存起来</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * ViewRootImpl 相当于时 Window 和 View 之间的桥梁，Window使用 ViewRootImpl 可以操作 View</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">            view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 挨个保存这些 View、ViewRootImpl 和布局参数 wparams</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            mViews.add(view);</span><br><span class="line">            mRoots.add(root);</span><br><span class="line">            mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                root.setView(view, wparams, panelParentView);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    removeViewLocked(index, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只关心  WindowManagerGlobal 中的 addView() 方法，该方法中会进行 balabala 的一阵操作，最后将该 View 保存到其内部的 mViews 列表中。</p>
<p>好了对于 WindowManager#addView() 方法这里只介绍到这里，我们只需要知道这个 mViews 就行。</p>
<p>接下来回到 RootViewWatcher 中来看 Curtains.onRootViewsChangedListeners ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Curtains.kt</span></span><br><span class="line"></span><br><span class="line">object Curtains &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当使用 rootViewsSpy 属性时，会执行 RootViewsSpy.install() 方法来返回一个 RootViewsSpy 实例</span></span><br><span class="line">  <span class="keyword">private</span> val rootViewsSpy by <span class="title function_">lazy</span><span class="params">(LazyThreadSafetyMode.NONE)</span> &#123;</span><br><span class="line">    RootViewsSpy.install()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@JvmStatic</span></span><br><span class="line">  val rootViews: List&lt;View&gt;</span><br><span class="line">    <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> rootViewsSpy.copyRootViewList()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外部使用该 onRootViewsChangedListeners 属性时，会拿到 rootViewsSpy 中的 listeners</span></span><br><span class="line">  <span class="meta">@JvmStatic</span></span><br><span class="line">  val onRootViewsChangedListeners: MutableList&lt;OnRootViewsChangedListener&gt;</span><br><span class="line">    <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> rootViewsSpy.listeners</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在外部访问 Curtains.onRootViewsChangedListeners 时，会去拿到 rootViewsSpy 属性中的 listeners 返回出来，此时会去访问 rootViewsSpy 属性，进而会去执行：RootViewsSpy.install() 方法拿到一个 RootViewsSpy 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RootViewsSpy.kt</span></span><br><span class="line"></span><br><span class="line">internal <span class="keyword">class</span> <span class="title class_">RootViewsSpy</span> <span class="keyword">private</span> <span class="title function_">constructor</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">val</span> <span class="variable">listeners</span> <span class="operator">=</span> CopyOnWriteArrayList&lt;OnRootViewsChangedListener&gt;()</span><br><span class="line"></span><br><span class="line">  fun <span class="title function_">copyRootViewList</span><span class="params">()</span>: List&lt;View&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">      delegatingViewList.toList()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      WindowManagerSpy.windowManagerMViewsArray().toList()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部定义一个 ArrayList 实例，重写其 add 和 removeAt 方法来监测添加和删除</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">val</span> <span class="variable">delegatingViewList</span> <span class="operator">=</span> object : ArrayList&lt;View&gt;() &#123;</span><br><span class="line">    override fun <span class="title function_">add</span><span class="params">(element: View)</span>: Boolean &#123;</span><br><span class="line">      listeners.forEach &#123; it.onRootViewsChanged(element, <span class="literal">true</span>) &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">removeAt</span><span class="params">(index: Int)</span>: View &#123;</span><br><span class="line">      <span class="type">val</span> <span class="variable">removedView</span> <span class="operator">=</span> <span class="built_in">super</span>.removeAt(index)</span><br><span class="line">      listeners.forEach &#123; it.onRootViewsChanged(removedView, <span class="literal">false</span>) &#125;</span><br><span class="line">      <span class="keyword">return</span> removedView</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  companion object &#123;</span><br><span class="line">    fun <span class="title function_">install</span><span class="params">()</span>: RootViewsSpy &#123;</span><br><span class="line">      <span class="comment">// 创建一个 RootViewsSpy 实例，并且会</span></span><br><span class="line">      <span class="keyword">return</span> RootViewsSpy().apply &#123;</span><br><span class="line">        <span class="comment">// 调用 WindowManagerSpy.swapWindowManagerGlobalMViews 方法</span></span><br><span class="line">        <span class="comment">// 来将当前 delegatingViewList 替换掉 WindowManagerGlobal 中的 mViews</span></span><br><span class="line">        WindowManagerSpy.swapWindowManagerGlobalMViews &#123; mViews -&gt;</span><br><span class="line">          delegatingViewList.apply &#123; addAll(mViews) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 RootViewsSpy 中定义了一个 delegatingViewList ，它继承自 ArrayList ，并且重写了 ArrayList 中的 add() 和 removeAt() 方法，往其中插入了回调 listeners 的逻辑，即分别在add() 方法和 removeAt() 方法中插入了遍历 listeners 的逻辑，也就是会去遍历调用  listeners 中每个 Item  的 onRootViewsChanged 方法，传入参数 element ，表示当前发生变化的view实例；以及传入第二个参数 true 或者 false ，分别表示当前发生变化的view 是被添加还是被移除的。</p>
<p>接着看 install() 方法中的核心逻辑，首先会去创建一个 RootViewsSpy 实例，接着会调用  WindowManagerSpy.swapWindowManagerGlobalMViews() 方法来返回该 RootViewsSpy 实例中的 delegatingViewList ，在返回该 delegatingViewList 之前，会将入参 mViews 添加进去。看不懂是吧？这便是 Kotlin 语法糖带来的问题，可读性下降了，但是编码写起来却很爽哈哈哈，开玩笑的，看不懂的原因是因为还没讲 WindowManagerSpy 呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowManagerSpy.kt</span></span><br><span class="line"></span><br><span class="line">internal object WindowManagerSpy &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反射拿到 WindowManagerGlobal 对应的 Class</span></span><br><span class="line">  <span class="keyword">private</span> val windowManagerClass by <span class="title function_">lazy</span><span class="params">(LazyThreadSafetyMode.NONE)</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">className</span> <span class="operator">=</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; <span class="number">16</span>) &#123;</span><br><span class="line">      <span class="string">&quot;android.view.WindowManagerGlobal&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="string">&quot;android.view.WindowManagerImpl&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(className)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      Log.w(<span class="string">&quot;WindowManagerSpy&quot;</span>, ignored)</span><br><span class="line">      <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反射拿到 WindowManagerGlobal 的实例，实际是调用其 getInstance() 方法</span></span><br><span class="line">  <span class="keyword">private</span> val windowManagerInstance by <span class="title function_">lazy</span><span class="params">(LazyThreadSafetyMode.NONE)</span> &#123;</span><br><span class="line">    windowManagerClass?.let &#123; windowManagerClass -&gt;</span><br><span class="line">      <span class="type">val</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="string">&quot;getInstance&quot;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;getDefault&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      windowManagerClass.getMethod(methodName).invoke(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反射拿到 WindowManagerGlobal 中的 mViews 方法定义</span></span><br><span class="line">  <span class="keyword">private</span> val mViewsField by <span class="title function_">lazy</span><span class="params">(LazyThreadSafetyMode.NONE)</span> &#123;</span><br><span class="line">    windowManagerClass?.let &#123; windowManagerClass -&gt;</span><br><span class="line">      windowManagerClass.getDeclaredField(<span class="string">&quot;mViews&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can discourage me all you want I&#x27;ll still do it.</span></span><br><span class="line">  <span class="meta">@SuppressLint(&quot;PrivateApi&quot;, &quot;ObsoleteSdkInt&quot;, &quot;DiscouragedPrivateApi&quot;)</span></span><br><span class="line">  fun <span class="title function_">swapWindowManagerGlobalMViews</span><span class="params">(swap: (ArrayList&lt;View&gt;)</span> -&gt; ArrayList&lt;View&gt;) &#123;</span><br><span class="line">    <span class="comment">// API 19以下不支持</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">19</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 反射拿到 WindowManagerGlobal 的实例</span></span><br><span class="line">      windowManagerInstance?.let &#123; windowManagerInstance -&gt;</span><br><span class="line">        mViewsField?.let &#123; mViewsField -&gt;</span><br><span class="line">          <span class="meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span></span><br><span class="line">          <span class="comment">// 拿到 WindowManagerGlobal 实例中的 mViews 属性实例，存到 mViews 中</span></span><br><span class="line">          <span class="type">val</span> <span class="variable">mViews</span> <span class="operator">=</span> mViewsField[windowManagerInstance] as ArrayList&lt;View&gt;</span><br><span class="line">          <span class="comment">// 调用 swap 方法来将刚拿出来的 mViews 实例包装成另外一个 ArrayList 实例</span></span><br><span class="line">          <span class="comment">// 并且将包装后的 ArrayList 实例保存到 WindowManagerGlobal 实例中的 mViews 中去</span></span><br><span class="line">          mViewsField[windowManagerInstance] = swap(mViews)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      Log.w(<span class="string">&quot;WindowManagerSpy&quot;</span>, ignored)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fun <span class="title function_">windowManagerMViewsArray</span><span class="params">()</span>: Array&lt;View&gt; &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">sdkInt</span> <span class="operator">=</span> Build.VERSION.SDK_INT</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(sdkInt &gt;= <span class="number">19</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> arrayOf()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      windowManagerInstance?.let &#123; windowManagerInstance -&gt;</span><br><span class="line">        mViewsField?.let &#123; mViewsField -&gt;</span><br><span class="line">          <span class="meta">@Suppress(&quot;UNCHECKED_CAST&quot;)</span></span><br><span class="line">          <span class="keyword">return</span> mViewsField[windowManagerInstance] as Array&lt;View&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      Log.w(<span class="string">&quot;WindowManagerSpy&quot;</span>, ignored)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayOf()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 WindowManagerSpy 的 swapWindowManagerGlobalMViews() 方法中，会先通过反射获取到 WindowManagerGlobal 实例中的 mViews 属性实例，然后再调用入参 swap 函数来将 mViews 转换为另外一个 ArrayList 实例，也就是前面讲的 RootViewsSpy 实例中的 delegatingViewList 。这也就解释了前面为啥 RootViewsSpy 的 install() 方法中为啥要 addAll 了，因为得保存 WindowManagerGlobal 实例中的 mViews 属性中原先的那些 View。</p>
<p>所以这里一切就都通了，结合前面 WindowMnager 的分析，所以这里监测 根View 的变化，主要是通过反射替换 WindowManagerGlobal 中的 mViews 属性，进而监测到其添加和删除动作，进而回调到外面去，也就是 RootViewWatcher 中去，进而可以完成后续的监测了。</p>
<h3 id="ServiceWatcher"><a href="#ServiceWatcher" class="headerlink" title="ServiceWatcher"></a>ServiceWatcher</h3><p>ServiceWatcher 中主要完成的任务是监测 Service 的回收，其实也就是监测 Service 的 onDestroy() 方法调用。我们来看看 leakcanary 是怎么实现监测的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceWatcher</span>(<span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> servicesToBeDestroyed = WeakHashMap&lt;IBinder, WeakReference&lt;Service&gt;&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反射拿到 ActivityThread</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> activityThreadClass <span class="keyword">by</span> lazy &#123; Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反射拿到 ActivityThread 实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> activityThreadInstance <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    activityThreadClass.getDeclaredMethod(<span class="string">&quot;currentActivityThread&quot;</span>).invoke(<span class="literal">null</span>)!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> activityThreadServices <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="comment">// 拿到 ActivityThread 中的 mServices 属性</span></span><br><span class="line">    <span class="keyword">val</span> mServicesField =</span><br><span class="line">      activityThreadClass.getDeclaredField(<span class="string">&quot;mServices&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到 ActivityThread 实例中的 mServices 实例，它是一个 Map 内部存储着当前APP中所有的 Service 实例</span></span><br><span class="line">    <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">    mServicesField[activityThreadInstance] <span class="keyword">as</span> Map&lt;IBinder, Service&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> uninstallActivityThreadHandlerCallback: (() -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> uninstallActivityManager: (() -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 检查必须是主线程调用</span></span><br><span class="line">    checkMainThread()</span><br><span class="line">    check(uninstallActivityThreadHandlerCallback == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="string">&quot;ServiceWatcher already installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(uninstallActivityManager == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="string">&quot;ServiceWatcher already installed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 代理</span></span><br><span class="line">      swapActivityThreadHandlerCallback &#123; mCallback -&gt;</span><br><span class="line">        <span class="comment">// 这里拿到的 mCallback 是 ActivityThread 实例中的 mH 属性实例 中的 mCallback 属性</span></span><br><span class="line">        <span class="comment">// 当然，它应该是空的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存activityManagerInstance，解除注册时要用的，也就是解除注册时替换为原来空的实例</span></span><br><span class="line">        uninstallActivityThreadHandlerCallback = &#123;</span><br><span class="line">          swapActivityThreadHandlerCallback &#123;</span><br><span class="line">            mCallback</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后新建一个  Handler.Callback 返回出去</span></span><br><span class="line">        Handler.Callback &#123; msg -&gt;</span><br><span class="line">          <span class="keyword">if</span> (msg.obj !<span class="keyword">is</span> IBinder) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@Callback</span> <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 只拦截 STOP_SERVICE 类型的消息</span></span><br><span class="line">          <span class="keyword">if</span> (msg.what == STOP_SERVICE) &#123;</span><br><span class="line">            <span class="keyword">val</span> key = msg.obj <span class="keyword">as</span> IBinder</span><br><span class="line">            <span class="comment">// 从 ActivityThread 实例中的 mServices 实例列表中取出当前要stop的 Service 实例</span></span><br><span class="line">            activityThreadServices[key]?.let &#123;</span><br><span class="line">              onServicePreDestroy(key, it)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 不然的话就走 mH 中原来的 mCallback ，但是它是 null</span></span><br><span class="line">          <span class="comment">// 所以返回 false ，也就是交由原来的 mH 内部实现的 handleMessage 方法去处理</span></span><br><span class="line">          mCallback?.handleMessage(msg) ?: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      swapActivityManager &#123; activityManagerInterface, activityManagerInstance -&gt;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * activityManagerInterface : 是 &quot;android.app.IActivityManager&quot; 对应的 Class</span></span><br><span class="line"><span class="comment">         * activityManagerInstance : 是 调用 ActivityManager 类中的 IActivityManagerSingleton 属性实例</span></span><br><span class="line"><span class="comment">         * -                  的 get() 方法来拿到 IActivityManager 的 binder 代理实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存activityManagerInstance，解除注册时要用的，也就是解除注册时替换为原来的实例</span></span><br><span class="line">        uninstallActivityManager = &#123;</span><br><span class="line">          swapActivityManager &#123; _, _ -&gt;</span><br><span class="line">            activityManagerInstance</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态代理来为 &quot;android.app.IActivityManager&quot; 接口创建一个代理类实例并返回出去</span></span><br><span class="line">        Proxy.newProxyInstance(</span><br><span class="line">          activityManagerInterface.classLoader, arrayOf(activityManagerInterface)</span><br><span class="line">        ) &#123; _, method, args -&gt;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 当外部调用的是 serviceDoneExecuting 方法时,表示ActivityThread 中的 handleStopService 中的逻辑执行完毕了</span></span><br><span class="line"><span class="comment">           * 也就是该 Service 的 onDestroy 方法执行完毕了</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">if</span> (METHOD_SERVICE_DONE_EXECUTING == method.name) &#123;</span><br><span class="line">            <span class="keyword">val</span> token = args!![<span class="number">0</span>] <span class="keyword">as</span> IBinder</span><br><span class="line">            <span class="comment">// 如果该 Service 之前在 ActivityThread 这端调用过 onDestroy</span></span><br><span class="line">            <span class="keyword">if</span> (servicesToBeDestroyed.containsKey(token)) &#123;</span><br><span class="line">              onServiceDestroyed(token)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 走被代理类其自身原来的逻辑，相当于上面就只是注入代码拦截了下 serviceDoneExecuting() 而已</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">              method.invoke(activityManagerInstance)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              method.invoke(activityManagerInstance, *args)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (invocationException: InvocationTargetException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> invocationException.targetException</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ignored: Throwable) &#123;</span><br><span class="line">      SharkLog.d(ignored) &#123; <span class="string">&quot;Could not watch destroyed services&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    checkMainThread()</span><br><span class="line"></span><br><span class="line">    uninstallActivityManager?.invoke()</span><br><span class="line">    uninstallActivityThreadHandlerCallback?.invoke()</span><br><span class="line">    uninstallActivityManager = <span class="literal">null</span></span><br><span class="line">    uninstallActivityThreadHandlerCallback = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServicePreDestroy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    token: <span class="type">IBinder</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    service: <span class="type">Service</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> &#123;</span><br><span class="line">    <span class="comment">// 先把它保存起来</span></span><br><span class="line">    servicesToBeDestroyed[token] = WeakReference(service)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDestroyed</span><span class="params">(token: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 最终被销毁了，此时可以去监测该 Service</span></span><br><span class="line">    servicesToBeDestroyed.remove(token)?.also &#123; serviceWeakReference -&gt;</span><br><span class="line">      serviceWeakReference.<span class="keyword">get</span>()?.let &#123; service -&gt;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          service, <span class="string">&quot;<span class="subst">$&#123;service::class.java.name&#125;</span> received Service#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">swapActivityThreadHandlerCallback</span><span class="params">(swap: (<span class="type">Handler</span>.<span class="type">Callback</span>?) -&gt; <span class="type">Handler</span>.<span class="type">Callback</span>?)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 拿到 ActivityThread 中的 mH 属性定义</span></span><br><span class="line">    <span class="keyword">val</span> mHField =</span><br><span class="line">      activityThreadClass.getDeclaredField(<span class="string">&quot;mH&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="comment">// 拿到 ActivityThread 实例中的 mH 属性实例</span></span><br><span class="line">    <span class="keyword">val</span> mH = mHField[activityThreadInstance] <span class="keyword">as</span> Handler</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到 Handler 中定义的 mCallback 属性</span></span><br><span class="line">    <span class="keyword">val</span> mCallbackField =</span><br><span class="line">      Handler::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;mCallback&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="comment">// 拿到 ActivityThread 实例中的 mH 属性实例 中的 mCallback 属性</span></span><br><span class="line">    <span class="comment">// 当然它应该是空的，因为 mH 中并没有设置 mCallback</span></span><br><span class="line">    <span class="keyword">val</span> mCallback = mCallbackField[mH] <span class="keyword">as</span> Handler.Callback?</span><br><span class="line">    <span class="comment">// 通过 swap 方法来将 mH 中原来的 mCallback 包装代理一层，并将最终的结果保存到 ActivityThread 中的 mH 中</span></span><br><span class="line">    <span class="comment">// 注意这里传入的 mCallback 是其原来的值，拿到最终包装代理之后的值</span></span><br><span class="line">    mCallbackField[mH] = swap(mCallback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressLint(<span class="string">&quot;PrivateApi&quot;</span>)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">swapActivityManager</span><span class="params">(swap: (<span class="type">Class</span>&lt;*&gt;, <span class="type">Any</span>) -&gt; <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> singletonClass = Class.forName(<span class="string">&quot;android.util.Singleton&quot;</span>)</span><br><span class="line">    <span class="comment">// 拿到 android.util.Singleton 中的 mInstance 属性</span></span><br><span class="line">    <span class="keyword">val</span> mInstanceField =</span><br><span class="line">      singletonClass.getDeclaredField(<span class="string">&quot;mInstance&quot;</span>).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到 android.util.Singleton 中的 get 方法</span></span><br><span class="line">    <span class="keyword">val</span> singletonGetMethod = singletonClass.getDeclaredMethod(<span class="string">&quot;get&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到 ActivityManager 的对应类和其内部的属性</span></span><br><span class="line">    <span class="comment">// 比当前 Android O 及其之后的版本是拿 ActivityManager 类中的 IActivityManagerSingleton 属性</span></span><br><span class="line">    <span class="comment">// 然后调用其 get 方法来拿到对应的 IActivityManager</span></span><br><span class="line">    <span class="keyword">val</span> (className, fieldName) = <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">      <span class="string">&quot;android.app.ActivityManager&quot;</span> to <span class="string">&quot;IActivityManagerSingleton&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="string">&quot;android.app.ActivityManagerNative&quot;</span> to <span class="string">&quot;gDefault&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到比如 android.app.ActivityManager 对应的 Class</span></span><br><span class="line">    <span class="keyword">val</span> activityManagerClass = Class.forName(className)</span><br><span class="line">    <span class="comment">// 拿到 ActivityManager 类中的 IActivityManagerSingleton 属性</span></span><br><span class="line">    <span class="keyword">val</span> activityManagerSingletonField =</span><br><span class="line">      activityManagerClass.getDeclaredField(fieldName).apply &#123; isAccessible = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里才是拿到 ActivityManager 类中的 IActivityManagerSingleton 属性的实例</span></span><br><span class="line">    <span class="keyword">val</span> activityManagerSingletonInstance = activityManagerSingletonField[activityManagerClass]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 ActivityManager 类中的 IActivityManagerSingleton 属性实例的 get() 方法来拿到 IActivityManager 的binder代理实例</span></span><br><span class="line">    <span class="keyword">val</span> activityManagerInstance = singletonGetMethod.invoke(activityManagerSingletonInstance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> iActivityManagerInterface = Class.forName(<span class="string">&quot;android.app.IActivityManager&quot;</span>)</span><br><span class="line"></span><br><span class="line">    mInstanceField[activityManagerSingletonInstance] =</span><br><span class="line">      swap(iActivityManagerInterface, activityManagerInstance!!)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> STOP_SERVICE = <span class="number">116</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> METHOD_SERVICE_DONE_EXECUTING = <span class="string">&quot;serviceDoneExecuting&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里就将其所有的代码都贴上来，因为其 install() 方法基本上将其内部的其他属性其他方法都牵扯到了。我们主要看 intstall() 方法中的逻辑。</p>
<p>install() 方法中代码很长，但是逻辑可以大概总结为两步：</p>
<p>① 第一步反射拿到 ActivityThread 实例中的 mH 属性实例 中的 mCallback 属性，然后构建一个新的 Handler.Callback 实例来替换掉它，而在这个 Handler.Callback 实例中会拦截处理 H.STOP_SERVICE &#x3D; 116 的消息，相当于就是拦截来自 ActivityManagerService 中通过 IApplicationThread Binder调用过来的的 scheduleStopService() 方法，在其真正执行 handleStopService() 方法之前将要 stop 的 Service 保存起来，因为它之后的 handleStopService() 方法中会将该 Service 从 ActivityThread 中的 mServices 列表中移除掉，现在不保存就没机会了。</p>
<p>② 第二步拦截当前进程中的 ActivityManagerService 的Binder代理实例，然后通过动态代理生成的类替换掉它，从而实现其 serviceDoneExecuting() 方法的调用拦截。该方法是 handleStopService() 方法中执行外该 Service 的 onDestroy() 方法之后调用的，用来通知 ActivityManagerService 我们这边执行完毕了。</p>
<p>所以这么大一长串代码就是为了实现这个需求，因为用了太多的反射，所以看起来比较绕。</p>
<p>当然如果你不懂为啥要在这两个点，那么建议你去看看：<a href="49929abd.html">Android Service 启动流程全解析</a> ；</p>
<p>当然如果你不知道为啥要修改 mH ，Handler 实例中的 mCallback 属性，那你可以去看看 ：Handler 源码中的 dispatchMessage() 方法，毕竟 Handler 源码应该是都看过的吧。</p>
<p>而在监测到 Service 的 onDestroy() 方法执行完毕之后，还是会在 onServiceDestroyed() 方法中调用 ：reachabilityWatcher.expectWeaklyReachable() 方法去监测后续该 Service 的回收情况。</p>
<p>这种通过反射的方式来注入拦截代码的例子还有很多，比如最常见的插件化中也会用到这些hook ，所以这要求你对源码的执行流程很熟悉才能精确巧妙的找到这些 hook点完成你的需求。</p>
<p>至此，前面提到的 InstallableWatcher 的四个实例就分析完了，他们在对应的对象被销毁时，会调用 reachabilityWatcher.expectWeaklyReachable() 方法去监测后续该对象实例的回收情况，那么接下来就看看该方法中的逻辑。</p>
<h3 id="expectWeaklyReachable"><a href="#expectWeaklyReachable" class="headerlink" title="expectWeaklyReachable"></a>expectWeaklyReachable</h3><p>该方法最终会调用的到其实现类 ObjectWatcher 中，而在 AppWatcher 中会创建出该 ObjectWatcher 实例，并为其指定了 checkRetainedExecutor ，当时指定的 checkRetainedExecutor 是过通过主线程 Handler 来延迟指定的 retainedDelayMillis ，默认是5s 时间后执行的。</p>
<p>接着我们看代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectWatcher.kt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> onObjectRetainedListeners = mutableSetOf&lt;OnObjectRetainedListener&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在观察的对象实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReferenceQueue 实例，用来给后续创建的 WeakReference 实例来用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> queue = ReferenceQueue&lt;Any&gt;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Synchronized</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">expectWeaklyReachable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  description: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 每次开始之前，先把之前的那些从队列中移除掉，处理掉之前的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为本次要监测的对象创建一个唯一key</span></span><br><span class="line">  <span class="keyword">val</span> key = UUID.randomUUID().toString()</span><br><span class="line">  <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用 WeakReference 将要观察的对象包装起来，然后指定一个 queue (ReferenceQueue) ,</span></span><br><span class="line"><span class="comment">   * 如果当 watchedObject 被回收的话，会将其挪入到 queue 中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">val</span> reference = KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">  SharkLog.d &#123;</span><br><span class="line">    <span class="string">&quot;Watching &quot;</span> +</span><br><span class="line">      (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">&quot;instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class="line">      (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">&quot; (<span class="variable">$description</span>)&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) +</span><br><span class="line">      <span class="string">&quot; with key <span class="variable">$key</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将该对象保存在 watchedObjects (HashMap) 中，表示该对象目前正在被监测，后续会将那些已被回收的对象然后从中移除掉</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  watchedObjects[key] = reference</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行延迟任务，比如默认的5s 之后</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  checkRetainedExecutor.execute &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5 s 之后执行到这里</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    moveToRetained(key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Synchronized</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 5s 之后再次从 ReferenceQueue 中检查是否存在被回收的对象，有的话则从 watchedObjects 中移除</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  removeWeaklyReachableObjects()</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1、如果 ReferenceQueue 中有该对象，那么 watchedObjects 中将会移除它，那么这里再从map中get时就会是null</span></span><br><span class="line"><span class="comment">   * 2、如果上面没有移除掉，此时get的值就不是null，那么此时表示该对象可能存在内存泄露了。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 该对象发生内存泄露，此时回调外部注册的监听器。外部的监听器是在 AppWatcher.manualInstall 中调用的</span></span><br><span class="line"><span class="comment">   * 最终监听器是在 InternalLeakCanary 中，即调用到：InternalLeakCanary # onObjectRetained 中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">    retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">    onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 ReferenceQueue 中查找一下，当前是否有被回收的对象，有的话则poll 会拿到被回收的对象</span></span><br><span class="line"><span class="comment"> * 没有的话，则表示没有被回收的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 有被回收的对象，则从目前观察对象的列表中移除它，表示它已经被回收了，而这个列表中最终存在的都是没被回收掉的</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      watchedObjects.remove(ref.key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来往后的逻辑就比较简单了，这里会将要观察的对象包装到一个 KeyedWeakReference 中，这个 KeyedWeakReference 它是继承自 WeakReference 的，所以它会在系统 gc 时被回收。在创建这个 WeakReference 实例时，还会给其指定一个 ReferenceQueue ，那么后续该 KeyedWeakReference 被回收时，这个 ReferenceQueue 中就能找到它。</p>
<p>然后将该KeyedWeakReference 实例先保存到 watchedObjects 列表中，接着执行一个延迟任务，等固定时长，比如5s 之后再去 ReferenceQueue 中找该 KeyedWeakReference 是否存在，存在的话则表示该对象已被回收；不存在的话表示该对象还没有被回收，可能存在内存泄露。那么会调用 onObjectRetainedListeners 接口通知到 InternalLeakCanary 那边去。</p>
<p>这便是一整个流程了，是不是比较简单的。</p>
<p>接着往后看：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InternalLeakCanary.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onObjectRetained</span><span class="params">()</span></span> = scheduleRetainedObjectCheck()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>::heapDumpTrigger.isInitialized) &#123;</span><br><span class="line">    heapDumpTrigger.scheduleRetainedObjectCheck()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// HeapDumpTrigger.kt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  delayMillis: <span class="type">Long</span> = <span class="number">0</span>L</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 检查刚才是否已经调用过当前方法了，因为内部会延迟执行后续逻辑</span></span><br><span class="line">  <span class="keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt</span><br><span class="line">  <span class="comment">// 避免异步任务重复执行</span></span><br><span class="line">  <span class="keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis</span><br><span class="line">  <span class="comment">// 延迟执行后续的 checkRetainedObjects() 逻辑</span></span><br><span class="line">  backgroundHandler.postDelayed(&#123;</span><br><span class="line">    checkScheduledAt = <span class="number">0</span></span><br><span class="line">    checkRetainedObjects()</span><br><span class="line">  &#125;, delayMillis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 InternalLeakCanary 中，会将后续逻辑都交给 HeapDumpTrigger 来处理，而 HeapDumpTrigger 实例的创建是在前面 LeakCanary 安装时就已经初始化过的。</p>
<p>接下来看看 dump 操作的流程：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HeapDumpTrigger.kt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> config = configProvider()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略 Nope 的情况</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断 ObjectWatcher 中的 watchedObjects 列表中存在的 KeyedWeakReference 个数</span></span><br><span class="line"><span class="comment">   * 这些 KeyedWeakReference 实例都是现在还没被回收的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 存在的话，尝试GC一次</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * runGc 里面会先调用 runtime.gc,然后等待100ms，然后 System.runFinalization()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    gcTrigger.runGc()</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面完事儿之后再次判断 watchedObjects 中是否还有对象，还有的话那多半内就是内存泄露了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查目前泄露的对象个数是否达到一定阈值(默认是5个)，达到了才会去执行后续 dump 操作</span></span><br><span class="line">  <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> now = SystemClock.uptimeMillis()</span><br><span class="line">  <span class="keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis</span><br><span class="line">  <span class="comment">// 判断本次出现泄露和上次出现泄露的时间是否小于1min，是的话则通知提示</span></span><br><span class="line">  <span class="keyword">if</span> (elapsedSinceLastDumpMillis &lt; HeapDumpTrigger.WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">    InternalLeakCanary.onRetainInstanceListener.onEvent(RetainInstanceEvent.CountChanged.DumpHappenedRecently)</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">      objectCount = retainedReferenceCount,</span><br><span class="line">      contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 并且延迟处理，两次 dump 的时间差至少间隔 1min</span></span><br><span class="line">    scheduleRetainedObjectCheck(</span><br><span class="line">      delayMillis = HeapDumpTrigger.WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 准备正式 dump 了，所以先隐藏掉之前的通知</span></span><br><span class="line">  dismissRetainedCountNotification()</span><br><span class="line">  <span class="keyword">val</span> visibility = <span class="keyword">if</span> (applicationVisible) <span class="string">&quot;visible&quot;</span> <span class="keyword">else</span> <span class="string">&quot;not visible&quot;</span></span><br><span class="line">  dumpHeap(</span><br><span class="line">    retainedReferenceCount = retainedReferenceCount,</span><br><span class="line">    retry = <span class="literal">true</span>,</span><br><span class="line">    reason = <span class="string">&quot;<span class="variable">$retainedReferenceCount</span> retained objects, app is <span class="variable">$visibility</span>&quot;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dumpHeap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  retainedReferenceCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  retry: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  reason: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">  <span class="comment">// dump 文件的存储路径</span></span><br><span class="line">  <span class="keyword">val</span> directoryProvider = InternalLeakCanary.createLeakDirectoryProvider(InternalLeakCanary.application)</span><br><span class="line">  <span class="keyword">val</span> heapDumpFile = directoryProvider.newHeapDumpFile()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> durationMillis: <span class="built_in">Long</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    InternalLeakCanary.sendEvent(EventListener.Event.DumpingHeap(currentEventUniqueId))</span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Could not create heap dump file&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    saveResourceIdNamesToMemory()</span><br><span class="line">    <span class="keyword">val</span> heapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">    KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式开始 dump 操作，也就是调用  Debug.dumpHprofData 方法</span></span><br><span class="line">    durationMillis = measureDurationMillis &#123;</span><br><span class="line">      configProvider().heapDumper.dumpHeap(heapDumpFile)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile.length() == <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;Dumped heap file is 0 byte length&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    lastDisplayedRetainedObjectCount = <span class="number">0</span></span><br><span class="line">    lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">    objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)</span><br><span class="line">    currentEventUniqueId = UUID.randomUUID().toString()</span><br><span class="line">    InternalLeakCanary.sendEvent(</span><br><span class="line">      EventListener.Event.HeapDump(</span><br><span class="line">        currentEventUniqueId,</span><br><span class="line">        heapDumpFile,</span><br><span class="line">        durationMillis,</span><br><span class="line">        reason</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">catch</span> (throwable: Throwable) &#123;</span><br><span class="line">    InternalLeakCanary.sendEvent(EventListener.Event.HeapDumpFailed(currentEventUniqueId, throwable, retry))</span><br><span class="line">    <span class="keyword">if</span> (retry) &#123;</span><br><span class="line">      scheduleRetainedObjectCheck(</span><br><span class="line">        delayMillis = HeapDumpTrigger.WAIT_AFTER_DUMP_FAILED_MILLIS</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    showRetainedCountNotification(</span><br><span class="line">      objectCount = retainedReferenceCount,</span><br><span class="line">      contentText = application.getString(</span><br><span class="line">        R.string.leak_canary_notification_retained_dump_failed</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较长，这里总结下其流程：</p>
<p>① 拿到前面的 objectWatcher 中的 watchedObjects 列表的个数，这个 个数就是当前没被回收掉的对象的数量，判断它如果大于0，也就是还存在没被回收掉的对象实例，则此时尝试通知系统进程 gc 操作。尽量尝试回收掉对象，避免误判。</p>
<p>② gc 之后再次获取 watchedObjects 列表的个数，判断那些对象现在是否已被回收，还没有被回收的话则表示这些对象确实是被泄露了。那么此时判断该个数是否大于指定阈值，默认是5。如果没超过则忽略后续操作，超过了才会接着往后执行</p>
<p>③ 判断距离上次 dump 操作的时间差，如果小于1分钟，则出提示提醒开发者，然后延后指定时间来处理。确保两次 dump 操作的时间差不能小于1分钟。</p>
<p>前面的操作都是为了减少dump操作，因为 dump 操作确实是个很耗时的操作。</p>
<p>④ 执行到这里，表示要进程 dump 操作了，此时会先为 dump 文件指定路径等操作，最后调用 heapDumper.dumpHeap() 方法来完成 dump 操作，其实就是执行 Debug.dumpHprofData() 方法。</p>
<p>至此，就完成了 hprof 文件的生成操作，后续开发者就可以拿到该文件来进行分析了。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/leakcanary/">leakcanary</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/64b5b134.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Kotlin协程 - 概述</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/7e3c732d.html">
        <span class="next-text nav-default">leakcanary install 分析</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
