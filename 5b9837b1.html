<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Binder - Client数据发送"/>




  <meta name="keywords" content="Binder," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/5b9837b1.html"/>


<meta name="description" content="前面一直讲：ServiceManager 服务在不同的进程中对应的都是 handle &#x3D; 0 的 BpBinder 代理类。下面从这个切入点开始在某个 Client 进程中如何获取 SM “实例”，并完成数据发送和数据接收的。 获取 SM在前面说过在发送数据给另外的进程之前，或者说是请求其他服务能力时，首先需要去 SM 中查找该服务的“实例”。这里说是实例其实不太对，因为该实例真正是位于">
<meta property="og:type" content="article">
<meta property="og:title" content="Binder - Client数据发送">
<meta property="og:url" content="https://youngkaaa.github.io/5b9837b1.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="前面一直讲：ServiceManager 服务在不同的进程中对应的都是 handle &#x3D; 0 的 BpBinder 代理类。下面从这个切入点开始在某个 Client 进程中如何获取 SM “实例”，并完成数据发送和数据接收的。 获取 SM在前面说过在发送数据给另外的进程之前，或者说是请求其他服务能力时，首先需要去 SM 中查找该服务的“实例”。这里说是实例其实不太对，因为该实例真正是位于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/5b9837b1/pic01.png">
<meta property="og:image" content="https://youngkaaa.github.io/5b9837b1/pic02.png">
<meta property="article:published_time" content="2022-06-07T02:48:56.000Z">
<meta property="article:modified_time" content="2022-12-27T13:32:54.235Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="Binder">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/5b9837b1/pic01.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Binder - Client数据发送 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Binder - Client数据发送
        
      </h1>

      <time class="post-time">
          6月 07 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>前面一直讲：ServiceManager 服务在不同的进程中对应的都是 handle &#x3D; 0 的 BpBinder 代理类。下面从这个切入点开始在某个 Client 进程中如何获取 SM “实例”，并完成数据发送和数据接收的。</p>
<h3 id="获取-SM"><a href="#获取-SM" class="headerlink" title="获取 SM"></a>获取 SM</h3><p>在前面说过在发送数据给另外的进程之前，或者说是请求其他服务能力时，首先需要去 SM 中查找该服务的“实例”。这里说是实例其实不太对，因为该实例真正是位于服务所在进程的，而不是当前进程，当前进程就算是拿到其实例地址也没用。所以这里的“实例”其实是该服务实例在当前进程中的一个代理。这里代理对象和真正的实例实现了同一个接口，因此其使用起来跟原实例没啥区别，但是实际两者天差地别。</p>
<p>在获取 SM 实例的操作分为Cpp层和Java层，但两者的调用路径绝大多数都是重合的，所以这里以Cpp来讲解。</p>
<p>开始以 MediaPlayerService 的注册为例子,其注册时的逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main_mediaserver.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建当前进程的 ProcessState 单例对象</span></span><br><span class="line"><span class="comment">     * 其内部在常见 ProcessState 时，会先打开 binder 驱动，然后对打开的binder驱动执行 mmap 操作，然后保存 mmap 映射在当前进程的地址 mVMStart</span></span><br><span class="line"><span class="comment">     * 而 ProcessState 是单例，则保证了一个进程只会打开一次 binder 驱动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前进程的 servierManger 实例，实际是获取到了 BpServiceManager 对象实例</span></span><br><span class="line"><span class="comment">     * 其内部包装了了一个 handle=0 的 BpBinder 对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">AIcu_initializeIcuOrDie</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始注册 多媒体 服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MediaPlayerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    ResourceManagerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    <span class="built_in">registerExtensions</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动 binder 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前线程加入到线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// MediaPlayerService.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MediaPlayerService::instantiate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拿到 ServiceManager ，然后调用起 addService 方法来注册 media.player 服务</span></span><br><span class="line"><span class="comment">     * 等价于调用 BpServiceManager()-&gt;addService 方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * MediaPlayerService 继承自: </span></span><br><span class="line"><span class="comment">     * BnMediaPlayerService -&gt; BnInterface&lt;IMediaPlayerService&gt; -&gt; BBinder -&gt; IBinder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">defaultServiceManager</span>()-&gt;<span class="built_in">addService</span>(</span><br><span class="line">            <span class="built_in">String16</span>(<span class="string">&quot;media.player&quot;</span>), <span class="keyword">new</span> <span class="built_in">MediaPlayerService</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 SM addService 方法之后，后续其他进程就可以通过 “media.player” 去SM 中查找时就可以对应到该服务了。在这里就会通过调用: defaultServiceManager() 方法来获取SM实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IServiceManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">nullptr</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.ProcessState::self() 拿到进程单例的 ProcessState 实例</span></span><br><span class="line"><span class="comment">             * 2.ProcessState::getContextObject() 拿到 ServiceManager(0位置)的 BpBinder 实例</span></span><br><span class="line"><span class="comment">             * 3.interface_cast 模板方法：调用 IServiceManager::asInterface(obj) </span></span><br><span class="line"><span class="comment">             * - 这里的 obj 就是前面获取到的 BpBinder 实例</span></span><br><span class="line"><span class="comment">             * - 而 asInterface 方法是通过宏定义来注入的，其实现详见后面</span></span><br><span class="line"><span class="comment">             * - 实际内部会创建一个 BpServiceManager 实例，然后将上面创建出来的 handle =0 的 BpBinder 传入进去</span></span><br><span class="line"><span class="comment">             * - 所以 gDefaultServiceManager 相当于 : new BpServiceManager(new BpBinder(0))</span></span><br><span class="line"><span class="comment">             * - 而 BpServiceManager 的定义后续再单独讲</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            gDefaultServiceManager = <span class="built_in">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">nullptr</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面按顺序拆分分析下 defaultServiceManager() 方法的执行：</p>
<p>1、ProcessState::self() ： 正如前文所说，这个ProcessState 是进程单例，其 self() 方法会返回其进程单例对象。在ProcessState 构造方法内，会为当前进程和Binder 驱动自动做好内存映射工作，详见前文。</p>
<p>2、ProcessState::getContextObject() ： 获取SM服务对应在当前进程的BpBinder代理实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessState.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找 0 位置的 BpBinder 实例，也就是 Service Manager 的 BpBinder 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getStrongProxyForHandle</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先从 ProcessState 类中的 mHandleToObject 列表中查找 handle 位置的 entry</span></span><br><span class="line"><span class="comment">     * 内部有的话则返回之前的，没有的话则创建一个放入列表并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    handle_entry* e = <span class="built_in">lookupHandleLocked</span>(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn&#x27;t currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果上面查询到的 handle 位置的 enrty 中 binder 为 null 或者其引用失效了</span></span><br><span class="line"><span class="comment">         * 那么需要为其创建一个 BpBinder 实例</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 为 null 的情况应该是在 lookupHandleLocked 中没找到，新创建的情况</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">nullptr</span> || !e-&gt;refs-&gt;<span class="built_in">attemptIncWeak</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Special case for context manager...</span></span><br><span class="line">                <span class="comment">// The context manager is the only object for which we create</span></span><br><span class="line">                <span class="comment">// a BpBinder proxy without already holding a reference.</span></span><br><span class="line">                <span class="comment">// Perform a dummy transaction to ensure the context manager</span></span><br><span class="line">                <span class="comment">// is registered before we create the first local reference</span></span><br><span class="line">                <span class="comment">// to it (which will occur when creating the BpBinder).</span></span><br><span class="line">                <span class="comment">// If a local reference is created for the BpBinder when the</span></span><br><span class="line">                <span class="comment">// context manager is not present, the driver will fail to</span></span><br><span class="line">                <span class="comment">// provide a reference to the context manager, but the</span></span><br><span class="line">                <span class="comment">// driver API does not return status.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// Note that this is not race-free if the context manager</span></span><br><span class="line">                <span class="comment">// dies while this code runs.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> add a driver API to wait for context manager, or</span></span><br><span class="line">                <span class="comment">// stop special casing handle 0 for context manager and add</span></span><br><span class="line">                <span class="comment">// a driver API to get a handle to the context manager with</span></span><br><span class="line">                <span class="comment">// proper reference counting.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 对于 Service Manager 来说，首先试一下是否可以连接通</span></span><br><span class="line"><span class="comment">                 * 通过 PING_TRANSACTION 来判断是否准备就绪 </span></span><br><span class="line"><span class="comment">                 * 如果在 context manager 还未生效前，一个 BpBinder 的本地引用就已经被创建，</span></span><br><span class="line"><span class="comment">                 * 那么驱动将无法提供 context manager 的引用</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 内部只是创建一个 BpBinder 实例，将 handle 封装了起来而已</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            b = BpBinder::<span class="built_in">create</span>(handle);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 将其赋值给 handle 位置刚查出来的 entry ，来保存起来。后续查找时就不是 null 了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;<span class="built_in">getWeakRefs</span>();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn&#x27;t have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;<span class="built_in">decWeak</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ProcessState::handle_entry* <span class="title">ProcessState::lookupHandleLocked</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> N=mHandleToObject.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果该 handle 不存在于 mHandleToObject 中，则向该Vector中添加(handle+1-N)个handle_entry结构体</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * handle =0 代表的是 ServiceManager ，所以 handle 可以理解为对应服务序号</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 假设当你要获取 handle = 3 的 binder 对象时，此时 mHandleToObject 列表中只有一个元素，N=1</span></span><br><span class="line"><span class="comment">     * 那么此时会插入 handle+1-N = 3+1-1 =3个 handle_entry 实例，此时 mHandleToObject 列表中就存在 4 个元素了</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 那么最后 mHandleToObject.editItemAt(3) 就合法了 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="type">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">nullptr</span>;</span><br><span class="line">        e.refs = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">status_t</span> err = mHandleToObject.<span class="built_in">insertAt</span>(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 之前有的话则返回之前的</span></span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.<span class="built_in">editItemAt</span>(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在查找 handle &#x3D; 0 时，首先会从 mHandleToObject 列表中查找是否已经有缓存了，有的话则直接复用；没有的话则会创建一个新的 BpBinder 实例将其存储起来并返回。</p>
<blockquote>
<p>这里如果找到了的话，表示在当前进程之前已经访问过该 handle 值了，访问过一次的话当前进程 ProcessState 实例中的 mHandleToObject 列表就会将其 BpBinder 实例缓存起来。</p>
</blockquote>
<p>下面看看BpBinder 是怎么创建的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BpBinder.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function">BpBinder* <span class="title">BpBinder::create</span><span class="params">(<span class="type">int32_t</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> trackedUid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// sCountByUidEnabled = false，里面逻辑可以先不考虑</span></span><br><span class="line">    <span class="keyword">if</span> (sCountByUidEnabled) &#123;</span><br><span class="line">        trackedUid = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">getCallingUid</span>();</span><br><span class="line">        AutoMutex _l(sTrackingLock);</span><br><span class="line">        <span class="type">uint32_t</span> trackedValue = sTrackingMap[trackedUid];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(trackedValue &amp; LIMIT_REACHED_MASK)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((trackedValue &amp; COUNTING_VALUE_MASK) &gt;= sBinderProxyCountHighWatermark) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;Too many binder proxy objects sent to uid %d from uid %d (%d proxies held)&quot;</span>,</span><br><span class="line">                      <span class="built_in">getuid</span>(), trackedUid, trackedValue);</span><br><span class="line">                sTrackingMap[trackedUid] |= LIMIT_REACHED_MASK;</span><br><span class="line">                <span class="keyword">if</span> (sLimitCallback) <span class="built_in">sLimitCallback</span>(trackedUid);</span><br><span class="line">                <span class="keyword">if</span> (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                    <span class="built_in">ALOGI</span>(<span class="string">&quot;Throttling binder proxy creates from uid %d in uid %d until binder proxy&quot;</span></span><br><span class="line">                          <span class="string">&quot; count drops below %d&quot;</span>,</span><br><span class="line">                          trackedUid, <span class="built_in">getuid</span>(), sBinderProxyCountLowWatermark);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sTrackingMap[trackedUid]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个 BpBinder 实例返回出去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BpBinder</span>(handle, trackedUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承自 IBinder 接口，</span></span><br><span class="line"><span class="comment"> * @param handle   对应的 handle id ，可以理解为某个地方数组的索引</span></span><br><span class="line"><span class="comment"> * @param trackedUid  -1 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BpBinder::<span class="built_in">BpBinder</span>(<span class="type">int32_t</span> handle, <span class="type">int32_t</span> trackedUid)</span><br><span class="line">    : <span class="built_in">mHandle</span>(handle)</span><br><span class="line">    , <span class="built_in">mAlive</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mObitsSent</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mObituaries</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mTrackedUid</span>(trackedUid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating BpBinder %p handle %d\n&quot;</span>, <span class="keyword">this</span>, mHandle);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延长对象的生命时间</span></span><br><span class="line">    <span class="built_in">extendObjectLifetime</span>(OBJECT_LIFETIME_WEAK);</span><br><span class="line">    <span class="comment">// handle 所对应的 bindle 弱引用 + 1</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">incWeakHandle</span>(handle, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>很简单，就是将入参 handle 值保存起来而已。所以可以把 BpBinder 简单认为是封装了 handle 值并且实现了 IBinder 接口的类。</p>
<p>上述代码也可以看出，在binder中很多地方都充斥着 handle &#x3D; 0 的硬编码，这也正好印证了 SM 服务在所有进程中都是预置的 handle&#x3D;0。</p>
<p>3、interface_cast ：这是最后一步，用来将上一步返回的 BpBinder(0) 包装成或者说是转换成 IServiceManager 接口的一个实现类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IInterface.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; <span class="title">interface_cast</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::<span class="built_in">asInterface</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它实际是调用到了INTERFACE::asInterface() 方法内，这里对应的是 ： IServiceManager.asInterface() 方法，而该方法是通过之前提及的 IMPLEMENT_META_INTERFACE 宏展开的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IServiceManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是 IMPLEMENT_META_INTERFACE 宏展开后内容</span></span><br><span class="line"><span class="type">const</span> ::<span class="function">android::String16 <span class="title">IServiceManager::descriptor</span><span class="params">(<span class="string">&quot;android.os.IServiceManager&quot;</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line"><span class="type">const</span> ::<span class="function">android::String16&amp; <span class="title">IServiceManager::getInterfaceDescriptor</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> IServiceManager::descriptor;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 这里的入参 obj 就是 BpBinder 实例了，而该方法内部其实就是创建一个 BpServiceManager(BpBinder)</span></span><br><span class="line"><span class="comment">// 也就是调用到 BpServiceManager 构造方法中去。BpServiceManager的定义在当前文件的上面，大概格式如下：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// BpServiceManager(const sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;IServiceManager&gt;(impl) &#123;    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 可以看到它会继承自 BpInterface (位于 IInterface.h 中)，然后同时继承自: IServiceManager 和 BpRefBase</span></span><br><span class="line"><span class="comment">// 所以内部会首先调用父类的初始化方法，比如 BpRefBase，会先调用 BpRefBase() 构造方法，</span></span><br><span class="line"><span class="comment">// 将这里的 obj(也就是 handle=0 的 BpBinder) 传入进去,其内部会将入参 obj 赋值给 BpRefBase 中的 mRemote </span></span><br><span class="line">::<span class="function">android::sp&lt;IServiceManager&gt; <span class="title">IServiceManager::asInterface</span><span class="params">(<span class="type">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; intr;   </span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 先调用 IBinder 的 queryLocalInterface 方法,BpBinder 中该方法没有额外实现，</span></span><br><span class="line">        <span class="comment">// 则使用的是 Binder.cpp 中的 默认实现 ， 返回null  </span></span><br><span class="line">        intr = <span class="built_in">static_cast</span>&lt;IServiceManager*&gt;(obj-&gt;<span class="built_in">queryLocalInterface</span>(IServiceManager::descriptor).<span class="built_in">get</span>());  </span><br><span class="line">        <span class="keyword">if</span> (intr == <span class="literal">nullptr</span>) &#123;  </span><br><span class="line">            intr = <span class="keyword">new</span> <span class="built_in">BpServiceManager</span>(obj);  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> intr;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">std::unique_ptr&lt;IServiceManager&gt; IServiceManager::default_impl;   </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IServiceManager::setDefaultImpl</span><span class="params">(std::unique_ptr&lt;IServiceManager&gt; impl)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (!IServiceManager::default_impl &amp;&amp; impl) &#123;  </span><br><span class="line">        IServiceManager::default_impl = std::<span class="built_in">move</span>(impl);   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">const</span> std::unique_ptr&lt;IServiceManager&gt;&amp; <span class="title">IServiceManager::getDefaultImpl</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> IServiceManager::default_impl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">IServiceManager::<span class="built_in">IServiceManager</span>() &#123; &#125;  </span><br><span class="line">IServiceManager::~<span class="built_in">IServiceManager</span>() &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，宏展开后的  asInterface 方法逻辑比较简单。入参 obj 此时是 BpBinder(0) ，其 queryLocalInterface() 方法为默认实现返回 null ，所以最终会返回一个 BpServiceManager 实例，该实例内部包装了这个 BpBinder(0) ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IServeiceManager.cpp</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承自 BpInterface&lt;IServiceManager&gt; ，实际也就是：</span></span><br><span class="line"><span class="comment"> * BpServiceManager : public BpInterface , public IServiceManager, public BpRefBase</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 内部实际的逻辑是通过 remote()  也就是 BpRefBase 中的 mRemote ，也就是构造方法入参 BpBinder 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BpServiceManager</span> : <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param impl  对应的 BpBinder 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpServiceManager</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span></span><br><span class="line"><span class="function">        : BpInterface&lt;IServiceManager&gt;(impl)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">getService</span><span class="params">(<span class="type">const</span> String16&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略无关代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略无关代码</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> allowIsolated, <span class="type">int</span> dumpsysPriority)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 省略无关代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt; <span class="title">listServices</span><span class="params">(<span class="type">int</span> dumpsysPriority)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略无关代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IInterface.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BpInterface</span> : <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span>                    <span class="title">BpInterface</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; remote)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> INTERFACE           BaseInterface;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IBinder.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BpRefBase</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span>                <span class="title">BpRefBase</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; o)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span>                 ~<span class="built_in">BpRefBase</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(<span class="type">uint32_t</span> flags, <span class="type">const</span> <span class="type">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  IBinder*        <span class="title">remote</span><span class="params">()</span>                </span>&#123; <span class="keyword">return</span> mRemote; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  IBinder*        <span class="title">remote</span><span class="params">()</span> <span class="type">const</span>          </span>&#123; <span class="keyword">return</span> mRemote; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">                            <span class="built_in">BpRefBase</span>(<span class="type">const</span> BpRefBase&amp; o);</span><br><span class="line">    BpRefBase&amp;              <span class="keyword">operator</span>=(<span class="type">const</span> BpRefBase&amp; o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对应的 BpBinder 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IBinder* <span class="type">const</span>          mRemote;</span><br><span class="line">    RefBase::weakref_type*  mRefs;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt;    mState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关于 BpInterface 和 BpRefBase 在前文已经介绍过了。这里的 BpServiceManager 实现便是它的一个实际用例了。</p>
<p>传入到 BpServiceManager 构造方法的 BpBinder(0) 会一层层保存到 BpRefBase 中的 mRemote 中，后续可以通过 remote() 方法来访问这个 BpBinder(0) 实例。</p>
<p>4、上面第3步中创建了一个 BpServiceManager 实例，该实例内部包装了 BpBinder(0) ，然后将该实例保存到 gDefaultServiceManager 中，后续再调用该方法来获取当前进程的 SM 时就可以直接复用了。</p>
<h3 id="使用SM发送数据"><a href="#使用SM发送数据" class="headerlink" title="使用SM发送数据"></a>使用SM发送数据</h3><p>发送数据这里主要分析其中的两个方法： addService 和 getService 。着重介绍第一个。</p>
<p>在上面获取到 SM 实例之后，接下来就是它的使用了。</p>
<p>先看看它的具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IServiceManager.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承自 BpInterface&lt;IServiceManager&gt; ，实际也就是：</span></span><br><span class="line"><span class="comment"> * BpServiceManager : public BpInterface , public IServiceManager, public BpRefBase</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 内部实际的逻辑是通过 remote()  也就是 BpRefBase 中的 mRemote ，也就是构造方法入参 BpBinder 实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BpServiceManager</span> : <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param impl  对应的 BpBinder 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BpServiceManager</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; impl)</span></span></span><br><span class="line"><span class="function">        : BpInterface&lt;IServiceManager&gt;(impl)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">getService</span><span class="params">(<span class="type">const</span> String16&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sp&lt;IBinder&gt; svc = <span class="built_in">checkService</span>(name);</span><br><span class="line">        <span class="keyword">if</span> (svc != <span class="literal">nullptr</span>) <span class="keyword">return</span> svc;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> isVendorService =</span><br><span class="line">            <span class="built_in">strcmp</span>(ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getDriverName</span>().<span class="built_in">c_str</span>(), <span class="string">&quot;/dev/vndbinder&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> timeout = <span class="built_in">uptimeMillis</span>() + <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">if</span> (!gSystemBootCompleted &amp;&amp; !isVendorService) &#123;</span><br><span class="line">            <span class="comment">// Vendor code can&#x27;t access system properties</span></span><br><span class="line">            <span class="type">char</span> bootCompleted[PROPERTY_VALUE_MAX];</span><br><span class="line">            <span class="built_in">property_get</span>(<span class="string">&quot;sys.boot_completed&quot;</span>, bootCompleted, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            gSystemBootCompleted = <span class="built_in">strcmp</span>(bootCompleted, <span class="string">&quot;1&quot;</span>) == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// retry interval in millisecond; note that vendor services stay at 100ms</span></span><br><span class="line">        <span class="type">const</span> <span class="type">long</span> sleepTime = gSystemBootCompleted ? <span class="number">1000</span> : <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">uptimeMillis</span>() &lt; timeout) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="built_in">ALOGI</span>(<span class="string">&quot;Waiting for service &#x27;%s&#x27; on &#x27;%s&#x27;...&quot;</span>, <span class="built_in">String8</span>(name).<span class="built_in">string</span>(),</span><br><span class="line">                ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getDriverName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>*sleepTime);</span><br><span class="line"></span><br><span class="line">            sp&lt;IBinder&gt; svc = <span class="built_in">checkService</span>(name);</span><br><span class="line">            <span class="keyword">if</span> (svc != <span class="literal">nullptr</span>) <span class="keyword">return</span> svc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Service %s didn&#x27;t start. Returning NULL&quot;</span>, <span class="built_in">String8</span>(name).<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 准备写入数据</span></span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">        data.<span class="built_in">writeString16</span>(name);</span><br><span class="line">        <span class="comment">// 将数据传输给 binder driver，然后等待返回响应</span></span><br><span class="line">        <span class="comment">// 过程中当前线程会阻塞，直到拿到返回结果</span></span><br><span class="line">        <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        <span class="comment">// 读取返回值</span></span><br><span class="line">        <span class="keyword">return</span> reply.<span class="built_in">readStrongBinder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> allowIsolated, <span class="type">int</span> dumpsysPriority)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先写入标识符 android.os.IServiceManager</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 写入要添加的 service name</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        data.<span class="built_in">writeString16</span>(name);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 写入对应的 service 实例,</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 比如从 main_mediaserver.cpp#main() -&gt; MediaPlayerService.cpp#instantiate() 方法中注册过来的 MediaPlayerService,其继承关系如下：</span></span><br><span class="line"><span class="comment">         * MediaPlayerService : public BnMediaPlayerService ,public BnInterface, public IMediaPlayerService, public BBinder</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        data.<span class="built_in">writeStrongBinder</span>(service);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 写入 allowIsolated</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        data.<span class="built_in">writeInt32</span>(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 写入 dumpsysPriority</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        data.<span class="built_in">writeInt32</span>(dumpsysPriority);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 然后调用 mRemote 的 transact 方法，来执行 ADD_SERVICE_TRANSACTION 操作，</span></span><br><span class="line"><span class="comment">         * 将参数 data 和存储返回值的 reply 传入进去，mRemote 就是之前传入的 BpBinder ，其中的 handle = 0 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 当前线程阻塞在这里，等待 transact 返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">status_t</span> err = <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行结束，读取 reply 中的返回值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> err == NO_ERROR ? reply.<span class="built_in">readExceptionCode</span>() : err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt; <span class="title">listServices</span><span class="params">(<span class="type">int</span> dumpsysPriority)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略无关代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中省略了一些不重要的代码，主要看其中的 addService() 和 getService() 方法：</p>
<h4 id="addService"><a href="#addService" class="headerlink" title="addService"></a>addService</h4><p>它接受一个 serviceName 和 IBinder service 实例，将其按照键值对保存在 SM 中。后续就可以通过这个 serviceName 查到该service 实例了。</p>
<p>这里提及的 IBinder service 实例实际是一个 BBinder 实例。因为 BBinder 是代表的service实体。</p>
<blockquote>
<p>比如上面举例使用的MediaPlayerService，它的继承关系为：MediaPlayerService -&gt; BnMediaPlayerService -&gt; BnInterface<IMediaPlayerService> -&gt; BBinder -&gt; IBinder</p>
</blockquote>
<p>在方法体内，首先会将当前 IServiceManager 的 Descriptor 写入Parcel 中，他是一个字符串：”android.os.IServiceManager” 。然后再写入本次要添加的Service 的名称：”media.player” （本次使用 MediaPlayerService举例），它也是一个字符串。接着使用 writeStrongBinder() 方法来将这个MediaPlayerService 实例，也就是 BBinder 实例写入Parcel。最后再写入两个Int值。</p>
<p>这里需要关注的是 writeStrongBinder() 方法 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parcel.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeStrongBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flatten_binder</span>(ProcessState::<span class="built_in">self</span>(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 binder 对象实例扁平化后将其放入到 Parcel 中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param proc ProcessState 进程单例对象</span></span><br><span class="line"><span class="comment"> * @param binder IBinder 对应的service 实例等，比如 MediaPlayerService </span></span><br><span class="line"><span class="comment"> * @param out Parcel binder 扁平化之后要写入的 Parcel 目的地</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">flatten_binder</span><span class="params">(<span class="type">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">backgroundSchedulingDisabled</span>()) &#123;</span><br><span class="line">        <span class="comment">/* minimum priority for all nodes is nice 0 */</span></span><br><span class="line">        obj.flags = FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* minimum priority for all nodes is MAX_NICE(19) */</span></span><br><span class="line">        obj.flags = <span class="number">0x13</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 关于 localBinder ，详见 Binder.c 中的实现</span></span><br><span class="line"><span class="comment">         * IBinder::localBinder -&gt; 返回 null</span></span><br><span class="line"><span class="comment">         * BBinder::localBinder -&gt; 返回 this</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 而这里传入进来的假如是：MediaPlayerService 的话，它的继承关系如下：</span></span><br><span class="line"><span class="comment">         * BnMediaPlayerService -&gt; BnInterface&lt;IMediaPlayerService&gt; -&gt; BBinder -&gt; IBinder</span></span><br><span class="line"><span class="comment">         * 所以这里返回的是 MediaPlayerService 自身</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 而如果传入的是一个代理对象，即继承自 BpBinder 的，那么其 localBinder 返回就是 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BBinder *local = binder-&gt;<span class="built_in">localBinder</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 对于 Binder 代理，则用 handle 记录 Binder 代理的句柄；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            <span class="comment">// 返回 BpBinder 自身</span></span><br><span class="line">            BpBinder *proxy = binder-&gt;<span class="built_in">remoteBinder</span>();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拿到 BpBinder 内部存储的 handle </span></span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> handle = proxy ? proxy-&gt;<span class="built_in">handle</span>() : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 使用 hdr.type 来区分存储的是 handle 还是 binder</span></span><br><span class="line">            obj.hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// 对于 Binder 实体，则 cookie 记录 Binder 实体的指针；</span></span><br><span class="line">            <span class="keyword">if</span> (local-&gt;<span class="built_in">isRequestingSid</span>()) &#123;</span><br><span class="line">                obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX;</span><br><span class="line">            &#125;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local-&gt;<span class="built_in">getWeakRefs</span>());</span><br><span class="line">            obj.cookie = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 如果入参 binder 都是 null ，则都赋值为 0</span></span><br><span class="line">        obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="number">0</span>;</span><br><span class="line">        obj.cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 flat_binder_object 写入到 parcel out 中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">finish_flatten_binder</span>(binder, obj, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">status_t</span> <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*binder*/</span>, <span class="type">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out-&gt;<span class="built_in">writeObject</span>(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// binder.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flat_binder_object</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * binder header ，相当于文件格式开头的魔数</span></span><br><span class="line"><span class="comment">	 * 其内部只有一个 type 字段，取值可能是 BINDER_TYPE_HANDLE 、 BINDER_TYPE_BINDER 等</span></span><br><span class="line"><span class="comment">	 * 如果是 BINDER_TYPE_HANDLE ，则其 binder 为 0， handle 不为 0</span></span><br><span class="line"><span class="comment">	 * 如果是 BINDER_TYPE_BINDER ，则其 binder 不为 0， handle 为 0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_object_header</span>	hdr;</span><br><span class="line">	__u32				flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 8 bytes of data. */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">binder_uintptr_t</span>	binder;	<span class="comment">/* local object */</span></span><br><span class="line">		__u32			handle;	<span class="comment">/* remote object */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* extra data associated with local object */</span></span><br><span class="line">	<span class="type">binder_uintptr_t</span>	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里最主要逻辑是在 flatten_binder() 方法内，该方法中会将入参 IBinder 实例转换成Parcel支持传输的 flat_binder_object 结构体实例。</p>
<p>在将 IBinder 实例转换为 flat_binder_object 结构体实例时会将 IBinder 分为两类来讨论，即是 BpBinder 的实例还是 BBinder 的实例，而这一步的区分工作是通过 IBinder 的 localBinder() 方法来实现的。</p>
<blockquote>
<p>正如之前文章所说：localBinder 它在 Binder.cpp 中提供了默认实现，即返回null，而在BBinder 中又重写了它，返回了 this。</p>
</blockquote>
<p>所以下面分为两类来讨论：</p>
<p>1、localBinder &#x3D;&#x3D; null 时，表示此时入参 IBinder 是一个 BpBinder 实例。那么此时会先调用其 remoteBinder() 方法来返回 BpBinder 实例自身。</p>
<blockquote>
<p>remoteBinder() 方法和前面的 localBinder() 方法是相反的，只有是BpBinder 时返回非空，BBinder时返回null</p>
</blockquote>
<p>然后拿到BpBinder 中的 handle 值将其保存到 flat_binder_object.handle 中，并且将flat_binder_object.binder 和 flat_binder_object.cookie 都置为0，因为这俩属性的作用是为了 BBinder 的。最后会将 flat_binder_object.hdr.type 修改为 BINDER_TYPE_HANDLE ，因为当前只保存了 handle ，也就是表示说当前的 flat_binder_object 实例是从 BpBinder 转换来的。</p>
<p>2、localBinder !&#x3D; null 时，表示此时入参 IBinder 是一个 BBinder 实例。此时只需要将当前 BBinder 实例的地址保存到 flat_binder_object.cookie 中即可，与此同时还会修改 flat_binder_object.binder 的值，最后同样还是将flat_binder_object.hdr.type 修改为 BINDER_TYPE_BINDER 。注意此时并没有修改flat_binder_object.handle 的值。说明对于 BBinder 和 BpBinder来说，这三个属性是分为两组来使用的，并且互斥。</p>
<p>所以说这里会将 BpBinder 或者 BBinder “序列化”成flat_binder_object 结构体实例，然后最后通过 finish_flatten_binder 方法将其写入到 Parcel 中，准备传输给 Binder 驱动。</p>
<p>再回到 addService 方法中接着往下看。</p>
<p>前面准备好了待传输的数据之后，接下来就该传输发送这些数据到Binder驱动了，也就是要将其发送到内核层去。</p>
<p>发送数据是通过 <code>remote()-&gt;transact()</code>来实现的，这里的 remote() 就是返回当前 BpServiceManager 中保存到 BpBinder(0) 实例。然后调用其 transact() 方法就行了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BpBinder.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知 binder ，执行指定操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param code  对应的操作码，比如从 IServiceManager#addService 方法过来的 ADD_SERVICE_TRANSACTION</span></span><br><span class="line"><span class="comment"> * @param data  存储着入参数据，比如从 IServiceManager#addService 方法过来的内部会存储service name、service实例等</span></span><br><span class="line"><span class="comment"> * @param reply 用来接收返回值的 Parcel</span></span><br><span class="line"><span class="comment"> * @param flags 不传入时默认是 0</span></span><br><span class="line"><span class="comment"> * @return status_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最终逻辑还是借助 IPCThreadState 来实现的</span></span><br><span class="line"><span class="comment">         * IPCThreadState 和 ProcessState 一样，这里还存在 IPCThreadState</span></span><br><span class="line"><span class="comment">         * 其都有 self 方法，用来创建对应的实例，比如 IPCThreadState 是线程间单例，一个线程只有一个实例，且线程间不会互相影响</span></span><br><span class="line"><span class="comment">         * 而 ProcessState 则是进程单例</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 然后调用线程单例 IPCThreadState 对象的 transact 方法</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * mHandle : 因为当前是位于 BpBinder 中的，它内部其实就是封装的 mHandle，比如 ServiceManager 的 BpBinder 中的 handle = 0\</span></span><br><span class="line"><span class="comment">         * 其他的属性就是入参传入进来的了</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * flags : 默认值是 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里转到其内部的 BpBinder 中去执行。其内部还是借助线程单例 IPCThreadState 实例来完成最终的数据传输工作。IPCThreadState 的简单介绍见前面文章。</p>
<p>接下来从 IPCThreadState 中接着往后看：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPCThreadState.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param handle 对应的 handle ，比如 ServiceManager 的 handle=0。</span></span><br><span class="line"><span class="comment"> * @param code 对应的操作码，比如从 IServiceManager#addService 方法过来的 ADD_SERVICE_TRANSACTION</span></span><br><span class="line"><span class="comment"> * @param data 存储着入参数据，比如从 IServiceManager#addService 方法过来的内部会存储service name、service实例等</span></span><br><span class="line"><span class="comment"> * @param reply 用来接收返回值的 Parcel</span></span><br><span class="line"><span class="comment"> * @param flags </span></span><br><span class="line"><span class="comment"> * @return status_t </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下省略部分无关代码</span></span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传输数据</span></span><br><span class="line"><span class="comment">     * 将入参 cmd 、data 等要传递给对应 handle 的数据封装成 binder_transaction_data ，然后将这些写入到 mOut 中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TF_ONE_WAY 表示的是异步的binder请求，不需要返回值的。而这里判断flag 是否是异步的，不是的话才执行 if </span></span><br><span class="line"><span class="comment">     * 也就是说才会执行 waitForResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * reply 是用来接收返回值的 Parcel ，将其传入到 waitForResponse 中去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 是 TF_ONE_WAY ，也就是异步不需要返回值的，则传入都是 null</span></span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在传送数据时，主要有两步操作：</p>
<p>1、writeTransactionData ： 通过该方法会将要传送的数据从入参 Parcel data 中转移到 IPCThreadState 中的 Parcel mOut 中，等待后续传送时统一发送。</p>
<p>下面先看看该方法的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPCThreadState.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新创建一个 binder_transaction_data ，然后将入参都保存起来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle; <span class="comment">// 对应的 handle ，比如 ServiceManager 的 handle=0。</span></span><br><span class="line">    tr.code = code;  <span class="comment">// 对应的操作码，比如从 IServiceManager#addService 方法过来的 ADD_SERVICE_TRANSACTION</span></span><br><span class="line">    tr.flags = binderFlags; </span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parcel data 内部记录了 service 信息，也将其保存到 tr 中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 比如从 main_mediaserver.cpp#main() -&gt; MediaPlayerService.cpp#instantiate() 方法中注册过来的 MediaPlayerService 时</span></span><br><span class="line"><span class="comment">     * 其 Parcel data 中的数据按顺序为：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * InterfaceDescriptor : android.os.IServiceManager</span></span><br><span class="line"><span class="comment">     * name                : &quot;media.player&quot;</span></span><br><span class="line"><span class="comment">     * service             : flat_binder_object</span></span><br><span class="line"><span class="comment">     * -                        flat_binder_object.hdr.type = BINDER_TYPE_BINDER</span></span><br><span class="line"><span class="comment">     * -                        flat_binder_object.binder = local-&gt;getWeakRefs()</span></span><br><span class="line"><span class="comment">     * -                        flat_binder_object.cookie = local</span></span><br><span class="line"><span class="comment">     * allowIsolated       : 0 (使用默认值)</span></span><br><span class="line"><span class="comment">     * dumpsysPriority     : 1 &lt;&lt; 3 (使用默认值)</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 此时需要将 addService 的数据让  tr.data 来指向它</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * data_size 表示 parcel 中存储的全部数据大小</span></span><br><span class="line"><span class="comment">     * data.ptr.buffer 表示 parcel 中存储的全部数据</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Binder 在不同进程中建立引用必须有驱动的参与，由驱动在内核创建并注册相关的数据结构后，发送方才能使用该引用。</span></span><br><span class="line"><span class="comment">     * 而且这些引用可以是强类型，需要驱动为其维护引用计数。</span></span><br><span class="line"><span class="comment">     * 然而这些跨进程传递的 Binder 对象数据是混杂在应用程序发送的整个数据包里的</span></span><br><span class="line"><span class="comment">     * 如果不把它们一一标记出来告知驱动，驱动将无法从数据中将它们提取出来。</span></span><br><span class="line"><span class="comment">     * 于是就使用数组 data.ptr.offsets 来存放用户数据中每个 Binder 对象数据相对 data.ptr.buffer 的偏移量，</span></span><br><span class="line"><span class="comment">     * 并且用 offsets_size 表示这个数组的大小。</span></span><br><span class="line"><span class="comment">     * 驱动在发送数据包时会根据 data.ptr.offsets 和 offset_size 将散落于 data.ptr.buffer 中的 Binder 对象实例</span></span><br><span class="line"><span class="comment">     * 找出来并一一为它们创建相关的数据结构</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="built_in">sizeof</span>(<span class="type">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将保存好的数据，写入到 mOut 中</span></span><br><span class="line"><span class="comment">     * 先写入 cmd (比如是 BC_TRANSACTION )，然后再写入对应的数据参数 data </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这些会写入到 mOut 中暂存，等后续在 talkWithDriver 中赋值给 write_buffer 传递给 binder 驱动</span></span><br><span class="line"><span class="comment">     * 然后执行到 kernel/common/drivers/android/binder.c#binder_ioctl 中去</span></span><br><span class="line"><span class="comment">     * 最终会在 binder.c 中的 binder_thread_write 方法内 case=BC_TRANSACTION 中被处理</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 所以最终mOut 中的解构可能是： </span></span><br><span class="line"><span class="comment">     * cmd  binder_transaction_data | cmd  binder_transaction_data | cmd  binder_transaction_data | ...</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这里的 cmd 是 BC_XXXX ，即 binder command</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// binder.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * binder_transaction_data为写入协议BC_TRANSACTION、BC_REPLY以及读出协议BR_TRANSACTION、BR_REPLY所指定的数据类型，</span></span><br><span class="line"><span class="comment"> * Binder驱动的使用者（e.i. Client、Service、Service Manager）通过binder_transaction_data和Binder driver进行数据交换</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * binder_transaction_data结构体，并不包含传输的数据，而是通过其ptr.buffer成员保存了数据的内存地址。</span></span><br><span class="line"><span class="comment"> * 而ptr.offsets成员则保存了Binder对象（或者说flat_binder_object）在ptr.buffer的偏移量数组的首地址。</span></span><br><span class="line"><span class="comment"> * data_size 成员则记录了数据的长度，offsets_size 则是编译量数组的长度（以字节为单位，所以，编译量数组实际的长度是offsets_size/4)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_transaction_data</span> &#123;</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * The first two are only used for bcTRANSACTION and brTRANSACTION,</span></span><br><span class="line"><span class="comment">	 * identifying the target and contents of the transaction.</span></span><br><span class="line"><span class="comment">	 * 具体的目的地，比如要执行到 ServiceManager 中去时， handle 就可以赋值为 0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* target descriptor of command transaction */</span></span><br><span class="line">		__u32	handle;</span><br><span class="line">		<span class="comment">/* target descriptor of return transaction */</span></span><br><span class="line">		<span class="type">binder_uintptr_t</span> ptr;</span><br><span class="line">	&#125; target;</span><br><span class="line">	<span class="type">binder_uintptr_t</span>	cookie;	<span class="comment">/* target object cookie */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对应的操作码，比如从 IServiceManager#addService 方法过来的 ADD_SERVICE_TRANSACTION</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__u32		code;		<span class="comment">/* transaction command */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* General information about the transaction. */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * TF_ONE_WAY和TF_ACCEPT_FDS 等</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__u32	        flags;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 发送方进程id</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">pid_t</span>		sender_pid;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 发送方用户id</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uid_t</span>		sender_euid;</span><br><span class="line">	<span class="type">binder_size_t</span>	data_size;	<span class="comment">/* number of bytes of data */</span></span><br><span class="line">	<span class="type">binder_size_t</span>	offsets_size;	<span class="comment">/* number of bytes of offsets */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If this transaction is inline, the data immediately</span></span><br><span class="line"><span class="comment">	 * follows here; otherwise, it ends with a pointer to</span></span><br><span class="line"><span class="comment">	 * the data buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			<span class="comment">/* transaction data */</span></span><br><span class="line">			<span class="type">binder_uintptr_t</span>	buffer;</span><br><span class="line">			<span class="comment">/* offsets from buffer to flat_binder_object structs */</span></span><br><span class="line">			<span class="type">binder_uintptr_t</span>	offsets;</span><br><span class="line">		&#125; ptr;</span><br><span class="line">		__u8	buf[<span class="number">8</span>];</span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在转移原 Parcel data 中的数据时，并不是将其内容完全复制过去，而是将其数据内存地址保存到binder_transaction_data 结构体实例中去，然后将该结构体实例写入到 Parcel mOut 中。具体字段赋值含义如下：</p>
<p>1）tr.target.handle：对应的是远端服务对应的handle值，此处实际应该是 0 ，因为当前是在 SM 的 BpBinder中发起的请求。</p>
<p>2）tr.target.ptr： 置为0。该属性在内核Binder驱动中会给它赋值。</p>
<blockquote>
<p>target 这个成员用来描述发送目的地的信息。由于目的地是在远端，所以这里由发送方填入对远端 Binder 实体的句柄handle，存放在 target.handle 中。Binder handle 也可以叫做句柄，是由 Binder 驱动生成的，并且是按照次序递增的一个整型数值，驱动会根据这个 handle，找到对应的 Server 端的 Binder 实体。</p>
<p>当数据包 binder_transaction_data 经过 Binder 驱动的时候，驱动会根据其中的 target.handle 来找到对应的远端 Binder 实体的指针，并将这个指针赋值给 ptr 域。</p>
<p>驱动是怎么知道远端的 Binder 实体的指针的呢？原因是该指针是 Server 接收方在将 Binder 实体传输给其它进程时（比如向 SM 注册）提交给驱动的，驱动程序已经把这个指针记录并保存了下来，具体细节以后会介绍。总之 Binder 驱动能够根据发送方填入的 Binder 引用（handle）找到对应的接收方 Binder 实体对象的指针，故接收方可以直接将其当做对象指针来使用（通常是将其 reinterpret_cast 成相应类）</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwg1226/article/details/107893816">https://blog.csdn.net/liuwg1226/article/details/107893816</a></p>
</blockquote>
<p>3）tr.code ： 表示具体的操作码，对应到 transact() 方法中的第一个参数 code。此处对应的是 ADD_SERVICE_TRANSACTION ，因为当前是从 BpServiceManager 中的 addService 方法过来的。</p>
<p>4）tr.flags ： 额外标识，此处是默认值0</p>
<blockquote>
<p>flags 是与交互相关的标志位，其中最重要的是 TF_ONE_WAY 位。如果该位置为 1，表明这次交互是异步的，Server 端不会返回任何数据。驱动利用该位来决定是否构建与返回有关的数据结构。另外一位 TF_ACCEPT_FDS 是出于安全考虑，如果发起请求的一方不希望在收到的回复中接收文件形式的 Binder，可以将该位置置为 0。因为收到一个文件形式的 Binder，会自动为数据接收方打开一个文件，使用该位可以防止打开文件过多</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwg1226/article/details/107893816">https://blog.csdn.net/liuwg1226/article/details/107893816</a></p>
</blockquote>
<p>5）tr.cookie ：此处是 0</p>
<blockquote>
<p>发送方忽略该成员；Binder 驱动会在把数据包返回给接收方用户空间之前，给该成员赋值，该成员存放的是接收方 Binder 实体对象的地址</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwg1226/article/details/107893816">https://blog.csdn.net/liuwg1226/article/details/107893816</a></p>
</blockquote>
<p>6）tr.sender_pid &amp; sender_euid ：发送方pid&#x2F;uid，暂时先填0，后续到binder 驱动内核空间中会给它赋值。这也正是前面提及的Binder 的安全性保障。</p>
<blockquote>
<p>该成员存放发送方的进程 ID 和用户 ID，由驱动负责填入，接收方可以读取该成员获知发送方的身份</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwg1226/article/details/107893816">https://blog.csdn.net/liuwg1226/article/details/107893816</a></p>
</blockquote>
<p>7）tr.data_size ：表示 Parcel data 中存储的全部数据大小，也就是要传输的数据长度。</p>
<p>8）tr.data.ptr.buffer ：表示 Parcel data 中存储的数据地址，通过地址和长度data_size 就可以访问所有要传输的数据了。</p>
<p>9）tr.offsets_size ：前面 writeStrongBinder() 方法中保存 BBinder(或者说是保存IBinder) 实例时，会将其转换为 flat_binder_object 对象保存起来。所以这里就表示其其内部 flat_binder_object 对象有多少个，即它的数组长度。得搭配后面的tr.data.ptr.offsets一起用就可以定位到所有数据中的 flat_binder_object 对象了。</p>
<blockquote>
<p>驱动一般情况下不关心 data.ptr.buffer 里存放什么数据，但如果有 Binder 对象(驱动中的数据结构为 flat_binder_object) 在其中传输则需要将其相对 data.ptr.buffer 的偏移位置，指出来让驱动知道。有可能存在多个 Binder 对象同时在数据中传递，所以须用数组表示所有偏移位置。本成员表示该数组的大小。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwg1226/article/details/107893816">https://blog.csdn.net/liuwg1226/article/details/107893816</a></p>
</blockquote>
<p>10）tr.data.ptr.offsets ：</p>
<blockquote>
<p>Binder 在不同进程中建立引用必须有驱动的参与，由驱动在内核创建并注册相关的数据结构后，发送方才能使用该引用。而且这些引用可以是强类型，需要驱动为其维护引用计数。然而这些跨进程传递的 Binder 混杂在应用程序发送的数据包里，数据格式由用户定义，如果不把它们一一标记出来告知驱动，驱动将无法从数据中将它们提取出来。于是就使用数组 data.ptr.offsets 存放用户数据中每个 Binder 相对 data.ptr.buffer 的偏移量，用 offsets_size 表示这个数组的大小。驱动在发送数据包时会根据 data.ptr.offsets 和 offset_size 将散落于 data.ptr.buffer 中的 Binder 找出来并一一为它们创建相关的数据结构。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwg1226/article/details/107893816">https://blog.csdn.net/liuwg1226/article/details/107893816</a></p>
</blockquote>
<p>对于接收方来说，该结构只相当于一个定长的消息头，真正的用户数据存放在 data.ptr.buffer 所指向的缓存区中。如果发送方在数据中内嵌了一个或多个 Binder，接收到的数据包中同样会用 data.offsets 和 offset_size 指出每个 Binder 的位置和总个数。不过通常接收方可以忽略这些信息，因为接收方是知道数据格式的，参考双方约定的格式定义就能知道这些 Binder 在什么位置。</p>
<p>下图直观反馈了 BINDER_WRITE_READ 协议执行写操作的时候，write_buffer 中的数据存储情况，可以看到写命令和数据是顺序存放的，并且可以存放多条命令和数据，其中重点关注最常用的传输命令 BC_TRANSACTION，它携带的数据为 binder_transaction_data 数据包，Binder 对象是以 flat_binder_object 的形式散落存在 data.ptr.buffer 中，offsets 就是可以标记这些 Binder 对象相对于 buffer 偏移位置的数组，驱动就是根据 offsets 和 offsets_size，来找到 data.ptr.buffer 中的 Binder 对象，并一一为其生成对应的数据结构。</p>
<p><img src="/5b9837b1/pic01.png" alt="pic01"></p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwg1226/article/details/107893816">https://blog.csdn.net/liuwg1226/article/details/107893816</a></p>
<p>最后将入参 cmd 和 binder_transaction_data 实例按顺序保存到 Parcel mOut 中去。注意这里的 cmd &#x3D; BC_TRANSACTION 。而如果多次写入时，mOut内部的结构可能不止一对，而是多对 cmd + binder_transaction_data 的顺序排列。</p>
<p>2、waitForResponse ：该方法主要是将 mOut 中存储的数据发送到 Binder 驱动中，并且处理来自 Binder驱动的返回值。其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPCThreadState.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死循环，自旋等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过 ioctl 来跟 binder  driver 通讯</span></span><br><span class="line"><span class="comment">         * 读取或者发送数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        err = mIn.<span class="built_in">errorCheck</span>();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.<span class="built_in">dataAvail</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * mIn 中存储着从 driver 中读取出来的数据</span></span><br><span class="line"><span class="comment">         * 这里是先从中读取出 cmd ，即 driver 发送给当前进程用户空间的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            err = FAILED_TRANSACTION;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ALOG_ASSERT</span>(acquireResult != <span class="literal">NULL</span>, <span class="string">&quot;Unexpected brACQUIRE_RESULT&quot;</span>);</span><br><span class="line">                <span class="type">const</span> <span class="type">int32_t</span> result = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">                <span class="keyword">if</span> (!acquireResult) <span class="keyword">continue</span>;</span><br><span class="line">                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">                <span class="built_in">ALOG_ASSERT</span>(err == NO_ERROR, <span class="string">&quot;Not enough command data for brREPLY&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 用来存储返回值的 reply Parcel 不为空，则将返回值设置进去</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        reply-&gt;<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="built_in">freeBuffer</span>(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">freeBuffer</span>(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="comment">// 其他 cmd ，则走 executeCommand</span></span><br><span class="line">            err = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前进程 binder 驱动加载是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终传给 binder 的数据，一定是 binder_write_read 结构体实例</span></span><br><span class="line"><span class="comment">     * 所以这里得将 mIn 和 mOut 中的值保存到其中去，然后再发送给 binder </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="comment">// 用来读取数据的 mIn 中的数据是空的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * doReceive 默认是 true ，此处也是 true ，表示是否要考虑之前的读取是否结束</span></span><br><span class="line"><span class="comment">     * needRead : mIn.dataPosition() &gt;= mIn.dataSize() 时等于 true ，表示目前还处于从 driver 读取数据的过程呢</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前面可以知道，在 mOut 中存储的是要传递的参数数据，所以这里是将其赋值给 write_xxxx</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 等传递到 binder 驱动中之后，会根据 write_size 来读取 write_buffer 中的数据，也就是 mOut 中的属性</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 而在前面 IPCThreadState::writeTransactionData 方法中，可以知道往 mOut 中先写入了 cmd，也就是 BC_TRANSACTION</span></span><br><span class="line"><span class="comment">     * 然后再写入了一个 binder_transaction_data 结构体实例，该实例内部会存储 handle ，具体的code 等值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 而此时 mOut 中的数据格式大概为：</span></span><br><span class="line"><span class="comment">     * cmd  binder_transaction_data | cmd  binder_transaction_data | cmd  binder_transaction_data | ...</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 此时又将这个数据封装到 binder_write_read 结构体内统一发送给 binder driver</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we&#x27;ll read.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 还需要从 binder 读取数据的话，则修改 read_size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始之前，将 读写的 offset 置为开头0</span></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 往binder 驱动中发送 BINDER_WRITE_READ 消息，将对应的bwr数据发送过去</span></span><br><span class="line"><span class="comment">         * 对应的会调用到 kernel/common/drivers/android/binder.c#binder_ioctl 方法中去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.<span class="built_in">dataSize</span>())</span><br><span class="line">                mOut.<span class="built_in">remove</span>(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mOut.<span class="built_in">setDataSize</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">processPostWriteDerefs</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.<span class="built_in">setDataSize</span>(bwr.read_consumed);</span><br><span class="line">            mIn.<span class="built_in">setDataPosition</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// binder.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_write_read</span> &#123;</span><br><span class="line">	<span class="type">binder_size_t</span>		write_size;	<span class="comment">/* bytes to write */</span></span><br><span class="line">	<span class="type">binder_size_t</span>		write_consumed;	<span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">	<span class="type">binder_uintptr_t</span>	write_buffer;</span><br><span class="line">	<span class="type">binder_size_t</span>		read_size;	<span class="comment">/* bytes to read */</span></span><br><span class="line">	<span class="type">binder_size_t</span>		read_consumed;	<span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">	<span class="type">binder_uintptr_t</span>	read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以到了 waitForResponse() 方法内的话，会一直循环调用 talkWithDriver() 方法来跟 Binder 驱动交互，也就是发送 mOut中的数据给Binder驱动，发送完数据后会将来自Binder驱动的返回数据存储到Parcel mIn 中，然后读取 mIn 中的返回数据，最后调用executeCommand() 方法来处理返回值。此处只看数据发送，关于数据接收等到后面再做单独分析。</p>
<p>所以着重看看 talkWithDriver() 方法。</p>
<p>在 talkWithDriver() 方法内，会将要传输发送的数据和要接收数据的内存地址保存到一个 binder_write_read 结构体实例中，这个结构体很简单，就只有6个属性，看起名称就可以知道它分为两部分：read 和 write</p>
<blockquote>
<p>一部分是向 Binder 驱动写入的数据，一部分是要从 Binder 驱动读出的数据，驱动程序先处理写部分，再处理读部分。这样安排的好处是应用程序可以很灵活地处理命令的同步或异步。例如：若要发送异步命令可以只填入写部分而将 read_size 置成 0；若要只从 Binder 获得数据可以将写部分置空即 write_size 置成 0；若要发送请求并同步等待返回数据可以将两部分都置上。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuwg1226/article/details/107893816">https://blog.csdn.net/liuwg1226/article/details/107893816</a></p>
</blockquote>
<p>这里会将 mOut 中的数据地址保存到binder_write_read.write_buffer 中，也就是会把刚才的多对 cmd + binder_transaction_data 数据地址保存到 write_buffer 中，后续内核中就可以按照这个结构去访问并且处理它。</p>
<p>在 binder_write_read 实例中设置好要发送的数据和用来接收来自Binder驱动数据的地址后，接下来就可以将其发送到 Binder驱动内了。具体是通过 <code>ioctl</code> 方法，然后传入的三个参数如下：</p>
<ol>
<li>mProcess-&gt;mDriverFD ：mProcess 指向的是 ProcessState 实例，它是进程单例。在其构造方法中会打开binder驱动并且将打开驱动之后的文件标识符存储在mDriverFD 中，这里呢则是将其传入到 ioctl 中去使用。</li>
<li>BINDER_WRITE_READ ： 对应的cmd命令类型</li>
<li>brw ： 就是刚才设置好数据之后的binder_write_read 实例。</li>
</ol>
<p>需要额外注意的是，处于进程的用户态调用 ioctl() 方法时，会使其陷入内核态，而其对应的 Binder驱动中会将该进程阻塞住，从而再此等待ioctl 处理的返回值。等其执行完毕后会回到这里的 ioctl 调用处往后接着执行。</p>
<p>至此，从 BpServiceManager 中 addService() 方法过来的数据就被传输到了 Binder 驱动中去。后续就到了Binder 驱动层面，等后面再分析。</p>
<h4 id="getService"><a href="#getService" class="headerlink" title="getService"></a>getService</h4><p>getService 方法的主要逻辑都在 checkService 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IServiceManager.cpp</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 准备写入数据</span></span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">        data.<span class="built_in">writeString16</span>(name);</span><br><span class="line">        <span class="comment">// 将数据传输给 binder driver，然后等待返回响应</span></span><br><span class="line">        <span class="comment">// 过程中当前线程会阻塞，直到拿到返回结果</span></span><br><span class="line">        <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        <span class="comment">// 读取返回值</span></span><br><span class="line">        <span class="keyword">return</span> reply.<span class="built_in">readStrongBinder</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中需要额外重点分析的是：<code>reply.readStrongBinder</code> 。</p>
<p>Parcel reply中存储着来自远端service的返回数据，这里通过readStrongBinder() 方法来读取其中存储的 IBinder实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parcel.cpp</span></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">Parcel::readStrongBinder</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    <span class="comment">// Note that a lot of code in Android reads binders by hand with this</span></span><br><span class="line">    <span class="comment">// method, and that code has historically been ok with getting nullptr</span></span><br><span class="line">    <span class="comment">// back (while ignoring error codes).</span></span><br><span class="line">    <span class="built_in">readNullableStrongBinder</span>(&amp;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::readNullableStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unflatten_binder</span>(ProcessState::<span class="built_in">self</span>(), *<span class="keyword">this</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">unflatten_binder</span><span class="params">(<span class="type">const</span> sp&lt;ProcessState&gt;&amp; proc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从 Parcel 中读取出返回值 flat_binder_object</span></span><br><span class="line">    <span class="type">const</span> flat_binder_object* flat = in.<span class="built_in">readObject</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;hdr.type) &#123;</span><br><span class="line">            <span class="comment">// 如果是 BINDER_TYPE_BINDER 类型，则</span></span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="built_in">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finish_unflatten_binder</span>(<span class="literal">nullptr</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE: <span class="comment">// 内存存储了 handle</span></span><br><span class="line">                <span class="comment">// 通过 handle 去获取其在当前进程中保存的 BpBinder 实例</span></span><br><span class="line">                *out = proc-&gt;<span class="built_in">getStrongProxyForHandle</span>(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finish_unflatten_binder</span>(</span><br><span class="line">                    <span class="built_in">static_cast</span>&lt;BpBinder*&gt;(out-&gt;<span class="built_in">get</span>()), *flat, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果前面 writeStrongBinder() 方法懂了的话，那么这里自然而言就理解了。</p>
<p>如果传输过来的 flat_binder_object.type 是 BINDER_TYPE_BINDER，那么它就表示一个 BBinder，也就是位于当前进程内的，那么其 cookie 保存的就是该 BBinder 的地址。如果不是同一个进程，地址自然是非法的，别的进程的地址在当前进程肯定不对。</p>
<p>如果是 BINDER_TYPE_HANDLE 时，则表示是一个 BpHandle 实例，那么通过传送过来的 handle 值去当前进程 ProcessState 中的mHandleToObject 中查找就行了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到这里，可以有如下的图表示这些类之间的关系：</p>
<p><img src="/5b9837b1/pic02.png" alt="pic01"></p>
<ol>
<li>每个Client 进程中都只有一个 ProcessState 实例，这个实例在创建时会自动完成当前Client进程和Binder驱动的内存映射工作。</li>
<li>每个Client进程中，同一个handle值只会存在一份BpBinder 对象，比如表示 SM 的 handle &#x3D; 0 的 BpBinder 对象在一个进程中只会存在一份。它会存储在进程单例ProcessState 中。</li>
<li>每个进程，不同线程内都持有各自的IPCThreadState实例，而这些不同的IPCThreadState 中都持有同一个 ProcessState 实例。</li>
<li>不同的 BpBinder 实例在执行 transact 方法时，会使用其当前线程所对应的IPCThreadState 实例去操作。</li>
</ol>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Binder/">Binder</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/9a74aa64.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Binder - Binder驱动数据处理</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/5d545083.html">
        <span class="next-text nav-default">Binder - 类介绍</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2022
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
