<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="【SurfaceFlinger · Vsync】EventThread"/>




  <meta name="keywords" content="AndroidFrameworks,SurfaceFlinger," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/7b339bd2.html"/>


<meta name="description" content="本文主要介绍 frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Scheduler&#x2F;EventThread.cpp 相关的内容,类图如下：  EventThread 类主要是在 SurfaceFlinger 相关模块中使用的，它的作用简单来说就是处理来自 DispSync 的 Vsync 事件，将其分发给对应的观察">
<meta property="og:type" content="article">
<meta property="og:title" content="【SurfaceFlinger · Vsync】EventThread">
<meta property="og:url" content="https://youngkaaa.github.io/7b339bd2.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="本文主要介绍 frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Scheduler&#x2F;EventThread.cpp 相关的内容,类图如下：  EventThread 类主要是在 SurfaceFlinger 相关模块中使用的，它的作用简单来说就是处理来自 DispSync 的 Vsync 事件，将其分发给对应的观察">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youngkaaa.github.io/7b339bd2/pic_01.png">
<meta property="og:image" content="https://youngkaaa.github.io/05-AOSP-DispSync/pic06.png">
<meta property="article:published_time" content="2022-08-05T15:00:56.000Z">
<meta property="article:modified_time" content="2022-10-13T13:35:48.316Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="AndroidFrameworks">
<meta property="article:tag" content="SurfaceFlinger">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youngkaaa.github.io/7b339bd2/pic_01.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 【SurfaceFlinger · Vsync】EventThread - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          【SurfaceFlinger · Vsync】EventThread
        
      </h1>

      <time class="post-time">
          8月 05 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>本文主要介绍 <a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;Scheduler&#x2F;EventThread.cpp</a> 相关的内容,类图如下：</p>
<p><img src="/7b339bd2/pic_01.png"></p>
<p>EventThread 类主要是在 SurfaceFlinger 相关模块中使用的，它的作用简单来说就是处理来自 <a href="6caea16d.html">DispSync</a> 的 Vsync 事件，将其分发给对应的观察者（监听者）。</p>
<h4 id="1、EventThread-的创建"><a href="#1、EventThread-的创建" class="headerlink" title="1、EventThread 的创建"></a>1、EventThread 的创建</h4><p>EventThread 的创建，得从 <a href="2fa835ad.html">SurfaceFlinger</a> 初始化开始来看，在 SurfaceFlinger::init 方法中相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SurfaceFlinger::init</span><span class="params">()</span> &#123;</span><br><span class="line">  ALOGI(<span class="string">&quot;SurfaceFlinger&#x27;s main thread ready to run. &quot;</span></span><br><span class="line">        <span class="string">&quot;Initializing graphics H/W...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ALOGI(<span class="string">&quot;Phase offset NS: %&quot;</span>PRId64<span class="string">&quot;&quot;</span>, mPhaseOffsets-&gt;getCurrentAppOffset());</span><br><span class="line"></span><br><span class="line">  Mutex::Autolock _l(mStateLock);</span><br><span class="line">  <span class="comment">// start the EventThread</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 先创建出唯一的 Scheduler 对象实例</span></span><br><span class="line">  mScheduler = getFactory().createScheduler([this](<span class="type">bool</span> enabled) &#123; setPrimaryVsyncEnabled(enabled); &#125;,</span><br><span class="line">                                            mRefreshRateConfigs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装好一个 ResyncCallback 实例</span></span><br><span class="line">  <span class="keyword">auto</span> resyncCallback = mScheduler-&gt;makeResyncCallback(<span class="built_in">std</span>::bind(&amp;SurfaceFlinger::getVsyncPeriod, this));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过 Scheduler 对象的 createConnection  方法来创建 EventThread 以及对应的 EventThreadConnection 和 DispSyncSource</span></span><br><span class="line"><span class="comment">   * 注意这里调用了两次 createConnection 方法，一个是 app ，一个是 sf 。</span></span><br><span class="line"><span class="comment">   * 所以在内部其实会创建两份 EventThread 实例那些</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mAppConnectionHandle =</span><br><span class="line">      mScheduler-&gt;createConnection(<span class="string">&quot;app&quot;</span>, mVsyncModulator.getOffsets().app,</span><br><span class="line">                                   mPhaseOffsets-&gt;getOffsetThresholdForNextVsync(),</span><br><span class="line">                                   resyncCallback,</span><br><span class="line">                                   impl::EventThread::InterceptVSyncsCallback());</span><br><span class="line"></span><br><span class="line">  mSfConnectionHandle =</span><br><span class="line">      mScheduler-&gt;createConnection(<span class="string">&quot;sf&quot;</span>, mVsyncModulator.getOffsets().sf,</span><br><span class="line">                                   mPhaseOffsets-&gt;getOffsetThresholdForNextVsync(),</span><br><span class="line">                                   resyncCallback, [this](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">            mInterceptor-&gt;saveVSyncEvent(timestamp);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将 sf 的 EventThreadConnection 关联到全局唯一的 EventQueue 中，其实就是个 MessageQueue 消息队列</span></span><br><span class="line"><span class="comment">   * 基本可以按照 Android 中的Looper 来考虑，但是还是有些细微的差别的，后续会单独讲解消息队列相关知识</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mEventQueue-&gt;setEventConnection(mScheduler-&gt;getEventConnection(mSfConnectionHandle));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 SurfaceFlinger 一开始初始化的时候，就会创建 Scheduler，进而使用 Scheduler 对象来创建两个 EventThread 相关的对象，一个是 app EventThread ，一个是 sf EventThread 。</p>
<p>接着看 Scheduler::createConnection 中是怎么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Scheduler::ConnectionHandle&gt; <span class="title function_">Scheduler::createConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *connectionName, <span class="type">nsecs_t</span> phaseOffsetNs, <span class="type">nsecs_t</span> offsetThresholdForNextVsync,</span></span><br><span class="line"><span class="params">    ResyncCallback resyncCallback,</span></span><br><span class="line"><span class="params">    impl::EventThread::InterceptVSyncsCallback interceptCallback)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * sNextId 是 Scheduler 中的属性，每次调用 createConnection 方法时会自增一次</span></span><br><span class="line"><span class="comment">   * 它在下面是作为 mConnections 的key的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int64_t</span> id = sNextId++;</span><br><span class="line">  ALOGV(<span class="string">&quot;Creating a connection handle with ID: %&quot;</span>PRId64<span class="string">&quot;\n&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前类下面的： Scheduler::makeEventThread</span></span><br><span class="line"><span class="comment">   * 创建一个 EventThread 类对象，在 EventThread 中会创建一个线程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventThread&gt; eventThread =</span><br><span class="line">      makeEventThread(connectionName, mPrimaryDispSync.get(), phaseOffsetNs,</span><br><span class="line">                      offsetThresholdForNextVsync, <span class="built_in">std</span>::move(interceptCallback));</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过 EventThread 对象实例的 createEventConnection 方法来创建一个 EventThreadConnection 实例</span></span><br><span class="line"><span class="comment">   * EventThreadConnection 其实就是把刚创建出来的 eventThread  、 resyncCallback 这些包装起来了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">auto</span> eventThreadConnection =</span><br><span class="line">      createConnectionInternal(eventThread.get(), <span class="built_in">std</span>::move(resyncCallback), ISurfaceComposer::eConfigChangedSuppress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * emplace 类似于 insert。</span></span><br><span class="line"><span class="comment">   * 通过 ConnectionHandle、 eventThreadConnection、 eventThread 来构建一个Connection存入mConnections数组中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mConnections.emplace(id, <span class="built_in">std</span>::make_unique&lt;Connection&gt;(new ConnectionHandle(id),</span><br><span class="line">                                                        eventThreadConnection,</span><br><span class="line">                                                        <span class="built_in">std</span>::move(eventThread)));</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回对应的 ConnectionHandle 对象，其实也就是上面刚new出来的那个 ConnectionHandle</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> mConnections[id]-&gt;handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 createConnection 方法中会通过 makeEventThread 方法来创建对应的 EventThread 实例，其中 connectionName 的取值就是 “sf” 和 “app”。然后将创建的 EventThread 和传入进来的 ResyncCallback 一起封装到 EventThreadConnection 中。最后将这两者封装成 Connection 存入到全局的  mConnections 列表中去。其中需要额外关注的是 makeEventThread  方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;EventThread&gt; <span class="title function_">Scheduler::makeEventThread</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *connectionName, DispSync *dispSync, <span class="type">nsecs_t</span> phaseOffsetNs,</span></span><br><span class="line"><span class="params">    <span class="type">nsecs_t</span> offsetThresholdForNextVsync,</span></span><br><span class="line"><span class="params">    impl::EventThread::InterceptVSyncsCallback interceptCallback)</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这里先把入参 DispSync 包装成 DispSyncSource 对象实例，然后传入到下面的 EventThread 中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VSyncSource&gt; eventThreadSource =</span><br><span class="line">      <span class="built_in">std</span>::make_unique&lt;DispSyncSource&gt;(dispSync, phaseOffsetNs, offsetThresholdForNextVsync, <span class="literal">true</span>, connectionName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建一个 EventThread 对象并返回，这里将上面的 DispSyncSource 保存进去</span></span><br><span class="line"><span class="comment">   * 而 DispSyncSource 中存储着 DispSync ，DispSync 中又有一个 DispSyncThread 线程</span></span><br><span class="line"><span class="comment">   * 而在 EventThread 中也有一个线程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;impl::EventThread&gt;(<span class="built_in">std</span>::move(eventThreadSource),</span><br><span class="line">                                             <span class="built_in">std</span>::move(interceptCallback), connectionName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在这里创建 EventThread 时，还会顺带创建 <a href="6caea16d.html">DispSyncSource</a> 实例，而在创建  <a href="6caea16d.html">DispSyncSource</a>  时，使用了前面 dispSync 实例，而通过翻看 createConnection 方法可知，它对应的是 Scheduler 类中唯一的 mPrimaryDispSync 实例。所以说： EventThread 、 DispSyncSource 、DispSync 这三者的关系是： 2:2:1。也就是说：sf EventThread 和 app EventThread 两个EventThread 中都各有一个 DispSyncSource ,而这两个 DispSyncSource 实例都对应同一个 DispSync 实例。</p>
<p>到这里，顺便把创建 EventThreadConnection 的也看一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;EventThreadConnection&gt; <span class="title function_">Scheduler::createConnectionInternal</span><span class="params">(</span></span><br><span class="line"><span class="params">    EventThread *eventThread, ResyncCallback &amp;&amp;resyncCallback, ISurfaceComposer::ConfigChanged configChanged)</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 里面其实就是 new 一个 EventThreadConnection ，然后把入参都包装起来而已</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> eventThread-&gt;createEventConnection(<span class="built_in">std</span>::move(resyncCallback), configChanged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;EventThreadConnection&gt; <span class="title function_">EventThread::createEventConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">    ResyncCallback resyncCallback, ISurfaceComposer::ConfigChanged configChanged)</span> <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> new EventThreadConnection(const_cast&lt;EventThread *&gt;(this), <span class="built_in">std</span>::move(resyncCallback), configChanged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，先通过 makeEventThread 方法创建出 EventThread 实例，然后再通过它来创建 EventThreadConnection 实例来将 EventThread 这些封装起来。最后将其统一保存到 Scheduler类中的 mConnections  map中，然后返回其对应的key给调用方，比如 SurfaceFlinger::init 方法，后续就可以通过返回的这个 key 来查找对应的 EventThread 等信息了。</p>
<p>到这里可以更新下上面的结论：EventThreadConnection、 EventThread 、 DispSyncSource 、DispSync 这四者的关系就是：2:2:2:1 了。(当然这里的说法不太准确，因为app可能存在多个 EventThreadConnection ，一个 app 一个 EventThreadConnection实例，这里只是将所有app当做一个整体了)</p>
<p>所以说，在 SurfaceFlinger::init 中会创建两个 EventThread ，分别是 sf 和 app 的。前者给 SurfaceFlinger 来使用，后者是给其他 APP 来使用，用来接收来自DispSync 的Vsync、hotplug信号等。</p>
<p>额外需要补充的几个点：</p>
<p><strong>1、EventThread 补充：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">EventThread::EventThread(VSyncSource *src, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VSyncSource&gt; uniqueSrc,</span><br><span class="line">                         InterceptVSyncsCallback interceptVSyncsCallback, <span class="type">const</span> <span class="type">char</span> *threadName)</span><br><span class="line">    : mVSyncSource(src), mVSyncSourceUnique(<span class="built_in">std</span>::move(uniqueSrc)),</span><br><span class="line">      mInterceptVSyncsCallback(<span class="built_in">std</span>::move(interceptVSyncsCallback)), mThreadName(threadName) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (src == nullptr) &#123;</span><br><span class="line">    mVSyncSource = mVSyncSourceUnique.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 因为 EventThread 实现了： EventThread.h # VSyncSource::Callback  接口（ 比如对应的 EventThread::onVSyncEvent 方法）</span></span><br><span class="line"><span class="comment">   * 在 DispSyncSource 中包装了 DispSync，而 DispSync 中接收来自 HWC 的 vsync 信号，然后通知到 DispSyncSource 中，然后它在回调出来</span></span><br><span class="line"><span class="comment">   * 所以这里是将 EventThread 自身注册给 DispSyncSource ，才能收到来自 DispSyncSource 的回调通知</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mVSyncSource-&gt;setCallback(this);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建一个线程，在线程中执行下面的  threadMain  方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  mThread = <span class="built_in">std</span>::thread([this]() &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mMutex);</span><br><span class="line">    threadMain(lock);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 给新创建的线程设置线程名、调度策略等信息，启动线程后会执行 threadMain 方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pthread_setname_np(mThread.native_handle(), threadName);</span><br><span class="line">  <span class="type">pid_t</span> tid = pthread_gettid_np(mThread.native_handle());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use SCHED_FIFO to minimize jitter</span></span><br><span class="line">  constexpr <span class="type">int</span> EVENT_THREAD_PRIORITY = <span class="number">2</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  param.sched_priority = EVENT_THREAD_PRIORITY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pthread_setschedparam(mThread.native_handle(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for EventThread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  set_sched_policy(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中注释写的比较全了，主要逻辑是将自身注册给 DispSyncSource 并且设置内部线程信息，其启动后会执行threadMain 方法。</p>
<p><strong>2、EventThreadConnection 补充</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventThreadConnection::EventThreadConnection(EventThread *eventThread,</span><br><span class="line">                                             ResyncCallback resyncCallback,</span><br><span class="line">                                             ISurfaceComposer::ConfigChanged configChanged)</span><br><span class="line">    : resyncCallback(<span class="built_in">std</span>::move(resyncCallback)),</span><br><span class="line">      configChanged(configChanged),</span><br><span class="line">      mEventThread(eventThread),</span><br><span class="line">      mChannel(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑比较简单就是保存入参，把 EventThread 保存起来。其中需要额外关注的点是：mChannel的赋值，会为其创建一个具有默认缓存大小的 BitTube 对象实例(默认是4k)，而 BitTube 其实就是 sokcet 的封装，内部一个发送端fd一个接收端fd，然后另外一个进程可以通过接收端fd收到来自发送端fd消息。而这里在创建完 mChannel 之后，后续会在 SurfaceFlinger::init 方法中调用 mEventQueue-&gt;setEventConnection 方法来将： sf  EventThreadConnection 中的 mChannel 和消息队列mEventQueue 关联起来，也就是让消息队列 mEventQueue  来监听 mChannel 中的接收端fd，后续通过 mChannel 发送端fd来发送 vsync事件时，在消息队列 mEventQueue 中就可以收到并挨个处理了。</p>
<p>而在上面EventThread::createEventConnection 方法中创建返回的是 sp<EventThreadConnection> ，所以后续返回值第一次被引用时，会调用 EventThreadConnection 的 onFirstRef 方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EventThreadConnection::onFirstRef</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">  mEventThread-&gt;registerDisplayEventConnection(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在该方法中会将自身注册给其对应的 EventThread ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> <span class="title function_">EventThread::registerDisplayEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt; &amp;connection)</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lock</span><span class="params">(mMutex)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this should never happen</span></span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">std</span>::find(mDisplayEventConnections.cbegin(), mDisplayEventConnections.cend(), connection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果该 EventThreadConnection 已经被注册添加过了</span></span><br><span class="line">  <span class="keyword">if</span> (it != mDisplayEventConnections.cend()) &#123;</span><br><span class="line">    ALOGW(<span class="string">&quot;DisplayEventConnection %p already exists&quot;</span>, connection.get());</span><br><span class="line">    mCondition.notify_all();</span><br><span class="line">    <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将注册的 EventThreadConnection 对象放入到 mDisplayEventConnections 中</span></span><br><span class="line">  mDisplayEventConnections.push_back(connection);</span><br><span class="line">  <span class="comment">// 都要 notify 一下，唤醒下 threadMain() ，让其处理这种变化</span></span><br><span class="line">  mCondition.notify_all();</span><br><span class="line">  <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又将 EventThreadConnection 注册给 EventThread 了，将其保存到EventThread 内部的 mDisplayEventConnections 列表中了，该列表表示当前有哪些观察者在观察 EventThread 中的vsync等事件，而结合上面提到的  mEventQueue-&gt;setEventConnection 方法，所以说，在 SurfaceFlinger::init 执行之后，这里就会有一个 EventThreadConnection 被注册保存起来，就是 sf EventThreadConnection。而app的 EventThreadConnection 后续也都会陆陆续续的添加注册进来的，当然app的 vsync 事件监听后面单独会写文章来讲解，这里暂且不表。</p>
<p>小结：</p>
<p>EventThread 的创建是从 SurfaceFlinger::init 过来的，会分别为 app 和 sf 创建：  EventThread 、 DispSyncSource ，然后这两组对象中，共用持有同一个 DispSync  实例。而 EventThreadConnection 则是会存在多个的，一个 sf EventThreadConnection 是固定的，而app的会存在多个 EventThreadConnection，一个app 一个 EventThreadConnection。看下面图会清晰些：</p>
<p><img src="/05-AOSP-DispSync/pic06.png"></p>
<p>而创建的 EventThreadConnection  中又存在一个 mChannel 实例，这个实例的作用在上面简单讲了，等后面会再分析它，算是现在埋下的一个伏笔吧。</p>
<h4 id="2、threadMain-方法"><a href="#2、threadMain-方法" class="headerlink" title="2、threadMain 方法"></a>2、threadMain 方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EventThread::threadMain</span><span class="params">(<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; &amp;lock)</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建一个 DisplayEventConsumers 对象实例</span></span><br><span class="line"><span class="comment">   * 可以把它理解为就是一个列表容器，可以存放多个 EventThreadConnection 实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  DisplayEventConsumers consumers;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当 mState 不等于 Quit 时，一直while循环</span></span><br><span class="line"><span class="comment">   * 而 mState 默认是 State::Idle （详见 EventThread.h # mState）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">while</span> (mState != State::Quit) &#123;</span><br><span class="line">    <span class="comment">// 用来存储即将要处理的事件Event</span></span><br><span class="line">    <span class="built_in">std</span>::optional&lt;DisplayEventReceiver::Event&gt; event;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine next event to dispatch.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查下当前有无待处理的事件要处理，mPendingEvents 中存储的是待处理的事件，其他地方想要发送 event 时，</span></span><br><span class="line"><span class="comment">     * 只需要往这个 mPendingEvents 中放置即可，这里的while循环会一直从它里面读取事件出来消费的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingEvents.empty()) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 取出列表中第一个事件，并且移除它</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      event = mPendingEvents.front();</span><br><span class="line">      mPendingEvents.pop_front();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 判断该事件的类型，根据其类型来重置修改对应的变量值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">switch</span> (event-&gt;header.type) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">          <span class="keyword">if</span> (event-&gt;hotplug.connected &amp;&amp; !mVSyncState) &#123;</span><br><span class="line"></span><br><span class="line">            mVSyncState.emplace(event-&gt;header.displayId);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!event-&gt;hotplug.connected &amp;&amp; mVSyncState &amp;&amp; mVSyncState-&gt;displayId == event-&gt;header.displayId) &#123;</span><br><span class="line">            mVSyncState.reset();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">          <span class="keyword">if</span> (mInterceptVSyncsCallback) &#123;</span><br><span class="line">            mInterceptVSyncsCallback(event-&gt;header.timestamp);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行到这里的话，如果有待处理的事件的话，event 中就会存储着它</span></span><br><span class="line"><span class="comment">     * 注意此时 vsyncRequested 默认值是false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> vsyncRequested = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find connections that should consume this event.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mDisplayEventConnections 保存的是外部观察者注册进来的 Connection ,</span></span><br><span class="line"><span class="comment">     * SF EventThread 线程里只有一个 Connection, 这个 Connection 主要是用来通知 SurfaceFlinger 来叠加图层等</span></span><br><span class="line"><span class="comment">     * APP EventThread 的话则会有多个 connection 注册进来，一般情况下是一个app会注册一个 connection，用来让app接受vsync等事件信号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">auto</span> it = mDisplayEventConnections.begin();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面从 mPendingEvents 中取出了待处理的 event，那么这里就需要找到能处理该 event 的 connection 了</span></span><br><span class="line"><span class="comment">     * 遍历 mDisplayEventConnections 列表中的每个 EventThreadConnection</span></span><br><span class="line"><span class="comment">     * 判断如果有哪个 EventThreadConnection 可以处理该 event 的话，就将其放入到 consumers 列表中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * mDisplayEventConnections : 里面存放了目前所有接收 event 的接收端。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (it != mDisplayEventConnections.end()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="type">const</span> <span class="keyword">auto</span> connection = it-&gt;promote()) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * vsyncRequested ：是否有 connection 请求过 vsync 信号</span></span><br><span class="line"><span class="comment">         * 即判断如果有一个 EventThreadConnection 端请求过 vsync 信号的话，则vsyncRequested 会被置为true</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * EventThreadConnection 中的 vsyncRequest 是一个枚举，它的取值有三个：</span></span><br><span class="line"><span class="comment">         * -     1、None = -1,  // 默认值，表示该connection另一端没有请求过vsync信号，那么此时就算有vsync事件也不应该给它</span></span><br><span class="line"><span class="comment">         * -     2、Single = 0,  // 表示只请求一次vsync事件，等有了vsync事件则回调通知它一次，然后会将它置为 None，即只给他一次vsync事件</span></span><br><span class="line"><span class="comment">         * -     3、Periodic = 1, // 持续性的要vsync事件，只要有了vsync事件都得一直通知我</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 外部可以通过修改这个值来实现对vsync信号的请求，比如调用 EventThreadConnection::requestNextVsync 方法来请求一个 Single 的vsync事件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vsyncRequested |= connection-&gt;vsyncRequest != VSyncRequest::None;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果event不为空,即前面 从mPendingEvents 中读取出了待处理的event了，那么此时判断当前 connection 是否可以处理该 event</span></span><br><span class="line"><span class="comment">         * 可以处理的话，则将该 connection 加入到 consumers 列表中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (event &amp;&amp; shouldConsumeEvent(*event, connection)) &#123;</span><br><span class="line">          consumers.push_back(connection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++it;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it = mDisplayEventConnections.erase(it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面 while 执行完毕之后，consumers 中就会存放着所有能处理该 event 的 connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!consumers.empty()) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 如果有可以处理这个 event 的 EventThreadConnection ，那么调用 EventThread::dispatchEvent  方法将event发送出去</span></span><br><span class="line"><span class="comment">       * 其实就是通过 EventThreadConnection # gui::BitTube mChannel # write 来发送 event ，然后 socket 接收端就会收到这个事件消息</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      dispatchEvent(*event, consumers);</span><br><span class="line">      consumers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    State nextState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 vsyncRequested = true 也就是有 EventConnection 请求过 vsync 信号，那么则将 nextState 置为 SyntheticVSync 或者 VSync</span></span><br><span class="line"><span class="comment">     * mVSyncState-&gt;synthetic = true 时，表示当前需要 假的vsync 比如当锁屏之后可能就需要它</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这里可以不考虑它，这里将其认为是 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mVSyncState &amp;&amp; vsyncRequested) &#123;</span><br><span class="line">      nextState = mVSyncState-&gt;synthetic ? State::SyntheticVSync : State::VSync;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ALOGW_IF(!mVSyncState, <span class="string">&quot;Ignoring VSYNC request while display is disconnected&quot;</span>);</span><br><span class="line">      <span class="comment">// 没有请求过 vsync 的话则统一都置为 Idle</span></span><br><span class="line">      nextState = State::Idle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 state 发生变化了，即新的 state 和当前state状态不一样了，那么需要通知到 DispSyncSource 中去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mState != nextState) &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 如果当前 state 是 VSync ，而 newState 肯定不是 vsync 了，此时调用 setVSyncEnabled 方法来关闭掉vsync事件监听</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (mState == State::VSync) &#123;</span><br><span class="line">        mVSyncSource-&gt;setVSyncEnabled(<span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextState == State::VSync) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果 newState 是 sync ，则需要开启 vsync 事件监听，后续在 EventThread::onVSyncEvent 中收到来自 DispSyncSource 的事件回调通知</span></span><br><span class="line"><span class="comment">         * 因为在前面 EventThread 的构造方法中就已经调用了:mVSyncSource-&gt;setCallback(this) 来将当前 EventThread 注册给了 DispSyncSource</span></span><br><span class="line"><span class="comment">         * 而这里调用 setVSyncEnabled 方法才是真正监听回调</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mVSyncSource-&gt;setVSyncEnabled(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 修改 mState 为最新的值</span></span><br><span class="line">      mState = nextState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * event 不为 null 的话表示上面从 mPendingEvents 列表中成功取出了一个待处理的事件，并且已经处理完了</span></span><br><span class="line"><span class="comment">     * 那么此时需要再次循环去判断 mPendingEvents 中是否还有剩余的事件待处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (event) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到这里的话，表示目前还没有任何 event 需要处理</span></span><br><span class="line">    <span class="comment">// Wait for event or client registration/request.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mState 默认就是 State::Idle ，所以一开始 EventThread 开始执行之后，就会在这里 wait 阻塞住</span></span><br><span class="line">    <span class="comment">// 或者没有注册 connection 时vsyncRequested=false，mState 就会使 idle 从而陷入等待</span></span><br><span class="line">    <span class="keyword">if</span> (mState == State::Idle) &#123;</span><br><span class="line">      mCondition.wait(lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * mState 不等于 Idle 的话，则表示上面 vsyncRequested = true，也就是有connection 请求过vsync 了</span></span><br><span class="line"><span class="comment">       * 但是目前又没有 vsync event 过来，也就是硬件没通知过来，所以此时创建个假的 vsync</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// Generate a fake VSYNC after a long timeout in case the driver stalls. When the</span></span><br><span class="line">      <span class="comment">// display is off, keep feeding clients at 60 Hz.</span></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> timeout = mState == State::SyntheticVSync ? <span class="number">16</span>ms : <span class="number">1000</span>ms;</span><br><span class="line">      <span class="keyword">if</span> (mCondition.wait_for(lock, timeout) == <span class="built_in">std</span>::cv_status::timeout) &#123;</span><br><span class="line">        ALOGW_IF(mState == State::VSync, <span class="string">&quot;Faking VSYNC due to driver stall&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LOG_FATAL_IF(!mVSyncState);</span><br><span class="line">        <span class="comment">// 就是往 mPendingEvents 中放入一个 event 即可，后面再次循环时会处理 mPendingEvents 中的事件</span></span><br><span class="line">        mPendingEvents.push_back(makeVSync(mVSyncState-&gt;displayId,</span><br><span class="line">                                           systemTime(SYSTEM_TIME_MONOTONIC),</span><br><span class="line">                                           ++mVSyncState-&gt;count));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释写的很清楚了，大致描述就是: </p>
<p>1、先从 mPendingEvents 列表中取出一个待处理的事件</p>
<blockquote>
<p>mPendingEvents 列表中存储着待处理的 Event 事件，有来自 DispSync 的vsync 事件，也有来自SurfaceFlinger接受传递进来的屏幕 hotplug 事件。而后续这些事件的处理，就是交由 EventThread::threadMain 循环来处理的，如果该列表中又待处理的事件的话则该方法内会将其消费掉(前提是有外部注册进来的 EventThreadConnection 来充当消费者），如果没有事件的话则会陷入等待。</p>
</blockquote>
<p>2、遍历外部观察者们给该 EventThread 注册的 EventThreadConnection 列表，判断是否存在 EventThreadConnection 要请求接受后续的 vsync 事件</p>
<blockquote>
<p>EventThreadConnection 的创建前面讲过了，其注册分为 sf 的注册和app的注册。sf 的注册应该是在 SurfaceFlinger::init 中调用 mEventQueue-&gt;setEventConnection(mScheduler-&gt;getEventConnection(mSfConnectionHandle)) 时触发的 EventThreadConnection::onFirstRef 来注册的；而app的注册得从 framework层开始分析了，这里简单来说就是从 DisplayEventReceiver.cpp 构造方法中触发的。而对应的EventThread中如果外部没有注册任何 EventThreadConnection 的话，它也是会一直陷入等待的。</p>
</blockquote>
<p>3、同时将该事件发送给所有能处理它的 EventThreadConnection  中</p>
<blockquote>
<p>上面第2步中，在遍历所有 EventThreadConnection 时，顺便会判断它们那些可以处理该Event事件（通过EventThread::shouldConsumeEvent方法），可以处理的话则会将这些 EventThreadConnection 保存到 consumers 列表中，然后这一步来分发该event（通过EventThread::dispatchEvent 方法）。关于EventThread::shouldConsumeEvent和 EventThread::dispatchEvent 方法详见后面解释。</p>
</blockquote>
<p>4、根据2中获取到的信息（vsyncRequested）来决定是否要让 EventThread 接受来自 DispSyncSource 后续的 vsync 事件消息</p>
<blockquote>
<p>根据上面计算出来的 vsyncRequested 来计算 nextState 的值，即 vsyncRequested  &#x3D; true时，nextState 置为 State::VSync ，否则都是置为 State::Idle ，而确定出来的 nextState 会影响下面调用 mVSyncSource-&gt;setVSyncEnabled(false) 还是 mVSyncSource-&gt;setVSyncEnabled(true) ，也就是会确定出来当前 EventThread 是否要接着接受来自 DispSync -&gt; DispSyncSource 的 vsync 事件。</p>
</blockquote>
<p>剩下的逻辑就很简单了，一直处理event 直到没有event待处理了。</p>
<p>补充一些关键方法的理解：</p>
<h5 id="2-1-EventThread-shouldConsumeEvent"><a href="#2-1-EventThread-shouldConsumeEvent" class="headerlink" title="2.1 EventThread::shouldConsumeEvent"></a>2.1 EventThread::shouldConsumeEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EventThread::shouldConsumeEvent</span><span class="params">(<span class="type">const</span> DisplayEventReceiver::Event &amp;event,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> sp&lt;EventThreadConnection&gt; &amp;connection)</span> <span class="type">const</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (event.header.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">      <span class="comment">// DISPLAY_EVENT_HOTPLUG 事件任何 connection 都可以处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_CONFIG_CHANGED:</span><br><span class="line">      <span class="keyword">return</span> connection-&gt;configChanged == ISurfaceComposer::eConfigChangedDispatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">      <span class="keyword">switch</span> (connection-&gt;vsyncRequest) &#123;</span><br><span class="line">        <span class="keyword">case</span> VSyncRequest::None:</span><br><span class="line">          <span class="comment">// 如果该connection没有请求vsync ，所以它不能处理 vsync 事件</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">case</span> VSyncRequest::Single:</span><br><span class="line">          <span class="comment">// 如果该 connection 只请求一次 vsync ，则他可以处理vsync事件，并且把它置为 None，因为它只需要一次</span></span><br><span class="line">          connection-&gt;vsyncRequest = VSyncRequest::None;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">case</span> VSyncRequest::Periodic:</span><br><span class="line">          <span class="comment">// 如果该 connection 请求持续的 vsync ，则返回true</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> event.vsync.count % vsyncPeriod(connection-&gt;vsyncRequest) == <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要用来判断对应的 EventThreadConnection 是否可以处理对应的 event。比如event是 HOTPLUG 类型时默认所有的Connection都可以处理，而是VSYNC 时，就必须是那些请求过vsync信号的Connection才可以处理，并且会修改其请求vsync 的模式，比如你之前只请求需要一个vsync信号，即VSyncRequest::Single，那么这里会将其修改为 VSyncRequest::None ，因为它只需要一次，相当于这次把它的机会给消耗掉了。</p>
<h5 id="2-1-EventThread-dispatchEvent"><a href="#2-1-EventThread-dispatchEvent" class="headerlink" title="2.1 EventThread::dispatchEvent"></a>2.1 EventThread::dispatchEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EventThread::dispatchEvent</span><span class="params">(<span class="type">const</span> DisplayEventReceiver::Event &amp;event,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> DisplayEventConsumers &amp;consumers)</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * DisplayEventConsumers 其实就是一个 vector&lt;sp&lt;EventThreadConnection&gt;&gt;</span></span><br><span class="line"><span class="comment">   * 里面存储着所有可以处理该 event 的 EventThreadConnection</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;consumer: consumers) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * consumer : EventThreadConnection : EventThreadConnection::postEvent</span></span><br><span class="line"><span class="comment">     * postEvent 中其实就是通过 EventThreadConnection # gui::BitTube mChannel # write 来发送event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">switch</span> (consumer-&gt;postEvent(event)) &#123;</span><br><span class="line">      <span class="keyword">case</span> NO_ERROR:<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> -EAGAIN:</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Try again if pipe is full.</span></span><br><span class="line">        ALOGW(<span class="string">&quot;Failed dispatching %s for %s&quot;</span>, toString(event).c_str(),</span><br><span class="line">              toString(*consumer).c_str());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Treat EPIPE and other errors as fatal.</span></span><br><span class="line">        removeDisplayEventConnectionLocked(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是用来将 event 分发出去的，consumers表示要接受处理该event 的 EventThreadConnection 列表。内部循环调用每个 EventThreadConnection::postEvent 方法来分发事件，而 postEvent 方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> <span class="title function_">EventThreadConnection::postEvent</span><span class="params">(<span class="type">const</span> DisplayEventReceiver::Event &amp;event)</span> &#123;</span><br><span class="line">  <span class="comment">// 调用到 DisplayEventReceiver.cpp # DisplayEventReceiver::sendEvents 方法中去</span></span><br><span class="line">  <span class="comment">// 这里将event 发送到 socket channel 中去，如果是sf的话，则SF中的MessageQueue会收到</span></span><br><span class="line">  <span class="comment">// 如果是app的话，则应该是 choreographer 会收到</span></span><br><span class="line">  <span class="type">ssize_t</span> size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="type">status_t</span>(size) : <span class="type">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面对于 mChannel 已经提过了，并且埋了个伏笔，这里相当于就是揭晓答案了，使用它来进行事件发送。它是socket的封装，可以跨进程通讯，这里发送之后，在另外一端会接受到消息，这里说的另外一端可能是某个app端，也可能是surfaceFlinger中代表 sf connection的mEventQueue 。因为存在两个 EventThread实例（一个app EventThread，一个sf EventThread），这里上面的结论是把两者拉在一起讲了，实际分开来讲的话应该是：1）app  EventThread 实例中 threadMain方法内会将对应的 Event 发送到某个 app 端去，这个过程是跨进程的；2）sf EventThrad 实例中 threadMain方法内会将对应的 Event 发送到 mEventQueue消息队列中去处理。</p>
<h4 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h4><p>所以简单来说，EventThread 就是一个线程，整个 SurfaceFlinger 中只会存在两个实例：app EventThread 和 sf EventThread。这俩线程内部会一直执行 threadMain 方法（除非休眠），在该方法中，会从mPendingEvents列表中取出待处理的event（所以说，有新事件到来时只需要将新事件放入到mPendingEvents队列中即可，比如从DispSyncSource 来的 vsync事件），然后遍历外部注册进来的 事件观察者 mDisplayEventConnections列表(所以说，外部有新增的观察者想要接受来自系统的vsync事件时，只需要往mDisplayEventConnections 中注册一下即可，比如来自app的 DisplayEventReceiver 可以注册一个 connection，从而使得该app可以接收到vsync事件从而触发其ViewRootImpl的重绘 )，最后将该 event 通过 EventThreadConnection::postEvent 方法来分发给所有感兴趣的 EventThreadConnection 中去(通过封装了socket的BitTube来实现event的发送和接收)，这样就完成了vsync事件的发送和接收，这也就是EventThread的使命。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/AndroidFrameworks/">AndroidFrameworks</a>
		  
			<a href="/tags/SurfaceFlinger/">SurfaceFlinger</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/5e3d97eb.html">
        <span class="next-text nav-default">【SurfaceFlinger · Vsync】EventControlThread</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2022
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
