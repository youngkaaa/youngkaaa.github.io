<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="OkHttp 连接缓存池"/>




  <meta name="keywords" content="okhttp," />





  <link rel="alternate" href="/default" title="咔咔咔" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="https://youngkaaa.github.io/a4b11ed8.html"/>


<meta name="description" content="在前面  OkHttp 拦截器介绍 中介绍 OkHttp 中的拦截器时，讲到了  ConnectInterceptor 这个拦截器，在其内部的 intercept() 方法中通过  Transmitter 创建出了 Exchange 实例，而本文开始分析这些相关的逻辑，包括其内部的连接缓存复用机制。  RealConnectionOkHttp 中的 RealConnection 类实现了 Conn">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp 连接缓存池">
<meta property="og:url" content="https://youngkaaa.github.io/a4b11ed8.html">
<meta property="og:site_name" content="咔咔咔">
<meta property="og:description" content="在前面  OkHttp 拦截器介绍 中介绍 OkHttp 中的拦截器时，讲到了  ConnectInterceptor 这个拦截器，在其内部的 intercept() 方法中通过  Transmitter 创建出了 Exchange 实例，而本文开始分析这些相关的逻辑，包括其内部的连接缓存复用机制。  RealConnectionOkHttp 中的 RealConnection 类实现了 Conn">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-21T13:50:56.000Z">
<meta property="article:modified_time" content="2023-03-08T11:49:29.612Z">
<meta property="article:author" content="咔咔咔">
<meta property="article:tag" content="okhttp">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> OkHttp 连接缓存池 - 咔咔咔 </title>
  <meta name="generator" content="Hexo 6.2.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">咔咔咔</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          OkHttp 连接缓存池
        
      </h1>

      <time class="post-time">
          1月 21 2022
      </time>
    </header>



    
            <div class="post-content">
            <p>在前面  <a href="52da40ac.html">OkHttp 拦截器介绍</a> 中介绍 OkHttp 中的拦截器时，讲到了  ConnectInterceptor 这个拦截器，在其内部的 intercept() 方法中通过  Transmitter 创建出了 Exchange 实例，而本文开始分析这些相关的逻辑，包括其内部的连接缓存复用机制。</p>
<hr>
<h3 id="RealConnection"><a href="#RealConnection" class="headerlink" title="RealConnection"></a>RealConnection</h3><p>OkHttp 中的 RealConnection 类实现了 Connection 接口，同时实现了其内部的接口方法如 socket() 返回一个 Sokcet 实例、protocol() 方法返回当前连接对应的协议类型等。</p>
<p>而 RealConnection 在 OkHttp 中代表着一条和服务端已经建立连接的链路，也就是一条 Socket 链路。当然由于它已经建立了链路，所以肯定完成了前置的握手操作，所以会在 handshake() 方法中返回一个握手信息。</p>
<p>接下来简单看看这个类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RealConnection</span> <span class="keyword">extends</span> <span class="title class_">Http2Connection</span>.Listener <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RealConnectionPool connectionPool;</span><br><span class="line">    <span class="comment">// 路由信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Route route;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这些属性在 connect() 方法中被赋值，且不会在被重新赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底层 socket</span></span><br><span class="line">    <span class="keyword">private</span> Socket rawSocket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用层 sokcet 实例</span></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="comment">// 握手信息</span></span><br><span class="line">    <span class="keyword">private</span> Handshake handshake;</span><br><span class="line">    <span class="comment">// 当前connection的HTTP协议信息</span></span><br><span class="line">    <span class="keyword">private</span> Protocol protocol;</span><br><span class="line">    <span class="comment">// HTTP2 的链接</span></span><br><span class="line">    <span class="keyword">private</span> Http2Connection http2Connection;</span><br><span class="line">    <span class="comment">// 用来和服务器那边写入 读出 数据</span></span><br><span class="line">    <span class="keyword">private</span> BufferedSource source;</span><br><span class="line">    <span class="keyword">private</span> BufferedSink sink;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这些属性是表示当前链接状态的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认是false ，一旦被置为true，则后续就一直是true，</span></span><br><span class="line"><span class="comment">     * 表示当前链接后续不会被分配新的  stream 流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> noNewExchanges;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> routeFailureCount;</span><br><span class="line">    <span class="type">int</span> successCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> refusedStreamCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此链接可以承载最大并发流的个数，如果不超过限制，可以随意增加</span></span><br><span class="line">    <span class="comment">// 默认是一个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">allocationLimit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 Connection 承载的请求Call列表。</span></span><br><span class="line"><span class="comment">     * 因为一个Call对应一个Transmitter实例，所以该列表存储着正在使用当前 Connection 的Transmitter列表</span></span><br><span class="line"><span class="comment">     * 如果该列表为空，表示当前 Connection 处于 idle 状态，也就是没有其他的Call在使用当前 Connection</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> Transmitter#acquireConnectionNoEvents(okhttp3.internal.connection.RealConnection)&#125;中add</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> Transmitter#releaseConnectionNoEvents()&#125;中remove</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;Reference&lt;Transmitter&gt;&gt; transmitters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 Connection 变成 idle 状态时的时间戳。其实就是当 transmitters size 变成0时的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">idleAtNanos</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里先贴出了 RealConnection 中的属性定义，他们分为三类：</p>
<p>第一类，在 RealConnection 构造方法中被赋值，被final修饰即赋值之后不可修改：</p>
<p>① connectionPool ： 缓存池对象实例，后面会分析它的。</p>
<p>② route ：路由信息实例，内部封装了目标IP地址以及代理等属性。</p>
<p>第二类：在 RealConnection 的 connect() 方法中被赋值，赋值之后不会被再次修改。如 rawSocket 、handshake、protocol 等。</p>
<p>第三类：代表当前 RealConnection 状态的一些属性，比如 noNewExchanges 表示将当前固定，不允许其再分配新的 stream 流，或者 transmitters ，表示当前 RealConnection 目前承载的请求 Call 的个数，因为一个 RealCall 对应一个 Transmitter 实例（详见RealCall 中 newRealCall() 方法）。</p>
<p>接着我们看 RealConnection 中的 connect() 方法：</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> connectTimeout, <span class="type">int</span> readTimeout, <span class="type">int</span> writeTimeout,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> pingIntervalMillis, <span class="type">boolean</span> connectionRetryEnabled, Call call,</span></span><br><span class="line"><span class="params">        EventListener eventListener)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先检查是否之前已经建立过链接了</span></span><br><span class="line">    <span class="keyword">if</span> (protocol != <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;already connected&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备建立链接，这里为其准备路由信息</span></span><br><span class="line">    <span class="type">RouteException</span> <span class="variable">routeException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 拿到连接对应的配置属性信息，比如 TLS 中需要的属性</span></span><br><span class="line">    List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs();</span><br><span class="line">    <span class="type">ConnectionSpecSelector</span> <span class="variable">connectionSpecSelector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionSpecSelector</span>(connectionSpecs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许明文通讯</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RouteException</span>(<span class="keyword">new</span> <span class="title class_">UnknownServiceException</span>(</span><br><span class="line">                    <span class="string">&quot;CLEARTEXT communication not enabled for client&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> route.address().url().host();</span><br><span class="line">        <span class="keyword">if</span> (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RouteException</span>(<span class="keyword">new</span> <span class="title class_">UnknownServiceException</span>(</span><br><span class="line">                    <span class="string">&quot;CLEARTEXT communication to &quot;</span> + host + <span class="string">&quot; not permitted by network security policy&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RouteException</span>(<span class="keyword">new</span> <span class="title class_">UnknownServiceException</span>(</span><br><span class="line">                    <span class="string">&quot;H2_PRIOR_KNOWLEDGE cannot be used with HTTPS&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始建立连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果需要隧道连接，则走 connectTunnel</span></span><br><span class="line">            <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">                <span class="keyword">if</span> (rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 走 connectSocket() 方法去走普连接</span></span><br><span class="line">                connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 走到这里时，连接一般都成功了，此时就可以知道本次建立的连接的HTTP协议版本等信息了</span></span><br><span class="line"><span class="comment">             * 因此此时会在 establishProtocol 方法中判断出协议类型，并且给 protocol 属性赋值</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);</span><br><span class="line">            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);</span><br><span class="line">            <span class="comment">// 建立连接成功了，此时终止循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 遇到 IO 异常，重置掉上次连接时的那些属性</span></span><br><span class="line">            closeQuietly(socket);</span><br><span class="line">            closeQuietly(rawSocket);</span><br><span class="line">            socket = <span class="literal">null</span>;</span><br><span class="line">            rawSocket = <span class="literal">null</span>;</span><br><span class="line">            source = <span class="literal">null</span>;</span><br><span class="line">            sink = <span class="literal">null</span>;</span><br><span class="line">            handshake = <span class="literal">null</span>;</span><br><span class="line">            protocol = <span class="literal">null</span>;</span><br><span class="line">            http2Connection = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            eventListener.connectFailed(call, route.socketAddress(), route.proxy(), <span class="literal">null</span>, e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (routeException == <span class="literal">null</span>) &#123;</span><br><span class="line">                routeException = <span class="keyword">new</span> <span class="title class_">RouteException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                routeException.addConnectException(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不再重试下一个路由了，那么就抛出异常终止掉外部循环，否则还是会接着循环去尝试下一个路由</span></span><br><span class="line">            <span class="keyword">if</span> (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> routeException;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (route.requiresTunnel() &amp;&amp; rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ProtocolException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolException</span>(<span class="string">&quot;Too many tunnel connections attempted: &quot;</span></span><br><span class="line">                + MAX_TUNNEL_ATTEMPTS);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RouteException</span>(exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            allocationLimit = http2Connection.maxConcurrentStreams();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，在 connect() 方法中会按照有无隧道来分为两种方式来建立连接，当然我们这里只分析常规的方式，即主要走的都是 connectSocket() 方法。</p>
<p>因此总的来看当前 connect() 方法中大的逻辑框架是：</p>
<p>执行 connectSocket() 方法来完成与服务端的 Socket 连接。如果失败了遇到异常，则会重置掉这些连接时相关的属性，为下一次重试做好准备。接着判断入参 connectionRetryEnabled 是否允许重试，是的话则走下一个 while 循环去重试。</p>
<p>② 如果 connectSocket() 方法建立连接成功，则会接着调用 establishProtocol() 方法来建立协议。包括 TLS 相关的初始化，HTTP协议版本的处理，执行成功会给 protocol 赋值。</p>
<p>下面先看 connectSocket() 方法的分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connectSocket</span><span class="params">(<span class="type">int</span> connectTimeout, <span class="type">int</span> readTimeout, Call call,</span></span><br><span class="line"><span class="params">        EventListener eventListener)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> route.proxy();</span><br><span class="line">    <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> route.address();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据代理类型来选择 socket 类型，是 代理 还是 直连</span></span><br><span class="line"><span class="comment">     * 这里是给 rawSocket 创建新的 Socket 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">            ? address.socketFactory().createSocket()</span><br><span class="line">            : <span class="keyword">new</span> <span class="title class_">Socket</span>(proxy);</span><br><span class="line"></span><br><span class="line">    eventListener.connectStart(call, route.socketAddress(), proxy);</span><br><span class="line">    rawSocket.setSoTimeout(readTimeout);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为了支持不同的平台，所以才有 Platform.get()</span></span><br><span class="line"><span class="comment">         * 这里是执行不同平台的 scoket connect 方法来进行socket连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">        <span class="type">ConnectException</span> <span class="variable">ce</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectException</span>(<span class="string">&quot;Failed to connect to &quot;</span> + route.socketAddress());</span><br><span class="line">        ce.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功了，此时得到 socket 对应的输入输出流</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">        sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">        <span class="keyword">if</span> (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(npe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 connectSocket() 方法中，首先会给 rawSocket 赋值，接着调用 Platform.get().connectSocket() 方法来往 route.socketAddress() 地址建立连接，如果失败则抛出异常，如果成功则接着往后走，会通过 Okio.buffer() 方法来给这个已建立连接的 rawSocket 创建对应的输入输出流，并分别赋值给 source 和 sink，后续通过他俩就可以与服务端进行数据通讯传输了。</p>
<p>接着往后会调用 establishProtocol() 方法来确认协议信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">establishProtocol</span><span class="params">(ConnectionSpecSelector connectionSpecSelector,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> pingIntervalMillis, Call call, EventListener eventListener)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// HTTP 方式的，不需要 SLL ，则此时将 socket 指向 rawSocket</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123;</span><br><span class="line">            socket = rawSocket;</span><br><span class="line">            protocol = Protocol.H2_PRIOR_KNOWLEDGE;</span><br><span class="line">            startHttp2(pingIntervalMillis);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket = rawSocket;</span><br><span class="line">        protocol = Protocol.HTTP_1_1;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventListener.secureConnectStart(call);</span><br><span class="line">    <span class="comment">// 进行 Tls 层连接，内部会将 socket 赋值为新的 SSLSocket</span></span><br><span class="line">    connectTls(connectionSpecSelector);</span><br><span class="line">    eventListener.secureConnectEnd(call, handshake);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立 HTTP/2 连接，内部会初始化一个 Http2Connection 保存给 http2Connection，并调用其 start ，</span></span><br><span class="line">    <span class="keyword">if</span> (protocol == Protocol.HTTP_2) &#123;</span><br><span class="line">        startHttp2(pingIntervalMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面与服务器端的 Socket 连接已经建立成功，此时就可以确认目前建立连接的类型，版本了。比如如果是 HTTPS ，则会执行 Tls 层连接，如果是 Http2 则会执行Http2的额外连接，并给其内部的 http2Connection 属性赋值。</p>
<p>至此，connect() 方法就简单分析完毕了，此时就已经和服务器建立了连接，当前 RealConnection 中的 rawSocket 、source 、sink 等属性就会被赋值了。</p>
<hr>
<h4 id="isEligible"><a href="#isEligible" class="headerlink" title="isEligible()"></a>isEligible()</h4><p>当前方法的作用是：判断对指定的 addres 和 route 来说，当前RealConnection 是否可以被重用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEligible</span><span class="params">(Address address, <span class="meta">@Nullable</span> List&lt;Route&gt; routes)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前的链接的最大并发数不能达到上限，</span></span><br><span class="line">    <span class="keyword">if</span> (transmitters.size() &gt;= allocationLimit || noNewExchanges) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非host域必须完全一样，如果不一样则不能重用</span></span><br><span class="line">    <span class="keyword">if</span> (!Internal.instance.equalsNonHost(<span class="built_in">this</span>.route.address(), address)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时 host 域也相同，则符合条件，可以被复用</span></span><br><span class="line">    <span class="keyword">if</span> (address.url().host().equals(<span class="built_in">this</span>.route().address().url().host())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上面的不符合，在下面的情况下可以合并链接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先这个链接需要是 HTTP/2</span></span><br><span class="line">    <span class="keyword">if</span> (http2Connection == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其次必须是 同一 IP</span></span><br><span class="line">    <span class="keyword">if</span> (routes == <span class="literal">null</span> || !routeMatchesAny(routes)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 且这个连接的服务器证书必须覆盖新的主机</span></span><br><span class="line">    <span class="keyword">if</span> (address.hostnameVerifier() != OkHostnameVerifier.INSTANCE) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!supportsUrl(address.url())) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后证书必须匹配</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        address.certificatePinner().check(address.url().host(), handshake().peerCertificates());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SSLPeerUnverifiedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上都满足则可以复用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前方法中，会有较多的条件判断，用于判断当前这个连接是否可以被新的请求复用。</p>
<h4 id="newCodec"><a href="#newCodec" class="headerlink" title="newCodec"></a>newCodec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnection.java</span></span><br><span class="line"></span><br><span class="line">ExchangeCodec <span class="title function_">newCodec</span><span class="params">(OkHttpClient client, Interceptor.Chain chain)</span> <span class="keyword">throws</span> SocketException &#123;</span><br><span class="line">    <span class="keyword">if</span> (http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Http2ExchangeCodec</span>(client, <span class="built_in">this</span>, chain, http2Connection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        socket.setSoTimeout(chain.readTimeoutMillis());</span><br><span class="line">        source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);</span><br><span class="line">        sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Http1ExchangeCodec</span>(client, <span class="built_in">this</span>, source, sink);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前方法主要是根据之前在 connect() 时的可能被赋值的 http2Connection 属性来创建不同的 ExchangeCodec 实例，也就是针对当前是 HTTP1 还是 HTTP2 ，分别建立一个 Http1ExchangeCodec 或者 Http2ExchangeCodec 实例返回出去。</p>
<h3 id="RealConnectionPool"><a href="#RealConnectionPool" class="headerlink" title="RealConnectionPool"></a>RealConnectionPool</h3><p>RealConnectionPool 正如其类名，是一个缓存 RealConnection 的缓存池，它正好也是前面的 RealConnection 中的一个属性，在 RealConnection 被创建时传入。为什么要有连接缓存池呢？因为频繁的进行Socket连接(三次握手)和断开Socket(TCP四次挥手)是非常消耗网络资源和浪费时间的。</p>
<p>下面先熟悉下 RealConnectionPool 中的属性定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RealConnectionPool</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个后台运行的线程池，用于在后台清理那些过期了的 RealConnection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">            Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp ConnectionPool&quot;</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个地址所对应的最大空闲连接数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxIdleConnections;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空闲连接的最大存活时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> keepAliveDurationNs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发清理工作的 runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">cleanupRunnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">waitNanos</span> <span class="operator">=</span> cleanup(System.nanoTime());</span><br><span class="line">            <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">                waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (okhttp3.internal.connection.RealConnectionPool.<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 下一次清理之前的等待</span></span><br><span class="line">                        okhttp3.internal.connection.RealConnectionPool.<span class="built_in">this</span>.wait(waitMillis, (<span class="type">int</span>) waitNanos);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部缓存的 RealConnection 列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由数据库，其实就是存储了一些失败过的路由信息列表，后面请求时，会优先跳过这些而使用别的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RouteDatabase</span> <span class="variable">routeDatabase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteDatabase</span>();</span><br><span class="line">    <span class="comment">// 当前是否正在执行清理工作中，避免重复执行清理逻辑</span></span><br><span class="line">    <span class="type">boolean</span> cleanupRunning;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性不多，这里先解释下 maxIdleConnections 和 keepAliveDurationNs 属性的含义，他俩首先是在 RealConnectionPool() 中被赋值的，分别表示当前 RealConnection 缓存池中：处于空闲IDLE状态的RealConnection的最大存活数、处理空闲IDLE状态的RealConnection的最大存活时间。而 RealConnectionPool 实例的创建目前是只在另外一个类：ConnectionPool 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConnectionPool.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConnectionPool</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> RealConnectionPool delegate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConnectionPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 最大空闲连接数5，最大空闲时间5分钟</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConnectionPool</span><span class="params">(<span class="type">int</span> maxIdleConnections, <span class="type">long</span> keepAliveDuration, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = <span class="keyword">new</span> <span class="title class_">RealConnectionPool</span>(maxIdleConnections, keepAliveDuration, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of idle connections in the pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">idleConnectionCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.idleConnectionCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns total number of connections in the pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">connectionCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.connectionCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Close and remove all idle connections in the pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evictAll</span><span class="params">()</span> &#123;</span><br><span class="line">        delegate.evictAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 ConnectionPool 实际代表的是连接池，而由于目前 Connecion 只有 RealConnection 一个实现类，所以为 RealConnection 实现了一个  RealConnectionPool ，这里的实现则都是使用 RealConnectionPool 来完成的。</p>
<p>同时这里的 ConnectionPool 被暴露给外部开发者，可以定制，即通过 OkHttpClient.Builder 来定制，当然一般没定制时则使用的是 ConnectionPool 的默认构造方法，也就是上面设置了：maxIdleConnections &#x3D; 5个，keepAliveDuration &#x3D;  5 分钟的情况了，所以后续分析中可能默认就是用这俩值来举例了。</p>
<h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>先看其源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(RealConnection connection)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在放置一个新的连接之前，先尝试先去清除任务，清理掉之前的闲置连接</span></span><br><span class="line"><span class="comment">     * 而 cleanupRunning 标记就是用来防止重复执行清理任务 cleanupRunnable 的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">        cleanupRunning = <span class="literal">true</span>;</span><br><span class="line">        executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后将其加入到 connections 中</span></span><br><span class="line">    connections.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码比较简单，就是将入参 RealConnection 实例保存到 connections 中，表示它进入到缓存池中了。但是在此之前，还可能会执行清理任务，即使用内置的线程池去调度执行 cleanupRunnable 任务。</p>
<p>下面看看 cleanupRunnable 任务中都做了啥吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">cleanupRunnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="comment">// 注意这里是 while 死循环，会一直执行内部清理逻辑的，</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 主要逻辑是执行 cleanup 方法，并且传入当前系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">waitNanos</span> <span class="operator">=</span> cleanup(System.nanoTime());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据返回值，决定下一次 cleanup() 啥时候执行</span></span><br><span class="line"><span class="comment">         * 如果它大于0,则需要等待固定时间之后再执行下一次循环进行下一次清理工作</span></span><br><span class="line"><span class="comment">         * 如果它等于-1 则终止清理工作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">            waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (RealConnectionPool.<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 下一次清理之前的等待</span></span><br><span class="line">                    RealConnectionPool.<span class="built_in">this</span>.wait(waitMillis, (<span class="type">int</span>) waitNanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它的主要逻辑就是不停的调用  cleanup() 方法来完成清理工作，期间还会插入一些休眠等待。所以接下来主要看 cleanup() 方法中做了啥吧。</p>
<h4 id="cleanup"><a href="#cleanup" class="headerlink" title="cleanup()"></a>cleanup()</h4><p>先看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">// 正在使用的连接数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">inUseConnectionCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 空闲连接数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">idleConnectionCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 空闲时间最长的连接</span></span><br><span class="line">    <span class="type">RealConnection</span> <span class="variable">longestIdleConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 最长的空闲时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">longestIdleDurationNs</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历连接：找到待清理的连接, 计算出其下一次要清理的时间</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">RealConnection</span> <span class="variable">connection</span> <span class="operator">=</span> i.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 判断这个连接是否还在使用，返回大于0时表示正在使用，等于0时表示没有 Transmitter 使用它了</span></span><br><span class="line"><span class="comment">             * 而连接如果正在使用，则将 inUseConnectionCount 计数自增，接着去循环</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                inUseConnectionCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 执行到这里，表示该 RealConnection 目前处于空闲状态</span></span><br><span class="line"><span class="comment">             * 所以给 空闲连接数 idleConnectionCount 自增1</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            idleConnectionCount++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 计算该 connection 处于 idle 空闲状态的时长</span></span><br><span class="line"><span class="comment">             * connection.idleAtNanos 的赋值是在前面 pruneAndGetAllocationCount() 中赋值的</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">idleDurationNs</span> <span class="operator">=</span> now - connection.idleAtNanos;</span><br><span class="line">            <span class="comment">// 将这些空闲时长保留一个最大的值，并且保存最大值对应的 RealConnection 实例</span></span><br><span class="line">            <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">                longestIdleDurationNs = idleDurationNs;</span><br><span class="line">                longestIdleConnection = connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若最长的空闲时间大于 keepAliveDurationNs 或 空闲数 大于 maxIdleConnections，就移除并关闭这个连接</span></span><br><span class="line">        <span class="comment">// 表示它应该被</span></span><br><span class="line">        <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="built_in">this</span>.keepAliveDurationNs</span><br><span class="line">                || idleConnectionCount &gt; <span class="built_in">this</span>.maxIdleConnections) &#123;</span><br><span class="line">            connections.remove(longestIdleConnection);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回 还剩多久到达 keepAliveDurationNs ，然后 wait 等到这个时间再来清理</span></span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前连接池不为空且存在正在使用的connection，那么就5分钟后再试</span></span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有连接，不清理,返回-1 外部会停止掉 while 循环</span></span><br><span class="line">            cleanupRunning = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭需要移除的移除的连接</span></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 能执行到这里，表示上面走的是第一个if 也就是移除了一个过期的connection</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    List&lt;Reference&lt;Transmitter&gt;&gt; references = connection.transmitters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有正在使用当前 Connection 的 Transmitter</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">        <span class="comment">// 其实是 TransmitterReference</span></span><br><span class="line">        Reference&lt;Transmitter&gt; reference = references.get(i);</span><br><span class="line">        <span class="comment">// 如果该 TransmitterReference 中的 Transmitter 仍旧存在，也就是还在使用中，</span></span><br><span class="line">        <span class="comment">// 那么就i++，继续下一次循环。这是明显的 引用计数法</span></span><br><span class="line">        <span class="keyword">if</span> (reference.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该 TransmitterReference 中的 Transmitter 不存在了，被回收掉了，也就是可能存在内存泄露</span></span><br><span class="line">        Transmitter.<span class="type">TransmitterReference</span> <span class="variable">transmitterRef</span> <span class="operator">=</span> (Transmitter.TransmitterReference) reference;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;A connection to &quot;</span> + connection.route().address().url()</span><br><span class="line">                + <span class="string">&quot; was leaked. Did you forget to close a response body?&quot;</span>;</span><br><span class="line">        Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除掉该 TransmitterReference</span></span><br><span class="line">        references.remove(i);</span><br><span class="line"></span><br><span class="line">        connection.noNewExchanges = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果现在 Transmitter 列表为空了，表示没人在用这个 RealConnection了，它变为空闲状态了。</span></span><br><span class="line"><span class="comment">         * 则此时更新 idle 时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">            connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理完成之后，最终的 references 是否是空的</span></span><br><span class="line">    <span class="keyword">return</span> references.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法逻辑比较简单，在源码中的注释很详细，这里只讲几个我觉得重要的点：</p>
<p>① 判断 RealConnection 是否处于空闲状态的标准是：其内部的 transmitters 列表中存储的 Transmitter 实例（实际是 Transmitter.TransmitterReference 实例）为空。因为每当有一个 RealCall 要使用该 RealConnection 时，都会将其内部的 Transmitter 实例包装成 Transmitter.TransmitterReference 然后保存到该 RealConnection 内部的 transmitters 列表中去，详见：RealConnectionPool 中的 transmitterAcquirePooledConnection() 方法。</p>
<p>而当最终使用完或者其他异常状态时，会调用到  Transmitter 中的 releaseConnectionNoEvents() 方法中，此时会将对应的Transmitter.TransmitterReference 从 transmitters 列表中移除掉。</p>
<p>所以说，后续只要判断这个 transmitters 列表是否为空，或者更准确的来说就是其内部的 Transmitter.TransmitterReference 元素没有没收回掉。因为Transmitter.TransmitterReference 继承自 WeakReference ，会在GC 时被回收掉。</p>
<p>② cleanup() 方法中每次最多只处理一个处于空闲状态的 RealConnection ，而由于外部 cleanupRunnable 中是循环调用的，所以如果还有满足条件的待清理的 RealConnection 会在下一次循环是被清理掉。</p>
<p>③ 正如前面所说，Transmitter.TransmitterReference 是继承自 WeakReference 的，会在GC 时被回收掉。所以说在遍历某个 RealConnection 中的 transmitters 列表时，如果其内部某个 Transmitter.TransmitterReference 中对应的对象已被回收掉，那么就认为是存在内存泄露，此时这边会同步将其从 transmitters 中移除掉。</p>
<h4 id="transmitterAcquirePooledConnection"><a href="#transmitterAcquirePooledConnection" class="headerlink" title="transmitterAcquirePooledConnection()"></a>transmitterAcquirePooledConnection()</h4><p>前面讲了put() 方法来往缓存池中放入 RealConnection 缓存起来，那什么时候 get() 呢？没有 get() 方法，但对应的有一个 transmitterAcquirePooledConnection() 方法来从缓存池中获取一个可用的 RealConnection 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealConnectionPool.java</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">transmitterAcquirePooledConnection</span><span class="params">(Address address, Transmitter transmitter,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> List&lt;Route&gt; routes, <span class="type">boolean</span> requireMultiplexed)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前缓存池中的所有 RealConnection</span></span><br><span class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入参要求多路复用，跳过不支持多路复用的连接。只有 http2 才支持多路复用</span></span><br><span class="line">        <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不合条件，跳过。内部会判断 host 等属性来决定该 RealConnection 是否可复用于当前 address,routes</span></span><br><span class="line">        <span class="keyword">if</span> (!connection.isEligible(address, routes))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到这里，表示可以复用该 RealConnection</span></span><br><span class="line"><span class="comment">         * 此时调用 acquireConnectionNoEvents() 方法来为该 RealConnection.transmitters 中添加一个 Transmitter 实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        transmitter.acquireConnectionNoEvents(connection);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历所有目前还存活没有被清理的 RealConnection ，挨个判断其是否可以支持入参：address, routes 所要求的复用条件，主要是调用到 RealConnection 中的 isEligible() 方法内，该方法在上面讲过了，他内部会判断 host 等属性来决定当前 RealConnection 是否可以被复用。</p>
<p>最终如果可以被复用的话，则调用 Transmitter 的 acquireConnectionNoEvents() 方法来进行属性保存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transmitter.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">acquireConnectionNoEvents</span><span class="params">(RealConnection connection)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入参合法性判断，即一个 Transmitter 只能同时被一个 RealConnection 使用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.connection != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    <span class="comment">// 将 connection 保存起来</span></span><br><span class="line">    <span class="built_in">this</span>.connection = connection;</span><br><span class="line">    <span class="comment">// 将当前 Transmitter 实例包装成 TransmitterReference 实例保存到 connection.transmitters 中</span></span><br><span class="line">    connection.transmitters.add(<span class="keyword">new</span> <span class="title class_">Transmitter</span>.TransmitterReference(<span class="built_in">this</span>, callStackTrace));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，一个 Transmitter 只能同时被一个 RealConnection 使用，而如果想要绑定另外一个 RealConnection ，那就得先调用  Transmitter 的 releaseConnectionNoEvents() 方法来解除绑定才行。</p>
<p>并且在该方法中还会修改 RealConnection 中的 transmitters ，将当前 Transmitter 实例包装成  TransmitterReference 实例保存进去。</p>
<p>因此不难知道：</p>
<p>① Transmitter 和 RealConnection 是一对一的，即一个 Transmitter 只能同时绑定一个 RealConnection；</p>
<p>② RealConnection  和 Transmitter 是一对多的，即一个RealConnection 可以同时绑定多个Transmitter；</p>
<p>③ RealCall 和 Transmitter 是一对一的，即一个 RealCall 中只会有一个 Transmitter ，而一个 Transmitter 中也只会对应一个RealConnection 实例。</p>
<h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>下面回到 ConnectInterceptor 中的逻辑，来分析：transmitter.newExchange() 方法是怎么处理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transmitter.java</span></span><br><span class="line"></span><br><span class="line">Exchange <span class="title function_">newExchange</span><span class="params">(Interceptor.Chain chain, <span class="type">boolean</span> doExtensiveHealthChecks)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理之前设置的 noMoreExchanges 标识，该标志被置为 true时表示当前 Transmitter 不可用，</span></span><br><span class="line">    <span class="comment">// 不能使用它再来创建 Exchange了</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (noMoreExchanges) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;released&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;cannot make a new request because the previous response &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still open: please call response.close()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找或者新建一个连接，然后通过其返回一个 ExchangeCodec 实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ExchangeCodec</span> <span class="variable">codec</span> <span class="operator">=</span> exchangeFinder.find(client, chain, doExtensiveHealthChecks);</span><br><span class="line">    <span class="comment">// 将 codec 等信息封装到 Exchange中返回出去</span></span><br><span class="line">    <span class="type">Exchange</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exchange</span>(<span class="built_in">this</span>, call, eventListener, exchangeFinder, codec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="built_in">this</span>.exchange = result;</span><br><span class="line">        <span class="built_in">this</span>.exchangeRequestDone = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.exchangeResponseDone = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要的逻辑是通过 exchangeFinder.find() 方法去完成的，而其内部的 exchangeFinder 属性的创建是在前面 RetryAndFollowUpInterceptor 中请求开始时，调用的 Transmitter#prepareToConnect() 方法来实现的。</p>
<p>拿到了 exchangeFinder.find() 方法返回的 ExchangeCodec 实例之后，会将其统一都封装到一个 Exchange 实例中返回出去。</p>
<p>所以下面重心是看这个 ExchangeCodec 实例是怎么创建出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExchangeFinder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ExchangeCodec <span class="title function_">find</span><span class="params">(OkHttpClient client, Interceptor.Chain chain, <span class="type">boolean</span> doExtensiveHealthChecks)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">connectTimeout</span> <span class="operator">=</span> chain.connectTimeoutMillis();</span><br><span class="line">    <span class="type">int</span> <span class="variable">readTimeout</span> <span class="operator">=</span> chain.readTimeoutMillis();</span><br><span class="line">    <span class="type">int</span> <span class="variable">writeTimeout</span> <span class="operator">=</span> chain.writeTimeoutMillis();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pingIntervalMillis</span> <span class="operator">=</span> client.pingIntervalMillis();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">connectionRetryEnabled</span> <span class="operator">=</span> client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 findHealthyConnection 方法来找到一个目前请求可用的连接</span></span><br><span class="line">        <span class="type">RealConnection</span> <span class="variable">resultConnection</span> <span class="operator">=</span> findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">                writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用找到的 RealConnection 来返回一个 ExchangeCodec 实例，</span></span><br><span class="line"><span class="comment">         * 实际是 Http2ExchangeCodec 或者 Http1ExchangeCodec 之一</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> resultConnection.newCodec(client, chain);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">        trackFailure();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        trackFailure();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RouteException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会先调用 findHealthyConnection() 方法来查找或者创建一个可用的 RealConnection，也就是一个可用的连接，这个连接是已经和服务端连接好了可以直接用的。</p>
<p>然后调用该 RealConnection 的 newCodec() 方法来返回一个对应的 ExchangeCodec 实例，这个方法上面讲过了，所以接下来看 findHealthyConnection() 方法是怎么找到 RealConnection 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExchangeFinder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RealConnection <span class="title function_">findHealthyConnection</span><span class="params">(<span class="type">int</span> connectTimeout, <span class="type">int</span> readTimeout,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> writeTimeout, <span class="type">int</span> pingIntervalMillis, <span class="type">boolean</span> connectionRetryEnabled,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里是循环执行，内部会一直找直到找到一个合适的</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过 findConnection 找到一个候选的 RealConnection 实例，此时找是没有链接健康检查的</span></span><br><span class="line">        <span class="type">RealConnection</span> <span class="variable">candidate</span> <span class="operator">=</span> findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">                pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来进行健康检查</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            <span class="comment">// 是一个新连接，并且 不是HTTP2.0 ，那么就直接返回，不用健康检查。</span></span><br><span class="line">            <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span> &amp;&amp; !candidate.isMultiplexed()) &#123;</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断该连接是否健康可用，不健康的话话将其标记为 noNewExchanges ，后续不能再使用它了</span></span><br><span class="line">        <span class="comment">// 然后接着循环去再找一个</span></span><br><span class="line">        <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">            candidate.noNewExchanges();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a哎呀，它里面还有一个 findConnection() 方法专门用于查找可用的 RealConnection ，而当前方法在 findConnection() 方法的基础上扩充了 RealConnection健康检查 的逻辑，即：尽管找到了一个可用的 RealConnection ，但是它此时是不健康的，比如对应的 socket 已经被关闭了，链路已经断了，或者其对应的IO流缓存用光了(详见 BufferedSource 的 exhausted() 方法)，此时外部也不能使用该 RealConnection ，则需要重新找一个。</p>
<p>接下来看看 findConnection() 方法中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExchangeFinder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RealConnection <span class="title function_">findConnection</span><span class="params">(<span class="type">int</span> connectTimeout, <span class="type">int</span> readTimeout, <span class="type">int</span> writeTimeout,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> pingIntervalMillis, <span class="type">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">foundPooledConnection</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">RealConnection</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Route</span> <span class="variable">selectedRoute</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    RealConnection releasedConnection;</span><br><span class="line">    Socket toClose;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查当前 Call 是否已经取消了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line"></span><br><span class="line">        hasStreamFailure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一个StreamAllocation刻画的是一个Call的数据流动。</span></span><br><span class="line"><span class="comment">         * 由于一个 Call 可能存在多次请求(重定向，Authenticate等)，所以当发生类似重定向等事件时优先使用原有的连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        releasedConnection = transmitter.connection;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有已分配的连接，但已经被限制承载新的数据流，就尝试释放掉（如果连接上已没有数据流），并返回待关闭的socket。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        toClose = transmitter.connection != <span class="literal">null</span> &amp;&amp; transmitter.connection.noNewExchanges</span><br><span class="line">                ? transmitter.releaseConnectionNoEvents() : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不为空，说明上面 releaseConnectionNoEvents 没有执行，也就是说 noNewExchanges=false</span></span><br><span class="line"><span class="comment">         * 那么此连接可用，此时直接使用该连接吧</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (transmitter.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            result = transmitter.connection;</span><br><span class="line">            releasedConnection = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 走到这里 result  = null 的话表示没有办法重用之前的 connection</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1、 第一次尝试从缓冲池里面获取 RealConnection</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                <span class="comment">// 从连接池获取到了</span></span><br><span class="line">                foundPooledConnection = <span class="literal">true</span>;</span><br><span class="line">                result = transmitter.connection;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 从连接池中没有获取到可复用的链接时，那么判断是否有可再次尝试的路由</span></span><br><span class="line"><span class="comment">                 * 2、如果缓冲池中没有，则看看有没有下一个Route可以尝试，这里只有重试的情况会走进来</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                selectedRoute = nextRouteToTry;</span><br><span class="line">                nextRouteToTry = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCurrentRoute()) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 3、如果已经设置了使用当前Route重试，那么会继续使用当前的Route</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                selectedRoute = transmitter.connection.route();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closeQuietly(toClose); <span class="comment">//（如果有）关闭待关闭的socket</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">        eventListener.connectionReleased(call, releasedConnection); <span class="comment">//（如果有）回调连接释放事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">        eventListener.connectionAcquired(call, result); <span class="comment">// (如果有）回调（从连接池）获取连接事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、如果前面发现 ConnectionPool 或者 transmitter 中有可以复用的 Connection，这里就直接返回了</span></span><br><span class="line"><span class="comment">     * 表示现在找到了一个可用的 RealConnection ，没找着的话则接着往下走</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果需要路由信息，就获取，是阻塞操作</span></span><br><span class="line"><span class="comment">     * 5、如果前面没有获取到 Connection，这里就需要通过 routeSelector 来获取到新的 Route 来进行 RealConnection 的创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newRouteSelection</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * routeSelection 默认是null，第一次时：routeSelection==null 条件满足，从 routeSelector 中拿到一个 routeSelection 实例</span></span><br><span class="line"><span class="comment">     * 后面优先使用该 routeSelection 来尝试，如果尝试完成后，还是不行的话就使用 routeSelector 的下一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="literal">null</span> &amp;&amp; (routeSelection == <span class="literal">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">        newRouteSelection = <span class="literal">true</span>; <span class="comment">// 表示有新的路由信息了</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 6、获取route的过程其实就是DNS获取到域名IP的过程，这是一个阻塞的过程，会等待DNS结果返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        routeSelection = routeSelector.next(); <span class="comment">// 切换代理，拿到新代理下的路由信息列表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Route&gt; routes = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有新的路由信息了，那么就再试一次从缓存池中拿对应的链接</span></span><br><span class="line"><span class="comment">         * 找到了就将 foundPooledConnection 置为 true，且 result 指向最终找到的 Connection</span></span><br><span class="line"><span class="comment">         * 没找到的话就新建一个 Connection，同样的 result 指向新建的这个 Connection</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 7，前面如果通过 routeSelector 拿到新的 Route，其实就是相当于拿到一批新的IP，这里会再次尝试从ConnectionPool</span></span><br><span class="line"><span class="comment">         *    中检查是否有可以复用的Connection</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 现在有了新的IP路由地址，再次尝试从连接池获取。可能会因为连接合并而匹配。</span></span><br><span class="line"><span class="comment">             * 注意这里 这里传入了routes，而上面的传的是 null</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            routes = routeSelection.getAll();</span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">                foundPooledConnection = <span class="literal">true</span>;</span><br><span class="line">                result = transmitter.connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次连接池也没找到，就新建连接</span></span><br><span class="line">        <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectedRoute == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 从 routeSelection 中拿到一个路由信息。 routeSelection 里面存储的是一个路由列表</span></span><br><span class="line"><span class="comment">                 * 8、前面我们拿到的是一批IP，这里通过routeSelection获取到其中一个IP，Route是proxy和InetAddress的包装类</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                selectedRoute = routeSelection.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 9、用新的 route 创建 RealConnection，注意这里还没有尝试连接，也就是还没有调用其 connect() 方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            result = <span class="keyword">new</span> <span class="title class_">RealConnection</span>(connectionPool, selectedRoute);</span><br><span class="line">            connectingConnection = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 10，如果第二次从连接池的尝试成功了，直接返回，因为连接池中的连接是已经和服务器建立连接的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">        eventListener.connectionAcquired(call, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 11、执行到这里的表示是新建的 Connection ,也就是上面第二次从缓存池中获取连接没成功，</span></span><br><span class="line"><span class="comment">     * 此时为这个新建的连接进行 connect 操作，进行TCP + TLS 握手，与服务端建立连接. 这是阻塞操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">            connectionRetryEnabled, call, eventListener);</span><br><span class="line">    <span class="comment">// 连接成功，那就从黑名单中移除这个路由，表示这个路由是通路</span></span><br><span class="line">    connectionPool.routeDatabase.connected(result.route());</span><br><span class="line"></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        connectingConnection = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最后一次尝试从连接池获取，注意最后一个参数为 true，即要求多路复用（http2.0）</span></span><br><span class="line"><span class="comment">         * 意思是，如果本次是http2.0，那么为了保证 多路复用性，（因为上面的握手操作不是线程安全）会再次确认连接池中此时是否已有同样连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果获取到，就关闭掉我们刚创建的连接，使用本次从缓存池中返回的连接</span></span><br><span class="line">            result.noNewExchanges = <span class="literal">true</span>;</span><br><span class="line">            socket = result.socket();</span><br><span class="line"></span><br><span class="line">            result = transmitter.connection;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 那么这个刚刚连接成功的路由 就可以 用作下次 尝试的路由</span></span><br><span class="line">            nextRouteToTry = selectedRoute;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 最后一次尝试也没有的话，就把刚刚新建的连接存入连接池，</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            connectionPool.put(result);</span><br><span class="line">            <span class="comment">// 然后将新建的这个连接保存到 transmitter.connection 中</span></span><br><span class="line">            transmitter.acquireConnectionNoEvents(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closeQuietly(socket); <span class="comment">// 如果刚刚建立的连接没用到，就关闭</span></span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑属实是有些长，这里总结下获取逻辑：</p>
<p>1、尝试在 transmitter 中寻找已经分配的连接。即先判断 transmitter 中的 connection 是否为空，是否被释放掉了。没有的话则尝试用它。</p>
<p>2、尝试在 connectionPool 中查找是否存在host 啥的都是一样的、可直接用的链接。</p>
<p>3、没有的话，则尝试进行一次DNS拿到新的一批IP路由信息，然后使用新的路由信息去 connectionPool 中查找是否有可用的</p>
<p>4、第二次从连接池中都没有找到的话，则会新建一个 RealConnection ，并开始握手TSL 等连接操作。</p>
<p>5、由于 HTTP&#x2F;2 下采用了连接的多路复用机制，所以连接可以并行进行，因此再次尝试从连接池中获取连接，获取到则丢弃创建的连接</p>
<p>6、若连接池中仍获取不到连接，则将刚刚创建的连接放入连接池</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/okhttp/">okhttp</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/b80024b2.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Retrofit-动态代理中的秘密</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/52da40ac.html">
        <span class="next-text nav-default">OkHttp 拦截器介绍</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2020 -
    
    2023
    <span class="footer-author">咔咔咔.</span>
    <span class="power-by">
        由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
